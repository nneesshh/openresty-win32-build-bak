// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: StoredProcTreasureMap.proto

#ifndef PROTOBUF_INCLUDED_StoredProcTreasureMap_2eproto
#define PROTOBUF_INCLUDED_StoredProcTreasureMap_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_StoredProcTreasureMap_2eproto 

namespace protobuf_StoredProcTreasureMap_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[8];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_StoredProcTreasureMap_2eproto
namespace db {
class ConfigTreasureMap;
class ConfigTreasureMapDefaultTypeInternal;
extern ConfigTreasureMapDefaultTypeInternal _ConfigTreasureMap_default_instance_;
class ConfigTreasureMapActivity;
class ConfigTreasureMapActivityDefaultTypeInternal;
extern ConfigTreasureMapActivityDefaultTypeInternal _ConfigTreasureMapActivity_default_instance_;
class ConfigTreasureMapActivityList;
class ConfigTreasureMapActivityListDefaultTypeInternal;
extern ConfigTreasureMapActivityListDefaultTypeInternal _ConfigTreasureMapActivityList_default_instance_;
class ConfigTreasureMapList;
class ConfigTreasureMapListDefaultTypeInternal;
extern ConfigTreasureMapListDefaultTypeInternal _ConfigTreasureMapList_default_instance_;
class ConfigTreasureMapTile;
class ConfigTreasureMapTileDefaultTypeInternal;
extern ConfigTreasureMapTileDefaultTypeInternal _ConfigTreasureMapTile_default_instance_;
class ConfigTreasureMapTileList;
class ConfigTreasureMapTileListDefaultTypeInternal;
extern ConfigTreasureMapTileListDefaultTypeInternal _ConfigTreasureMapTileList_default_instance_;
class UserStatsTreasureMap;
class UserStatsTreasureMapDefaultTypeInternal;
extern UserStatsTreasureMapDefaultTypeInternal _UserStatsTreasureMap_default_instance_;
class UserTreasureMap;
class UserTreasureMapDefaultTypeInternal;
extern UserTreasureMapDefaultTypeInternal _UserTreasureMap_default_instance_;
}  // namespace db
namespace google {
namespace protobuf {
template<> ::db::ConfigTreasureMap* Arena::CreateMaybeMessage<::db::ConfigTreasureMap>(Arena*);
template<> ::db::ConfigTreasureMapActivity* Arena::CreateMaybeMessage<::db::ConfigTreasureMapActivity>(Arena*);
template<> ::db::ConfigTreasureMapActivityList* Arena::CreateMaybeMessage<::db::ConfigTreasureMapActivityList>(Arena*);
template<> ::db::ConfigTreasureMapList* Arena::CreateMaybeMessage<::db::ConfigTreasureMapList>(Arena*);
template<> ::db::ConfigTreasureMapTile* Arena::CreateMaybeMessage<::db::ConfigTreasureMapTile>(Arena*);
template<> ::db::ConfigTreasureMapTileList* Arena::CreateMaybeMessage<::db::ConfigTreasureMapTileList>(Arena*);
template<> ::db::UserStatsTreasureMap* Arena::CreateMaybeMessage<::db::UserStatsTreasureMap>(Arena*);
template<> ::db::UserTreasureMap* Arena::CreateMaybeMessage<::db::UserTreasureMap>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace db {

// ===================================================================

class ConfigTreasureMapTile : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:db.ConfigTreasureMapTile) */ {
 public:
  ConfigTreasureMapTile();
  virtual ~ConfigTreasureMapTile();

  ConfigTreasureMapTile(const ConfigTreasureMapTile& from);

  inline ConfigTreasureMapTile& operator=(const ConfigTreasureMapTile& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConfigTreasureMapTile(ConfigTreasureMapTile&& from) noexcept
    : ConfigTreasureMapTile() {
    *this = ::std::move(from);
  }

  inline ConfigTreasureMapTile& operator=(ConfigTreasureMapTile&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const ConfigTreasureMapTile& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConfigTreasureMapTile* internal_default_instance() {
    return reinterpret_cast<const ConfigTreasureMapTile*>(
               &_ConfigTreasureMapTile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void UnsafeArenaSwap(ConfigTreasureMapTile* other);
  void Swap(ConfigTreasureMapTile* other);
  friend void swap(ConfigTreasureMapTile& a, ConfigTreasureMapTile& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConfigTreasureMapTile* New() const final {
    return CreateMaybeMessage<ConfigTreasureMapTile>(NULL);
  }

  ConfigTreasureMapTile* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConfigTreasureMapTile>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ConfigTreasureMapTile& from);
  void MergeFrom(const ConfigTreasureMapTile& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigTreasureMapTile* other);
  protected:
  explicit ConfigTreasureMapTile(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes map_size = 2;
  bool has_map_size() const;
  void clear_map_size();
  static const int kMapSizeFieldNumber = 2;
  const ::std::string& map_size() const;
  void set_map_size(const ::std::string& value);
  #if LANG_CXX11
  void set_map_size(::std::string&& value);
  #endif
  void set_map_size(const char* value);
  void set_map_size(const void* value, size_t size);
  ::std::string* mutable_map_size();
  ::std::string* release_map_size();
  void set_allocated_map_size(::std::string* map_size);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_map_size();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_map_size(
      ::std::string* map_size);

  // required bytes map_data = 3;
  bool has_map_data() const;
  void clear_map_data();
  static const int kMapDataFieldNumber = 3;
  const ::std::string& map_data() const;
  void set_map_data(const ::std::string& value);
  #if LANG_CXX11
  void set_map_data(::std::string&& value);
  #endif
  void set_map_data(const char* value);
  void set_map_data(const void* value, size_t size);
  ::std::string* mutable_map_data();
  ::std::string* release_map_data();
  void set_allocated_map_data(::std::string* map_data);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_map_data();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_map_data(
      ::std::string* map_data);

  // required int32 level = 1;
  bool has_level() const;
  void clear_level();
  static const int kLevelFieldNumber = 1;
  ::google::protobuf::int32 level() const;
  void set_level(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:db.ConfigTreasureMapTile)
 private:
  void set_has_level();
  void clear_has_level();
  void set_has_map_size();
  void clear_has_map_size();
  void set_has_map_data();
  void clear_has_map_data();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr map_size_;
  ::google::protobuf::internal::ArenaStringPtr map_data_;
  ::google::protobuf::int32 level_;
  friend struct ::protobuf_StoredProcTreasureMap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ConfigTreasureMapTileList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:db.ConfigTreasureMapTileList) */ {
 public:
  ConfigTreasureMapTileList();
  virtual ~ConfigTreasureMapTileList();

  ConfigTreasureMapTileList(const ConfigTreasureMapTileList& from);

  inline ConfigTreasureMapTileList& operator=(const ConfigTreasureMapTileList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConfigTreasureMapTileList(ConfigTreasureMapTileList&& from) noexcept
    : ConfigTreasureMapTileList() {
    *this = ::std::move(from);
  }

  inline ConfigTreasureMapTileList& operator=(ConfigTreasureMapTileList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const ConfigTreasureMapTileList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConfigTreasureMapTileList* internal_default_instance() {
    return reinterpret_cast<const ConfigTreasureMapTileList*>(
               &_ConfigTreasureMapTileList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void UnsafeArenaSwap(ConfigTreasureMapTileList* other);
  void Swap(ConfigTreasureMapTileList* other);
  friend void swap(ConfigTreasureMapTileList& a, ConfigTreasureMapTileList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConfigTreasureMapTileList* New() const final {
    return CreateMaybeMessage<ConfigTreasureMapTileList>(NULL);
  }

  ConfigTreasureMapTileList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConfigTreasureMapTileList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ConfigTreasureMapTileList& from);
  void MergeFrom(const ConfigTreasureMapTileList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigTreasureMapTileList* other);
  protected:
  explicit ConfigTreasureMapTileList(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .db.ConfigTreasureMapTile list = 1;
  int list_size() const;
  void clear_list();
  static const int kListFieldNumber = 1;
  ::db::ConfigTreasureMapTile* mutable_list(int index);
  ::google::protobuf::RepeatedPtrField< ::db::ConfigTreasureMapTile >*
      mutable_list();
  const ::db::ConfigTreasureMapTile& list(int index) const;
  ::db::ConfigTreasureMapTile* add_list();
  const ::google::protobuf::RepeatedPtrField< ::db::ConfigTreasureMapTile >&
      list() const;

  // @@protoc_insertion_point(class_scope:db.ConfigTreasureMapTileList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::db::ConfigTreasureMapTile > list_;
  friend struct ::protobuf_StoredProcTreasureMap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ConfigTreasureMapActivity : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:db.ConfigTreasureMapActivity) */ {
 public:
  ConfigTreasureMapActivity();
  virtual ~ConfigTreasureMapActivity();

  ConfigTreasureMapActivity(const ConfigTreasureMapActivity& from);

  inline ConfigTreasureMapActivity& operator=(const ConfigTreasureMapActivity& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConfigTreasureMapActivity(ConfigTreasureMapActivity&& from) noexcept
    : ConfigTreasureMapActivity() {
    *this = ::std::move(from);
  }

  inline ConfigTreasureMapActivity& operator=(ConfigTreasureMapActivity&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const ConfigTreasureMapActivity& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConfigTreasureMapActivity* internal_default_instance() {
    return reinterpret_cast<const ConfigTreasureMapActivity*>(
               &_ConfigTreasureMapActivity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void UnsafeArenaSwap(ConfigTreasureMapActivity* other);
  void Swap(ConfigTreasureMapActivity* other);
  friend void swap(ConfigTreasureMapActivity& a, ConfigTreasureMapActivity& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConfigTreasureMapActivity* New() const final {
    return CreateMaybeMessage<ConfigTreasureMapActivity>(NULL);
  }

  ConfigTreasureMapActivity* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConfigTreasureMapActivity>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ConfigTreasureMapActivity& from);
  void MergeFrom(const ConfigTreasureMapActivity& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigTreasureMapActivity* other);
  protected:
  explicit ConfigTreasureMapActivity(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 level = 1;
  bool has_level() const;
  void clear_level();
  static const int kLevelFieldNumber = 1;
  ::google::protobuf::int32 level() const;
  void set_level(::google::protobuf::int32 value);

  // required int32 num1 = 2;
  bool has_num1() const;
  void clear_num1();
  static const int kNum1FieldNumber = 2;
  ::google::protobuf::int32 num1() const;
  void set_num1(::google::protobuf::int32 value);

  // required int32 num2 = 3;
  bool has_num2() const;
  void clear_num2();
  static const int kNum2FieldNumber = 3;
  ::google::protobuf::int32 num2() const;
  void set_num2(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:db.ConfigTreasureMapActivity)
 private:
  void set_has_level();
  void clear_has_level();
  void set_has_num1();
  void clear_has_num1();
  void set_has_num2();
  void clear_has_num2();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 num1_;
  ::google::protobuf::int32 num2_;
  friend struct ::protobuf_StoredProcTreasureMap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ConfigTreasureMapActivityList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:db.ConfigTreasureMapActivityList) */ {
 public:
  ConfigTreasureMapActivityList();
  virtual ~ConfigTreasureMapActivityList();

  ConfigTreasureMapActivityList(const ConfigTreasureMapActivityList& from);

  inline ConfigTreasureMapActivityList& operator=(const ConfigTreasureMapActivityList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConfigTreasureMapActivityList(ConfigTreasureMapActivityList&& from) noexcept
    : ConfigTreasureMapActivityList() {
    *this = ::std::move(from);
  }

  inline ConfigTreasureMapActivityList& operator=(ConfigTreasureMapActivityList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const ConfigTreasureMapActivityList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConfigTreasureMapActivityList* internal_default_instance() {
    return reinterpret_cast<const ConfigTreasureMapActivityList*>(
               &_ConfigTreasureMapActivityList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void UnsafeArenaSwap(ConfigTreasureMapActivityList* other);
  void Swap(ConfigTreasureMapActivityList* other);
  friend void swap(ConfigTreasureMapActivityList& a, ConfigTreasureMapActivityList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConfigTreasureMapActivityList* New() const final {
    return CreateMaybeMessage<ConfigTreasureMapActivityList>(NULL);
  }

  ConfigTreasureMapActivityList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConfigTreasureMapActivityList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ConfigTreasureMapActivityList& from);
  void MergeFrom(const ConfigTreasureMapActivityList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigTreasureMapActivityList* other);
  protected:
  explicit ConfigTreasureMapActivityList(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .db.ConfigTreasureMapActivity list = 1;
  int list_size() const;
  void clear_list();
  static const int kListFieldNumber = 1;
  ::db::ConfigTreasureMapActivity* mutable_list(int index);
  ::google::protobuf::RepeatedPtrField< ::db::ConfigTreasureMapActivity >*
      mutable_list();
  const ::db::ConfigTreasureMapActivity& list(int index) const;
  ::db::ConfigTreasureMapActivity* add_list();
  const ::google::protobuf::RepeatedPtrField< ::db::ConfigTreasureMapActivity >&
      list() const;

  // @@protoc_insertion_point(class_scope:db.ConfigTreasureMapActivityList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::db::ConfigTreasureMapActivity > list_;
  friend struct ::protobuf_StoredProcTreasureMap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ConfigTreasureMap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:db.ConfigTreasureMap) */ {
 public:
  ConfigTreasureMap();
  virtual ~ConfigTreasureMap();

  ConfigTreasureMap(const ConfigTreasureMap& from);

  inline ConfigTreasureMap& operator=(const ConfigTreasureMap& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConfigTreasureMap(ConfigTreasureMap&& from) noexcept
    : ConfigTreasureMap() {
    *this = ::std::move(from);
  }

  inline ConfigTreasureMap& operator=(ConfigTreasureMap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const ConfigTreasureMap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConfigTreasureMap* internal_default_instance() {
    return reinterpret_cast<const ConfigTreasureMap*>(
               &_ConfigTreasureMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void UnsafeArenaSwap(ConfigTreasureMap* other);
  void Swap(ConfigTreasureMap* other);
  friend void swap(ConfigTreasureMap& a, ConfigTreasureMap& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConfigTreasureMap* New() const final {
    return CreateMaybeMessage<ConfigTreasureMap>(NULL);
  }

  ConfigTreasureMap* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConfigTreasureMap>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ConfigTreasureMap& from);
  void MergeFrom(const ConfigTreasureMap& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigTreasureMap* other);
  protected:
  explicit ConfigTreasureMap(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes name = 3;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const void* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_name();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      ::std::string* name);

  // required bytes desc = 4;
  bool has_desc() const;
  void clear_desc();
  static const int kDescFieldNumber = 4;
  const ::std::string& desc() const;
  void set_desc(const ::std::string& value);
  #if LANG_CXX11
  void set_desc(::std::string&& value);
  #endif
  void set_desc(const char* value);
  void set_desc(const void* value, size_t size);
  ::std::string* mutable_desc();
  ::std::string* release_desc();
  void set_allocated_desc(::std::string* desc);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_desc();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_desc(
      ::std::string* desc);

  // required bytes location = 11;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 11;
  const ::std::string& location() const;
  void set_location(const ::std::string& value);
  #if LANG_CXX11
  void set_location(::std::string&& value);
  #endif
  void set_location(const char* value);
  void set_location(const void* value, size_t size);
  ::std::string* mutable_location();
  ::std::string* release_location();
  void set_allocated_location(::std::string* location);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_location();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_location(
      ::std::string* location);

  // required bytes level_range = 12;
  bool has_level_range() const;
  void clear_level_range();
  static const int kLevelRangeFieldNumber = 12;
  const ::std::string& level_range() const;
  void set_level_range(const ::std::string& value);
  #if LANG_CXX11
  void set_level_range(::std::string&& value);
  #endif
  void set_level_range(const char* value);
  void set_level_range(const void* value, size_t size);
  ::std::string* mutable_level_range();
  ::std::string* release_level_range();
  void set_allocated_level_range(::std::string* level_range);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_level_range();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_level_range(
      ::std::string* level_range);

  // required bytes trigger = 13;
  bool has_trigger() const;
  void clear_trigger();
  static const int kTriggerFieldNumber = 13;
  const ::std::string& trigger() const;
  void set_trigger(const ::std::string& value);
  #if LANG_CXX11
  void set_trigger(::std::string&& value);
  #endif
  void set_trigger(const char* value);
  void set_trigger(const void* value, size_t size);
  ::std::string* mutable_trigger();
  ::std::string* release_trigger();
  void set_allocated_trigger(::std::string* trigger);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_trigger();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_trigger(
      ::std::string* trigger);

  // required bytes monster_group = 14;
  bool has_monster_group() const;
  void clear_monster_group();
  static const int kMonsterGroupFieldNumber = 14;
  const ::std::string& monster_group() const;
  void set_monster_group(const ::std::string& value);
  #if LANG_CXX11
  void set_monster_group(::std::string&& value);
  #endif
  void set_monster_group(const char* value);
  void set_monster_group(const void* value, size_t size);
  ::std::string* mutable_monster_group();
  ::std::string* release_monster_group();
  void set_allocated_monster_group(::std::string* monster_group);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_monster_group();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_monster_group(
      ::std::string* monster_group);

  // required bytes monster_drop = 15;
  bool has_monster_drop() const;
  void clear_monster_drop();
  static const int kMonsterDropFieldNumber = 15;
  const ::std::string& monster_drop() const;
  void set_monster_drop(const ::std::string& value);
  #if LANG_CXX11
  void set_monster_drop(::std::string&& value);
  #endif
  void set_monster_drop(const char* value);
  void set_monster_drop(const void* value, size_t size);
  ::std::string* mutable_monster_drop();
  ::std::string* release_monster_drop();
  void set_allocated_monster_drop(::std::string* monster_drop);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_monster_drop();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_monster_drop(
      ::std::string* monster_drop);

  // required bytes treasure_drop = 16;
  bool has_treasure_drop() const;
  void clear_treasure_drop();
  static const int kTreasureDropFieldNumber = 16;
  const ::std::string& treasure_drop() const;
  void set_treasure_drop(const ::std::string& value);
  #if LANG_CXX11
  void set_treasure_drop(::std::string&& value);
  #endif
  void set_treasure_drop(const char* value);
  void set_treasure_drop(const void* value, size_t size);
  ::std::string* mutable_treasure_drop();
  ::std::string* release_treasure_drop();
  void set_allocated_treasure_drop(::std::string* treasure_drop);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_treasure_drop();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_treasure_drop(
      ::std::string* treasure_drop);

  // required bytes trap_lost = 17;
  bool has_trap_lost() const;
  void clear_trap_lost();
  static const int kTrapLostFieldNumber = 17;
  const ::std::string& trap_lost() const;
  void set_trap_lost(const ::std::string& value);
  #if LANG_CXX11
  void set_trap_lost(::std::string&& value);
  #endif
  void set_trap_lost(const char* value);
  void set_trap_lost(const void* value, size_t size);
  ::std::string* mutable_trap_lost();
  ::std::string* release_trap_lost();
  void set_allocated_trap_lost(::std::string* trap_lost);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_trap_lost();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_trap_lost(
      ::std::string* trap_lost);

  // required int32 toolid = 1;
  bool has_toolid() const;
  void clear_toolid();
  static const int kToolidFieldNumber = 1;
  ::google::protobuf::int32 toolid() const;
  void set_toolid(::google::protobuf::int32 value);

  // required int32 tool_type = 2;
  bool has_tool_type() const;
  void clear_tool_type();
  static const int kToolTypeFieldNumber = 2;
  ::google::protobuf::int32 tool_type() const;
  void set_tool_type(::google::protobuf::int32 value);

  // required uint64 itemid = 5;
  bool has_itemid() const;
  void clear_itemid();
  static const int kItemidFieldNumber = 5;
  ::google::protobuf::uint64 itemid() const;
  void set_itemid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:db.ConfigTreasureMap)
 private:
  void set_has_toolid();
  void clear_has_toolid();
  void set_has_tool_type();
  void clear_has_tool_type();
  void set_has_name();
  void clear_has_name();
  void set_has_desc();
  void clear_has_desc();
  void set_has_itemid();
  void clear_has_itemid();
  void set_has_location();
  void clear_has_location();
  void set_has_level_range();
  void clear_has_level_range();
  void set_has_trigger();
  void clear_has_trigger();
  void set_has_monster_group();
  void clear_has_monster_group();
  void set_has_monster_drop();
  void clear_has_monster_drop();
  void set_has_treasure_drop();
  void clear_has_treasure_drop();
  void set_has_trap_lost();
  void clear_has_trap_lost();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr desc_;
  ::google::protobuf::internal::ArenaStringPtr location_;
  ::google::protobuf::internal::ArenaStringPtr level_range_;
  ::google::protobuf::internal::ArenaStringPtr trigger_;
  ::google::protobuf::internal::ArenaStringPtr monster_group_;
  ::google::protobuf::internal::ArenaStringPtr monster_drop_;
  ::google::protobuf::internal::ArenaStringPtr treasure_drop_;
  ::google::protobuf::internal::ArenaStringPtr trap_lost_;
  ::google::protobuf::int32 toolid_;
  ::google::protobuf::int32 tool_type_;
  ::google::protobuf::uint64 itemid_;
  friend struct ::protobuf_StoredProcTreasureMap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ConfigTreasureMapList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:db.ConfigTreasureMapList) */ {
 public:
  ConfigTreasureMapList();
  virtual ~ConfigTreasureMapList();

  ConfigTreasureMapList(const ConfigTreasureMapList& from);

  inline ConfigTreasureMapList& operator=(const ConfigTreasureMapList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConfigTreasureMapList(ConfigTreasureMapList&& from) noexcept
    : ConfigTreasureMapList() {
    *this = ::std::move(from);
  }

  inline ConfigTreasureMapList& operator=(ConfigTreasureMapList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const ConfigTreasureMapList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConfigTreasureMapList* internal_default_instance() {
    return reinterpret_cast<const ConfigTreasureMapList*>(
               &_ConfigTreasureMapList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void UnsafeArenaSwap(ConfigTreasureMapList* other);
  void Swap(ConfigTreasureMapList* other);
  friend void swap(ConfigTreasureMapList& a, ConfigTreasureMapList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConfigTreasureMapList* New() const final {
    return CreateMaybeMessage<ConfigTreasureMapList>(NULL);
  }

  ConfigTreasureMapList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConfigTreasureMapList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ConfigTreasureMapList& from);
  void MergeFrom(const ConfigTreasureMapList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigTreasureMapList* other);
  protected:
  explicit ConfigTreasureMapList(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .db.ConfigTreasureMap list = 1;
  int list_size() const;
  void clear_list();
  static const int kListFieldNumber = 1;
  ::db::ConfigTreasureMap* mutable_list(int index);
  ::google::protobuf::RepeatedPtrField< ::db::ConfigTreasureMap >*
      mutable_list();
  const ::db::ConfigTreasureMap& list(int index) const;
  ::db::ConfigTreasureMap* add_list();
  const ::google::protobuf::RepeatedPtrField< ::db::ConfigTreasureMap >&
      list() const;

  // @@protoc_insertion_point(class_scope:db.ConfigTreasureMapList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::db::ConfigTreasureMap > list_;
  friend struct ::protobuf_StoredProcTreasureMap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserStatsTreasureMap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:db.UserStatsTreasureMap) */ {
 public:
  UserStatsTreasureMap();
  virtual ~UserStatsTreasureMap();

  UserStatsTreasureMap(const UserStatsTreasureMap& from);

  inline UserStatsTreasureMap& operator=(const UserStatsTreasureMap& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserStatsTreasureMap(UserStatsTreasureMap&& from) noexcept
    : UserStatsTreasureMap() {
    *this = ::std::move(from);
  }

  inline UserStatsTreasureMap& operator=(UserStatsTreasureMap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserStatsTreasureMap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserStatsTreasureMap* internal_default_instance() {
    return reinterpret_cast<const UserStatsTreasureMap*>(
               &_UserStatsTreasureMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void UnsafeArenaSwap(UserStatsTreasureMap* other);
  void Swap(UserStatsTreasureMap* other);
  friend void swap(UserStatsTreasureMap& a, UserStatsTreasureMap& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserStatsTreasureMap* New() const final {
    return CreateMaybeMessage<UserStatsTreasureMap>(NULL);
  }

  UserStatsTreasureMap* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserStatsTreasureMap>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserStatsTreasureMap& from);
  void MergeFrom(const UserStatsTreasureMap& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserStatsTreasureMap* other);
  protected:
  explicit UserStatsTreasureMap(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes userid = 1;
  bool has_userid() const;
  void clear_userid();
  static const int kUseridFieldNumber = 1;
  const ::std::string& userid() const;
  void set_userid(const ::std::string& value);
  #if LANG_CXX11
  void set_userid(::std::string&& value);
  #endif
  void set_userid(const char* value);
  void set_userid(const void* value, size_t size);
  ::std::string* mutable_userid();
  ::std::string* release_userid();
  void set_allocated_userid(::std::string* userid);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_userid();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_userid(
      ::std::string* userid);

  // required sfixed64 refreshtime = 2;
  bool has_refreshtime() const;
  void clear_refreshtime();
  static const int kRefreshtimeFieldNumber = 2;
  ::google::protobuf::int64 refreshtime() const;
  void set_refreshtime(::google::protobuf::int64 value);

  // required uint32 flag = 3;
  bool has_flag() const;
  void clear_flag();
  static const int kFlagFieldNumber = 3;
  ::google::protobuf::uint32 flag() const;
  void set_flag(::google::protobuf::uint32 value);

  // required uint32 num1 = 4;
  bool has_num1() const;
  void clear_num1();
  static const int kNum1FieldNumber = 4;
  ::google::protobuf::uint32 num1() const;
  void set_num1(::google::protobuf::uint32 value);

  // required uint32 num2 = 5;
  bool has_num2() const;
  void clear_num2();
  static const int kNum2FieldNumber = 5;
  ::google::protobuf::uint32 num2() const;
  void set_num2(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:db.UserStatsTreasureMap)
 private:
  void set_has_userid();
  void clear_has_userid();
  void set_has_refreshtime();
  void clear_has_refreshtime();
  void set_has_flag();
  void clear_has_flag();
  void set_has_num1();
  void clear_has_num1();
  void set_has_num2();
  void clear_has_num2();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr userid_;
  ::google::protobuf::int64 refreshtime_;
  ::google::protobuf::uint32 flag_;
  ::google::protobuf::uint32 num1_;
  ::google::protobuf::uint32 num2_;
  friend struct ::protobuf_StoredProcTreasureMap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserTreasureMap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:db.UserTreasureMap) */ {
 public:
  UserTreasureMap();
  virtual ~UserTreasureMap();

  UserTreasureMap(const UserTreasureMap& from);

  inline UserTreasureMap& operator=(const UserTreasureMap& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserTreasureMap(UserTreasureMap&& from) noexcept
    : UserTreasureMap() {
    *this = ::std::move(from);
  }

  inline UserTreasureMap& operator=(UserTreasureMap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserTreasureMap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserTreasureMap* internal_default_instance() {
    return reinterpret_cast<const UserTreasureMap*>(
               &_UserTreasureMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void UnsafeArenaSwap(UserTreasureMap* other);
  void Swap(UserTreasureMap* other);
  friend void swap(UserTreasureMap& a, UserTreasureMap& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserTreasureMap* New() const final {
    return CreateMaybeMessage<UserTreasureMap>(NULL);
  }

  UserTreasureMap* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserTreasureMap>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserTreasureMap& from);
  void MergeFrom(const UserTreasureMap& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserTreasureMap* other);
  protected:
  explicit UserTreasureMap(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes userid = 1;
  bool has_userid() const;
  void clear_userid();
  static const int kUseridFieldNumber = 1;
  const ::std::string& userid() const;
  void set_userid(const ::std::string& value);
  #if LANG_CXX11
  void set_userid(::std::string&& value);
  #endif
  void set_userid(const char* value);
  void set_userid(const void* value, size_t size);
  ::std::string* mutable_userid();
  ::std::string* release_userid();
  void set_allocated_userid(::std::string* userid);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_userid();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_userid(
      ::std::string* userid);

  // required int32 sn = 2;
  bool has_sn() const;
  void clear_sn();
  static const int kSnFieldNumber = 2;
  ::google::protobuf::int32 sn() const;
  void set_sn(::google::protobuf::int32 value);

  // required int32 toolid = 3;
  bool has_toolid() const;
  void clear_toolid();
  static const int kToolidFieldNumber = 3;
  ::google::protobuf::int32 toolid() const;
  void set_toolid(::google::protobuf::int32 value);

  // required int32 state = 4;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 4;
  ::google::protobuf::int32 state() const;
  void set_state(::google::protobuf::int32 value);

  // required int32 areaid = 5;
  bool has_areaid() const;
  void clear_areaid();
  static const int kAreaidFieldNumber = 5;
  ::google::protobuf::int32 areaid() const;
  void set_areaid(::google::protobuf::int32 value);

  // required int32 coord_x = 6;
  bool has_coord_x() const;
  void clear_coord_x();
  static const int kCoordXFieldNumber = 6;
  ::google::protobuf::int32 coord_x() const;
  void set_coord_x(::google::protobuf::int32 value);

  // required int32 coord_y = 7;
  bool has_coord_y() const;
  void clear_coord_y();
  static const int kCoordYFieldNumber = 7;
  ::google::protobuf::int32 coord_y() const;
  void set_coord_y(::google::protobuf::int32 value);

  // required int32 trap_lost_num = 22;
  bool has_trap_lost_num() const;
  void clear_trap_lost_num();
  static const int kTrapLostNumFieldNumber = 22;
  ::google::protobuf::int32 trap_lost_num() const;
  void set_trap_lost_num(::google::protobuf::int32 value);

  // required int32 monster_group = 11;
  bool has_monster_group() const;
  void clear_monster_group();
  static const int kMonsterGroupFieldNumber = 11;
  ::google::protobuf::int32 monster_group() const;
  void set_monster_group(::google::protobuf::int32 value);

  // required int32 trap_type = 21;
  bool has_trap_type() const;
  void clear_trap_type();
  static const int kTrapTypeFieldNumber = 21;
  ::google::protobuf::int32 trap_type() const;
  void set_trap_type(::google::protobuf::int32 value);

  // optional sfixed64 optime = 31;
  bool has_optime() const;
  void clear_optime();
  static const int kOptimeFieldNumber = 31;
  ::google::protobuf::int64 optime() const;
  void set_optime(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:db.UserTreasureMap)
 private:
  void set_has_userid();
  void clear_has_userid();
  void set_has_sn();
  void clear_has_sn();
  void set_has_toolid();
  void clear_has_toolid();
  void set_has_state();
  void clear_has_state();
  void set_has_areaid();
  void clear_has_areaid();
  void set_has_coord_x();
  void clear_has_coord_x();
  void set_has_coord_y();
  void clear_has_coord_y();
  void set_has_monster_group();
  void clear_has_monster_group();
  void set_has_trap_type();
  void clear_has_trap_type();
  void set_has_trap_lost_num();
  void clear_has_trap_lost_num();
  void set_has_optime();
  void clear_has_optime();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr userid_;
  ::google::protobuf::int32 sn_;
  ::google::protobuf::int32 toolid_;
  ::google::protobuf::int32 state_;
  ::google::protobuf::int32 areaid_;
  ::google::protobuf::int32 coord_x_;
  ::google::protobuf::int32 coord_y_;
  ::google::protobuf::int32 trap_lost_num_;
  ::google::protobuf::int32 monster_group_;
  ::google::protobuf::int32 trap_type_;
  ::google::protobuf::int64 optime_;
  friend struct ::protobuf_StoredProcTreasureMap_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ConfigTreasureMapTile

// required int32 level = 1;
inline bool ConfigTreasureMapTile::has_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConfigTreasureMapTile::set_has_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConfigTreasureMapTile::clear_has_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConfigTreasureMapTile::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 ConfigTreasureMapTile::level() const {
  // @@protoc_insertion_point(field_get:db.ConfigTreasureMapTile.level)
  return level_;
}
inline void ConfigTreasureMapTile::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:db.ConfigTreasureMapTile.level)
}

// required bytes map_size = 2;
inline bool ConfigTreasureMapTile::has_map_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConfigTreasureMapTile::set_has_map_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConfigTreasureMapTile::clear_has_map_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConfigTreasureMapTile::clear_map_size() {
  map_size_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_map_size();
}
inline const ::std::string& ConfigTreasureMapTile::map_size() const {
  // @@protoc_insertion_point(field_get:db.ConfigTreasureMapTile.map_size)
  return map_size_.Get();
}
inline void ConfigTreasureMapTile::set_map_size(const ::std::string& value) {
  set_has_map_size();
  map_size_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:db.ConfigTreasureMapTile.map_size)
}
#if LANG_CXX11
inline void ConfigTreasureMapTile::set_map_size(::std::string&& value) {
  set_has_map_size();
  map_size_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:db.ConfigTreasureMapTile.map_size)
}
#endif
inline void ConfigTreasureMapTile::set_map_size(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_map_size();
  map_size_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:db.ConfigTreasureMapTile.map_size)
}
inline void ConfigTreasureMapTile::set_map_size(const void* value,
    size_t size) {
  set_has_map_size();
  map_size_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:db.ConfigTreasureMapTile.map_size)
}
inline ::std::string* ConfigTreasureMapTile::mutable_map_size() {
  set_has_map_size();
  // @@protoc_insertion_point(field_mutable:db.ConfigTreasureMapTile.map_size)
  return map_size_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* ConfigTreasureMapTile::release_map_size() {
  // @@protoc_insertion_point(field_release:db.ConfigTreasureMapTile.map_size)
  if (!has_map_size()) {
    return NULL;
  }
  clear_has_map_size();
  return map_size_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void ConfigTreasureMapTile::set_allocated_map_size(::std::string* map_size) {
  if (map_size != NULL) {
    set_has_map_size();
  } else {
    clear_has_map_size();
  }
  map_size_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), map_size,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:db.ConfigTreasureMapTile.map_size)
}
inline ::std::string* ConfigTreasureMapTile::unsafe_arena_release_map_size() {
  // @@protoc_insertion_point(field_unsafe_arena_release:db.ConfigTreasureMapTile.map_size)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_map_size();
  return map_size_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void ConfigTreasureMapTile::unsafe_arena_set_allocated_map_size(
    ::std::string* map_size) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (map_size != NULL) {
    set_has_map_size();
  } else {
    clear_has_map_size();
  }
  map_size_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      map_size, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:db.ConfigTreasureMapTile.map_size)
}

// required bytes map_data = 3;
inline bool ConfigTreasureMapTile::has_map_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConfigTreasureMapTile::set_has_map_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConfigTreasureMapTile::clear_has_map_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConfigTreasureMapTile::clear_map_data() {
  map_data_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_map_data();
}
inline const ::std::string& ConfigTreasureMapTile::map_data() const {
  // @@protoc_insertion_point(field_get:db.ConfigTreasureMapTile.map_data)
  return map_data_.Get();
}
inline void ConfigTreasureMapTile::set_map_data(const ::std::string& value) {
  set_has_map_data();
  map_data_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:db.ConfigTreasureMapTile.map_data)
}
#if LANG_CXX11
inline void ConfigTreasureMapTile::set_map_data(::std::string&& value) {
  set_has_map_data();
  map_data_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:db.ConfigTreasureMapTile.map_data)
}
#endif
inline void ConfigTreasureMapTile::set_map_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_map_data();
  map_data_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:db.ConfigTreasureMapTile.map_data)
}
inline void ConfigTreasureMapTile::set_map_data(const void* value,
    size_t size) {
  set_has_map_data();
  map_data_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:db.ConfigTreasureMapTile.map_data)
}
inline ::std::string* ConfigTreasureMapTile::mutable_map_data() {
  set_has_map_data();
  // @@protoc_insertion_point(field_mutable:db.ConfigTreasureMapTile.map_data)
  return map_data_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* ConfigTreasureMapTile::release_map_data() {
  // @@protoc_insertion_point(field_release:db.ConfigTreasureMapTile.map_data)
  if (!has_map_data()) {
    return NULL;
  }
  clear_has_map_data();
  return map_data_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void ConfigTreasureMapTile::set_allocated_map_data(::std::string* map_data) {
  if (map_data != NULL) {
    set_has_map_data();
  } else {
    clear_has_map_data();
  }
  map_data_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), map_data,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:db.ConfigTreasureMapTile.map_data)
}
inline ::std::string* ConfigTreasureMapTile::unsafe_arena_release_map_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:db.ConfigTreasureMapTile.map_data)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_map_data();
  return map_data_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void ConfigTreasureMapTile::unsafe_arena_set_allocated_map_data(
    ::std::string* map_data) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (map_data != NULL) {
    set_has_map_data();
  } else {
    clear_has_map_data();
  }
  map_data_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      map_data, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:db.ConfigTreasureMapTile.map_data)
}

// -------------------------------------------------------------------

// ConfigTreasureMapTileList

// repeated .db.ConfigTreasureMapTile list = 1;
inline int ConfigTreasureMapTileList::list_size() const {
  return list_.size();
}
inline void ConfigTreasureMapTileList::clear_list() {
  list_.Clear();
}
inline ::db::ConfigTreasureMapTile* ConfigTreasureMapTileList::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:db.ConfigTreasureMapTileList.list)
  return list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::db::ConfigTreasureMapTile >*
ConfigTreasureMapTileList::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:db.ConfigTreasureMapTileList.list)
  return &list_;
}
inline const ::db::ConfigTreasureMapTile& ConfigTreasureMapTileList::list(int index) const {
  // @@protoc_insertion_point(field_get:db.ConfigTreasureMapTileList.list)
  return list_.Get(index);
}
inline ::db::ConfigTreasureMapTile* ConfigTreasureMapTileList::add_list() {
  // @@protoc_insertion_point(field_add:db.ConfigTreasureMapTileList.list)
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::db::ConfigTreasureMapTile >&
ConfigTreasureMapTileList::list() const {
  // @@protoc_insertion_point(field_list:db.ConfigTreasureMapTileList.list)
  return list_;
}

// -------------------------------------------------------------------

// ConfigTreasureMapActivity

// required int32 level = 1;
inline bool ConfigTreasureMapActivity::has_level() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConfigTreasureMapActivity::set_has_level() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConfigTreasureMapActivity::clear_has_level() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConfigTreasureMapActivity::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 ConfigTreasureMapActivity::level() const {
  // @@protoc_insertion_point(field_get:db.ConfigTreasureMapActivity.level)
  return level_;
}
inline void ConfigTreasureMapActivity::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:db.ConfigTreasureMapActivity.level)
}

// required int32 num1 = 2;
inline bool ConfigTreasureMapActivity::has_num1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConfigTreasureMapActivity::set_has_num1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConfigTreasureMapActivity::clear_has_num1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConfigTreasureMapActivity::clear_num1() {
  num1_ = 0;
  clear_has_num1();
}
inline ::google::protobuf::int32 ConfigTreasureMapActivity::num1() const {
  // @@protoc_insertion_point(field_get:db.ConfigTreasureMapActivity.num1)
  return num1_;
}
inline void ConfigTreasureMapActivity::set_num1(::google::protobuf::int32 value) {
  set_has_num1();
  num1_ = value;
  // @@protoc_insertion_point(field_set:db.ConfigTreasureMapActivity.num1)
}

// required int32 num2 = 3;
inline bool ConfigTreasureMapActivity::has_num2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConfigTreasureMapActivity::set_has_num2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConfigTreasureMapActivity::clear_has_num2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConfigTreasureMapActivity::clear_num2() {
  num2_ = 0;
  clear_has_num2();
}
inline ::google::protobuf::int32 ConfigTreasureMapActivity::num2() const {
  // @@protoc_insertion_point(field_get:db.ConfigTreasureMapActivity.num2)
  return num2_;
}
inline void ConfigTreasureMapActivity::set_num2(::google::protobuf::int32 value) {
  set_has_num2();
  num2_ = value;
  // @@protoc_insertion_point(field_set:db.ConfigTreasureMapActivity.num2)
}

// -------------------------------------------------------------------

// ConfigTreasureMapActivityList

// repeated .db.ConfigTreasureMapActivity list = 1;
inline int ConfigTreasureMapActivityList::list_size() const {
  return list_.size();
}
inline void ConfigTreasureMapActivityList::clear_list() {
  list_.Clear();
}
inline ::db::ConfigTreasureMapActivity* ConfigTreasureMapActivityList::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:db.ConfigTreasureMapActivityList.list)
  return list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::db::ConfigTreasureMapActivity >*
ConfigTreasureMapActivityList::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:db.ConfigTreasureMapActivityList.list)
  return &list_;
}
inline const ::db::ConfigTreasureMapActivity& ConfigTreasureMapActivityList::list(int index) const {
  // @@protoc_insertion_point(field_get:db.ConfigTreasureMapActivityList.list)
  return list_.Get(index);
}
inline ::db::ConfigTreasureMapActivity* ConfigTreasureMapActivityList::add_list() {
  // @@protoc_insertion_point(field_add:db.ConfigTreasureMapActivityList.list)
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::db::ConfigTreasureMapActivity >&
ConfigTreasureMapActivityList::list() const {
  // @@protoc_insertion_point(field_list:db.ConfigTreasureMapActivityList.list)
  return list_;
}

// -------------------------------------------------------------------

// ConfigTreasureMap

// required int32 toolid = 1;
inline bool ConfigTreasureMap::has_toolid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ConfigTreasureMap::set_has_toolid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ConfigTreasureMap::clear_has_toolid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ConfigTreasureMap::clear_toolid() {
  toolid_ = 0;
  clear_has_toolid();
}
inline ::google::protobuf::int32 ConfigTreasureMap::toolid() const {
  // @@protoc_insertion_point(field_get:db.ConfigTreasureMap.toolid)
  return toolid_;
}
inline void ConfigTreasureMap::set_toolid(::google::protobuf::int32 value) {
  set_has_toolid();
  toolid_ = value;
  // @@protoc_insertion_point(field_set:db.ConfigTreasureMap.toolid)
}

// required int32 tool_type = 2;
inline bool ConfigTreasureMap::has_tool_type() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ConfigTreasureMap::set_has_tool_type() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ConfigTreasureMap::clear_has_tool_type() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ConfigTreasureMap::clear_tool_type() {
  tool_type_ = 0;
  clear_has_tool_type();
}
inline ::google::protobuf::int32 ConfigTreasureMap::tool_type() const {
  // @@protoc_insertion_point(field_get:db.ConfigTreasureMap.tool_type)
  return tool_type_;
}
inline void ConfigTreasureMap::set_tool_type(::google::protobuf::int32 value) {
  set_has_tool_type();
  tool_type_ = value;
  // @@protoc_insertion_point(field_set:db.ConfigTreasureMap.tool_type)
}

// required bytes name = 3;
inline bool ConfigTreasureMap::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConfigTreasureMap::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConfigTreasureMap::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConfigTreasureMap::clear_name() {
  name_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_name();
}
inline const ::std::string& ConfigTreasureMap::name() const {
  // @@protoc_insertion_point(field_get:db.ConfigTreasureMap.name)
  return name_.Get();
}
inline void ConfigTreasureMap::set_name(const ::std::string& value) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:db.ConfigTreasureMap.name)
}
#if LANG_CXX11
inline void ConfigTreasureMap::set_name(::std::string&& value) {
  set_has_name();
  name_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:db.ConfigTreasureMap.name)
}
#endif
inline void ConfigTreasureMap::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:db.ConfigTreasureMap.name)
}
inline void ConfigTreasureMap::set_name(const void* value,
    size_t size) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:db.ConfigTreasureMap.name)
}
inline ::std::string* ConfigTreasureMap::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:db.ConfigTreasureMap.name)
  return name_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* ConfigTreasureMap::release_name() {
  // @@protoc_insertion_point(field_release:db.ConfigTreasureMap.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void ConfigTreasureMap::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:db.ConfigTreasureMap.name)
}
inline ::std::string* ConfigTreasureMap::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:db.ConfigTreasureMap.name)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_name();
  return name_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void ConfigTreasureMap::unsafe_arena_set_allocated_name(
    ::std::string* name) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      name, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:db.ConfigTreasureMap.name)
}

// required bytes desc = 4;
inline bool ConfigTreasureMap::has_desc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConfigTreasureMap::set_has_desc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConfigTreasureMap::clear_has_desc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConfigTreasureMap::clear_desc() {
  desc_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_desc();
}
inline const ::std::string& ConfigTreasureMap::desc() const {
  // @@protoc_insertion_point(field_get:db.ConfigTreasureMap.desc)
  return desc_.Get();
}
inline void ConfigTreasureMap::set_desc(const ::std::string& value) {
  set_has_desc();
  desc_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:db.ConfigTreasureMap.desc)
}
#if LANG_CXX11
inline void ConfigTreasureMap::set_desc(::std::string&& value) {
  set_has_desc();
  desc_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:db.ConfigTreasureMap.desc)
}
#endif
inline void ConfigTreasureMap::set_desc(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_desc();
  desc_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:db.ConfigTreasureMap.desc)
}
inline void ConfigTreasureMap::set_desc(const void* value,
    size_t size) {
  set_has_desc();
  desc_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:db.ConfigTreasureMap.desc)
}
inline ::std::string* ConfigTreasureMap::mutable_desc() {
  set_has_desc();
  // @@protoc_insertion_point(field_mutable:db.ConfigTreasureMap.desc)
  return desc_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* ConfigTreasureMap::release_desc() {
  // @@protoc_insertion_point(field_release:db.ConfigTreasureMap.desc)
  if (!has_desc()) {
    return NULL;
  }
  clear_has_desc();
  return desc_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void ConfigTreasureMap::set_allocated_desc(::std::string* desc) {
  if (desc != NULL) {
    set_has_desc();
  } else {
    clear_has_desc();
  }
  desc_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), desc,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:db.ConfigTreasureMap.desc)
}
inline ::std::string* ConfigTreasureMap::unsafe_arena_release_desc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:db.ConfigTreasureMap.desc)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_desc();
  return desc_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void ConfigTreasureMap::unsafe_arena_set_allocated_desc(
    ::std::string* desc) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (desc != NULL) {
    set_has_desc();
  } else {
    clear_has_desc();
  }
  desc_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      desc, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:db.ConfigTreasureMap.desc)
}

// required uint64 itemid = 5;
inline bool ConfigTreasureMap::has_itemid() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ConfigTreasureMap::set_has_itemid() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ConfigTreasureMap::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ConfigTreasureMap::clear_itemid() {
  itemid_ = GOOGLE_ULONGLONG(0);
  clear_has_itemid();
}
inline ::google::protobuf::uint64 ConfigTreasureMap::itemid() const {
  // @@protoc_insertion_point(field_get:db.ConfigTreasureMap.itemid)
  return itemid_;
}
inline void ConfigTreasureMap::set_itemid(::google::protobuf::uint64 value) {
  set_has_itemid();
  itemid_ = value;
  // @@protoc_insertion_point(field_set:db.ConfigTreasureMap.itemid)
}

// required bytes location = 11;
inline bool ConfigTreasureMap::has_location() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConfigTreasureMap::set_has_location() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConfigTreasureMap::clear_has_location() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConfigTreasureMap::clear_location() {
  location_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_location();
}
inline const ::std::string& ConfigTreasureMap::location() const {
  // @@protoc_insertion_point(field_get:db.ConfigTreasureMap.location)
  return location_.Get();
}
inline void ConfigTreasureMap::set_location(const ::std::string& value) {
  set_has_location();
  location_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:db.ConfigTreasureMap.location)
}
#if LANG_CXX11
inline void ConfigTreasureMap::set_location(::std::string&& value) {
  set_has_location();
  location_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:db.ConfigTreasureMap.location)
}
#endif
inline void ConfigTreasureMap::set_location(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_location();
  location_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:db.ConfigTreasureMap.location)
}
inline void ConfigTreasureMap::set_location(const void* value,
    size_t size) {
  set_has_location();
  location_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:db.ConfigTreasureMap.location)
}
inline ::std::string* ConfigTreasureMap::mutable_location() {
  set_has_location();
  // @@protoc_insertion_point(field_mutable:db.ConfigTreasureMap.location)
  return location_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* ConfigTreasureMap::release_location() {
  // @@protoc_insertion_point(field_release:db.ConfigTreasureMap.location)
  if (!has_location()) {
    return NULL;
  }
  clear_has_location();
  return location_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void ConfigTreasureMap::set_allocated_location(::std::string* location) {
  if (location != NULL) {
    set_has_location();
  } else {
    clear_has_location();
  }
  location_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), location,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:db.ConfigTreasureMap.location)
}
inline ::std::string* ConfigTreasureMap::unsafe_arena_release_location() {
  // @@protoc_insertion_point(field_unsafe_arena_release:db.ConfigTreasureMap.location)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_location();
  return location_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void ConfigTreasureMap::unsafe_arena_set_allocated_location(
    ::std::string* location) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (location != NULL) {
    set_has_location();
  } else {
    clear_has_location();
  }
  location_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      location, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:db.ConfigTreasureMap.location)
}

// required bytes level_range = 12;
inline bool ConfigTreasureMap::has_level_range() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ConfigTreasureMap::set_has_level_range() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ConfigTreasureMap::clear_has_level_range() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ConfigTreasureMap::clear_level_range() {
  level_range_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_level_range();
}
inline const ::std::string& ConfigTreasureMap::level_range() const {
  // @@protoc_insertion_point(field_get:db.ConfigTreasureMap.level_range)
  return level_range_.Get();
}
inline void ConfigTreasureMap::set_level_range(const ::std::string& value) {
  set_has_level_range();
  level_range_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:db.ConfigTreasureMap.level_range)
}
#if LANG_CXX11
inline void ConfigTreasureMap::set_level_range(::std::string&& value) {
  set_has_level_range();
  level_range_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:db.ConfigTreasureMap.level_range)
}
#endif
inline void ConfigTreasureMap::set_level_range(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_level_range();
  level_range_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:db.ConfigTreasureMap.level_range)
}
inline void ConfigTreasureMap::set_level_range(const void* value,
    size_t size) {
  set_has_level_range();
  level_range_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:db.ConfigTreasureMap.level_range)
}
inline ::std::string* ConfigTreasureMap::mutable_level_range() {
  set_has_level_range();
  // @@protoc_insertion_point(field_mutable:db.ConfigTreasureMap.level_range)
  return level_range_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* ConfigTreasureMap::release_level_range() {
  // @@protoc_insertion_point(field_release:db.ConfigTreasureMap.level_range)
  if (!has_level_range()) {
    return NULL;
  }
  clear_has_level_range();
  return level_range_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void ConfigTreasureMap::set_allocated_level_range(::std::string* level_range) {
  if (level_range != NULL) {
    set_has_level_range();
  } else {
    clear_has_level_range();
  }
  level_range_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), level_range,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:db.ConfigTreasureMap.level_range)
}
inline ::std::string* ConfigTreasureMap::unsafe_arena_release_level_range() {
  // @@protoc_insertion_point(field_unsafe_arena_release:db.ConfigTreasureMap.level_range)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_level_range();
  return level_range_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void ConfigTreasureMap::unsafe_arena_set_allocated_level_range(
    ::std::string* level_range) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (level_range != NULL) {
    set_has_level_range();
  } else {
    clear_has_level_range();
  }
  level_range_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      level_range, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:db.ConfigTreasureMap.level_range)
}

// required bytes trigger = 13;
inline bool ConfigTreasureMap::has_trigger() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ConfigTreasureMap::set_has_trigger() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ConfigTreasureMap::clear_has_trigger() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ConfigTreasureMap::clear_trigger() {
  trigger_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_trigger();
}
inline const ::std::string& ConfigTreasureMap::trigger() const {
  // @@protoc_insertion_point(field_get:db.ConfigTreasureMap.trigger)
  return trigger_.Get();
}
inline void ConfigTreasureMap::set_trigger(const ::std::string& value) {
  set_has_trigger();
  trigger_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:db.ConfigTreasureMap.trigger)
}
#if LANG_CXX11
inline void ConfigTreasureMap::set_trigger(::std::string&& value) {
  set_has_trigger();
  trigger_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:db.ConfigTreasureMap.trigger)
}
#endif
inline void ConfigTreasureMap::set_trigger(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_trigger();
  trigger_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:db.ConfigTreasureMap.trigger)
}
inline void ConfigTreasureMap::set_trigger(const void* value,
    size_t size) {
  set_has_trigger();
  trigger_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:db.ConfigTreasureMap.trigger)
}
inline ::std::string* ConfigTreasureMap::mutable_trigger() {
  set_has_trigger();
  // @@protoc_insertion_point(field_mutable:db.ConfigTreasureMap.trigger)
  return trigger_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* ConfigTreasureMap::release_trigger() {
  // @@protoc_insertion_point(field_release:db.ConfigTreasureMap.trigger)
  if (!has_trigger()) {
    return NULL;
  }
  clear_has_trigger();
  return trigger_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void ConfigTreasureMap::set_allocated_trigger(::std::string* trigger) {
  if (trigger != NULL) {
    set_has_trigger();
  } else {
    clear_has_trigger();
  }
  trigger_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), trigger,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:db.ConfigTreasureMap.trigger)
}
inline ::std::string* ConfigTreasureMap::unsafe_arena_release_trigger() {
  // @@protoc_insertion_point(field_unsafe_arena_release:db.ConfigTreasureMap.trigger)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_trigger();
  return trigger_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void ConfigTreasureMap::unsafe_arena_set_allocated_trigger(
    ::std::string* trigger) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (trigger != NULL) {
    set_has_trigger();
  } else {
    clear_has_trigger();
  }
  trigger_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      trigger, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:db.ConfigTreasureMap.trigger)
}

// required bytes monster_group = 14;
inline bool ConfigTreasureMap::has_monster_group() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ConfigTreasureMap::set_has_monster_group() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ConfigTreasureMap::clear_has_monster_group() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ConfigTreasureMap::clear_monster_group() {
  monster_group_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_monster_group();
}
inline const ::std::string& ConfigTreasureMap::monster_group() const {
  // @@protoc_insertion_point(field_get:db.ConfigTreasureMap.monster_group)
  return monster_group_.Get();
}
inline void ConfigTreasureMap::set_monster_group(const ::std::string& value) {
  set_has_monster_group();
  monster_group_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:db.ConfigTreasureMap.monster_group)
}
#if LANG_CXX11
inline void ConfigTreasureMap::set_monster_group(::std::string&& value) {
  set_has_monster_group();
  monster_group_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:db.ConfigTreasureMap.monster_group)
}
#endif
inline void ConfigTreasureMap::set_monster_group(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_monster_group();
  monster_group_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:db.ConfigTreasureMap.monster_group)
}
inline void ConfigTreasureMap::set_monster_group(const void* value,
    size_t size) {
  set_has_monster_group();
  monster_group_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:db.ConfigTreasureMap.monster_group)
}
inline ::std::string* ConfigTreasureMap::mutable_monster_group() {
  set_has_monster_group();
  // @@protoc_insertion_point(field_mutable:db.ConfigTreasureMap.monster_group)
  return monster_group_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* ConfigTreasureMap::release_monster_group() {
  // @@protoc_insertion_point(field_release:db.ConfigTreasureMap.monster_group)
  if (!has_monster_group()) {
    return NULL;
  }
  clear_has_monster_group();
  return monster_group_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void ConfigTreasureMap::set_allocated_monster_group(::std::string* monster_group) {
  if (monster_group != NULL) {
    set_has_monster_group();
  } else {
    clear_has_monster_group();
  }
  monster_group_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), monster_group,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:db.ConfigTreasureMap.monster_group)
}
inline ::std::string* ConfigTreasureMap::unsafe_arena_release_monster_group() {
  // @@protoc_insertion_point(field_unsafe_arena_release:db.ConfigTreasureMap.monster_group)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_monster_group();
  return monster_group_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void ConfigTreasureMap::unsafe_arena_set_allocated_monster_group(
    ::std::string* monster_group) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (monster_group != NULL) {
    set_has_monster_group();
  } else {
    clear_has_monster_group();
  }
  monster_group_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      monster_group, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:db.ConfigTreasureMap.monster_group)
}

// required bytes monster_drop = 15;
inline bool ConfigTreasureMap::has_monster_drop() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ConfigTreasureMap::set_has_monster_drop() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ConfigTreasureMap::clear_has_monster_drop() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ConfigTreasureMap::clear_monster_drop() {
  monster_drop_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_monster_drop();
}
inline const ::std::string& ConfigTreasureMap::monster_drop() const {
  // @@protoc_insertion_point(field_get:db.ConfigTreasureMap.monster_drop)
  return monster_drop_.Get();
}
inline void ConfigTreasureMap::set_monster_drop(const ::std::string& value) {
  set_has_monster_drop();
  monster_drop_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:db.ConfigTreasureMap.monster_drop)
}
#if LANG_CXX11
inline void ConfigTreasureMap::set_monster_drop(::std::string&& value) {
  set_has_monster_drop();
  monster_drop_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:db.ConfigTreasureMap.monster_drop)
}
#endif
inline void ConfigTreasureMap::set_monster_drop(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_monster_drop();
  monster_drop_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:db.ConfigTreasureMap.monster_drop)
}
inline void ConfigTreasureMap::set_monster_drop(const void* value,
    size_t size) {
  set_has_monster_drop();
  monster_drop_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:db.ConfigTreasureMap.monster_drop)
}
inline ::std::string* ConfigTreasureMap::mutable_monster_drop() {
  set_has_monster_drop();
  // @@protoc_insertion_point(field_mutable:db.ConfigTreasureMap.monster_drop)
  return monster_drop_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* ConfigTreasureMap::release_monster_drop() {
  // @@protoc_insertion_point(field_release:db.ConfigTreasureMap.monster_drop)
  if (!has_monster_drop()) {
    return NULL;
  }
  clear_has_monster_drop();
  return monster_drop_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void ConfigTreasureMap::set_allocated_monster_drop(::std::string* monster_drop) {
  if (monster_drop != NULL) {
    set_has_monster_drop();
  } else {
    clear_has_monster_drop();
  }
  monster_drop_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), monster_drop,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:db.ConfigTreasureMap.monster_drop)
}
inline ::std::string* ConfigTreasureMap::unsafe_arena_release_monster_drop() {
  // @@protoc_insertion_point(field_unsafe_arena_release:db.ConfigTreasureMap.monster_drop)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_monster_drop();
  return monster_drop_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void ConfigTreasureMap::unsafe_arena_set_allocated_monster_drop(
    ::std::string* monster_drop) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (monster_drop != NULL) {
    set_has_monster_drop();
  } else {
    clear_has_monster_drop();
  }
  monster_drop_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      monster_drop, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:db.ConfigTreasureMap.monster_drop)
}

// required bytes treasure_drop = 16;
inline bool ConfigTreasureMap::has_treasure_drop() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ConfigTreasureMap::set_has_treasure_drop() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ConfigTreasureMap::clear_has_treasure_drop() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ConfigTreasureMap::clear_treasure_drop() {
  treasure_drop_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_treasure_drop();
}
inline const ::std::string& ConfigTreasureMap::treasure_drop() const {
  // @@protoc_insertion_point(field_get:db.ConfigTreasureMap.treasure_drop)
  return treasure_drop_.Get();
}
inline void ConfigTreasureMap::set_treasure_drop(const ::std::string& value) {
  set_has_treasure_drop();
  treasure_drop_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:db.ConfigTreasureMap.treasure_drop)
}
#if LANG_CXX11
inline void ConfigTreasureMap::set_treasure_drop(::std::string&& value) {
  set_has_treasure_drop();
  treasure_drop_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:db.ConfigTreasureMap.treasure_drop)
}
#endif
inline void ConfigTreasureMap::set_treasure_drop(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_treasure_drop();
  treasure_drop_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:db.ConfigTreasureMap.treasure_drop)
}
inline void ConfigTreasureMap::set_treasure_drop(const void* value,
    size_t size) {
  set_has_treasure_drop();
  treasure_drop_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:db.ConfigTreasureMap.treasure_drop)
}
inline ::std::string* ConfigTreasureMap::mutable_treasure_drop() {
  set_has_treasure_drop();
  // @@protoc_insertion_point(field_mutable:db.ConfigTreasureMap.treasure_drop)
  return treasure_drop_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* ConfigTreasureMap::release_treasure_drop() {
  // @@protoc_insertion_point(field_release:db.ConfigTreasureMap.treasure_drop)
  if (!has_treasure_drop()) {
    return NULL;
  }
  clear_has_treasure_drop();
  return treasure_drop_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void ConfigTreasureMap::set_allocated_treasure_drop(::std::string* treasure_drop) {
  if (treasure_drop != NULL) {
    set_has_treasure_drop();
  } else {
    clear_has_treasure_drop();
  }
  treasure_drop_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), treasure_drop,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:db.ConfigTreasureMap.treasure_drop)
}
inline ::std::string* ConfigTreasureMap::unsafe_arena_release_treasure_drop() {
  // @@protoc_insertion_point(field_unsafe_arena_release:db.ConfigTreasureMap.treasure_drop)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_treasure_drop();
  return treasure_drop_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void ConfigTreasureMap::unsafe_arena_set_allocated_treasure_drop(
    ::std::string* treasure_drop) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (treasure_drop != NULL) {
    set_has_treasure_drop();
  } else {
    clear_has_treasure_drop();
  }
  treasure_drop_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      treasure_drop, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:db.ConfigTreasureMap.treasure_drop)
}

// required bytes trap_lost = 17;
inline bool ConfigTreasureMap::has_trap_lost() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ConfigTreasureMap::set_has_trap_lost() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ConfigTreasureMap::clear_has_trap_lost() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ConfigTreasureMap::clear_trap_lost() {
  trap_lost_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_trap_lost();
}
inline const ::std::string& ConfigTreasureMap::trap_lost() const {
  // @@protoc_insertion_point(field_get:db.ConfigTreasureMap.trap_lost)
  return trap_lost_.Get();
}
inline void ConfigTreasureMap::set_trap_lost(const ::std::string& value) {
  set_has_trap_lost();
  trap_lost_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:db.ConfigTreasureMap.trap_lost)
}
#if LANG_CXX11
inline void ConfigTreasureMap::set_trap_lost(::std::string&& value) {
  set_has_trap_lost();
  trap_lost_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:db.ConfigTreasureMap.trap_lost)
}
#endif
inline void ConfigTreasureMap::set_trap_lost(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_trap_lost();
  trap_lost_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:db.ConfigTreasureMap.trap_lost)
}
inline void ConfigTreasureMap::set_trap_lost(const void* value,
    size_t size) {
  set_has_trap_lost();
  trap_lost_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:db.ConfigTreasureMap.trap_lost)
}
inline ::std::string* ConfigTreasureMap::mutable_trap_lost() {
  set_has_trap_lost();
  // @@protoc_insertion_point(field_mutable:db.ConfigTreasureMap.trap_lost)
  return trap_lost_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* ConfigTreasureMap::release_trap_lost() {
  // @@protoc_insertion_point(field_release:db.ConfigTreasureMap.trap_lost)
  if (!has_trap_lost()) {
    return NULL;
  }
  clear_has_trap_lost();
  return trap_lost_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void ConfigTreasureMap::set_allocated_trap_lost(::std::string* trap_lost) {
  if (trap_lost != NULL) {
    set_has_trap_lost();
  } else {
    clear_has_trap_lost();
  }
  trap_lost_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), trap_lost,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:db.ConfigTreasureMap.trap_lost)
}
inline ::std::string* ConfigTreasureMap::unsafe_arena_release_trap_lost() {
  // @@protoc_insertion_point(field_unsafe_arena_release:db.ConfigTreasureMap.trap_lost)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_trap_lost();
  return trap_lost_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void ConfigTreasureMap::unsafe_arena_set_allocated_trap_lost(
    ::std::string* trap_lost) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (trap_lost != NULL) {
    set_has_trap_lost();
  } else {
    clear_has_trap_lost();
  }
  trap_lost_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      trap_lost, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:db.ConfigTreasureMap.trap_lost)
}

// -------------------------------------------------------------------

// ConfigTreasureMapList

// repeated .db.ConfigTreasureMap list = 1;
inline int ConfigTreasureMapList::list_size() const {
  return list_.size();
}
inline void ConfigTreasureMapList::clear_list() {
  list_.Clear();
}
inline ::db::ConfigTreasureMap* ConfigTreasureMapList::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:db.ConfigTreasureMapList.list)
  return list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::db::ConfigTreasureMap >*
ConfigTreasureMapList::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:db.ConfigTreasureMapList.list)
  return &list_;
}
inline const ::db::ConfigTreasureMap& ConfigTreasureMapList::list(int index) const {
  // @@protoc_insertion_point(field_get:db.ConfigTreasureMapList.list)
  return list_.Get(index);
}
inline ::db::ConfigTreasureMap* ConfigTreasureMapList::add_list() {
  // @@protoc_insertion_point(field_add:db.ConfigTreasureMapList.list)
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::db::ConfigTreasureMap >&
ConfigTreasureMapList::list() const {
  // @@protoc_insertion_point(field_list:db.ConfigTreasureMapList.list)
  return list_;
}

// -------------------------------------------------------------------

// UserStatsTreasureMap

// required bytes userid = 1;
inline bool UserStatsTreasureMap::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserStatsTreasureMap::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserStatsTreasureMap::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserStatsTreasureMap::clear_userid() {
  userid_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_userid();
}
inline const ::std::string& UserStatsTreasureMap::userid() const {
  // @@protoc_insertion_point(field_get:db.UserStatsTreasureMap.userid)
  return userid_.Get();
}
inline void UserStatsTreasureMap::set_userid(const ::std::string& value) {
  set_has_userid();
  userid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:db.UserStatsTreasureMap.userid)
}
#if LANG_CXX11
inline void UserStatsTreasureMap::set_userid(::std::string&& value) {
  set_has_userid();
  userid_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:db.UserStatsTreasureMap.userid)
}
#endif
inline void UserStatsTreasureMap::set_userid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_userid();
  userid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:db.UserStatsTreasureMap.userid)
}
inline void UserStatsTreasureMap::set_userid(const void* value,
    size_t size) {
  set_has_userid();
  userid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:db.UserStatsTreasureMap.userid)
}
inline ::std::string* UserStatsTreasureMap::mutable_userid() {
  set_has_userid();
  // @@protoc_insertion_point(field_mutable:db.UserStatsTreasureMap.userid)
  return userid_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* UserStatsTreasureMap::release_userid() {
  // @@protoc_insertion_point(field_release:db.UserStatsTreasureMap.userid)
  if (!has_userid()) {
    return NULL;
  }
  clear_has_userid();
  return userid_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void UserStatsTreasureMap::set_allocated_userid(::std::string* userid) {
  if (userid != NULL) {
    set_has_userid();
  } else {
    clear_has_userid();
  }
  userid_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), userid,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:db.UserStatsTreasureMap.userid)
}
inline ::std::string* UserStatsTreasureMap::unsafe_arena_release_userid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:db.UserStatsTreasureMap.userid)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_userid();
  return userid_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void UserStatsTreasureMap::unsafe_arena_set_allocated_userid(
    ::std::string* userid) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (userid != NULL) {
    set_has_userid();
  } else {
    clear_has_userid();
  }
  userid_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      userid, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:db.UserStatsTreasureMap.userid)
}

// required sfixed64 refreshtime = 2;
inline bool UserStatsTreasureMap::has_refreshtime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserStatsTreasureMap::set_has_refreshtime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserStatsTreasureMap::clear_has_refreshtime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserStatsTreasureMap::clear_refreshtime() {
  refreshtime_ = GOOGLE_LONGLONG(0);
  clear_has_refreshtime();
}
inline ::google::protobuf::int64 UserStatsTreasureMap::refreshtime() const {
  // @@protoc_insertion_point(field_get:db.UserStatsTreasureMap.refreshtime)
  return refreshtime_;
}
inline void UserStatsTreasureMap::set_refreshtime(::google::protobuf::int64 value) {
  set_has_refreshtime();
  refreshtime_ = value;
  // @@protoc_insertion_point(field_set:db.UserStatsTreasureMap.refreshtime)
}

// required uint32 flag = 3;
inline bool UserStatsTreasureMap::has_flag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserStatsTreasureMap::set_has_flag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserStatsTreasureMap::clear_has_flag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserStatsTreasureMap::clear_flag() {
  flag_ = 0u;
  clear_has_flag();
}
inline ::google::protobuf::uint32 UserStatsTreasureMap::flag() const {
  // @@protoc_insertion_point(field_get:db.UserStatsTreasureMap.flag)
  return flag_;
}
inline void UserStatsTreasureMap::set_flag(::google::protobuf::uint32 value) {
  set_has_flag();
  flag_ = value;
  // @@protoc_insertion_point(field_set:db.UserStatsTreasureMap.flag)
}

// required uint32 num1 = 4;
inline bool UserStatsTreasureMap::has_num1() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserStatsTreasureMap::set_has_num1() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserStatsTreasureMap::clear_has_num1() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserStatsTreasureMap::clear_num1() {
  num1_ = 0u;
  clear_has_num1();
}
inline ::google::protobuf::uint32 UserStatsTreasureMap::num1() const {
  // @@protoc_insertion_point(field_get:db.UserStatsTreasureMap.num1)
  return num1_;
}
inline void UserStatsTreasureMap::set_num1(::google::protobuf::uint32 value) {
  set_has_num1();
  num1_ = value;
  // @@protoc_insertion_point(field_set:db.UserStatsTreasureMap.num1)
}

// required uint32 num2 = 5;
inline bool UserStatsTreasureMap::has_num2() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserStatsTreasureMap::set_has_num2() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserStatsTreasureMap::clear_has_num2() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserStatsTreasureMap::clear_num2() {
  num2_ = 0u;
  clear_has_num2();
}
inline ::google::protobuf::uint32 UserStatsTreasureMap::num2() const {
  // @@protoc_insertion_point(field_get:db.UserStatsTreasureMap.num2)
  return num2_;
}
inline void UserStatsTreasureMap::set_num2(::google::protobuf::uint32 value) {
  set_has_num2();
  num2_ = value;
  // @@protoc_insertion_point(field_set:db.UserStatsTreasureMap.num2)
}

// -------------------------------------------------------------------

// UserTreasureMap

// required bytes userid = 1;
inline bool UserTreasureMap::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserTreasureMap::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserTreasureMap::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserTreasureMap::clear_userid() {
  userid_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_userid();
}
inline const ::std::string& UserTreasureMap::userid() const {
  // @@protoc_insertion_point(field_get:db.UserTreasureMap.userid)
  return userid_.Get();
}
inline void UserTreasureMap::set_userid(const ::std::string& value) {
  set_has_userid();
  userid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:db.UserTreasureMap.userid)
}
#if LANG_CXX11
inline void UserTreasureMap::set_userid(::std::string&& value) {
  set_has_userid();
  userid_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:db.UserTreasureMap.userid)
}
#endif
inline void UserTreasureMap::set_userid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_userid();
  userid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:db.UserTreasureMap.userid)
}
inline void UserTreasureMap::set_userid(const void* value,
    size_t size) {
  set_has_userid();
  userid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:db.UserTreasureMap.userid)
}
inline ::std::string* UserTreasureMap::mutable_userid() {
  set_has_userid();
  // @@protoc_insertion_point(field_mutable:db.UserTreasureMap.userid)
  return userid_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* UserTreasureMap::release_userid() {
  // @@protoc_insertion_point(field_release:db.UserTreasureMap.userid)
  if (!has_userid()) {
    return NULL;
  }
  clear_has_userid();
  return userid_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void UserTreasureMap::set_allocated_userid(::std::string* userid) {
  if (userid != NULL) {
    set_has_userid();
  } else {
    clear_has_userid();
  }
  userid_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), userid,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:db.UserTreasureMap.userid)
}
inline ::std::string* UserTreasureMap::unsafe_arena_release_userid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:db.UserTreasureMap.userid)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_userid();
  return userid_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void UserTreasureMap::unsafe_arena_set_allocated_userid(
    ::std::string* userid) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (userid != NULL) {
    set_has_userid();
  } else {
    clear_has_userid();
  }
  userid_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      userid, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:db.UserTreasureMap.userid)
}

// required int32 sn = 2;
inline bool UserTreasureMap::has_sn() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserTreasureMap::set_has_sn() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserTreasureMap::clear_has_sn() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserTreasureMap::clear_sn() {
  sn_ = 0;
  clear_has_sn();
}
inline ::google::protobuf::int32 UserTreasureMap::sn() const {
  // @@protoc_insertion_point(field_get:db.UserTreasureMap.sn)
  return sn_;
}
inline void UserTreasureMap::set_sn(::google::protobuf::int32 value) {
  set_has_sn();
  sn_ = value;
  // @@protoc_insertion_point(field_set:db.UserTreasureMap.sn)
}

// required int32 toolid = 3;
inline bool UserTreasureMap::has_toolid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserTreasureMap::set_has_toolid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserTreasureMap::clear_has_toolid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserTreasureMap::clear_toolid() {
  toolid_ = 0;
  clear_has_toolid();
}
inline ::google::protobuf::int32 UserTreasureMap::toolid() const {
  // @@protoc_insertion_point(field_get:db.UserTreasureMap.toolid)
  return toolid_;
}
inline void UserTreasureMap::set_toolid(::google::protobuf::int32 value) {
  set_has_toolid();
  toolid_ = value;
  // @@protoc_insertion_point(field_set:db.UserTreasureMap.toolid)
}

// required int32 state = 4;
inline bool UserTreasureMap::has_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserTreasureMap::set_has_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserTreasureMap::clear_has_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserTreasureMap::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 UserTreasureMap::state() const {
  // @@protoc_insertion_point(field_get:db.UserTreasureMap.state)
  return state_;
}
inline void UserTreasureMap::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:db.UserTreasureMap.state)
}

// required int32 areaid = 5;
inline bool UserTreasureMap::has_areaid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserTreasureMap::set_has_areaid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserTreasureMap::clear_has_areaid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserTreasureMap::clear_areaid() {
  areaid_ = 0;
  clear_has_areaid();
}
inline ::google::protobuf::int32 UserTreasureMap::areaid() const {
  // @@protoc_insertion_point(field_get:db.UserTreasureMap.areaid)
  return areaid_;
}
inline void UserTreasureMap::set_areaid(::google::protobuf::int32 value) {
  set_has_areaid();
  areaid_ = value;
  // @@protoc_insertion_point(field_set:db.UserTreasureMap.areaid)
}

// required int32 coord_x = 6;
inline bool UserTreasureMap::has_coord_x() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserTreasureMap::set_has_coord_x() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserTreasureMap::clear_has_coord_x() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserTreasureMap::clear_coord_x() {
  coord_x_ = 0;
  clear_has_coord_x();
}
inline ::google::protobuf::int32 UserTreasureMap::coord_x() const {
  // @@protoc_insertion_point(field_get:db.UserTreasureMap.coord_x)
  return coord_x_;
}
inline void UserTreasureMap::set_coord_x(::google::protobuf::int32 value) {
  set_has_coord_x();
  coord_x_ = value;
  // @@protoc_insertion_point(field_set:db.UserTreasureMap.coord_x)
}

// required int32 coord_y = 7;
inline bool UserTreasureMap::has_coord_y() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserTreasureMap::set_has_coord_y() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserTreasureMap::clear_has_coord_y() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserTreasureMap::clear_coord_y() {
  coord_y_ = 0;
  clear_has_coord_y();
}
inline ::google::protobuf::int32 UserTreasureMap::coord_y() const {
  // @@protoc_insertion_point(field_get:db.UserTreasureMap.coord_y)
  return coord_y_;
}
inline void UserTreasureMap::set_coord_y(::google::protobuf::int32 value) {
  set_has_coord_y();
  coord_y_ = value;
  // @@protoc_insertion_point(field_set:db.UserTreasureMap.coord_y)
}

// required int32 monster_group = 11;
inline bool UserTreasureMap::has_monster_group() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UserTreasureMap::set_has_monster_group() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UserTreasureMap::clear_has_monster_group() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UserTreasureMap::clear_monster_group() {
  monster_group_ = 0;
  clear_has_monster_group();
}
inline ::google::protobuf::int32 UserTreasureMap::monster_group() const {
  // @@protoc_insertion_point(field_get:db.UserTreasureMap.monster_group)
  return monster_group_;
}
inline void UserTreasureMap::set_monster_group(::google::protobuf::int32 value) {
  set_has_monster_group();
  monster_group_ = value;
  // @@protoc_insertion_point(field_set:db.UserTreasureMap.monster_group)
}

// required int32 trap_type = 21;
inline bool UserTreasureMap::has_trap_type() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UserTreasureMap::set_has_trap_type() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UserTreasureMap::clear_has_trap_type() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UserTreasureMap::clear_trap_type() {
  trap_type_ = 0;
  clear_has_trap_type();
}
inline ::google::protobuf::int32 UserTreasureMap::trap_type() const {
  // @@protoc_insertion_point(field_get:db.UserTreasureMap.trap_type)
  return trap_type_;
}
inline void UserTreasureMap::set_trap_type(::google::protobuf::int32 value) {
  set_has_trap_type();
  trap_type_ = value;
  // @@protoc_insertion_point(field_set:db.UserTreasureMap.trap_type)
}

// required int32 trap_lost_num = 22;
inline bool UserTreasureMap::has_trap_lost_num() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserTreasureMap::set_has_trap_lost_num() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserTreasureMap::clear_has_trap_lost_num() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserTreasureMap::clear_trap_lost_num() {
  trap_lost_num_ = 0;
  clear_has_trap_lost_num();
}
inline ::google::protobuf::int32 UserTreasureMap::trap_lost_num() const {
  // @@protoc_insertion_point(field_get:db.UserTreasureMap.trap_lost_num)
  return trap_lost_num_;
}
inline void UserTreasureMap::set_trap_lost_num(::google::protobuf::int32 value) {
  set_has_trap_lost_num();
  trap_lost_num_ = value;
  // @@protoc_insertion_point(field_set:db.UserTreasureMap.trap_lost_num)
}

// optional sfixed64 optime = 31;
inline bool UserTreasureMap::has_optime() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void UserTreasureMap::set_has_optime() {
  _has_bits_[0] |= 0x00000400u;
}
inline void UserTreasureMap::clear_has_optime() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void UserTreasureMap::clear_optime() {
  optime_ = GOOGLE_LONGLONG(0);
  clear_has_optime();
}
inline ::google::protobuf::int64 UserTreasureMap::optime() const {
  // @@protoc_insertion_point(field_get:db.UserTreasureMap.optime)
  return optime_;
}
inline void UserTreasureMap::set_optime(::google::protobuf::int64 value) {
  set_has_optime();
  optime_ = value;
  // @@protoc_insertion_point(field_set:db.UserTreasureMap.optime)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace db

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_StoredProcTreasureMap_2eproto
