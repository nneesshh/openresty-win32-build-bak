// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Moments.proto

#ifndef PROTOBUF_INCLUDED_Moments_2eproto
#define PROTOBUF_INCLUDED_Moments_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_Moments_2eproto 

namespace protobuf_Moments_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[7];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_Moments_2eproto
namespace sg {
class CommentContent;
class CommentContentDefaultTypeInternal;
extern CommentContentDefaultTypeInternal _CommentContent_default_instance_;
class CommentContentList;
class CommentContentListDefaultTypeInternal;
extern CommentContentListDefaultTypeInternal _CommentContentList_default_instance_;
class CommentData;
class CommentDataDefaultTypeInternal;
extern CommentDataDefaultTypeInternal _CommentData_default_instance_;
class CommentDataList;
class CommentDataListDefaultTypeInternal;
extern CommentDataListDefaultTypeInternal _CommentDataList_default_instance_;
class CommentService;
class CommentServiceDefaultTypeInternal;
extern CommentServiceDefaultTypeInternal _CommentService_default_instance_;
class CommentService_CommentRequest;
class CommentService_CommentRequestDefaultTypeInternal;
extern CommentService_CommentRequestDefaultTypeInternal _CommentService_CommentRequest_default_instance_;
class CommentService_CommentResponse;
class CommentService_CommentResponseDefaultTypeInternal;
extern CommentService_CommentResponseDefaultTypeInternal _CommentService_CommentResponse_default_instance_;
}  // namespace sg
namespace google {
namespace protobuf {
template<> ::sg::CommentContent* Arena::CreateMaybeMessage<::sg::CommentContent>(Arena*);
template<> ::sg::CommentContentList* Arena::CreateMaybeMessage<::sg::CommentContentList>(Arena*);
template<> ::sg::CommentData* Arena::CreateMaybeMessage<::sg::CommentData>(Arena*);
template<> ::sg::CommentDataList* Arena::CreateMaybeMessage<::sg::CommentDataList>(Arena*);
template<> ::sg::CommentService* Arena::CreateMaybeMessage<::sg::CommentService>(Arena*);
template<> ::sg::CommentService_CommentRequest* Arena::CreateMaybeMessage<::sg::CommentService_CommentRequest>(Arena*);
template<> ::sg::CommentService_CommentResponse* Arena::CreateMaybeMessage<::sg::CommentService_CommentResponse>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace sg {

enum CommentService_COMMENT_COMMAND {
  CommentService_COMMENT_COMMAND_QUERY = 1,
  CommentService_COMMENT_COMMAND_ADD = 2,
  CommentService_COMMENT_COMMAND_LIKE = 3
};
bool CommentService_COMMENT_COMMAND_IsValid(int value);
const CommentService_COMMENT_COMMAND CommentService_COMMENT_COMMAND_COMMENT_COMMAND_MIN = CommentService_COMMENT_COMMAND_QUERY;
const CommentService_COMMENT_COMMAND CommentService_COMMENT_COMMAND_COMMENT_COMMAND_MAX = CommentService_COMMENT_COMMAND_LIKE;
const int CommentService_COMMENT_COMMAND_COMMENT_COMMAND_ARRAYSIZE = CommentService_COMMENT_COMMAND_COMMENT_COMMAND_MAX + 1;

const ::google::protobuf::EnumDescriptor* CommentService_COMMENT_COMMAND_descriptor();
inline const ::std::string& CommentService_COMMENT_COMMAND_Name(CommentService_COMMENT_COMMAND value) {
  return ::google::protobuf::internal::NameOfEnum(
    CommentService_COMMENT_COMMAND_descriptor(), value);
}
inline bool CommentService_COMMENT_COMMAND_Parse(
    const ::std::string& name, CommentService_COMMENT_COMMAND* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CommentService_COMMENT_COMMAND>(
    CommentService_COMMENT_COMMAND_descriptor(), name, value);
}
enum COMMENT_SUBJECT_CATEGORY {
  COMMENT_SUBJECT_UNKNOWN = 0,
  COMMENT_SUBJECT_SHIP = 1,
  COMMENT_SUBJECT_EQUIP = 2,
  COMMENT_SUBJECT_SCENE = 3
};
bool COMMENT_SUBJECT_CATEGORY_IsValid(int value);
const COMMENT_SUBJECT_CATEGORY COMMENT_SUBJECT_CATEGORY_MIN = COMMENT_SUBJECT_UNKNOWN;
const COMMENT_SUBJECT_CATEGORY COMMENT_SUBJECT_CATEGORY_MAX = COMMENT_SUBJECT_SCENE;
const int COMMENT_SUBJECT_CATEGORY_ARRAYSIZE = COMMENT_SUBJECT_CATEGORY_MAX + 1;

const ::google::protobuf::EnumDescriptor* COMMENT_SUBJECT_CATEGORY_descriptor();
inline const ::std::string& COMMENT_SUBJECT_CATEGORY_Name(COMMENT_SUBJECT_CATEGORY value) {
  return ::google::protobuf::internal::NameOfEnum(
    COMMENT_SUBJECT_CATEGORY_descriptor(), value);
}
inline bool COMMENT_SUBJECT_CATEGORY_Parse(
    const ::std::string& name, COMMENT_SUBJECT_CATEGORY* value) {
  return ::google::protobuf::internal::ParseNamedEnum<COMMENT_SUBJECT_CATEGORY>(
    COMMENT_SUBJECT_CATEGORY_descriptor(), name, value);
}
enum COMMENT_ERROR {
  COMMENT_ERROR_SUBJECTID_IS_INVALID = -1,
  COMMENT_ERROR_CONTENT_LENGTH_IS_INVALID = -2,
  COMMENT_ERROR_ROLE_LEVEL_IS_TOO_LOW = -3,
  COMMENT_ERROR_COMMENT_NUM_OVERFLOW = -4,
  COMMENT_ERROR_COMMENT_IS_TOO_HOT = -5,
  COMMENT_ERROR_ = -6
};
bool COMMENT_ERROR_IsValid(int value);
const COMMENT_ERROR COMMENT_ERROR_MIN = COMMENT_ERROR_;
const COMMENT_ERROR COMMENT_ERROR_MAX = COMMENT_ERROR_SUBJECTID_IS_INVALID;
const int COMMENT_ERROR_ARRAYSIZE = COMMENT_ERROR_MAX + 1;

const ::google::protobuf::EnumDescriptor* COMMENT_ERROR_descriptor();
inline const ::std::string& COMMENT_ERROR_Name(COMMENT_ERROR value) {
  return ::google::protobuf::internal::NameOfEnum(
    COMMENT_ERROR_descriptor(), value);
}
inline bool COMMENT_ERROR_Parse(
    const ::std::string& name, COMMENT_ERROR* value) {
  return ::google::protobuf::internal::ParseNamedEnum<COMMENT_ERROR>(
    COMMENT_ERROR_descriptor(), name, value);
}
// ===================================================================

class CommentContent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.CommentContent) */ {
 public:
  CommentContent();
  virtual ~CommentContent();

  CommentContent(const CommentContent& from);

  inline CommentContent& operator=(const CommentContent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CommentContent(CommentContent&& from) noexcept
    : CommentContent() {
    *this = ::std::move(from);
  }

  inline CommentContent& operator=(CommentContent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const CommentContent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CommentContent* internal_default_instance() {
    return reinterpret_cast<const CommentContent*>(
               &_CommentContent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void UnsafeArenaSwap(CommentContent* other);
  void Swap(CommentContent* other);
  friend void swap(CommentContent& a, CommentContent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CommentContent* New() const final {
    return CreateMaybeMessage<CommentContent>(NULL);
  }

  CommentContent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CommentContent>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CommentContent& from);
  void MergeFrom(const CommentContent& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommentContent* other);
  protected:
  explicit CommentContent(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes nick = 2;
  bool has_nick() const;
  void clear_nick();
  static const int kNickFieldNumber = 2;
  const ::std::string& nick() const;
  void set_nick(const ::std::string& value);
  #if LANG_CXX11
  void set_nick(::std::string&& value);
  #endif
  void set_nick(const char* value);
  void set_nick(const void* value, size_t size);
  ::std::string* mutable_nick();
  ::std::string* release_nick();
  void set_allocated_nick(::std::string* nick);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_nick();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_nick(
      ::std::string* nick);

  // required bytes content = 3;
  bool has_content() const;
  void clear_content();
  static const int kContentFieldNumber = 3;
  const ::std::string& content() const;
  void set_content(const ::std::string& value);
  #if LANG_CXX11
  void set_content(::std::string&& value);
  #endif
  void set_content(const char* value);
  void set_content(const void* value, size_t size);
  ::std::string* mutable_content();
  ::std::string* release_content();
  void set_allocated_content(::std::string* content);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_content();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_content(
      ::std::string* content);

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // required int32 like_num = 4;
  bool has_like_num() const;
  void clear_like_num();
  static const int kLikeNumFieldNumber = 4;
  ::google::protobuf::int32 like_num() const;
  void set_like_num(::google::protobuf::int32 value);

  // required bool self_like = 5;
  bool has_self_like() const;
  void clear_self_like();
  static const int kSelfLikeFieldNumber = 5;
  bool self_like() const;
  void set_self_like(bool value);

  // required sfixed64 createtime = 11;
  bool has_createtime() const;
  void clear_createtime();
  static const int kCreatetimeFieldNumber = 11;
  ::google::protobuf::int64 createtime() const;
  void set_createtime(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:sg.CommentContent)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_nick();
  void clear_has_nick();
  void set_has_content();
  void clear_has_content();
  void set_has_like_num();
  void clear_has_like_num();
  void set_has_self_like();
  void clear_has_self_like();
  void set_has_createtime();
  void clear_has_createtime();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr nick_;
  ::google::protobuf::internal::ArenaStringPtr content_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 like_num_;
  bool self_like_;
  ::google::protobuf::int64 createtime_;
  friend struct ::protobuf_Moments_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CommentContentList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.CommentContentList) */ {
 public:
  CommentContentList();
  virtual ~CommentContentList();

  CommentContentList(const CommentContentList& from);

  inline CommentContentList& operator=(const CommentContentList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CommentContentList(CommentContentList&& from) noexcept
    : CommentContentList() {
    *this = ::std::move(from);
  }

  inline CommentContentList& operator=(CommentContentList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const CommentContentList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CommentContentList* internal_default_instance() {
    return reinterpret_cast<const CommentContentList*>(
               &_CommentContentList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void UnsafeArenaSwap(CommentContentList* other);
  void Swap(CommentContentList* other);
  friend void swap(CommentContentList& a, CommentContentList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CommentContentList* New() const final {
    return CreateMaybeMessage<CommentContentList>(NULL);
  }

  CommentContentList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CommentContentList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CommentContentList& from);
  void MergeFrom(const CommentContentList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommentContentList* other);
  protected:
  explicit CommentContentList(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sg.CommentContent list = 1;
  int list_size() const;
  void clear_list();
  static const int kListFieldNumber = 1;
  ::sg::CommentContent* mutable_list(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::CommentContent >*
      mutable_list();
  const ::sg::CommentContent& list(int index) const;
  ::sg::CommentContent* add_list();
  const ::google::protobuf::RepeatedPtrField< ::sg::CommentContent >&
      list() const;

  // @@protoc_insertion_point(class_scope:sg.CommentContentList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::CommentContent > list_;
  friend struct ::protobuf_Moments_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CommentData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.CommentData) */ {
 public:
  CommentData();
  virtual ~CommentData();

  CommentData(const CommentData& from);

  inline CommentData& operator=(const CommentData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CommentData(CommentData&& from) noexcept
    : CommentData() {
    *this = ::std::move(from);
  }

  inline CommentData& operator=(CommentData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const CommentData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CommentData* internal_default_instance() {
    return reinterpret_cast<const CommentData*>(
               &_CommentData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void UnsafeArenaSwap(CommentData* other);
  void Swap(CommentData* other);
  friend void swap(CommentData& a, CommentData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CommentData* New() const final {
    return CreateMaybeMessage<CommentData>(NULL);
  }

  CommentData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CommentData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CommentData& from);
  void MergeFrom(const CommentData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommentData* other);
  protected:
  explicit CommentData(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .sg.CommentContentList content_list = 11;
  bool has_content_list() const;
  void clear_content_list();
  static const int kContentListFieldNumber = 11;
  private:
  const ::sg::CommentContentList& _internal_content_list() const;
  public:
  const ::sg::CommentContentList& content_list() const;
  ::sg::CommentContentList* release_content_list();
  ::sg::CommentContentList* mutable_content_list();
  void set_allocated_content_list(::sg::CommentContentList* content_list);
  void unsafe_arena_set_allocated_content_list(
      ::sg::CommentContentList* content_list);
  ::sg::CommentContentList* unsafe_arena_release_content_list();

  // required uint64 subject_typeid = 1;
  bool has_subject_typeid() const;
  void clear_subject_typeid();
  static const int kSubjectTypeidFieldNumber = 1;
  ::google::protobuf::uint64 subject_typeid() const;
  void set_subject_typeid(::google::protobuf::uint64 value);

  // required .sg.COMMENT_SUBJECT_CATEGORY subject_category = 2;
  bool has_subject_category() const;
  void clear_subject_category();
  static const int kSubjectCategoryFieldNumber = 2;
  ::sg::COMMENT_SUBJECT_CATEGORY subject_category() const;
  void set_subject_category(::sg::COMMENT_SUBJECT_CATEGORY value);

  // optional int32 subject_day_hot = 3;
  bool has_subject_day_hot() const;
  void clear_subject_day_hot();
  static const int kSubjectDayHotFieldNumber = 3;
  ::google::protobuf::int32 subject_day_hot() const;
  void set_subject_day_hot(::google::protobuf::int32 value);

  // optional int32 self_postid = 4;
  bool has_self_postid() const;
  void clear_self_postid();
  static const int kSelfPostidFieldNumber = 4;
  ::google::protobuf::int32 self_postid() const;
  void set_self_postid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.CommentData)
 private:
  void set_has_subject_typeid();
  void clear_has_subject_typeid();
  void set_has_subject_category();
  void clear_has_subject_category();
  void set_has_subject_day_hot();
  void clear_has_subject_day_hot();
  void set_has_self_postid();
  void clear_has_self_postid();
  void set_has_content_list();
  void clear_has_content_list();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::sg::CommentContentList* content_list_;
  ::google::protobuf::uint64 subject_typeid_;
  int subject_category_;
  ::google::protobuf::int32 subject_day_hot_;
  ::google::protobuf::int32 self_postid_;
  friend struct ::protobuf_Moments_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CommentDataList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.CommentDataList) */ {
 public:
  CommentDataList();
  virtual ~CommentDataList();

  CommentDataList(const CommentDataList& from);

  inline CommentDataList& operator=(const CommentDataList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CommentDataList(CommentDataList&& from) noexcept
    : CommentDataList() {
    *this = ::std::move(from);
  }

  inline CommentDataList& operator=(CommentDataList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const CommentDataList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CommentDataList* internal_default_instance() {
    return reinterpret_cast<const CommentDataList*>(
               &_CommentDataList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void UnsafeArenaSwap(CommentDataList* other);
  void Swap(CommentDataList* other);
  friend void swap(CommentDataList& a, CommentDataList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CommentDataList* New() const final {
    return CreateMaybeMessage<CommentDataList>(NULL);
  }

  CommentDataList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CommentDataList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CommentDataList& from);
  void MergeFrom(const CommentDataList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommentDataList* other);
  protected:
  explicit CommentDataList(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sg.CommentData list = 1;
  int list_size() const;
  void clear_list();
  static const int kListFieldNumber = 1;
  ::sg::CommentData* mutable_list(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::CommentData >*
      mutable_list();
  const ::sg::CommentData& list(int index) const;
  ::sg::CommentData* add_list();
  const ::google::protobuf::RepeatedPtrField< ::sg::CommentData >&
      list() const;

  // @@protoc_insertion_point(class_scope:sg.CommentDataList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::CommentData > list_;
  friend struct ::protobuf_Moments_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CommentService_CommentRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.CommentService.CommentRequest) */ {
 public:
  CommentService_CommentRequest();
  virtual ~CommentService_CommentRequest();

  CommentService_CommentRequest(const CommentService_CommentRequest& from);

  inline CommentService_CommentRequest& operator=(const CommentService_CommentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CommentService_CommentRequest(CommentService_CommentRequest&& from) noexcept
    : CommentService_CommentRequest() {
    *this = ::std::move(from);
  }

  inline CommentService_CommentRequest& operator=(CommentService_CommentRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const CommentService_CommentRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CommentService_CommentRequest* internal_default_instance() {
    return reinterpret_cast<const CommentService_CommentRequest*>(
               &_CommentService_CommentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void UnsafeArenaSwap(CommentService_CommentRequest* other);
  void Swap(CommentService_CommentRequest* other);
  friend void swap(CommentService_CommentRequest& a, CommentService_CommentRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CommentService_CommentRequest* New() const final {
    return CreateMaybeMessage<CommentService_CommentRequest>(NULL);
  }

  CommentService_CommentRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CommentService_CommentRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CommentService_CommentRequest& from);
  void MergeFrom(const CommentService_CommentRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommentService_CommentRequest* other);
  protected:
  explicit CommentService_CommentRequest(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes comment_content = 4;
  bool has_comment_content() const;
  void clear_comment_content();
  static const int kCommentContentFieldNumber = 4;
  const ::std::string& comment_content() const;
  void set_comment_content(const ::std::string& value);
  #if LANG_CXX11
  void set_comment_content(::std::string&& value);
  #endif
  void set_comment_content(const char* value);
  void set_comment_content(const void* value, size_t size);
  ::std::string* mutable_comment_content();
  ::std::string* release_comment_content();
  void set_allocated_comment_content(::std::string* comment_content);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_comment_content();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_comment_content(
      ::std::string* comment_content);

  // optional int64 subject_typeid = 2;
  bool has_subject_typeid() const;
  void clear_subject_typeid();
  static const int kSubjectTypeidFieldNumber = 2;
  ::google::protobuf::int64 subject_typeid() const;
  void set_subject_typeid(::google::protobuf::int64 value);

  // optional int32 content_id = 3;
  bool has_content_id() const;
  void clear_content_id();
  static const int kContentIdFieldNumber = 3;
  ::google::protobuf::int32 content_id() const;
  void set_content_id(::google::protobuf::int32 value);

  // required .sg.CommentService.COMMENT_COMMAND cmd = 1;
  bool has_cmd() const;
  void clear_cmd();
  static const int kCmdFieldNumber = 1;
  ::sg::CommentService_COMMENT_COMMAND cmd() const;
  void set_cmd(::sg::CommentService_COMMENT_COMMAND value);

  // @@protoc_insertion_point(class_scope:sg.CommentService.CommentRequest)
 private:
  void set_has_cmd();
  void clear_has_cmd();
  void set_has_subject_typeid();
  void clear_has_subject_typeid();
  void set_has_content_id();
  void clear_has_content_id();
  void set_has_comment_content();
  void clear_has_comment_content();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr comment_content_;
  ::google::protobuf::int64 subject_typeid_;
  ::google::protobuf::int32 content_id_;
  int cmd_;
  friend struct ::protobuf_Moments_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CommentService_CommentResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.CommentService.CommentResponse) */ {
 public:
  CommentService_CommentResponse();
  virtual ~CommentService_CommentResponse();

  CommentService_CommentResponse(const CommentService_CommentResponse& from);

  inline CommentService_CommentResponse& operator=(const CommentService_CommentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CommentService_CommentResponse(CommentService_CommentResponse&& from) noexcept
    : CommentService_CommentResponse() {
    *this = ::std::move(from);
  }

  inline CommentService_CommentResponse& operator=(CommentService_CommentResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const CommentService_CommentResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CommentService_CommentResponse* internal_default_instance() {
    return reinterpret_cast<const CommentService_CommentResponse*>(
               &_CommentService_CommentResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void UnsafeArenaSwap(CommentService_CommentResponse* other);
  void Swap(CommentService_CommentResponse* other);
  friend void swap(CommentService_CommentResponse& a, CommentService_CommentResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CommentService_CommentResponse* New() const final {
    return CreateMaybeMessage<CommentService_CommentResponse>(NULL);
  }

  CommentService_CommentResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CommentService_CommentResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CommentService_CommentResponse& from);
  void MergeFrom(const CommentService_CommentResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommentService_CommentResponse* other);
  protected:
  explicit CommentService_CommentResponse(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .sg.CommentData data = 2;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  private:
  const ::sg::CommentData& _internal_data() const;
  public:
  const ::sg::CommentData& data() const;
  ::sg::CommentData* release_data();
  ::sg::CommentData* mutable_data();
  void set_allocated_data(::sg::CommentData* data);
  void unsafe_arena_set_allocated_data(
      ::sg::CommentData* data);
  ::sg::CommentData* unsafe_arena_release_data();

  // required int32 result = 1;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::google::protobuf::int32 result() const;
  void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.CommentService.CommentResponse)
 private:
  void set_has_result();
  void clear_has_result();
  void set_has_data();
  void clear_has_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::sg::CommentData* data_;
  ::google::protobuf::int32 result_;
  friend struct ::protobuf_Moments_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CommentService : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.CommentService) */ {
 public:
  CommentService();
  virtual ~CommentService();

  CommentService(const CommentService& from);

  inline CommentService& operator=(const CommentService& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CommentService(CommentService&& from) noexcept
    : CommentService() {
    *this = ::std::move(from);
  }

  inline CommentService& operator=(CommentService&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const CommentService& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CommentService* internal_default_instance() {
    return reinterpret_cast<const CommentService*>(
               &_CommentService_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void UnsafeArenaSwap(CommentService* other);
  void Swap(CommentService* other);
  friend void swap(CommentService& a, CommentService& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CommentService* New() const final {
    return CreateMaybeMessage<CommentService>(NULL);
  }

  CommentService* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CommentService>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CommentService& from);
  void MergeFrom(const CommentService& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommentService* other);
  protected:
  explicit CommentService(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CommentService_CommentRequest CommentRequest;
  typedef CommentService_CommentResponse CommentResponse;

  typedef CommentService_COMMENT_COMMAND COMMENT_COMMAND;
  static const COMMENT_COMMAND QUERY =
    CommentService_COMMENT_COMMAND_QUERY;
  static const COMMENT_COMMAND ADD =
    CommentService_COMMENT_COMMAND_ADD;
  static const COMMENT_COMMAND LIKE =
    CommentService_COMMENT_COMMAND_LIKE;
  static inline bool COMMENT_COMMAND_IsValid(int value) {
    return CommentService_COMMENT_COMMAND_IsValid(value);
  }
  static const COMMENT_COMMAND COMMENT_COMMAND_MIN =
    CommentService_COMMENT_COMMAND_COMMENT_COMMAND_MIN;
  static const COMMENT_COMMAND COMMENT_COMMAND_MAX =
    CommentService_COMMENT_COMMAND_COMMENT_COMMAND_MAX;
  static const int COMMENT_COMMAND_ARRAYSIZE =
    CommentService_COMMENT_COMMAND_COMMENT_COMMAND_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  COMMENT_COMMAND_descriptor() {
    return CommentService_COMMENT_COMMAND_descriptor();
  }
  static inline const ::std::string& COMMENT_COMMAND_Name(COMMENT_COMMAND value) {
    return CommentService_COMMENT_COMMAND_Name(value);
  }
  static inline bool COMMENT_COMMAND_Parse(const ::std::string& name,
      COMMENT_COMMAND* value) {
    return CommentService_COMMENT_COMMAND_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .sg.CommentService.CommentRequest req = 1;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 1;
  private:
  const ::sg::CommentService_CommentRequest& _internal_req() const;
  public:
  const ::sg::CommentService_CommentRequest& req() const;
  ::sg::CommentService_CommentRequest* release_req();
  ::sg::CommentService_CommentRequest* mutable_req();
  void set_allocated_req(::sg::CommentService_CommentRequest* req);
  void unsafe_arena_set_allocated_req(
      ::sg::CommentService_CommentRequest* req);
  ::sg::CommentService_CommentRequest* unsafe_arena_release_req();

  // optional .sg.CommentService.CommentResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  private:
  const ::sg::CommentService_CommentResponse& _internal_resp() const;
  public:
  const ::sg::CommentService_CommentResponse& resp() const;
  ::sg::CommentService_CommentResponse* release_resp();
  ::sg::CommentService_CommentResponse* mutable_resp();
  void set_allocated_resp(::sg::CommentService_CommentResponse* resp);
  void unsafe_arena_set_allocated_resp(
      ::sg::CommentService_CommentResponse* resp);
  ::sg::CommentService_CommentResponse* unsafe_arena_release_resp();

  // @@protoc_insertion_point(class_scope:sg.CommentService)
 private:
  void set_has_req();
  void clear_has_req();
  void set_has_resp();
  void clear_has_resp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::sg::CommentService_CommentRequest* req_;
  ::sg::CommentService_CommentResponse* resp_;
  friend struct ::protobuf_Moments_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CommentContent

// required int32 id = 1;
inline bool CommentContent::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommentContent::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommentContent::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommentContent::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 CommentContent::id() const {
  // @@protoc_insertion_point(field_get:sg.CommentContent.id)
  return id_;
}
inline void CommentContent::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:sg.CommentContent.id)
}

// required bytes nick = 2;
inline bool CommentContent::has_nick() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommentContent::set_has_nick() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommentContent::clear_has_nick() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommentContent::clear_nick() {
  nick_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_nick();
}
inline const ::std::string& CommentContent::nick() const {
  // @@protoc_insertion_point(field_get:sg.CommentContent.nick)
  return nick_.Get();
}
inline void CommentContent::set_nick(const ::std::string& value) {
  set_has_nick();
  nick_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:sg.CommentContent.nick)
}
#if LANG_CXX11
inline void CommentContent::set_nick(::std::string&& value) {
  set_has_nick();
  nick_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:sg.CommentContent.nick)
}
#endif
inline void CommentContent::set_nick(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_nick();
  nick_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:sg.CommentContent.nick)
}
inline void CommentContent::set_nick(const void* value,
    size_t size) {
  set_has_nick();
  nick_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:sg.CommentContent.nick)
}
inline ::std::string* CommentContent::mutable_nick() {
  set_has_nick();
  // @@protoc_insertion_point(field_mutable:sg.CommentContent.nick)
  return nick_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* CommentContent::release_nick() {
  // @@protoc_insertion_point(field_release:sg.CommentContent.nick)
  if (!has_nick()) {
    return NULL;
  }
  clear_has_nick();
  return nick_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void CommentContent::set_allocated_nick(::std::string* nick) {
  if (nick != NULL) {
    set_has_nick();
  } else {
    clear_has_nick();
  }
  nick_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nick,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:sg.CommentContent.nick)
}
inline ::std::string* CommentContent::unsafe_arena_release_nick() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.CommentContent.nick)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_nick();
  return nick_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void CommentContent::unsafe_arena_set_allocated_nick(
    ::std::string* nick) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (nick != NULL) {
    set_has_nick();
  } else {
    clear_has_nick();
  }
  nick_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      nick, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sg.CommentContent.nick)
}

// required bytes content = 3;
inline bool CommentContent::has_content() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommentContent::set_has_content() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommentContent::clear_has_content() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommentContent::clear_content() {
  content_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_content();
}
inline const ::std::string& CommentContent::content() const {
  // @@protoc_insertion_point(field_get:sg.CommentContent.content)
  return content_.Get();
}
inline void CommentContent::set_content(const ::std::string& value) {
  set_has_content();
  content_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:sg.CommentContent.content)
}
#if LANG_CXX11
inline void CommentContent::set_content(::std::string&& value) {
  set_has_content();
  content_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:sg.CommentContent.content)
}
#endif
inline void CommentContent::set_content(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_content();
  content_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:sg.CommentContent.content)
}
inline void CommentContent::set_content(const void* value,
    size_t size) {
  set_has_content();
  content_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:sg.CommentContent.content)
}
inline ::std::string* CommentContent::mutable_content() {
  set_has_content();
  // @@protoc_insertion_point(field_mutable:sg.CommentContent.content)
  return content_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* CommentContent::release_content() {
  // @@protoc_insertion_point(field_release:sg.CommentContent.content)
  if (!has_content()) {
    return NULL;
  }
  clear_has_content();
  return content_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void CommentContent::set_allocated_content(::std::string* content) {
  if (content != NULL) {
    set_has_content();
  } else {
    clear_has_content();
  }
  content_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), content,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:sg.CommentContent.content)
}
inline ::std::string* CommentContent::unsafe_arena_release_content() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.CommentContent.content)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_content();
  return content_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void CommentContent::unsafe_arena_set_allocated_content(
    ::std::string* content) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (content != NULL) {
    set_has_content();
  } else {
    clear_has_content();
  }
  content_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      content, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sg.CommentContent.content)
}

// required int32 like_num = 4;
inline bool CommentContent::has_like_num() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommentContent::set_has_like_num() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommentContent::clear_has_like_num() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommentContent::clear_like_num() {
  like_num_ = 0;
  clear_has_like_num();
}
inline ::google::protobuf::int32 CommentContent::like_num() const {
  // @@protoc_insertion_point(field_get:sg.CommentContent.like_num)
  return like_num_;
}
inline void CommentContent::set_like_num(::google::protobuf::int32 value) {
  set_has_like_num();
  like_num_ = value;
  // @@protoc_insertion_point(field_set:sg.CommentContent.like_num)
}

// required bool self_like = 5;
inline bool CommentContent::has_self_like() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommentContent::set_has_self_like() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommentContent::clear_has_self_like() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommentContent::clear_self_like() {
  self_like_ = false;
  clear_has_self_like();
}
inline bool CommentContent::self_like() const {
  // @@protoc_insertion_point(field_get:sg.CommentContent.self_like)
  return self_like_;
}
inline void CommentContent::set_self_like(bool value) {
  set_has_self_like();
  self_like_ = value;
  // @@protoc_insertion_point(field_set:sg.CommentContent.self_like)
}

// required sfixed64 createtime = 11;
inline bool CommentContent::has_createtime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommentContent::set_has_createtime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommentContent::clear_has_createtime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommentContent::clear_createtime() {
  createtime_ = GOOGLE_LONGLONG(0);
  clear_has_createtime();
}
inline ::google::protobuf::int64 CommentContent::createtime() const {
  // @@protoc_insertion_point(field_get:sg.CommentContent.createtime)
  return createtime_;
}
inline void CommentContent::set_createtime(::google::protobuf::int64 value) {
  set_has_createtime();
  createtime_ = value;
  // @@protoc_insertion_point(field_set:sg.CommentContent.createtime)
}

// -------------------------------------------------------------------

// CommentContentList

// repeated .sg.CommentContent list = 1;
inline int CommentContentList::list_size() const {
  return list_.size();
}
inline void CommentContentList::clear_list() {
  list_.Clear();
}
inline ::sg::CommentContent* CommentContentList::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:sg.CommentContentList.list)
  return list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::CommentContent >*
CommentContentList::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:sg.CommentContentList.list)
  return &list_;
}
inline const ::sg::CommentContent& CommentContentList::list(int index) const {
  // @@protoc_insertion_point(field_get:sg.CommentContentList.list)
  return list_.Get(index);
}
inline ::sg::CommentContent* CommentContentList::add_list() {
  // @@protoc_insertion_point(field_add:sg.CommentContentList.list)
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::CommentContent >&
CommentContentList::list() const {
  // @@protoc_insertion_point(field_list:sg.CommentContentList.list)
  return list_;
}

// -------------------------------------------------------------------

// CommentData

// required uint64 subject_typeid = 1;
inline bool CommentData::has_subject_typeid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommentData::set_has_subject_typeid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommentData::clear_has_subject_typeid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommentData::clear_subject_typeid() {
  subject_typeid_ = GOOGLE_ULONGLONG(0);
  clear_has_subject_typeid();
}
inline ::google::protobuf::uint64 CommentData::subject_typeid() const {
  // @@protoc_insertion_point(field_get:sg.CommentData.subject_typeid)
  return subject_typeid_;
}
inline void CommentData::set_subject_typeid(::google::protobuf::uint64 value) {
  set_has_subject_typeid();
  subject_typeid_ = value;
  // @@protoc_insertion_point(field_set:sg.CommentData.subject_typeid)
}

// required .sg.COMMENT_SUBJECT_CATEGORY subject_category = 2;
inline bool CommentData::has_subject_category() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommentData::set_has_subject_category() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommentData::clear_has_subject_category() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommentData::clear_subject_category() {
  subject_category_ = 0;
  clear_has_subject_category();
}
inline ::sg::COMMENT_SUBJECT_CATEGORY CommentData::subject_category() const {
  // @@protoc_insertion_point(field_get:sg.CommentData.subject_category)
  return static_cast< ::sg::COMMENT_SUBJECT_CATEGORY >(subject_category_);
}
inline void CommentData::set_subject_category(::sg::COMMENT_SUBJECT_CATEGORY value) {
  assert(::sg::COMMENT_SUBJECT_CATEGORY_IsValid(value));
  set_has_subject_category();
  subject_category_ = value;
  // @@protoc_insertion_point(field_set:sg.CommentData.subject_category)
}

// optional int32 subject_day_hot = 3;
inline bool CommentData::has_subject_day_hot() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommentData::set_has_subject_day_hot() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommentData::clear_has_subject_day_hot() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommentData::clear_subject_day_hot() {
  subject_day_hot_ = 0;
  clear_has_subject_day_hot();
}
inline ::google::protobuf::int32 CommentData::subject_day_hot() const {
  // @@protoc_insertion_point(field_get:sg.CommentData.subject_day_hot)
  return subject_day_hot_;
}
inline void CommentData::set_subject_day_hot(::google::protobuf::int32 value) {
  set_has_subject_day_hot();
  subject_day_hot_ = value;
  // @@protoc_insertion_point(field_set:sg.CommentData.subject_day_hot)
}

// optional int32 self_postid = 4;
inline bool CommentData::has_self_postid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommentData::set_has_self_postid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommentData::clear_has_self_postid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommentData::clear_self_postid() {
  self_postid_ = 0;
  clear_has_self_postid();
}
inline ::google::protobuf::int32 CommentData::self_postid() const {
  // @@protoc_insertion_point(field_get:sg.CommentData.self_postid)
  return self_postid_;
}
inline void CommentData::set_self_postid(::google::protobuf::int32 value) {
  set_has_self_postid();
  self_postid_ = value;
  // @@protoc_insertion_point(field_set:sg.CommentData.self_postid)
}

// optional .sg.CommentContentList content_list = 11;
inline bool CommentData::has_content_list() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommentData::set_has_content_list() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommentData::clear_has_content_list() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommentData::clear_content_list() {
  if (content_list_ != NULL) content_list_->Clear();
  clear_has_content_list();
}
inline const ::sg::CommentContentList& CommentData::_internal_content_list() const {
  return *content_list_;
}
inline const ::sg::CommentContentList& CommentData::content_list() const {
  const ::sg::CommentContentList* p = content_list_;
  // @@protoc_insertion_point(field_get:sg.CommentData.content_list)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::CommentContentList*>(
      &::sg::_CommentContentList_default_instance_);
}
inline ::sg::CommentContentList* CommentData::release_content_list() {
  // @@protoc_insertion_point(field_release:sg.CommentData.content_list)
  clear_has_content_list();
  ::sg::CommentContentList* temp = content_list_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  content_list_ = NULL;
  return temp;
}
inline ::sg::CommentContentList* CommentData::unsafe_arena_release_content_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.CommentData.content_list)
  clear_has_content_list();
  ::sg::CommentContentList* temp = content_list_;
  content_list_ = NULL;
  return temp;
}
inline ::sg::CommentContentList* CommentData::mutable_content_list() {
  set_has_content_list();
  if (content_list_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::CommentContentList>(GetArenaNoVirtual());
    content_list_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.CommentData.content_list)
  return content_list_;
}
inline void CommentData::set_allocated_content_list(::sg::CommentContentList* content_list) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete content_list_;
  }
  if (content_list) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(content_list);
    if (message_arena != submessage_arena) {
      content_list = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, content_list, submessage_arena);
    }
    set_has_content_list();
  } else {
    clear_has_content_list();
  }
  content_list_ = content_list;
  // @@protoc_insertion_point(field_set_allocated:sg.CommentData.content_list)
}

// -------------------------------------------------------------------

// CommentDataList

// repeated .sg.CommentData list = 1;
inline int CommentDataList::list_size() const {
  return list_.size();
}
inline void CommentDataList::clear_list() {
  list_.Clear();
}
inline ::sg::CommentData* CommentDataList::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:sg.CommentDataList.list)
  return list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::CommentData >*
CommentDataList::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:sg.CommentDataList.list)
  return &list_;
}
inline const ::sg::CommentData& CommentDataList::list(int index) const {
  // @@protoc_insertion_point(field_get:sg.CommentDataList.list)
  return list_.Get(index);
}
inline ::sg::CommentData* CommentDataList::add_list() {
  // @@protoc_insertion_point(field_add:sg.CommentDataList.list)
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::CommentData >&
CommentDataList::list() const {
  // @@protoc_insertion_point(field_list:sg.CommentDataList.list)
  return list_;
}

// -------------------------------------------------------------------

// CommentService_CommentRequest

// required .sg.CommentService.COMMENT_COMMAND cmd = 1;
inline bool CommentService_CommentRequest::has_cmd() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommentService_CommentRequest::set_has_cmd() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommentService_CommentRequest::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommentService_CommentRequest::clear_cmd() {
  cmd_ = 1;
  clear_has_cmd();
}
inline ::sg::CommentService_COMMENT_COMMAND CommentService_CommentRequest::cmd() const {
  // @@protoc_insertion_point(field_get:sg.CommentService.CommentRequest.cmd)
  return static_cast< ::sg::CommentService_COMMENT_COMMAND >(cmd_);
}
inline void CommentService_CommentRequest::set_cmd(::sg::CommentService_COMMENT_COMMAND value) {
  assert(::sg::CommentService_COMMENT_COMMAND_IsValid(value));
  set_has_cmd();
  cmd_ = value;
  // @@protoc_insertion_point(field_set:sg.CommentService.CommentRequest.cmd)
}

// optional int64 subject_typeid = 2;
inline bool CommentService_CommentRequest::has_subject_typeid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommentService_CommentRequest::set_has_subject_typeid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommentService_CommentRequest::clear_has_subject_typeid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommentService_CommentRequest::clear_subject_typeid() {
  subject_typeid_ = GOOGLE_LONGLONG(0);
  clear_has_subject_typeid();
}
inline ::google::protobuf::int64 CommentService_CommentRequest::subject_typeid() const {
  // @@protoc_insertion_point(field_get:sg.CommentService.CommentRequest.subject_typeid)
  return subject_typeid_;
}
inline void CommentService_CommentRequest::set_subject_typeid(::google::protobuf::int64 value) {
  set_has_subject_typeid();
  subject_typeid_ = value;
  // @@protoc_insertion_point(field_set:sg.CommentService.CommentRequest.subject_typeid)
}

// optional int32 content_id = 3;
inline bool CommentService_CommentRequest::has_content_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommentService_CommentRequest::set_has_content_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommentService_CommentRequest::clear_has_content_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommentService_CommentRequest::clear_content_id() {
  content_id_ = 0;
  clear_has_content_id();
}
inline ::google::protobuf::int32 CommentService_CommentRequest::content_id() const {
  // @@protoc_insertion_point(field_get:sg.CommentService.CommentRequest.content_id)
  return content_id_;
}
inline void CommentService_CommentRequest::set_content_id(::google::protobuf::int32 value) {
  set_has_content_id();
  content_id_ = value;
  // @@protoc_insertion_point(field_set:sg.CommentService.CommentRequest.content_id)
}

// optional bytes comment_content = 4;
inline bool CommentService_CommentRequest::has_comment_content() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommentService_CommentRequest::set_has_comment_content() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommentService_CommentRequest::clear_has_comment_content() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommentService_CommentRequest::clear_comment_content() {
  comment_content_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_comment_content();
}
inline const ::std::string& CommentService_CommentRequest::comment_content() const {
  // @@protoc_insertion_point(field_get:sg.CommentService.CommentRequest.comment_content)
  return comment_content_.Get();
}
inline void CommentService_CommentRequest::set_comment_content(const ::std::string& value) {
  set_has_comment_content();
  comment_content_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:sg.CommentService.CommentRequest.comment_content)
}
#if LANG_CXX11
inline void CommentService_CommentRequest::set_comment_content(::std::string&& value) {
  set_has_comment_content();
  comment_content_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:sg.CommentService.CommentRequest.comment_content)
}
#endif
inline void CommentService_CommentRequest::set_comment_content(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_comment_content();
  comment_content_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:sg.CommentService.CommentRequest.comment_content)
}
inline void CommentService_CommentRequest::set_comment_content(const void* value,
    size_t size) {
  set_has_comment_content();
  comment_content_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:sg.CommentService.CommentRequest.comment_content)
}
inline ::std::string* CommentService_CommentRequest::mutable_comment_content() {
  set_has_comment_content();
  // @@protoc_insertion_point(field_mutable:sg.CommentService.CommentRequest.comment_content)
  return comment_content_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* CommentService_CommentRequest::release_comment_content() {
  // @@protoc_insertion_point(field_release:sg.CommentService.CommentRequest.comment_content)
  if (!has_comment_content()) {
    return NULL;
  }
  clear_has_comment_content();
  return comment_content_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void CommentService_CommentRequest::set_allocated_comment_content(::std::string* comment_content) {
  if (comment_content != NULL) {
    set_has_comment_content();
  } else {
    clear_has_comment_content();
  }
  comment_content_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), comment_content,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:sg.CommentService.CommentRequest.comment_content)
}
inline ::std::string* CommentService_CommentRequest::unsafe_arena_release_comment_content() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.CommentService.CommentRequest.comment_content)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_comment_content();
  return comment_content_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void CommentService_CommentRequest::unsafe_arena_set_allocated_comment_content(
    ::std::string* comment_content) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (comment_content != NULL) {
    set_has_comment_content();
  } else {
    clear_has_comment_content();
  }
  comment_content_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      comment_content, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sg.CommentService.CommentRequest.comment_content)
}

// -------------------------------------------------------------------

// CommentService_CommentResponse

// required int32 result = 1;
inline bool CommentService_CommentResponse::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommentService_CommentResponse::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommentService_CommentResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommentService_CommentResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 CommentService_CommentResponse::result() const {
  // @@protoc_insertion_point(field_get:sg.CommentService.CommentResponse.result)
  return result_;
}
inline void CommentService_CommentResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:sg.CommentService.CommentResponse.result)
}

// optional .sg.CommentData data = 2;
inline bool CommentService_CommentResponse::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommentService_CommentResponse::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommentService_CommentResponse::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommentService_CommentResponse::clear_data() {
  if (data_ != NULL) data_->Clear();
  clear_has_data();
}
inline const ::sg::CommentData& CommentService_CommentResponse::_internal_data() const {
  return *data_;
}
inline const ::sg::CommentData& CommentService_CommentResponse::data() const {
  const ::sg::CommentData* p = data_;
  // @@protoc_insertion_point(field_get:sg.CommentService.CommentResponse.data)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::CommentData*>(
      &::sg::_CommentData_default_instance_);
}
inline ::sg::CommentData* CommentService_CommentResponse::release_data() {
  // @@protoc_insertion_point(field_release:sg.CommentService.CommentResponse.data)
  clear_has_data();
  ::sg::CommentData* temp = data_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  data_ = NULL;
  return temp;
}
inline ::sg::CommentData* CommentService_CommentResponse::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.CommentService.CommentResponse.data)
  clear_has_data();
  ::sg::CommentData* temp = data_;
  data_ = NULL;
  return temp;
}
inline ::sg::CommentData* CommentService_CommentResponse::mutable_data() {
  set_has_data();
  if (data_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::CommentData>(GetArenaNoVirtual());
    data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.CommentService.CommentResponse.data)
  return data_;
}
inline void CommentService_CommentResponse::set_allocated_data(::sg::CommentData* data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete data_;
  }
  if (data) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(data);
    if (message_arena != submessage_arena) {
      data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    set_has_data();
  } else {
    clear_has_data();
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:sg.CommentService.CommentResponse.data)
}

// -------------------------------------------------------------------

// CommentService

// optional .sg.CommentService.CommentRequest req = 1;
inline bool CommentService::has_req() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommentService::set_has_req() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommentService::clear_has_req() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommentService::clear_req() {
  if (req_ != NULL) req_->Clear();
  clear_has_req();
}
inline const ::sg::CommentService_CommentRequest& CommentService::_internal_req() const {
  return *req_;
}
inline const ::sg::CommentService_CommentRequest& CommentService::req() const {
  const ::sg::CommentService_CommentRequest* p = req_;
  // @@protoc_insertion_point(field_get:sg.CommentService.req)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::CommentService_CommentRequest*>(
      &::sg::_CommentService_CommentRequest_default_instance_);
}
inline ::sg::CommentService_CommentRequest* CommentService::release_req() {
  // @@protoc_insertion_point(field_release:sg.CommentService.req)
  clear_has_req();
  ::sg::CommentService_CommentRequest* temp = req_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  req_ = NULL;
  return temp;
}
inline ::sg::CommentService_CommentRequest* CommentService::unsafe_arena_release_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.CommentService.req)
  clear_has_req();
  ::sg::CommentService_CommentRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline ::sg::CommentService_CommentRequest* CommentService::mutable_req() {
  set_has_req();
  if (req_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::CommentService_CommentRequest>(GetArenaNoVirtual());
    req_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.CommentService.req)
  return req_;
}
inline void CommentService::set_allocated_req(::sg::CommentService_CommentRequest* req) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete req_;
  }
  if (req) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(req);
    if (message_arena != submessage_arena) {
      req = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, req, submessage_arena);
    }
    set_has_req();
  } else {
    clear_has_req();
  }
  req_ = req;
  // @@protoc_insertion_point(field_set_allocated:sg.CommentService.req)
}

// optional .sg.CommentService.CommentResponse resp = 2;
inline bool CommentService::has_resp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommentService::set_has_resp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommentService::clear_has_resp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommentService::clear_resp() {
  if (resp_ != NULL) resp_->Clear();
  clear_has_resp();
}
inline const ::sg::CommentService_CommentResponse& CommentService::_internal_resp() const {
  return *resp_;
}
inline const ::sg::CommentService_CommentResponse& CommentService::resp() const {
  const ::sg::CommentService_CommentResponse* p = resp_;
  // @@protoc_insertion_point(field_get:sg.CommentService.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::CommentService_CommentResponse*>(
      &::sg::_CommentService_CommentResponse_default_instance_);
}
inline ::sg::CommentService_CommentResponse* CommentService::release_resp() {
  // @@protoc_insertion_point(field_release:sg.CommentService.resp)
  clear_has_resp();
  ::sg::CommentService_CommentResponse* temp = resp_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  resp_ = NULL;
  return temp;
}
inline ::sg::CommentService_CommentResponse* CommentService::unsafe_arena_release_resp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.CommentService.resp)
  clear_has_resp();
  ::sg::CommentService_CommentResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline ::sg::CommentService_CommentResponse* CommentService::mutable_resp() {
  set_has_resp();
  if (resp_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::CommentService_CommentResponse>(GetArenaNoVirtual());
    resp_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.CommentService.resp)
  return resp_;
}
inline void CommentService::set_allocated_resp(::sg::CommentService_CommentResponse* resp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete resp_;
  }
  if (resp) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(resp);
    if (message_arena != submessage_arena) {
      resp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, resp, submessage_arena);
    }
    set_has_resp();
  } else {
    clear_has_resp();
  }
  resp_ = resp;
  // @@protoc_insertion_point(field_set_allocated:sg.CommentService.resp)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace sg

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::sg::CommentService_COMMENT_COMMAND> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::CommentService_COMMENT_COMMAND>() {
  return ::sg::CommentService_COMMENT_COMMAND_descriptor();
}
template <> struct is_proto_enum< ::sg::COMMENT_SUBJECT_CATEGORY> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::COMMENT_SUBJECT_CATEGORY>() {
  return ::sg::COMMENT_SUBJECT_CATEGORY_descriptor();
}
template <> struct is_proto_enum< ::sg::COMMENT_ERROR> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::COMMENT_ERROR>() {
  return ::sg::COMMENT_ERROR_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_Moments_2eproto
