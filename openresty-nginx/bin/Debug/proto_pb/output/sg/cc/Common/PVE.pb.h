// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: PVE.proto

#ifndef PROTOBUF_INCLUDED_PVE_2eproto
#define PROTOBUF_INCLUDED_PVE_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "BaseStruct.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_PVE_2eproto 

namespace protobuf_PVE_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[31];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_PVE_2eproto
namespace sg {
class DungeonAltar;
class DungeonAltarDefaultTypeInternal;
extern DungeonAltarDefaultTypeInternal _DungeonAltar_default_instance_;
class DungeonAltar_Relic;
class DungeonAltar_RelicDefaultTypeInternal;
extern DungeonAltar_RelicDefaultTypeInternal _DungeonAltar_Relic_default_instance_;
class DungeonContent;
class DungeonContentDefaultTypeInternal;
extern DungeonContentDefaultTypeInternal _DungeonContent_default_instance_;
class DungeonContent_PathBranch;
class DungeonContent_PathBranchDefaultTypeInternal;
extern DungeonContent_PathBranchDefaultTypeInternal _DungeonContent_PathBranch_default_instance_;
class DungeonElement;
class DungeonElementDefaultTypeInternal;
extern DungeonElementDefaultTypeInternal _DungeonElement_default_instance_;
class DungeonElement_Exchange;
class DungeonElement_ExchangeDefaultTypeInternal;
extern DungeonElement_ExchangeDefaultTypeInternal _DungeonElement_Exchange_default_instance_;
class DungeonElement_Exchange_Exchange_Item;
class DungeonElement_Exchange_Exchange_ItemDefaultTypeInternal;
extern DungeonElement_Exchange_Exchange_ItemDefaultTypeInternal _DungeonElement_Exchange_Exchange_Item_default_instance_;
class DungeonEvent;
class DungeonEventDefaultTypeInternal;
extern DungeonEventDefaultTypeInternal _DungeonEvent_default_instance_;
class DungeonInfo;
class DungeonInfoDefaultTypeInternal;
extern DungeonInfoDefaultTypeInternal _DungeonInfo_default_instance_;
class ElementProperty;
class ElementPropertyDefaultTypeInternal;
extern ElementPropertyDefaultTypeInternal _ElementProperty_default_instance_;
class ElementProperty_RoomData;
class ElementProperty_RoomDataDefaultTypeInternal;
extern ElementProperty_RoomDataDefaultTypeInternal _ElementProperty_RoomData_default_instance_;
class ElementProperty_RoomData_RoomEffect;
class ElementProperty_RoomData_RoomEffectDefaultTypeInternal;
extern ElementProperty_RoomData_RoomEffectDefaultTypeInternal _ElementProperty_RoomData_RoomEffect_default_instance_;
class Enemy;
class EnemyDefaultTypeInternal;
extern EnemyDefaultTypeInternal _Enemy_default_instance_;
class FightManual;
class FightManualDefaultTypeInternal;
extern FightManualDefaultTypeInternal _FightManual_default_instance_;
class MonsterInDungeon;
class MonsterInDungeonDefaultTypeInternal;
extern MonsterInDungeonDefaultTypeInternal _MonsterInDungeon_default_instance_;
class PVEBattleService;
class PVEBattleServiceDefaultTypeInternal;
extern PVEBattleServiceDefaultTypeInternal _PVEBattleService_default_instance_;
class PVEBattleService_PVEBattleRequest;
class PVEBattleService_PVEBattleRequestDefaultTypeInternal;
extern PVEBattleService_PVEBattleRequestDefaultTypeInternal _PVEBattleService_PVEBattleRequest_default_instance_;
class PVEBattleService_PVEBattleResponse;
class PVEBattleService_PVEBattleResponseDefaultTypeInternal;
extern PVEBattleService_PVEBattleResponseDefaultTypeInternal _PVEBattleService_PVEBattleResponse_default_instance_;
class PveDefenderData;
class PveDefenderDataDefaultTypeInternal;
extern PveDefenderDataDefaultTypeInternal _PveDefenderData_default_instance_;
class PveFacility;
class PveFacilityDefaultTypeInternal;
extern PveFacilityDefaultTypeInternal _PveFacility_default_instance_;
class PveMapData;
class PveMapDataDefaultTypeInternal;
extern PveMapDataDefaultTypeInternal _PveMapData_default_instance_;
class PvePlayerMapData;
class PvePlayerMapDataDefaultTypeInternal;
extern PvePlayerMapDataDefaultTypeInternal _PvePlayerMapData_default_instance_;
class SailorInDungeon;
class SailorInDungeonDefaultTypeInternal;
extern SailorInDungeonDefaultTypeInternal _SailorInDungeon_default_instance_;
class ShipData;
class ShipDataDefaultTypeInternal;
extern ShipDataDefaultTypeInternal _ShipData_default_instance_;
class UserDungeonInformation;
class UserDungeonInformationDefaultTypeInternal;
extern UserDungeonInformationDefaultTypeInternal _UserDungeonInformation_default_instance_;
class UserDungeonInformation_ElementCount;
class UserDungeonInformation_ElementCountDefaultTypeInternal;
extern UserDungeonInformation_ElementCountDefaultTypeInternal _UserDungeonInformation_ElementCount_default_instance_;
class UserDungeonOperation;
class UserDungeonOperationDefaultTypeInternal;
extern UserDungeonOperationDefaultTypeInternal _UserDungeonOperation_default_instance_;
class UserDungeonService;
class UserDungeonServiceDefaultTypeInternal;
extern UserDungeonServiceDefaultTypeInternal _UserDungeonService_default_instance_;
class UserDungeonService_UserDungeonRequest;
class UserDungeonService_UserDungeonRequestDefaultTypeInternal;
extern UserDungeonService_UserDungeonRequestDefaultTypeInternal _UserDungeonService_UserDungeonRequest_default_instance_;
class UserDungeonService_UserDungeonResponse;
class UserDungeonService_UserDungeonResponseDefaultTypeInternal;
extern UserDungeonService_UserDungeonResponseDefaultTypeInternal _UserDungeonService_UserDungeonResponse_default_instance_;
class UserTeamData;
class UserTeamDataDefaultTypeInternal;
extern UserTeamDataDefaultTypeInternal _UserTeamData_default_instance_;
}  // namespace sg
namespace google {
namespace protobuf {
template<> ::sg::DungeonAltar* Arena::CreateMaybeMessage<::sg::DungeonAltar>(Arena*);
template<> ::sg::DungeonAltar_Relic* Arena::CreateMaybeMessage<::sg::DungeonAltar_Relic>(Arena*);
template<> ::sg::DungeonContent* Arena::CreateMaybeMessage<::sg::DungeonContent>(Arena*);
template<> ::sg::DungeonContent_PathBranch* Arena::CreateMaybeMessage<::sg::DungeonContent_PathBranch>(Arena*);
template<> ::sg::DungeonElement* Arena::CreateMaybeMessage<::sg::DungeonElement>(Arena*);
template<> ::sg::DungeonElement_Exchange* Arena::CreateMaybeMessage<::sg::DungeonElement_Exchange>(Arena*);
template<> ::sg::DungeonElement_Exchange_Exchange_Item* Arena::CreateMaybeMessage<::sg::DungeonElement_Exchange_Exchange_Item>(Arena*);
template<> ::sg::DungeonEvent* Arena::CreateMaybeMessage<::sg::DungeonEvent>(Arena*);
template<> ::sg::DungeonInfo* Arena::CreateMaybeMessage<::sg::DungeonInfo>(Arena*);
template<> ::sg::ElementProperty* Arena::CreateMaybeMessage<::sg::ElementProperty>(Arena*);
template<> ::sg::ElementProperty_RoomData* Arena::CreateMaybeMessage<::sg::ElementProperty_RoomData>(Arena*);
template<> ::sg::ElementProperty_RoomData_RoomEffect* Arena::CreateMaybeMessage<::sg::ElementProperty_RoomData_RoomEffect>(Arena*);
template<> ::sg::Enemy* Arena::CreateMaybeMessage<::sg::Enemy>(Arena*);
template<> ::sg::FightManual* Arena::CreateMaybeMessage<::sg::FightManual>(Arena*);
template<> ::sg::MonsterInDungeon* Arena::CreateMaybeMessage<::sg::MonsterInDungeon>(Arena*);
template<> ::sg::PVEBattleService* Arena::CreateMaybeMessage<::sg::PVEBattleService>(Arena*);
template<> ::sg::PVEBattleService_PVEBattleRequest* Arena::CreateMaybeMessage<::sg::PVEBattleService_PVEBattleRequest>(Arena*);
template<> ::sg::PVEBattleService_PVEBattleResponse* Arena::CreateMaybeMessage<::sg::PVEBattleService_PVEBattleResponse>(Arena*);
template<> ::sg::PveDefenderData* Arena::CreateMaybeMessage<::sg::PveDefenderData>(Arena*);
template<> ::sg::PveFacility* Arena::CreateMaybeMessage<::sg::PveFacility>(Arena*);
template<> ::sg::PveMapData* Arena::CreateMaybeMessage<::sg::PveMapData>(Arena*);
template<> ::sg::PvePlayerMapData* Arena::CreateMaybeMessage<::sg::PvePlayerMapData>(Arena*);
template<> ::sg::SailorInDungeon* Arena::CreateMaybeMessage<::sg::SailorInDungeon>(Arena*);
template<> ::sg::ShipData* Arena::CreateMaybeMessage<::sg::ShipData>(Arena*);
template<> ::sg::UserDungeonInformation* Arena::CreateMaybeMessage<::sg::UserDungeonInformation>(Arena*);
template<> ::sg::UserDungeonInformation_ElementCount* Arena::CreateMaybeMessage<::sg::UserDungeonInformation_ElementCount>(Arena*);
template<> ::sg::UserDungeonOperation* Arena::CreateMaybeMessage<::sg::UserDungeonOperation>(Arena*);
template<> ::sg::UserDungeonService* Arena::CreateMaybeMessage<::sg::UserDungeonService>(Arena*);
template<> ::sg::UserDungeonService_UserDungeonRequest* Arena::CreateMaybeMessage<::sg::UserDungeonService_UserDungeonRequest>(Arena*);
template<> ::sg::UserDungeonService_UserDungeonResponse* Arena::CreateMaybeMessage<::sg::UserDungeonService_UserDungeonResponse>(Arena*);
template<> ::sg::UserTeamData* Arena::CreateMaybeMessage<::sg::UserTeamData>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace sg {

enum PVEBattleService_PVE_CMD {
  PVEBattleService_PVE_CMD_START = 1,
  PVEBattleService_PVE_CMD_TO_NEXT = 2,
  PVEBattleService_PVE_CMD_OVER = 3,
  PVEBattleService_PVE_CMD_RESTORE = 4,
  PVEBattleService_PVE_CMD_ATTACK_ENTRY = 5,
  PVEBattleService_PVE_CMD_ATTACK_OVER = 6,
  PVEBattleService_PVE_CMD_CHECK_CAN_FIGHT = 7,
  PVEBattleService_PVE_CMD_HUNT_START = 8,
  PVEBattleService_PVE_CMD_HUNT_OVER = 9,
  PVEBattleService_PVE_CMD_TREASURE_BATTLE_START = 10,
  PVEBattleService_PVE_CMD_TREASURE_BATTLE_OVER = 11,
  PVEBattleService_PVE_CMD_QUERY_FIGHT_MANUAL = 12,
  PVEBattleService_PVE_CMD_REVIVE = 13,
  PVEBattleService_PVE_CMD_ATTACK_MODEL_START = 14,
  PVEBattleService_PVE_CMD_ATTACK_MODEL_OVER = 15,
  PVEBattleService_PVE_CMD_SHIP_EVENT_START = 16,
  PVEBattleService_PVE_CMD_SHIP_EVENT_OVER = 17,
  PVEBattleService_PVE_CMD_NAVIGATION_EVENT_START = 18,
  PVEBattleService_PVE_CMD_NAVIGATION_EVENT_DOING = 19,
  PVEBattleService_PVE_CMD_NAVIGATION_EVENT_OVER = 20,
  PVEBattleService_PVE_CMD_MAELSTROM_EVENT_START = 21,
  PVEBattleService_PVE_CMD_MAELSTROM_EVENT_DOING = 22,
  PVEBattleService_PVE_CMD_MAELSTROM_EVENT_OVER = 23,
  PVEBattleService_PVE_CMD_OPEN_CHEST = 24,
  PVEBattleService_PVE_CMD_INVADE_START = 25,
  PVEBattleService_PVE_CMD_REVENGE_START = 26
};
bool PVEBattleService_PVE_CMD_IsValid(int value);
const PVEBattleService_PVE_CMD PVEBattleService_PVE_CMD_PVE_CMD_MIN = PVEBattleService_PVE_CMD_START;
const PVEBattleService_PVE_CMD PVEBattleService_PVE_CMD_PVE_CMD_MAX = PVEBattleService_PVE_CMD_REVENGE_START;
const int PVEBattleService_PVE_CMD_PVE_CMD_ARRAYSIZE = PVEBattleService_PVE_CMD_PVE_CMD_MAX + 1;

const ::google::protobuf::EnumDescriptor* PVEBattleService_PVE_CMD_descriptor();
inline const ::std::string& PVEBattleService_PVE_CMD_Name(PVEBattleService_PVE_CMD value) {
  return ::google::protobuf::internal::NameOfEnum(
    PVEBattleService_PVE_CMD_descriptor(), value);
}
inline bool PVEBattleService_PVE_CMD_Parse(
    const ::std::string& name, PVEBattleService_PVE_CMD* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PVEBattleService_PVE_CMD>(
    PVEBattleService_PVE_CMD_descriptor(), name, value);
}
enum UserDungeonService_DUNGEON_CMD {
  UserDungeonService_DUNGEON_CMD_QUERY_EVENT = 1,
  UserDungeonService_DUNGEON_CMD_QUERY_DUNGEON = 2,
  UserDungeonService_DUNGEON_CMD_FAST_FINISH = 3,
  UserDungeonService_DUNGEON_CMD_GET_EVENT_REWARD = 4,
  UserDungeonService_DUNGEON_CMD_GET_FINAL_REWARD = 5,
  UserDungeonService_DUNGEON_CMD_UNLOCK_DUNGEON = 6,
  UserDungeonService_DUNGEON_CMD_GET_LAYER_REWARD = 7
};
bool UserDungeonService_DUNGEON_CMD_IsValid(int value);
const UserDungeonService_DUNGEON_CMD UserDungeonService_DUNGEON_CMD_DUNGEON_CMD_MIN = UserDungeonService_DUNGEON_CMD_QUERY_EVENT;
const UserDungeonService_DUNGEON_CMD UserDungeonService_DUNGEON_CMD_DUNGEON_CMD_MAX = UserDungeonService_DUNGEON_CMD_GET_LAYER_REWARD;
const int UserDungeonService_DUNGEON_CMD_DUNGEON_CMD_ARRAYSIZE = UserDungeonService_DUNGEON_CMD_DUNGEON_CMD_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserDungeonService_DUNGEON_CMD_descriptor();
inline const ::std::string& UserDungeonService_DUNGEON_CMD_Name(UserDungeonService_DUNGEON_CMD value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserDungeonService_DUNGEON_CMD_descriptor(), value);
}
inline bool UserDungeonService_DUNGEON_CMD_Parse(
    const ::std::string& name, UserDungeonService_DUNGEON_CMD* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserDungeonService_DUNGEON_CMD>(
    UserDungeonService_DUNGEON_CMD_descriptor(), name, value);
}
enum DUNGEON_SPECIAL_EVENT {
  DSE_CLEAR_ITEM_ON_THE_GROUND = 1,
  DSE_CHANGE_MODEL = 2,
  DSE_LAYER_CHANGE = 3,
  DSE_ENTER_SECRET_ROOM = 4,
  DSE_UNLOCK_ROOM = 5,
  DSE_EVENT_TRIGGER = 6
};
bool DUNGEON_SPECIAL_EVENT_IsValid(int value);
const DUNGEON_SPECIAL_EVENT DUNGEON_SPECIAL_EVENT_MIN = DSE_CLEAR_ITEM_ON_THE_GROUND;
const DUNGEON_SPECIAL_EVENT DUNGEON_SPECIAL_EVENT_MAX = DSE_EVENT_TRIGGER;
const int DUNGEON_SPECIAL_EVENT_ARRAYSIZE = DUNGEON_SPECIAL_EVENT_MAX + 1;

const ::google::protobuf::EnumDescriptor* DUNGEON_SPECIAL_EVENT_descriptor();
inline const ::std::string& DUNGEON_SPECIAL_EVENT_Name(DUNGEON_SPECIAL_EVENT value) {
  return ::google::protobuf::internal::NameOfEnum(
    DUNGEON_SPECIAL_EVENT_descriptor(), value);
}
inline bool DUNGEON_SPECIAL_EVENT_Parse(
    const ::std::string& name, DUNGEON_SPECIAL_EVENT* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DUNGEON_SPECIAL_EVENT>(
    DUNGEON_SPECIAL_EVENT_descriptor(), name, value);
}
enum PVE_BATTLE_RESULT {
  BATTLE_SUCCESS = 1,
  BATTLE_FAILED = 2
};
bool PVE_BATTLE_RESULT_IsValid(int value);
const PVE_BATTLE_RESULT PVE_BATTLE_RESULT_MIN = BATTLE_SUCCESS;
const PVE_BATTLE_RESULT PVE_BATTLE_RESULT_MAX = BATTLE_FAILED;
const int PVE_BATTLE_RESULT_ARRAYSIZE = PVE_BATTLE_RESULT_MAX + 1;

const ::google::protobuf::EnumDescriptor* PVE_BATTLE_RESULT_descriptor();
inline const ::std::string& PVE_BATTLE_RESULT_Name(PVE_BATTLE_RESULT value) {
  return ::google::protobuf::internal::NameOfEnum(
    PVE_BATTLE_RESULT_descriptor(), value);
}
inline bool PVE_BATTLE_RESULT_Parse(
    const ::std::string& name, PVE_BATTLE_RESULT* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PVE_BATTLE_RESULT>(
    PVE_BATTLE_RESULT_descriptor(), name, value);
}
enum DUNGEON_STATE {
  DUNGEON_STATE_LOCKED = 1,
  DUNGEON_STATE_UNLOCKED = 2,
  DUNGEON_STATE_NO_REWARD = 3,
  DUNGEON_STATE_FINISHED = 4
};
bool DUNGEON_STATE_IsValid(int value);
const DUNGEON_STATE DUNGEON_STATE_MIN = DUNGEON_STATE_LOCKED;
const DUNGEON_STATE DUNGEON_STATE_MAX = DUNGEON_STATE_FINISHED;
const int DUNGEON_STATE_ARRAYSIZE = DUNGEON_STATE_MAX + 1;

const ::google::protobuf::EnumDescriptor* DUNGEON_STATE_descriptor();
inline const ::std::string& DUNGEON_STATE_Name(DUNGEON_STATE value) {
  return ::google::protobuf::internal::NameOfEnum(
    DUNGEON_STATE_descriptor(), value);
}
inline bool DUNGEON_STATE_Parse(
    const ::std::string& name, DUNGEON_STATE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DUNGEON_STATE>(
    DUNGEON_STATE_descriptor(), name, value);
}
// ===================================================================

class SailorInDungeon : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.SailorInDungeon) */ {
 public:
  SailorInDungeon();
  virtual ~SailorInDungeon();

  SailorInDungeon(const SailorInDungeon& from);

  inline SailorInDungeon& operator=(const SailorInDungeon& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SailorInDungeon(SailorInDungeon&& from) noexcept
    : SailorInDungeon() {
    *this = ::std::move(from);
  }

  inline SailorInDungeon& operator=(SailorInDungeon&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const SailorInDungeon& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SailorInDungeon* internal_default_instance() {
    return reinterpret_cast<const SailorInDungeon*>(
               &_SailorInDungeon_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void UnsafeArenaSwap(SailorInDungeon* other);
  void Swap(SailorInDungeon* other);
  friend void swap(SailorInDungeon& a, SailorInDungeon& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SailorInDungeon* New() const final {
    return CreateMaybeMessage<SailorInDungeon>(NULL);
  }

  SailorInDungeon* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SailorInDungeon>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SailorInDungeon& from);
  void MergeFrom(const SailorInDungeon& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SailorInDungeon* other);
  protected:
  explicit SailorInDungeon(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sg.pb_pair_int_float attribute = 7;
  int attribute_size() const;
  void clear_attribute();
  static const int kAttributeFieldNumber = 7;
  ::sg::pb_pair_int_float* mutable_attribute(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_float >*
      mutable_attribute();
  const ::sg::pb_pair_int_float& attribute(int index) const;
  ::sg::pb_pair_int_float* add_attribute();
  const ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_float >&
      attribute() const;

  // repeated .sg.pb_pair_int_int buff = 8;
  int buff_size() const;
  void clear_buff();
  static const int kBuffFieldNumber = 8;
  ::sg::pb_pair_int_int* mutable_buff(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int >*
      mutable_buff();
  const ::sg::pb_pair_int_int& buff(int index) const;
  ::sg::pb_pair_int_int* add_buff();
  const ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int >&
      buff() const;

  // repeated .sg.pb_pair_int_float fight_attribute = 9;
  int fight_attribute_size() const;
  void clear_fight_attribute();
  static const int kFightAttributeFieldNumber = 9;
  ::sg::pb_pair_int_float* mutable_fight_attribute(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_float >*
      mutable_fight_attribute();
  const ::sg::pb_pair_int_float& fight_attribute(int index) const;
  ::sg::pb_pair_int_float* add_fight_attribute();
  const ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_float >&
      fight_attribute() const;

  // repeated .sg.pb_pair_string_int special_attribute = 10;
  int special_attribute_size() const;
  void clear_special_attribute();
  static const int kSpecialAttributeFieldNumber = 10;
  ::sg::pb_pair_string_int* mutable_special_attribute(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_string_int >*
      mutable_special_attribute();
  const ::sg::pb_pair_string_int& special_attribute(int index) const;
  ::sg::pb_pair_string_int* add_special_attribute();
  const ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_string_int >&
      special_attribute() const;

  // repeated .sg.pb_pair_int64_int skill = 11;
  int skill_size() const;
  void clear_skill();
  static const int kSkillFieldNumber = 11;
  ::sg::pb_pair_int64_int* mutable_skill(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int64_int >*
      mutable_skill();
  const ::sg::pb_pair_int64_int& skill(int index) const;
  ::sg::pb_pair_int64_int* add_skill();
  const ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int64_int >&
      skill() const;

  // optional .sg.SailorTalent talent = 12;
  bool has_talent() const;
  void clear_talent();
  static const int kTalentFieldNumber = 12;
  private:
  const ::sg::SailorTalent& _internal_talent() const;
  public:
  const ::sg::SailorTalent& talent() const;
  ::sg::SailorTalent* release_talent();
  ::sg::SailorTalent* mutable_talent();
  void set_allocated_talent(::sg::SailorTalent* talent);
  void unsafe_arena_set_allocated_talent(
      ::sg::SailorTalent* talent);
  ::sg::SailorTalent* unsafe_arena_release_talent();

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // required int32 typeid = 2;
  bool has_typeid_() const;
  void clear_typeid_();
  static const int kTypeidFieldNumber = 2;
  ::google::protobuf::int32 typeid_() const;
  void set_typeid_(::google::protobuf::int32 value);

  // required int32 state = 3;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 3;
  ::google::protobuf::int32 state() const;
  void set_state(::google::protobuf::int32 value);

  // required int32 index = 4;
  bool has_index() const;
  void clear_index();
  static const int kIndexFieldNumber = 4;
  ::google::protobuf::int32 index() const;
  void set_index(::google::protobuf::int32 value);

  // required int32 level = 5;
  bool has_level() const;
  void clear_level();
  static const int kLevelFieldNumber = 5;
  ::google::protobuf::int32 level() const;
  void set_level(::google::protobuf::int32 value);

  // required int32 star = 6;
  bool has_star() const;
  void clear_star();
  static const int kStarFieldNumber = 6;
  ::google::protobuf::int32 star() const;
  void set_star(::google::protobuf::int32 value);

  // optional float hp_remain = 13;
  bool has_hp_remain() const;
  void clear_hp_remain();
  static const int kHpRemainFieldNumber = 13;
  float hp_remain() const;
  void set_hp_remain(float value);

  // optional int32 place = 14;
  bool has_place() const;
  void clear_place();
  static const int kPlaceFieldNumber = 14;
  ::google::protobuf::int32 place() const;
  void set_place(::google::protobuf::int32 value);

  // optional int32 hunger = 15;
  bool has_hunger() const;
  void clear_hunger();
  static const int kHungerFieldNumber = 15;
  ::google::protobuf::int32 hunger() const;
  void set_hunger(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.SailorInDungeon)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_typeid_();
  void clear_has_typeid_();
  void set_has_state();
  void clear_has_state();
  void set_has_index();
  void clear_has_index();
  void set_has_level();
  void clear_has_level();
  void set_has_star();
  void clear_has_star();
  void set_has_talent();
  void clear_has_talent();
  void set_has_hp_remain();
  void clear_has_hp_remain();
  void set_has_place();
  void clear_has_place();
  void set_has_hunger();
  void clear_has_hunger();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_float > attribute_;
  ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int > buff_;
  ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_float > fight_attribute_;
  ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_string_int > special_attribute_;
  ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int64_int > skill_;
  ::sg::SailorTalent* talent_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 typeid__;
  ::google::protobuf::int32 state_;
  ::google::protobuf::int32 index_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 star_;
  float hp_remain_;
  ::google::protobuf::int32 place_;
  ::google::protobuf::int32 hunger_;
  friend struct ::protobuf_PVE_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MonsterInDungeon : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.MonsterInDungeon) */ {
 public:
  MonsterInDungeon();
  virtual ~MonsterInDungeon();

  MonsterInDungeon(const MonsterInDungeon& from);

  inline MonsterInDungeon& operator=(const MonsterInDungeon& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MonsterInDungeon(MonsterInDungeon&& from) noexcept
    : MonsterInDungeon() {
    *this = ::std::move(from);
  }

  inline MonsterInDungeon& operator=(MonsterInDungeon&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const MonsterInDungeon& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MonsterInDungeon* internal_default_instance() {
    return reinterpret_cast<const MonsterInDungeon*>(
               &_MonsterInDungeon_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void UnsafeArenaSwap(MonsterInDungeon* other);
  void Swap(MonsterInDungeon* other);
  friend void swap(MonsterInDungeon& a, MonsterInDungeon& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MonsterInDungeon* New() const final {
    return CreateMaybeMessage<MonsterInDungeon>(NULL);
  }

  MonsterInDungeon* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MonsterInDungeon>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MonsterInDungeon& from);
  void MergeFrom(const MonsterInDungeon& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MonsterInDungeon* other);
  protected:
  explicit MonsterInDungeon(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sg.pb_pair_int_float attribute = 7;
  int attribute_size() const;
  void clear_attribute();
  static const int kAttributeFieldNumber = 7;
  ::sg::pb_pair_int_float* mutable_attribute(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_float >*
      mutable_attribute();
  const ::sg::pb_pair_int_float& attribute(int index) const;
  ::sg::pb_pair_int_float* add_attribute();
  const ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_float >&
      attribute() const;

  // repeated .sg.pb_pair_int_int buff = 8;
  int buff_size() const;
  void clear_buff();
  static const int kBuffFieldNumber = 8;
  ::sg::pb_pair_int_int* mutable_buff(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int >*
      mutable_buff();
  const ::sg::pb_pair_int_int& buff(int index) const;
  ::sg::pb_pair_int_int* add_buff();
  const ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int >&
      buff() const;

  // repeated .sg.pb_pair_int64_int skill = 11;
  int skill_size() const;
  void clear_skill();
  static const int kSkillFieldNumber = 11;
  ::sg::pb_pair_int64_int* mutable_skill(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int64_int >*
      mutable_skill();
  const ::sg::pb_pair_int64_int& skill(int index) const;
  ::sg::pb_pair_int64_int* add_skill();
  const ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int64_int >&
      skill() const;

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // required int32 typeid = 2;
  bool has_typeid_() const;
  void clear_typeid_();
  static const int kTypeidFieldNumber = 2;
  ::google::protobuf::int32 typeid_() const;
  void set_typeid_(::google::protobuf::int32 value);

  // required int32 state = 3;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 3;
  ::google::protobuf::int32 state() const;
  void set_state(::google::protobuf::int32 value);

  // required int32 level = 4;
  bool has_level() const;
  void clear_level();
  static const int kLevelFieldNumber = 4;
  ::google::protobuf::int32 level() const;
  void set_level(::google::protobuf::int32 value);

  // optional float hp_remain = 13;
  bool has_hp_remain() const;
  void clear_hp_remain();
  static const int kHpRemainFieldNumber = 13;
  float hp_remain() const;
  void set_hp_remain(float value);

  // @@protoc_insertion_point(class_scope:sg.MonsterInDungeon)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_typeid_();
  void clear_has_typeid_();
  void set_has_state();
  void clear_has_state();
  void set_has_level();
  void clear_has_level();
  void set_has_hp_remain();
  void clear_has_hp_remain();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_float > attribute_;
  ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int > buff_;
  ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int64_int > skill_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 typeid__;
  ::google::protobuf::int32 state_;
  ::google::protobuf::int32 level_;
  float hp_remain_;
  friend struct ::protobuf_PVE_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Enemy : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.Enemy) */ {
 public:
  Enemy();
  virtual ~Enemy();

  Enemy(const Enemy& from);

  inline Enemy& operator=(const Enemy& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Enemy(Enemy&& from) noexcept
    : Enemy() {
    *this = ::std::move(from);
  }

  inline Enemy& operator=(Enemy&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Enemy& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Enemy* internal_default_instance() {
    return reinterpret_cast<const Enemy*>(
               &_Enemy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void UnsafeArenaSwap(Enemy* other);
  void Swap(Enemy* other);
  friend void swap(Enemy& a, Enemy& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Enemy* New() const final {
    return CreateMaybeMessage<Enemy>(NULL);
  }

  Enemy* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Enemy>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Enemy& from);
  void MergeFrom(const Enemy& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Enemy* other);
  protected:
  explicit Enemy(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 contain_elements = 6;
  int contain_elements_size() const;
  void clear_contain_elements();
  static const int kContainElementsFieldNumber = 6;
  ::google::protobuf::int32 contain_elements(int index) const;
  void set_contain_elements(int index, ::google::protobuf::int32 value);
  void add_contain_elements(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      contain_elements() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_contain_elements();

  // optional .sg.SailorInDungeon sailor_data = 4;
  bool has_sailor_data() const;
  void clear_sailor_data();
  static const int kSailorDataFieldNumber = 4;
  private:
  const ::sg::SailorInDungeon& _internal_sailor_data() const;
  public:
  const ::sg::SailorInDungeon& sailor_data() const;
  ::sg::SailorInDungeon* release_sailor_data();
  ::sg::SailorInDungeon* mutable_sailor_data();
  void set_allocated_sailor_data(::sg::SailorInDungeon* sailor_data);
  void unsafe_arena_set_allocated_sailor_data(
      ::sg::SailorInDungeon* sailor_data);
  ::sg::SailorInDungeon* unsafe_arena_release_sailor_data();

  // optional .sg.MonsterInDungeon monster_data = 5;
  bool has_monster_data() const;
  void clear_monster_data();
  static const int kMonsterDataFieldNumber = 5;
  private:
  const ::sg::MonsterInDungeon& _internal_monster_data() const;
  public:
  const ::sg::MonsterInDungeon& monster_data() const;
  ::sg::MonsterInDungeon* release_monster_data();
  ::sg::MonsterInDungeon* mutable_monster_data();
  void set_allocated_monster_data(::sg::MonsterInDungeon* monster_data);
  void unsafe_arena_set_allocated_monster_data(
      ::sg::MonsterInDungeon* monster_data);
  ::sg::MonsterInDungeon* unsafe_arena_release_monster_data();

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // required int32 type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // optional int32 seat = 3;
  bool has_seat() const;
  void clear_seat();
  static const int kSeatFieldNumber = 3;
  ::google::protobuf::int32 seat() const;
  void set_seat(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.Enemy)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_type();
  void clear_has_type();
  void set_has_seat();
  void clear_has_seat();
  void set_has_sailor_data();
  void clear_has_sailor_data();
  void set_has_monster_data();
  void clear_has_monster_data();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > contain_elements_;
  ::sg::SailorInDungeon* sailor_data_;
  ::sg::MonsterInDungeon* monster_data_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 seat_;
  friend struct ::protobuf_PVE_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DungeonAltar_Relic : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.DungeonAltar.Relic) */ {
 public:
  DungeonAltar_Relic();
  virtual ~DungeonAltar_Relic();

  DungeonAltar_Relic(const DungeonAltar_Relic& from);

  inline DungeonAltar_Relic& operator=(const DungeonAltar_Relic& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DungeonAltar_Relic(DungeonAltar_Relic&& from) noexcept
    : DungeonAltar_Relic() {
    *this = ::std::move(from);
  }

  inline DungeonAltar_Relic& operator=(DungeonAltar_Relic&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const DungeonAltar_Relic& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DungeonAltar_Relic* internal_default_instance() {
    return reinterpret_cast<const DungeonAltar_Relic*>(
               &_DungeonAltar_Relic_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void UnsafeArenaSwap(DungeonAltar_Relic* other);
  void Swap(DungeonAltar_Relic* other);
  friend void swap(DungeonAltar_Relic& a, DungeonAltar_Relic& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DungeonAltar_Relic* New() const final {
    return CreateMaybeMessage<DungeonAltar_Relic>(NULL);
  }

  DungeonAltar_Relic* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DungeonAltar_Relic>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DungeonAltar_Relic& from);
  void MergeFrom(const DungeonAltar_Relic& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DungeonAltar_Relic* other);
  protected:
  explicit DungeonAltar_Relic(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sg.pb_pair_int_int skills = 2;
  int skills_size() const;
  void clear_skills();
  static const int kSkillsFieldNumber = 2;
  ::sg::pb_pair_int_int* mutable_skills(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int >*
      mutable_skills();
  const ::sg::pb_pair_int_int& skills(int index) const;
  ::sg::pb_pair_int_int* add_skills();
  const ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int >&
      skills() const;

  // required int32 typeid = 1;
  bool has_typeid_() const;
  void clear_typeid_();
  static const int kTypeidFieldNumber = 1;
  ::google::protobuf::int32 typeid_() const;
  void set_typeid_(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.DungeonAltar.Relic)
 private:
  void set_has_typeid_();
  void clear_has_typeid_();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int > skills_;
  ::google::protobuf::int32 typeid__;
  friend struct ::protobuf_PVE_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DungeonAltar : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.DungeonAltar) */ {
 public:
  DungeonAltar();
  virtual ~DungeonAltar();

  DungeonAltar(const DungeonAltar& from);

  inline DungeonAltar& operator=(const DungeonAltar& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DungeonAltar(DungeonAltar&& from) noexcept
    : DungeonAltar() {
    *this = ::std::move(from);
  }

  inline DungeonAltar& operator=(DungeonAltar&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const DungeonAltar& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DungeonAltar* internal_default_instance() {
    return reinterpret_cast<const DungeonAltar*>(
               &_DungeonAltar_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void UnsafeArenaSwap(DungeonAltar* other);
  void Swap(DungeonAltar* other);
  friend void swap(DungeonAltar& a, DungeonAltar& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DungeonAltar* New() const final {
    return CreateMaybeMessage<DungeonAltar>(NULL);
  }

  DungeonAltar* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DungeonAltar>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DungeonAltar& from);
  void MergeFrom(const DungeonAltar& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DungeonAltar* other);
  protected:
  explicit DungeonAltar(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DungeonAltar_Relic Relic;

  // accessors -------------------------------------------------------

  // optional .sg.DungeonAltar.Relic relic = 3;
  bool has_relic() const;
  void clear_relic();
  static const int kRelicFieldNumber = 3;
  private:
  const ::sg::DungeonAltar_Relic& _internal_relic() const;
  public:
  const ::sg::DungeonAltar_Relic& relic() const;
  ::sg::DungeonAltar_Relic* release_relic();
  ::sg::DungeonAltar_Relic* mutable_relic();
  void set_allocated_relic(::sg::DungeonAltar_Relic* relic);
  void unsafe_arena_set_allocated_relic(
      ::sg::DungeonAltar_Relic* relic);
  ::sg::DungeonAltar_Relic* unsafe_arena_release_relic();

  // optional .sg.MonsterInDungeon monster = 4;
  bool has_monster() const;
  void clear_monster();
  static const int kMonsterFieldNumber = 4;
  private:
  const ::sg::MonsterInDungeon& _internal_monster() const;
  public:
  const ::sg::MonsterInDungeon& monster() const;
  ::sg::MonsterInDungeon* release_monster();
  ::sg::MonsterInDungeon* mutable_monster();
  void set_allocated_monster(::sg::MonsterInDungeon* monster);
  void unsafe_arena_set_allocated_monster(
      ::sg::MonsterInDungeon* monster);
  ::sg::MonsterInDungeon* unsafe_arena_release_monster();

  // required int32 typeid = 1;
  bool has_typeid_() const;
  void clear_typeid_();
  static const int kTypeidFieldNumber = 1;
  ::google::protobuf::int32 typeid_() const;
  void set_typeid_(::google::protobuf::int32 value);

  // required int32 state = 2;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 2;
  ::google::protobuf::int32 state() const;
  void set_state(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.DungeonAltar)
 private:
  void set_has_typeid_();
  void clear_has_typeid_();
  void set_has_state();
  void clear_has_state();
  void set_has_relic();
  void clear_has_relic();
  void set_has_monster();
  void clear_has_monster();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::sg::DungeonAltar_Relic* relic_;
  ::sg::MonsterInDungeon* monster_;
  ::google::protobuf::int32 typeid__;
  ::google::protobuf::int32 state_;
  friend struct ::protobuf_PVE_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ElementProperty_RoomData_RoomEffect : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.ElementProperty.RoomData.RoomEffect) */ {
 public:
  ElementProperty_RoomData_RoomEffect();
  virtual ~ElementProperty_RoomData_RoomEffect();

  ElementProperty_RoomData_RoomEffect(const ElementProperty_RoomData_RoomEffect& from);

  inline ElementProperty_RoomData_RoomEffect& operator=(const ElementProperty_RoomData_RoomEffect& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ElementProperty_RoomData_RoomEffect(ElementProperty_RoomData_RoomEffect&& from) noexcept
    : ElementProperty_RoomData_RoomEffect() {
    *this = ::std::move(from);
  }

  inline ElementProperty_RoomData_RoomEffect& operator=(ElementProperty_RoomData_RoomEffect&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const ElementProperty_RoomData_RoomEffect& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ElementProperty_RoomData_RoomEffect* internal_default_instance() {
    return reinterpret_cast<const ElementProperty_RoomData_RoomEffect*>(
               &_ElementProperty_RoomData_RoomEffect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void UnsafeArenaSwap(ElementProperty_RoomData_RoomEffect* other);
  void Swap(ElementProperty_RoomData_RoomEffect* other);
  friend void swap(ElementProperty_RoomData_RoomEffect& a, ElementProperty_RoomData_RoomEffect& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ElementProperty_RoomData_RoomEffect* New() const final {
    return CreateMaybeMessage<ElementProperty_RoomData_RoomEffect>(NULL);
  }

  ElementProperty_RoomData_RoomEffect* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ElementProperty_RoomData_RoomEffect>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ElementProperty_RoomData_RoomEffect& from);
  void MergeFrom(const ElementProperty_RoomData_RoomEffect& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ElementProperty_RoomData_RoomEffect* other);
  protected:
  explicit ElementProperty_RoomData_RoomEffect(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sg.Item contain = 5;
  int contain_size() const;
  void clear_contain();
  static const int kContainFieldNumber = 5;
  ::sg::Item* mutable_contain(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::Item >*
      mutable_contain();
  const ::sg::Item& contain(int index) const;
  ::sg::Item* add_contain();
  const ::google::protobuf::RepeatedPtrField< ::sg::Item >&
      contain() const;

  // repeated .sg.Equip equips = 6;
  int equips_size() const;
  void clear_equips();
  static const int kEquipsFieldNumber = 6;
  ::sg::Equip* mutable_equips(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::Equip >*
      mutable_equips();
  const ::sg::Equip& equips(int index) const;
  ::sg::Equip* add_equips();
  const ::google::protobuf::RepeatedPtrField< ::sg::Equip >&
      equips() const;

  // optional int32 enter_effect = 1;
  bool has_enter_effect() const;
  void clear_enter_effect();
  static const int kEnterEffectFieldNumber = 1;
  ::google::protobuf::int32 enter_effect() const;
  void set_enter_effect(::google::protobuf::int32 value);

  // optional int32 effect_id = 2;
  bool has_effect_id() const;
  void clear_effect_id();
  static const int kEffectIdFieldNumber = 2;
  ::google::protobuf::int32 effect_id() const;
  void set_effect_id(::google::protobuf::int32 value);

  // optional int32 effect_value = 3;
  bool has_effect_value() const;
  void clear_effect_value();
  static const int kEffectValueFieldNumber = 3;
  ::google::protobuf::int32 effect_value() const;
  void set_effect_value(::google::protobuf::int32 value);

  // optional float effect_value_ratio = 4;
  bool has_effect_value_ratio() const;
  void clear_effect_value_ratio();
  static const int kEffectValueRatioFieldNumber = 4;
  float effect_value_ratio() const;
  void set_effect_value_ratio(float value);

  // @@protoc_insertion_point(class_scope:sg.ElementProperty.RoomData.RoomEffect)
 private:
  void set_has_enter_effect();
  void clear_has_enter_effect();
  void set_has_effect_id();
  void clear_has_effect_id();
  void set_has_effect_value();
  void clear_has_effect_value();
  void set_has_effect_value_ratio();
  void clear_has_effect_value_ratio();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::Item > contain_;
  ::google::protobuf::RepeatedPtrField< ::sg::Equip > equips_;
  ::google::protobuf::int32 enter_effect_;
  ::google::protobuf::int32 effect_id_;
  ::google::protobuf::int32 effect_value_;
  float effect_value_ratio_;
  friend struct ::protobuf_PVE_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ElementProperty_RoomData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.ElementProperty.RoomData) */ {
 public:
  ElementProperty_RoomData();
  virtual ~ElementProperty_RoomData();

  ElementProperty_RoomData(const ElementProperty_RoomData& from);

  inline ElementProperty_RoomData& operator=(const ElementProperty_RoomData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ElementProperty_RoomData(ElementProperty_RoomData&& from) noexcept
    : ElementProperty_RoomData() {
    *this = ::std::move(from);
  }

  inline ElementProperty_RoomData& operator=(ElementProperty_RoomData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const ElementProperty_RoomData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ElementProperty_RoomData* internal_default_instance() {
    return reinterpret_cast<const ElementProperty_RoomData*>(
               &_ElementProperty_RoomData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void UnsafeArenaSwap(ElementProperty_RoomData* other);
  void Swap(ElementProperty_RoomData* other);
  friend void swap(ElementProperty_RoomData& a, ElementProperty_RoomData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ElementProperty_RoomData* New() const final {
    return CreateMaybeMessage<ElementProperty_RoomData>(NULL);
  }

  ElementProperty_RoomData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ElementProperty_RoomData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ElementProperty_RoomData& from);
  void MergeFrom(const ElementProperty_RoomData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ElementProperty_RoomData* other);
  protected:
  explicit ElementProperty_RoomData(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ElementProperty_RoomData_RoomEffect RoomEffect;

  // accessors -------------------------------------------------------

  // repeated .sg.ElementProperty.RoomData.RoomEffect effects = 4;
  int effects_size() const;
  void clear_effects();
  static const int kEffectsFieldNumber = 4;
  ::sg::ElementProperty_RoomData_RoomEffect* mutable_effects(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::ElementProperty_RoomData_RoomEffect >*
      mutable_effects();
  const ::sg::ElementProperty_RoomData_RoomEffect& effects(int index) const;
  ::sg::ElementProperty_RoomData_RoomEffect* add_effects();
  const ::google::protobuf::RepeatedPtrField< ::sg::ElementProperty_RoomData_RoomEffect >&
      effects() const;

  // required int32 roomid = 1;
  bool has_roomid() const;
  void clear_roomid();
  static const int kRoomidFieldNumber = 1;
  ::google::protobuf::int32 roomid() const;
  void set_roomid(::google::protobuf::int32 value);

  // optional int32 type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // optional int32 state = 3;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 3;
  ::google::protobuf::int32 state() const;
  void set_state(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.ElementProperty.RoomData)
 private:
  void set_has_roomid();
  void clear_has_roomid();
  void set_has_type();
  void clear_has_type();
  void set_has_state();
  void clear_has_state();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::ElementProperty_RoomData_RoomEffect > effects_;
  ::google::protobuf::int32 roomid_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 state_;
  friend struct ::protobuf_PVE_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ElementProperty : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.ElementProperty) */ {
 public:
  ElementProperty();
  virtual ~ElementProperty();

  ElementProperty(const ElementProperty& from);

  inline ElementProperty& operator=(const ElementProperty& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ElementProperty(ElementProperty&& from) noexcept
    : ElementProperty() {
    *this = ::std::move(from);
  }

  inline ElementProperty& operator=(ElementProperty&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const ElementProperty& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ElementProperty* internal_default_instance() {
    return reinterpret_cast<const ElementProperty*>(
               &_ElementProperty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void UnsafeArenaSwap(ElementProperty* other);
  void Swap(ElementProperty* other);
  friend void swap(ElementProperty& a, ElementProperty& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ElementProperty* New() const final {
    return CreateMaybeMessage<ElementProperty>(NULL);
  }

  ElementProperty* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ElementProperty>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ElementProperty& from);
  void MergeFrom(const ElementProperty& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ElementProperty* other);
  protected:
  explicit ElementProperty(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ElementProperty_RoomData RoomData;

  // accessors -------------------------------------------------------

  // repeated int32 locked_room = 14;
  int locked_room_size() const;
  void clear_locked_room();
  static const int kLockedRoomFieldNumber = 14;
  ::google::protobuf::int32 locked_room(int index) const;
  void set_locked_room(int index, ::google::protobuf::int32 value);
  void add_locked_room(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      locked_room() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_locked_room();

  // optional bytes map_data = 12;
  bool has_map_data() const;
  void clear_map_data();
  static const int kMapDataFieldNumber = 12;
  const ::std::string& map_data() const;
  void set_map_data(const ::std::string& value);
  #if LANG_CXX11
  void set_map_data(::std::string&& value);
  #endif
  void set_map_data(const char* value);
  void set_map_data(const void* value, size_t size);
  ::std::string* mutable_map_data();
  ::std::string* release_map_data();
  void set_allocated_map_data(::std::string* map_data);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_map_data();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_map_data(
      ::std::string* map_data);

  // optional .sg.ElementProperty.RoomData room_data = 16;
  bool has_room_data() const;
  void clear_room_data();
  static const int kRoomDataFieldNumber = 16;
  private:
  const ::sg::ElementProperty_RoomData& _internal_room_data() const;
  public:
  const ::sg::ElementProperty_RoomData& room_data() const;
  ::sg::ElementProperty_RoomData* release_room_data();
  ::sg::ElementProperty_RoomData* mutable_room_data();
  void set_allocated_room_data(::sg::ElementProperty_RoomData* room_data);
  void unsafe_arena_set_allocated_room_data(
      ::sg::ElementProperty_RoomData* room_data);
  ::sg::ElementProperty_RoomData* unsafe_arena_release_room_data();

  // optional int32 index = 1;
  bool has_index() const;
  void clear_index();
  static const int kIndexFieldNumber = 1;
  ::google::protobuf::int32 index() const;
  void set_index(::google::protobuf::int32 value);

  // optional int32 num = 2;
  bool has_num() const;
  void clear_num();
  static const int kNumFieldNumber = 2;
  ::google::protobuf::int32 num() const;
  void set_num(::google::protobuf::int32 value);

  // optional int32 exp = 3;
  bool has_exp() const;
  void clear_exp();
  static const int kExpFieldNumber = 3;
  ::google::protobuf::int32 exp() const;
  void set_exp(::google::protobuf::int32 value);

  // optional int32 pos_x = 4;
  bool has_pos_x() const;
  void clear_pos_x();
  static const int kPosXFieldNumber = 4;
  ::google::protobuf::int32 pos_x() const;
  void set_pos_x(::google::protobuf::int32 value);

  // optional int32 pos_y = 5;
  bool has_pos_y() const;
  void clear_pos_y();
  static const int kPosYFieldNumber = 5;
  ::google::protobuf::int32 pos_y() const;
  void set_pos_y(::google::protobuf::int32 value);

  // optional int32 lock_id = 6;
  bool has_lock_id() const;
  void clear_lock_id();
  static const int kLockIdFieldNumber = 6;
  ::google::protobuf::int32 lock_id() const;
  void set_lock_id(::google::protobuf::int32 value);

  // optional int32 room_id = 7;
  bool has_room_id() const;
  void clear_room_id();
  static const int kRoomIdFieldNumber = 7;
  ::google::protobuf::int32 room_id() const;
  void set_room_id(::google::protobuf::int32 value);

  // optional int32 change_model = 8;
  bool has_change_model() const;
  void clear_change_model();
  static const int kChangeModelFieldNumber = 8;
  ::google::protobuf::int32 change_model() const;
  void set_change_model(::google::protobuf::int32 value);

  // optional int32 trigger_id = 9;
  bool has_trigger_id() const;
  void clear_trigger_id();
  static const int kTriggerIdFieldNumber = 9;
  ::google::protobuf::int32 trigger_id() const;
  void set_trigger_id(::google::protobuf::int32 value);

  // optional int32 clean_up_reward_tag = 10;
  bool has_clean_up_reward_tag() const;
  void clear_clean_up_reward_tag();
  static const int kCleanUpRewardTagFieldNumber = 10;
  ::google::protobuf::int32 clean_up_reward_tag() const;
  void set_clean_up_reward_tag(::google::protobuf::int32 value);

  // optional int32 belong_facility = 11;
  bool has_belong_facility() const;
  void clear_belong_facility();
  static const int kBelongFacilityFieldNumber = 11;
  ::google::protobuf::int32 belong_facility() const;
  void set_belong_facility(::google::protobuf::int32 value);

  // optional int32 unlock_room = 13;
  bool has_unlock_room() const;
  void clear_unlock_room();
  static const int kUnlockRoomFieldNumber = 13;
  ::google::protobuf::int32 unlock_room() const;
  void set_unlock_room(::google::protobuf::int32 value);

  // optional int64 trigger_event = 15;
  bool has_trigger_event() const;
  void clear_trigger_event();
  static const int kTriggerEventFieldNumber = 15;
  ::google::protobuf::int64 trigger_event() const;
  void set_trigger_event(::google::protobuf::int64 value);

  // optional int32 state = 17;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 17;
  ::google::protobuf::int32 state() const;
  void set_state(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.ElementProperty)
 private:
  void set_has_index();
  void clear_has_index();
  void set_has_num();
  void clear_has_num();
  void set_has_exp();
  void clear_has_exp();
  void set_has_pos_x();
  void clear_has_pos_x();
  void set_has_pos_y();
  void clear_has_pos_y();
  void set_has_lock_id();
  void clear_has_lock_id();
  void set_has_room_id();
  void clear_has_room_id();
  void set_has_change_model();
  void clear_has_change_model();
  void set_has_trigger_id();
  void clear_has_trigger_id();
  void set_has_clean_up_reward_tag();
  void clear_has_clean_up_reward_tag();
  void set_has_belong_facility();
  void clear_has_belong_facility();
  void set_has_map_data();
  void clear_has_map_data();
  void set_has_unlock_room();
  void clear_has_unlock_room();
  void set_has_trigger_event();
  void clear_has_trigger_event();
  void set_has_room_data();
  void clear_has_room_data();
  void set_has_state();
  void clear_has_state();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > locked_room_;
  ::google::protobuf::internal::ArenaStringPtr map_data_;
  ::sg::ElementProperty_RoomData* room_data_;
  ::google::protobuf::int32 index_;
  ::google::protobuf::int32 num_;
  ::google::protobuf::int32 exp_;
  ::google::protobuf::int32 pos_x_;
  ::google::protobuf::int32 pos_y_;
  ::google::protobuf::int32 lock_id_;
  ::google::protobuf::int32 room_id_;
  ::google::protobuf::int32 change_model_;
  ::google::protobuf::int32 trigger_id_;
  ::google::protobuf::int32 clean_up_reward_tag_;
  ::google::protobuf::int32 belong_facility_;
  ::google::protobuf::int32 unlock_room_;
  ::google::protobuf::int64 trigger_event_;
  ::google::protobuf::int32 state_;
  friend struct ::protobuf_PVE_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FightManual : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.FightManual) */ {
 public:
  FightManual();
  virtual ~FightManual();

  FightManual(const FightManual& from);

  inline FightManual& operator=(const FightManual& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FightManual(FightManual&& from) noexcept
    : FightManual() {
    *this = ::std::move(from);
  }

  inline FightManual& operator=(FightManual&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const FightManual& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FightManual* internal_default_instance() {
    return reinterpret_cast<const FightManual*>(
               &_FightManual_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void UnsafeArenaSwap(FightManual* other);
  void Swap(FightManual* other);
  friend void swap(FightManual& a, FightManual& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FightManual* New() const final {
    return CreateMaybeMessage<FightManual>(NULL);
  }

  FightManual* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FightManual>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FightManual& from);
  void MergeFrom(const FightManual& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FightManual* other);
  protected:
  explicit FightManual(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 typeid = 2;
  int typeid__size() const;
  void clear_typeid_();
  static const int kTypeidFieldNumber = 2;
  ::google::protobuf::int32 typeid_(int index) const;
  void set_typeid_(int index, ::google::protobuf::int32 value);
  void add_typeid_(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      typeid_() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_typeid_();

  // required int32 type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.FightManual)
 private:
  void set_has_type();
  void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > typeid__;
  ::google::protobuf::int32 type_;
  friend struct ::protobuf_PVE_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DungeonElement_Exchange_Exchange_Item : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.DungeonElement.Exchange.Exchange_Item) */ {
 public:
  DungeonElement_Exchange_Exchange_Item();
  virtual ~DungeonElement_Exchange_Exchange_Item();

  DungeonElement_Exchange_Exchange_Item(const DungeonElement_Exchange_Exchange_Item& from);

  inline DungeonElement_Exchange_Exchange_Item& operator=(const DungeonElement_Exchange_Exchange_Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DungeonElement_Exchange_Exchange_Item(DungeonElement_Exchange_Exchange_Item&& from) noexcept
    : DungeonElement_Exchange_Exchange_Item() {
    *this = ::std::move(from);
  }

  inline DungeonElement_Exchange_Exchange_Item& operator=(DungeonElement_Exchange_Exchange_Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const DungeonElement_Exchange_Exchange_Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DungeonElement_Exchange_Exchange_Item* internal_default_instance() {
    return reinterpret_cast<const DungeonElement_Exchange_Exchange_Item*>(
               &_DungeonElement_Exchange_Exchange_Item_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void UnsafeArenaSwap(DungeonElement_Exchange_Exchange_Item* other);
  void Swap(DungeonElement_Exchange_Exchange_Item* other);
  friend void swap(DungeonElement_Exchange_Exchange_Item& a, DungeonElement_Exchange_Exchange_Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DungeonElement_Exchange_Exchange_Item* New() const final {
    return CreateMaybeMessage<DungeonElement_Exchange_Exchange_Item>(NULL);
  }

  DungeonElement_Exchange_Exchange_Item* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DungeonElement_Exchange_Exchange_Item>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DungeonElement_Exchange_Exchange_Item& from);
  void MergeFrom(const DungeonElement_Exchange_Exchange_Item& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DungeonElement_Exchange_Exchange_Item* other);
  protected:
  explicit DungeonElement_Exchange_Exchange_Item(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 item_type = 1;
  bool has_item_type() const;
  void clear_item_type();
  static const int kItemTypeFieldNumber = 1;
  ::google::protobuf::int32 item_type() const;
  void set_item_type(::google::protobuf::int32 value);

  // optional int32 id = 2;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 2;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // optional uint64 typeid = 4;
  bool has_typeid_() const;
  void clear_typeid_();
  static const int kTypeidFieldNumber = 4;
  ::google::protobuf::uint64 typeid_() const;
  void set_typeid_(::google::protobuf::uint64 value);

  // optional uint64 value = 5;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 5;
  ::google::protobuf::uint64 value() const;
  void set_value(::google::protobuf::uint64 value);

  // optional int32 type = 3;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.DungeonElement.Exchange.Exchange_Item)
 private:
  void set_has_item_type();
  void clear_has_item_type();
  void set_has_id();
  void clear_has_id();
  void set_has_type();
  void clear_has_type();
  void set_has_typeid_();
  void clear_has_typeid_();
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 item_type_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::uint64 typeid__;
  ::google::protobuf::uint64 value_;
  ::google::protobuf::int32 type_;
  friend struct ::protobuf_PVE_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DungeonElement_Exchange : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.DungeonElement.Exchange) */ {
 public:
  DungeonElement_Exchange();
  virtual ~DungeonElement_Exchange();

  DungeonElement_Exchange(const DungeonElement_Exchange& from);

  inline DungeonElement_Exchange& operator=(const DungeonElement_Exchange& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DungeonElement_Exchange(DungeonElement_Exchange&& from) noexcept
    : DungeonElement_Exchange() {
    *this = ::std::move(from);
  }

  inline DungeonElement_Exchange& operator=(DungeonElement_Exchange&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const DungeonElement_Exchange& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DungeonElement_Exchange* internal_default_instance() {
    return reinterpret_cast<const DungeonElement_Exchange*>(
               &_DungeonElement_Exchange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void UnsafeArenaSwap(DungeonElement_Exchange* other);
  void Swap(DungeonElement_Exchange* other);
  friend void swap(DungeonElement_Exchange& a, DungeonElement_Exchange& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DungeonElement_Exchange* New() const final {
    return CreateMaybeMessage<DungeonElement_Exchange>(NULL);
  }

  DungeonElement_Exchange* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DungeonElement_Exchange>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DungeonElement_Exchange& from);
  void MergeFrom(const DungeonElement_Exchange& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DungeonElement_Exchange* other);
  protected:
  explicit DungeonElement_Exchange(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DungeonElement_Exchange_Exchange_Item Exchange_Item;

  // accessors -------------------------------------------------------

  // repeated .sg.DungeonElement.Exchange.Exchange_Item cost = 4;
  int cost_size() const;
  void clear_cost();
  static const int kCostFieldNumber = 4;
  ::sg::DungeonElement_Exchange_Exchange_Item* mutable_cost(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::DungeonElement_Exchange_Exchange_Item >*
      mutable_cost();
  const ::sg::DungeonElement_Exchange_Exchange_Item& cost(int index) const;
  ::sg::DungeonElement_Exchange_Exchange_Item* add_cost();
  const ::google::protobuf::RepeatedPtrField< ::sg::DungeonElement_Exchange_Exchange_Item >&
      cost() const;

  // repeated .sg.DungeonElement.Exchange.Exchange_Item get = 5;
  int get_size() const;
  void clear_get();
  static const int kGetFieldNumber = 5;
  ::sg::DungeonElement_Exchange_Exchange_Item* mutable_get(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::DungeonElement_Exchange_Exchange_Item >*
      mutable_get();
  const ::sg::DungeonElement_Exchange_Exchange_Item& get(int index) const;
  ::sg::DungeonElement_Exchange_Exchange_Item* add_get();
  const ::google::protobuf::RepeatedPtrField< ::sg::DungeonElement_Exchange_Exchange_Item >&
      get() const;

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // required int32 typeid = 2;
  bool has_typeid_() const;
  void clear_typeid_();
  static const int kTypeidFieldNumber = 2;
  ::google::protobuf::int32 typeid_() const;
  void set_typeid_(::google::protobuf::int32 value);

  // required int32 index = 3;
  bool has_index() const;
  void clear_index();
  static const int kIndexFieldNumber = 3;
  ::google::protobuf::int32 index() const;
  void set_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.DungeonElement.Exchange)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_typeid_();
  void clear_has_typeid_();
  void set_has_index();
  void clear_has_index();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::DungeonElement_Exchange_Exchange_Item > cost_;
  ::google::protobuf::RepeatedPtrField< ::sg::DungeonElement_Exchange_Exchange_Item > get_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 typeid__;
  ::google::protobuf::int32 index_;
  friend struct ::protobuf_PVE_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DungeonElement : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.DungeonElement) */ {
 public:
  DungeonElement();
  virtual ~DungeonElement();

  DungeonElement(const DungeonElement& from);

  inline DungeonElement& operator=(const DungeonElement& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DungeonElement(DungeonElement&& from) noexcept
    : DungeonElement() {
    *this = ::std::move(from);
  }

  inline DungeonElement& operator=(DungeonElement&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const DungeonElement& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DungeonElement* internal_default_instance() {
    return reinterpret_cast<const DungeonElement*>(
               &_DungeonElement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void UnsafeArenaSwap(DungeonElement* other);
  void Swap(DungeonElement* other);
  friend void swap(DungeonElement& a, DungeonElement& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DungeonElement* New() const final {
    return CreateMaybeMessage<DungeonElement>(NULL);
  }

  DungeonElement* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DungeonElement>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DungeonElement& from);
  void MergeFrom(const DungeonElement& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DungeonElement* other);
  protected:
  explicit DungeonElement(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DungeonElement_Exchange Exchange;

  // accessors -------------------------------------------------------

  // repeated .sg.DungeonElement.Exchange exchange_list = 6;
  int exchange_list_size() const;
  void clear_exchange_list();
  static const int kExchangeListFieldNumber = 6;
  ::sg::DungeonElement_Exchange* mutable_exchange_list(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::DungeonElement_Exchange >*
      mutable_exchange_list();
  const ::sg::DungeonElement_Exchange& exchange_list(int index) const;
  ::sg::DungeonElement_Exchange* add_exchange_list();
  const ::google::protobuf::RepeatedPtrField< ::sg::DungeonElement_Exchange >&
      exchange_list() const;

  // repeated int32 elements = 7;
  int elements_size() const;
  void clear_elements();
  static const int kElementsFieldNumber = 7;
  ::google::protobuf::int32 elements(int index) const;
  void set_elements(int index, ::google::protobuf::int32 value);
  void add_elements(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      elements() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_elements();

  // optional .sg.ElementProperty property = 5;
  bool has_property() const;
  void clear_property();
  static const int kPropertyFieldNumber = 5;
  private:
  const ::sg::ElementProperty& _internal_property() const;
  public:
  const ::sg::ElementProperty& property() const;
  ::sg::ElementProperty* release_property();
  ::sg::ElementProperty* mutable_property();
  void set_allocated_property(::sg::ElementProperty* property);
  void unsafe_arena_set_allocated_property(
      ::sg::ElementProperty* property);
  ::sg::ElementProperty* unsafe_arena_release_property();

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // required int32 owner_id = 2;
  bool has_owner_id() const;
  void clear_owner_id();
  static const int kOwnerIdFieldNumber = 2;
  ::google::protobuf::int32 owner_id() const;
  void set_owner_id(::google::protobuf::int32 value);

  // required int64 typeid_ = 4;
  bool has_typeid_() const;
  void clear_typeid_();
  static const int kTypeidFieldNumber = 4;
  ::google::protobuf::int64 typeid_() const;
  void set_typeid_(::google::protobuf::int64 value);

  // required int32 type = 3;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.DungeonElement)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_owner_id();
  void clear_has_owner_id();
  void set_has_type();
  void clear_has_type();
  void set_has_typeid_();
  void clear_has_typeid_();
  void set_has_property();
  void clear_has_property();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::DungeonElement_Exchange > exchange_list_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > elements_;
  ::sg::ElementProperty* property_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 owner_id_;
  ::google::protobuf::int64 typeid__;
  ::google::protobuf::int32 type_;
  friend struct ::protobuf_PVE_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DungeonContent_PathBranch : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.DungeonContent.PathBranch) */ {
 public:
  DungeonContent_PathBranch();
  virtual ~DungeonContent_PathBranch();

  DungeonContent_PathBranch(const DungeonContent_PathBranch& from);

  inline DungeonContent_PathBranch& operator=(const DungeonContent_PathBranch& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DungeonContent_PathBranch(DungeonContent_PathBranch&& from) noexcept
    : DungeonContent_PathBranch() {
    *this = ::std::move(from);
  }

  inline DungeonContent_PathBranch& operator=(DungeonContent_PathBranch&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const DungeonContent_PathBranch& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DungeonContent_PathBranch* internal_default_instance() {
    return reinterpret_cast<const DungeonContent_PathBranch*>(
               &_DungeonContent_PathBranch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void UnsafeArenaSwap(DungeonContent_PathBranch* other);
  void Swap(DungeonContent_PathBranch* other);
  friend void swap(DungeonContent_PathBranch& a, DungeonContent_PathBranch& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DungeonContent_PathBranch* New() const final {
    return CreateMaybeMessage<DungeonContent_PathBranch>(NULL);
  }

  DungeonContent_PathBranch* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DungeonContent_PathBranch>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DungeonContent_PathBranch& from);
  void MergeFrom(const DungeonContent_PathBranch& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DungeonContent_PathBranch* other);
  protected:
  explicit DungeonContent_PathBranch(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sg.pb_pair_int_int layer_change = 2;
  int layer_change_size() const;
  void clear_layer_change();
  static const int kLayerChangeFieldNumber = 2;
  ::sg::pb_pair_int_int* mutable_layer_change(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int >*
      mutable_layer_change();
  const ::sg::pb_pair_int_int& layer_change(int index) const;
  ::sg::pb_pair_int_int* add_layer_change();
  const ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int >&
      layer_change() const;

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.DungeonContent.PathBranch)
 private:
  void set_has_id();
  void clear_has_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int > layer_change_;
  ::google::protobuf::int32 id_;
  friend struct ::protobuf_PVE_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DungeonContent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.DungeonContent) */ {
 public:
  DungeonContent();
  virtual ~DungeonContent();

  DungeonContent(const DungeonContent& from);

  inline DungeonContent& operator=(const DungeonContent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DungeonContent(DungeonContent&& from) noexcept
    : DungeonContent() {
    *this = ::std::move(from);
  }

  inline DungeonContent& operator=(DungeonContent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const DungeonContent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DungeonContent* internal_default_instance() {
    return reinterpret_cast<const DungeonContent*>(
               &_DungeonContent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void UnsafeArenaSwap(DungeonContent* other);
  void Swap(DungeonContent* other);
  friend void swap(DungeonContent& a, DungeonContent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DungeonContent* New() const final {
    return CreateMaybeMessage<DungeonContent>(NULL);
  }

  DungeonContent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DungeonContent>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DungeonContent& from);
  void MergeFrom(const DungeonContent& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DungeonContent* other);
  protected:
  explicit DungeonContent(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DungeonContent_PathBranch PathBranch;

  // accessors -------------------------------------------------------

  // repeated .sg.DungeonElement elements = 4;
  int elements_size() const;
  void clear_elements();
  static const int kElementsFieldNumber = 4;
  ::sg::DungeonElement* mutable_elements(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::DungeonElement >*
      mutable_elements();
  const ::sg::DungeonElement& elements(int index) const;
  ::sg::DungeonElement* add_elements();
  const ::google::protobuf::RepeatedPtrField< ::sg::DungeonElement >&
      elements() const;

  // repeated .sg.DungeonContent.PathBranch path_choice = 5;
  int path_choice_size() const;
  void clear_path_choice();
  static const int kPathChoiceFieldNumber = 5;
  ::sg::DungeonContent_PathBranch* mutable_path_choice(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::DungeonContent_PathBranch >*
      mutable_path_choice();
  const ::sg::DungeonContent_PathBranch& path_choice(int index) const;
  ::sg::DungeonContent_PathBranch* add_path_choice();
  const ::google::protobuf::RepeatedPtrField< ::sg::DungeonContent_PathBranch >&
      path_choice() const;

  // repeated .sg.Enemy enemys = 8;
  int enemys_size() const;
  void clear_enemys();
  static const int kEnemysFieldNumber = 8;
  ::sg::Enemy* mutable_enemys(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::Enemy >*
      mutable_enemys();
  const ::sg::Enemy& enemys(int index) const;
  ::sg::Enemy* add_enemys();
  const ::google::protobuf::RepeatedPtrField< ::sg::Enemy >&
      enemys() const;

  // required int32 now_layer = 1;
  bool has_now_layer() const;
  void clear_now_layer();
  static const int kNowLayerFieldNumber = 1;
  ::google::protobuf::int32 now_layer() const;
  void set_now_layer(::google::protobuf::int32 value);

  // required int32 style = 2;
  bool has_style() const;
  void clear_style();
  static const int kStyleFieldNumber = 2;
  ::google::protobuf::int32 style() const;
  void set_style(::google::protobuf::int32 value);

  // required int32 monster_level = 3;
  bool has_monster_level() const;
  void clear_monster_level();
  static const int kMonsterLevelFieldNumber = 3;
  ::google::protobuf::int32 monster_level() const;
  void set_monster_level(::google::protobuf::int32 value);

  // optional int32 real_layer = 6;
  bool has_real_layer() const;
  void clear_real_layer();
  static const int kRealLayerFieldNumber = 6;
  ::google::protobuf::int32 real_layer() const;
  void set_real_layer(::google::protobuf::int32 value);

  // optional int32 model_id = 7;
  bool has_model_id() const;
  void clear_model_id();
  static const int kModelIdFieldNumber = 7;
  ::google::protobuf::int32 model_id() const;
  void set_model_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.DungeonContent)
 private:
  void set_has_now_layer();
  void clear_has_now_layer();
  void set_has_style();
  void clear_has_style();
  void set_has_monster_level();
  void clear_has_monster_level();
  void set_has_real_layer();
  void clear_has_real_layer();
  void set_has_model_id();
  void clear_has_model_id();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::DungeonElement > elements_;
  ::google::protobuf::RepeatedPtrField< ::sg::DungeonContent_PathBranch > path_choice_;
  ::google::protobuf::RepeatedPtrField< ::sg::Enemy > enemys_;
  ::google::protobuf::int32 now_layer_;
  ::google::protobuf::int32 style_;
  ::google::protobuf::int32 monster_level_;
  ::google::protobuf::int32 real_layer_;
  ::google::protobuf::int32 model_id_;
  friend struct ::protobuf_PVE_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserTeamData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.UserTeamData) */ {
 public:
  UserTeamData();
  virtual ~UserTeamData();

  UserTeamData(const UserTeamData& from);

  inline UserTeamData& operator=(const UserTeamData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserTeamData(UserTeamData&& from) noexcept
    : UserTeamData() {
    *this = ::std::move(from);
  }

  inline UserTeamData& operator=(UserTeamData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserTeamData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserTeamData* internal_default_instance() {
    return reinterpret_cast<const UserTeamData*>(
               &_UserTeamData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void UnsafeArenaSwap(UserTeamData* other);
  void Swap(UserTeamData* other);
  friend void swap(UserTeamData& a, UserTeamData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserTeamData* New() const final {
    return CreateMaybeMessage<UserTeamData>(NULL);
  }

  UserTeamData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserTeamData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserTeamData& from);
  void MergeFrom(const UserTeamData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserTeamData* other);
  protected:
  explicit UserTeamData(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sg.SailorInDungeon team = 2;
  int team_size() const;
  void clear_team();
  static const int kTeamFieldNumber = 2;
  ::sg::SailorInDungeon* mutable_team(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::SailorInDungeon >*
      mutable_team();
  const ::sg::SailorInDungeon& team(int index) const;
  ::sg::SailorInDungeon* add_team();
  const ::google::protobuf::RepeatedPtrField< ::sg::SailorInDungeon >&
      team() const;

  // repeated .sg.pb_pair_int_int talents = 3;
  int talents_size() const;
  void clear_talents();
  static const int kTalentsFieldNumber = 3;
  ::sg::pb_pair_int_int* mutable_talents(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int >*
      mutable_talents();
  const ::sg::pb_pair_int_int& talents(int index) const;
  ::sg::pb_pair_int_int* add_talents();
  const ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int >&
      talents() const;

  // required int32 user_level = 1;
  bool has_user_level() const;
  void clear_user_level();
  static const int kUserLevelFieldNumber = 1;
  ::google::protobuf::int32 user_level() const;
  void set_user_level(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.UserTeamData)
 private:
  void set_has_user_level();
  void clear_has_user_level();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::SailorInDungeon > team_;
  ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int > talents_;
  ::google::protobuf::int32 user_level_;
  friend struct ::protobuf_PVE_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserDungeonInformation_ElementCount : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.UserDungeonInformation.ElementCount) */ {
 public:
  UserDungeonInformation_ElementCount();
  virtual ~UserDungeonInformation_ElementCount();

  UserDungeonInformation_ElementCount(const UserDungeonInformation_ElementCount& from);

  inline UserDungeonInformation_ElementCount& operator=(const UserDungeonInformation_ElementCount& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserDungeonInformation_ElementCount(UserDungeonInformation_ElementCount&& from) noexcept
    : UserDungeonInformation_ElementCount() {
    *this = ::std::move(from);
  }

  inline UserDungeonInformation_ElementCount& operator=(UserDungeonInformation_ElementCount&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserDungeonInformation_ElementCount& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserDungeonInformation_ElementCount* internal_default_instance() {
    return reinterpret_cast<const UserDungeonInformation_ElementCount*>(
               &_UserDungeonInformation_ElementCount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void UnsafeArenaSwap(UserDungeonInformation_ElementCount* other);
  void Swap(UserDungeonInformation_ElementCount* other);
  friend void swap(UserDungeonInformation_ElementCount& a, UserDungeonInformation_ElementCount& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserDungeonInformation_ElementCount* New() const final {
    return CreateMaybeMessage<UserDungeonInformation_ElementCount>(NULL);
  }

  UserDungeonInformation_ElementCount* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserDungeonInformation_ElementCount>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserDungeonInformation_ElementCount& from);
  void MergeFrom(const UserDungeonInformation_ElementCount& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserDungeonInformation_ElementCount* other);
  protected:
  explicit UserDungeonInformation_ElementCount(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // required int32 typeid = 2;
  bool has_typeid_() const;
  void clear_typeid_();
  static const int kTypeidFieldNumber = 2;
  ::google::protobuf::int32 typeid_() const;
  void set_typeid_(::google::protobuf::int32 value);

  // required int32 num = 3;
  bool has_num() const;
  void clear_num();
  static const int kNumFieldNumber = 3;
  ::google::protobuf::int32 num() const;
  void set_num(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.UserDungeonInformation.ElementCount)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_typeid_();
  void clear_has_typeid_();
  void set_has_num();
  void clear_has_num();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 typeid__;
  ::google::protobuf::int32 num_;
  friend struct ::protobuf_PVE_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserDungeonInformation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.UserDungeonInformation) */ {
 public:
  UserDungeonInformation();
  virtual ~UserDungeonInformation();

  UserDungeonInformation(const UserDungeonInformation& from);

  inline UserDungeonInformation& operator=(const UserDungeonInformation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserDungeonInformation(UserDungeonInformation&& from) noexcept
    : UserDungeonInformation() {
    *this = ::std::move(from);
  }

  inline UserDungeonInformation& operator=(UserDungeonInformation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserDungeonInformation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserDungeonInformation* internal_default_instance() {
    return reinterpret_cast<const UserDungeonInformation*>(
               &_UserDungeonInformation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void UnsafeArenaSwap(UserDungeonInformation* other);
  void Swap(UserDungeonInformation* other);
  friend void swap(UserDungeonInformation& a, UserDungeonInformation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserDungeonInformation* New() const final {
    return CreateMaybeMessage<UserDungeonInformation>(NULL);
  }

  UserDungeonInformation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserDungeonInformation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserDungeonInformation& from);
  void MergeFrom(const UserDungeonInformation& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserDungeonInformation* other);
  protected:
  explicit UserDungeonInformation(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UserDungeonInformation_ElementCount ElementCount;

  // accessors -------------------------------------------------------

  // repeated .sg.pb_pair_int_int talents = 3;
  int talents_size() const;
  void clear_talents();
  static const int kTalentsFieldNumber = 3;
  ::sg::pb_pair_int_int* mutable_talents(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int >*
      mutable_talents();
  const ::sg::pb_pair_int_int& talents(int index) const;
  ::sg::pb_pair_int_int* add_talents();
  const ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int >&
      talents() const;

  // repeated .sg.pb_pair_int_int packages = 4;
  int packages_size() const;
  void clear_packages();
  static const int kPackagesFieldNumber = 4;
  ::sg::pb_pair_int_int* mutable_packages(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int >*
      mutable_packages();
  const ::sg::pb_pair_int_int& packages(int index) const;
  ::sg::pb_pair_int_int* add_packages();
  const ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int >&
      packages() const;

  // repeated int64 saved_npc = 5;
  int saved_npc_size() const;
  void clear_saved_npc();
  static const int kSavedNpcFieldNumber = 5;
  ::google::protobuf::int64 saved_npc(int index) const;
  void set_saved_npc(int index, ::google::protobuf::int64 value);
  void add_saved_npc(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      saved_npc() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_saved_npc();

  // repeated int64 saved_customers = 6;
  int saved_customers_size() const;
  void clear_saved_customers();
  static const int kSavedCustomersFieldNumber = 6;
  ::google::protobuf::int64 saved_customers(int index) const;
  void set_saved_customers(int index, ::google::protobuf::int64 value);
  void add_saved_customers(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      saved_customers() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_saved_customers();

  // repeated int64 triggered_event = 7;
  int triggered_event_size() const;
  void clear_triggered_event();
  static const int kTriggeredEventFieldNumber = 7;
  ::google::protobuf::int64 triggered_event(int index) const;
  void set_triggered_event(int index, ::google::protobuf::int64 value);
  void add_triggered_event(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      triggered_event() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_triggered_event();

  // repeated .sg.pb_pair_int_int secret_room_distribute = 9;
  int secret_room_distribute_size() const;
  void clear_secret_room_distribute();
  static const int kSecretRoomDistributeFieldNumber = 9;
  ::sg::pb_pair_int_int* mutable_secret_room_distribute(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int >*
      mutable_secret_room_distribute();
  const ::sg::pb_pair_int_int& secret_room_distribute(int index) const;
  ::sg::pb_pair_int_int* add_secret_room_distribute();
  const ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int >&
      secret_room_distribute() const;

  // repeated .sg.pb_pair_int_int layer_change = 10;
  int layer_change_size() const;
  void clear_layer_change();
  static const int kLayerChangeFieldNumber = 10;
  ::sg::pb_pair_int_int* mutable_layer_change(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int >*
      mutable_layer_change();
  const ::sg::pb_pair_int_int& layer_change(int index) const;
  ::sg::pb_pair_int_int* add_layer_change();
  const ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int >&
      layer_change() const;

  // repeated .sg.MonsterInDungeon friendly_monsters = 11;
  int friendly_monsters_size() const;
  void clear_friendly_monsters();
  static const int kFriendlyMonstersFieldNumber = 11;
  ::sg::MonsterInDungeon* mutable_friendly_monsters(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::MonsterInDungeon >*
      mutable_friendly_monsters();
  const ::sg::MonsterInDungeon& friendly_monsters(int index) const;
  ::sg::MonsterInDungeon* add_friendly_monsters();
  const ::google::protobuf::RepeatedPtrField< ::sg::MonsterInDungeon >&
      friendly_monsters() const;

  // repeated .sg.DungeonAltar altars = 12;
  int altars_size() const;
  void clear_altars();
  static const int kAltarsFieldNumber = 12;
  ::sg::DungeonAltar* mutable_altars(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::DungeonAltar >*
      mutable_altars();
  const ::sg::DungeonAltar& altars(int index) const;
  ::sg::DungeonAltar* add_altars();
  const ::google::protobuf::RepeatedPtrField< ::sg::DungeonAltar >&
      altars() const;

  // repeated .sg.UserDungeonInformation.ElementCount element_count = 13;
  int element_count_size() const;
  void clear_element_count();
  static const int kElementCountFieldNumber = 13;
  ::sg::UserDungeonInformation_ElementCount* mutable_element_count(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::UserDungeonInformation_ElementCount >*
      mutable_element_count();
  const ::sg::UserDungeonInformation_ElementCount& element_count(int index) const;
  ::sg::UserDungeonInformation_ElementCount* add_element_count();
  const ::google::protobuf::RepeatedPtrField< ::sg::UserDungeonInformation_ElementCount >&
      element_count() const;

  // optional int32 revive_times = 1;
  bool has_revive_times() const;
  void clear_revive_times();
  static const int kReviveTimesFieldNumber = 1;
  ::google::protobuf::int32 revive_times() const;
  void set_revive_times(::google::protobuf::int32 value);

  // optional int32 occupation = 8;
  bool has_occupation() const;
  void clear_occupation();
  static const int kOccupationFieldNumber = 8;
  ::google::protobuf::int32 occupation() const;
  void set_occupation(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.UserDungeonInformation)
 private:
  void set_has_revive_times();
  void clear_has_revive_times();
  void set_has_occupation();
  void clear_has_occupation();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int > talents_;
  ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int > packages_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > saved_npc_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > saved_customers_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > triggered_event_;
  ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int > secret_room_distribute_;
  ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int > layer_change_;
  ::google::protobuf::RepeatedPtrField< ::sg::MonsterInDungeon > friendly_monsters_;
  ::google::protobuf::RepeatedPtrField< ::sg::DungeonAltar > altars_;
  ::google::protobuf::RepeatedPtrField< ::sg::UserDungeonInformation_ElementCount > element_count_;
  ::google::protobuf::int32 revive_times_;
  ::google::protobuf::int32 occupation_;
  friend struct ::protobuf_PVE_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserDungeonOperation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.UserDungeonOperation) */ {
 public:
  UserDungeonOperation();
  virtual ~UserDungeonOperation();

  UserDungeonOperation(const UserDungeonOperation& from);

  inline UserDungeonOperation& operator=(const UserDungeonOperation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserDungeonOperation(UserDungeonOperation&& from) noexcept
    : UserDungeonOperation() {
    *this = ::std::move(from);
  }

  inline UserDungeonOperation& operator=(UserDungeonOperation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserDungeonOperation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserDungeonOperation* internal_default_instance() {
    return reinterpret_cast<const UserDungeonOperation*>(
               &_UserDungeonOperation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void UnsafeArenaSwap(UserDungeonOperation* other);
  void Swap(UserDungeonOperation* other);
  friend void swap(UserDungeonOperation& a, UserDungeonOperation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserDungeonOperation* New() const final {
    return CreateMaybeMessage<UserDungeonOperation>(NULL);
  }

  UserDungeonOperation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserDungeonOperation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserDungeonOperation& from);
  void MergeFrom(const UserDungeonOperation& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserDungeonOperation* other);
  protected:
  explicit UserDungeonOperation(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes data = 4;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 4;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_data();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_data(
      ::std::string* data);

  // required int32 operation_type = 1;
  bool has_operation_type() const;
  void clear_operation_type();
  static const int kOperationTypeFieldNumber = 1;
  ::google::protobuf::int32 operation_type() const;
  void set_operation_type(::google::protobuf::int32 value);

  // optional int32 target_element = 2;
  bool has_target_element() const;
  void clear_target_element();
  static const int kTargetElementFieldNumber = 2;
  ::google::protobuf::int32 target_element() const;
  void set_target_element(::google::protobuf::int32 value);

  // optional int32 operation_param = 3;
  bool has_operation_param() const;
  void clear_operation_param();
  static const int kOperationParamFieldNumber = 3;
  ::google::protobuf::int32 operation_param() const;
  void set_operation_param(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.UserDungeonOperation)
 private:
  void set_has_operation_type();
  void clear_has_operation_type();
  void set_has_target_element();
  void clear_has_target_element();
  void set_has_operation_param();
  void clear_has_operation_param();
  void set_has_data();
  void clear_has_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::int32 operation_type_;
  ::google::protobuf::int32 target_element_;
  ::google::protobuf::int32 operation_param_;
  friend struct ::protobuf_PVE_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DungeonEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.DungeonEvent) */ {
 public:
  DungeonEvent();
  virtual ~DungeonEvent();

  DungeonEvent(const DungeonEvent& from);

  inline DungeonEvent& operator=(const DungeonEvent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DungeonEvent(DungeonEvent&& from) noexcept
    : DungeonEvent() {
    *this = ::std::move(from);
  }

  inline DungeonEvent& operator=(DungeonEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const DungeonEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DungeonEvent* internal_default_instance() {
    return reinterpret_cast<const DungeonEvent*>(
               &_DungeonEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void UnsafeArenaSwap(DungeonEvent* other);
  void Swap(DungeonEvent* other);
  friend void swap(DungeonEvent& a, DungeonEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DungeonEvent* New() const final {
    return CreateMaybeMessage<DungeonEvent>(NULL);
  }

  DungeonEvent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DungeonEvent>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DungeonEvent& from);
  void MergeFrom(const DungeonEvent& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DungeonEvent* other);
  protected:
  explicit DungeonEvent(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // required int32 state = 2;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 2;
  ::google::protobuf::int32 state() const;
  void set_state(::google::protobuf::int32 value);

  // required int32 finish_value = 3;
  bool has_finish_value() const;
  void clear_finish_value();
  static const int kFinishValueFieldNumber = 3;
  ::google::protobuf::int32 finish_value() const;
  void set_finish_value(::google::protobuf::int32 value);

  // optional int32 require_value = 4;
  bool has_require_value() const;
  void clear_require_value();
  static const int kRequireValueFieldNumber = 4;
  ::google::protobuf::int32 require_value() const;
  void set_require_value(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.DungeonEvent)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_state();
  void clear_has_state();
  void set_has_finish_value();
  void clear_has_finish_value();
  void set_has_require_value();
  void clear_has_require_value();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 state_;
  ::google::protobuf::int32 finish_value_;
  ::google::protobuf::int32 require_value_;
  friend struct ::protobuf_PVE_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ShipData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.ShipData) */ {
 public:
  ShipData();
  virtual ~ShipData();

  ShipData(const ShipData& from);

  inline ShipData& operator=(const ShipData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ShipData(ShipData&& from) noexcept
    : ShipData() {
    *this = ::std::move(from);
  }

  inline ShipData& operator=(ShipData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const ShipData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ShipData* internal_default_instance() {
    return reinterpret_cast<const ShipData*>(
               &_ShipData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void UnsafeArenaSwap(ShipData* other);
  void Swap(ShipData* other);
  friend void swap(ShipData& a, ShipData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ShipData* New() const final {
    return CreateMaybeMessage<ShipData>(NULL);
  }

  ShipData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ShipData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ShipData& from);
  void MergeFrom(const ShipData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShipData* other);
  protected:
  explicit ShipData(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sg.Sailor sailors = 6;
  int sailors_size() const;
  void clear_sailors();
  static const int kSailorsFieldNumber = 6;
  ::sg::Sailor* mutable_sailors(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::Sailor >*
      mutable_sailors();
  const ::sg::Sailor& sailors(int index) const;
  ::sg::Sailor* add_sailors();
  const ::google::protobuf::RepeatedPtrField< ::sg::Sailor >&
      sailors() const;

  // required bytes userid = 1;
  bool has_userid() const;
  void clear_userid();
  static const int kUseridFieldNumber = 1;
  const ::std::string& userid() const;
  void set_userid(const ::std::string& value);
  #if LANG_CXX11
  void set_userid(::std::string&& value);
  #endif
  void set_userid(const char* value);
  void set_userid(const void* value, size_t size);
  ::std::string* mutable_userid();
  ::std::string* release_userid();
  void set_allocated_userid(::std::string* userid);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_userid();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_userid(
      ::std::string* userid);

  // optional bytes rooms = 3;
  bool has_rooms() const;
  void clear_rooms();
  static const int kRoomsFieldNumber = 3;
  const ::std::string& rooms() const;
  void set_rooms(const ::std::string& value);
  #if LANG_CXX11
  void set_rooms(::std::string&& value);
  #endif
  void set_rooms(const char* value);
  void set_rooms(const void* value, size_t size);
  ::std::string* mutable_rooms();
  ::std::string* release_rooms();
  void set_allocated_rooms(::std::string* rooms);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_rooms();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_rooms(
      ::std::string* rooms);

  // optional bytes ship_tiles = 4;
  bool has_ship_tiles() const;
  void clear_ship_tiles();
  static const int kShipTilesFieldNumber = 4;
  const ::std::string& ship_tiles() const;
  void set_ship_tiles(const ::std::string& value);
  #if LANG_CXX11
  void set_ship_tiles(::std::string&& value);
  #endif
  void set_ship_tiles(const char* value);
  void set_ship_tiles(const void* value, size_t size);
  ::std::string* mutable_ship_tiles();
  ::std::string* release_ship_tiles();
  void set_allocated_ship_tiles(::std::string* ship_tiles);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_ship_tiles();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_ship_tiles(
      ::std::string* ship_tiles);

  // required bytes facilitys = 5;
  bool has_facilitys() const;
  void clear_facilitys();
  static const int kFacilitysFieldNumber = 5;
  const ::std::string& facilitys() const;
  void set_facilitys(const ::std::string& value);
  #if LANG_CXX11
  void set_facilitys(::std::string&& value);
  #endif
  void set_facilitys(const char* value);
  void set_facilitys(const void* value, size_t size);
  ::std::string* mutable_facilitys();
  ::std::string* release_facilitys();
  void set_allocated_facilitys(::std::string* facilitys);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_facilitys();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_facilitys(
      ::std::string* facilitys);

  // required int32 ship_model = 2;
  bool has_ship_model() const;
  void clear_ship_model();
  static const int kShipModelFieldNumber = 2;
  ::google::protobuf::int32 ship_model() const;
  void set_ship_model(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.ShipData)
 private:
  void set_has_userid();
  void clear_has_userid();
  void set_has_ship_model();
  void clear_has_ship_model();
  void set_has_rooms();
  void clear_has_rooms();
  void set_has_ship_tiles();
  void clear_has_ship_tiles();
  void set_has_facilitys();
  void clear_has_facilitys();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::Sailor > sailors_;
  ::google::protobuf::internal::ArenaStringPtr userid_;
  ::google::protobuf::internal::ArenaStringPtr rooms_;
  ::google::protobuf::internal::ArenaStringPtr ship_tiles_;
  ::google::protobuf::internal::ArenaStringPtr facilitys_;
  ::google::protobuf::int32 ship_model_;
  friend struct ::protobuf_PVE_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PveFacility : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.PveFacility) */ {
 public:
  PveFacility();
  virtual ~PveFacility();

  PveFacility(const PveFacility& from);

  inline PveFacility& operator=(const PveFacility& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PveFacility(PveFacility&& from) noexcept
    : PveFacility() {
    *this = ::std::move(from);
  }

  inline PveFacility& operator=(PveFacility&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const PveFacility& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PveFacility* internal_default_instance() {
    return reinterpret_cast<const PveFacility*>(
               &_PveFacility_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void UnsafeArenaSwap(PveFacility* other);
  void Swap(PveFacility* other);
  friend void swap(PveFacility& a, PveFacility& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PveFacility* New() const final {
    return CreateMaybeMessage<PveFacility>(NULL);
  }

  PveFacility* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PveFacility>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PveFacility& from);
  void MergeFrom(const PveFacility& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PveFacility* other);
  protected:
  explicit PveFacility(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sg.Item contain = 5;
  int contain_size() const;
  void clear_contain();
  static const int kContainFieldNumber = 5;
  ::sg::Item* mutable_contain(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::Item >*
      mutable_contain();
  const ::sg::Item& contain(int index) const;
  ::sg::Item* add_contain();
  const ::google::protobuf::RepeatedPtrField< ::sg::Item >&
      contain() const;

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // required int32 typeid = 2;
  bool has_typeid_() const;
  void clear_typeid_();
  static const int kTypeidFieldNumber = 2;
  ::google::protobuf::int32 typeid_() const;
  void set_typeid_(::google::protobuf::int32 value);

  // optional int32 x = 3;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 3;
  ::google::protobuf::int32 x() const;
  void set_x(::google::protobuf::int32 value);

  // optional int32 y = 4;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 4;
  ::google::protobuf::int32 y() const;
  void set_y(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.PveFacility)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_typeid_();
  void clear_has_typeid_();
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::Item > contain_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 typeid__;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  friend struct ::protobuf_PVE_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PveMapData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.PveMapData) */ {
 public:
  PveMapData();
  virtual ~PveMapData();

  PveMapData(const PveMapData& from);

  inline PveMapData& operator=(const PveMapData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PveMapData(PveMapData&& from) noexcept
    : PveMapData() {
    *this = ::std::move(from);
  }

  inline PveMapData& operator=(PveMapData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const PveMapData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PveMapData* internal_default_instance() {
    return reinterpret_cast<const PveMapData*>(
               &_PveMapData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void UnsafeArenaSwap(PveMapData* other);
  void Swap(PveMapData* other);
  friend void swap(PveMapData& a, PveMapData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PveMapData* New() const final {
    return CreateMaybeMessage<PveMapData>(NULL);
  }

  PveMapData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PveMapData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PveMapData& from);
  void MergeFrom(const PveMapData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PveMapData* other);
  protected:
  explicit PveMapData(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sg.PveFacility facilitys = 7;
  int facilitys_size() const;
  void clear_facilitys();
  static const int kFacilitysFieldNumber = 7;
  ::sg::PveFacility* mutable_facilitys(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::PveFacility >*
      mutable_facilitys();
  const ::sg::PveFacility& facilitys(int index) const;
  ::sg::PveFacility* add_facilitys();
  const ::google::protobuf::RepeatedPtrField< ::sg::PveFacility >&
      facilitys() const;

  // optional bytes rooms = 5;
  bool has_rooms() const;
  void clear_rooms();
  static const int kRoomsFieldNumber = 5;
  const ::std::string& rooms() const;
  void set_rooms(const ::std::string& value);
  #if LANG_CXX11
  void set_rooms(::std::string&& value);
  #endif
  void set_rooms(const char* value);
  void set_rooms(const void* value, size_t size);
  ::std::string* mutable_rooms();
  ::std::string* release_rooms();
  void set_allocated_rooms(::std::string* rooms);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_rooms();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_rooms(
      ::std::string* rooms);

  // optional bytes map_tiles = 6;
  bool has_map_tiles() const;
  void clear_map_tiles();
  static const int kMapTilesFieldNumber = 6;
  const ::std::string& map_tiles() const;
  void set_map_tiles(const ::std::string& value);
  #if LANG_CXX11
  void set_map_tiles(::std::string&& value);
  #endif
  void set_map_tiles(const char* value);
  void set_map_tiles(const void* value, size_t size);
  ::std::string* mutable_map_tiles();
  ::std::string* release_map_tiles();
  void set_allocated_map_tiles(::std::string* map_tiles);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_map_tiles();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_map_tiles(
      ::std::string* map_tiles);

  // required int32 model_id = 2;
  bool has_model_id() const;
  void clear_model_id();
  static const int kModelIdFieldNumber = 2;
  ::google::protobuf::int32 model_id() const;
  void set_model_id(::google::protobuf::int32 value);

  // required int32 width = 3;
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 3;
  ::google::protobuf::int32 width() const;
  void set_width(::google::protobuf::int32 value);

  // required int32 height = 4;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 4;
  ::google::protobuf::int32 height() const;
  void set_height(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.PveMapData)
 private:
  void set_has_model_id();
  void clear_has_model_id();
  void set_has_width();
  void clear_has_width();
  void set_has_height();
  void clear_has_height();
  void set_has_rooms();
  void clear_has_rooms();
  void set_has_map_tiles();
  void clear_has_map_tiles();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::PveFacility > facilitys_;
  ::google::protobuf::internal::ArenaStringPtr rooms_;
  ::google::protobuf::internal::ArenaStringPtr map_tiles_;
  ::google::protobuf::int32 model_id_;
  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 height_;
  friend struct ::protobuf_PVE_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PvePlayerMapData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.PvePlayerMapData) */ {
 public:
  PvePlayerMapData();
  virtual ~PvePlayerMapData();

  PvePlayerMapData(const PvePlayerMapData& from);

  inline PvePlayerMapData& operator=(const PvePlayerMapData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PvePlayerMapData(PvePlayerMapData&& from) noexcept
    : PvePlayerMapData() {
    *this = ::std::move(from);
  }

  inline PvePlayerMapData& operator=(PvePlayerMapData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const PvePlayerMapData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PvePlayerMapData* internal_default_instance() {
    return reinterpret_cast<const PvePlayerMapData*>(
               &_PvePlayerMapData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void UnsafeArenaSwap(PvePlayerMapData* other);
  void Swap(PvePlayerMapData* other);
  friend void swap(PvePlayerMapData& a, PvePlayerMapData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PvePlayerMapData* New() const final {
    return CreateMaybeMessage<PvePlayerMapData>(NULL);
  }

  PvePlayerMapData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PvePlayerMapData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PvePlayerMapData& from);
  void MergeFrom(const PvePlayerMapData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PvePlayerMapData* other);
  protected:
  explicit PvePlayerMapData(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sg.PveFacility facilitys = 2;
  int facilitys_size() const;
  void clear_facilitys();
  static const int kFacilitysFieldNumber = 2;
  ::sg::PveFacility* mutable_facilitys(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::PveFacility >*
      mutable_facilitys();
  const ::sg::PveFacility& facilitys(int index) const;
  ::sg::PveFacility* add_facilitys();
  const ::google::protobuf::RepeatedPtrField< ::sg::PveFacility >&
      facilitys() const;

  // required .sg.ShipData shipdata = 1;
  bool has_shipdata() const;
  void clear_shipdata();
  static const int kShipdataFieldNumber = 1;
  private:
  const ::sg::ShipData& _internal_shipdata() const;
  public:
  const ::sg::ShipData& shipdata() const;
  ::sg::ShipData* release_shipdata();
  ::sg::ShipData* mutable_shipdata();
  void set_allocated_shipdata(::sg::ShipData* shipdata);
  void unsafe_arena_set_allocated_shipdata(
      ::sg::ShipData* shipdata);
  ::sg::ShipData* unsafe_arena_release_shipdata();

  // @@protoc_insertion_point(class_scope:sg.PvePlayerMapData)
 private:
  void set_has_shipdata();
  void clear_has_shipdata();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::PveFacility > facilitys_;
  ::sg::ShipData* shipdata_;
  friend struct ::protobuf_PVE_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PveDefenderData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.PveDefenderData) */ {
 public:
  PveDefenderData();
  virtual ~PveDefenderData();

  PveDefenderData(const PveDefenderData& from);

  inline PveDefenderData& operator=(const PveDefenderData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PveDefenderData(PveDefenderData&& from) noexcept
    : PveDefenderData() {
    *this = ::std::move(from);
  }

  inline PveDefenderData& operator=(PveDefenderData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const PveDefenderData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PveDefenderData* internal_default_instance() {
    return reinterpret_cast<const PveDefenderData*>(
               &_PveDefenderData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void UnsafeArenaSwap(PveDefenderData* other);
  void Swap(PveDefenderData* other);
  friend void swap(PveDefenderData& a, PveDefenderData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PveDefenderData* New() const final {
    return CreateMaybeMessage<PveDefenderData>(NULL);
  }

  PveDefenderData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PveDefenderData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PveDefenderData& from);
  void MergeFrom(const PveDefenderData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PveDefenderData* other);
  protected:
  explicit PveDefenderData(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sg.Sailor defend_team = 2;
  int defend_team_size() const;
  void clear_defend_team();
  static const int kDefendTeamFieldNumber = 2;
  ::sg::Sailor* mutable_defend_team(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::Sailor >*
      mutable_defend_team();
  const ::sg::Sailor& defend_team(int index) const;
  ::sg::Sailor* add_defend_team();
  const ::google::protobuf::RepeatedPtrField< ::sg::Sailor >&
      defend_team() const;

  // required bytes userid = 1;
  bool has_userid() const;
  void clear_userid();
  static const int kUseridFieldNumber = 1;
  const ::std::string& userid() const;
  void set_userid(const ::std::string& value);
  #if LANG_CXX11
  void set_userid(::std::string&& value);
  #endif
  void set_userid(const char* value);
  void set_userid(const void* value, size_t size);
  ::std::string* mutable_userid();
  ::std::string* release_userid();
  void set_allocated_userid(::std::string* userid);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_userid();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_userid(
      ::std::string* userid);

  // @@protoc_insertion_point(class_scope:sg.PveDefenderData)
 private:
  void set_has_userid();
  void clear_has_userid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::Sailor > defend_team_;
  ::google::protobuf::internal::ArenaStringPtr userid_;
  friend struct ::protobuf_PVE_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PVEBattleService_PVEBattleRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.PVEBattleService.PVEBattleRequest) */ {
 public:
  PVEBattleService_PVEBattleRequest();
  virtual ~PVEBattleService_PVEBattleRequest();

  PVEBattleService_PVEBattleRequest(const PVEBattleService_PVEBattleRequest& from);

  inline PVEBattleService_PVEBattleRequest& operator=(const PVEBattleService_PVEBattleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PVEBattleService_PVEBattleRequest(PVEBattleService_PVEBattleRequest&& from) noexcept
    : PVEBattleService_PVEBattleRequest() {
    *this = ::std::move(from);
  }

  inline PVEBattleService_PVEBattleRequest& operator=(PVEBattleService_PVEBattleRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const PVEBattleService_PVEBattleRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PVEBattleService_PVEBattleRequest* internal_default_instance() {
    return reinterpret_cast<const PVEBattleService_PVEBattleRequest*>(
               &_PVEBattleService_PVEBattleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void UnsafeArenaSwap(PVEBattleService_PVEBattleRequest* other);
  void Swap(PVEBattleService_PVEBattleRequest* other);
  friend void swap(PVEBattleService_PVEBattleRequest& a, PVEBattleService_PVEBattleRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PVEBattleService_PVEBattleRequest* New() const final {
    return CreateMaybeMessage<PVEBattleService_PVEBattleRequest>(NULL);
  }

  PVEBattleService_PVEBattleRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PVEBattleService_PVEBattleRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PVEBattleService_PVEBattleRequest& from);
  void MergeFrom(const PVEBattleService_PVEBattleRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PVEBattleService_PVEBattleRequest* other);
  protected:
  explicit PVEBattleService_PVEBattleRequest(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 used_sailor = 4;
  int used_sailor_size() const;
  void clear_used_sailor();
  static const int kUsedSailorFieldNumber = 4;
  ::google::protobuf::int32 used_sailor(int index) const;
  void set_used_sailor(int index, ::google::protobuf::int32 value);
  void add_used_sailor(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      used_sailor() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_used_sailor();

  // repeated .sg.UserDungeonOperation operation_list = 5;
  int operation_list_size() const;
  void clear_operation_list();
  static const int kOperationListFieldNumber = 5;
  ::sg::UserDungeonOperation* mutable_operation_list(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::UserDungeonOperation >*
      mutable_operation_list();
  const ::sg::UserDungeonOperation& operation_list(int index) const;
  ::sg::UserDungeonOperation* add_operation_list();
  const ::google::protobuf::RepeatedPtrField< ::sg::UserDungeonOperation >&
      operation_list() const;

  // repeated .sg.SailorInDungeon team_state = 6;
  int team_state_size() const;
  void clear_team_state();
  static const int kTeamStateFieldNumber = 6;
  ::sg::SailorInDungeon* mutable_team_state(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::SailorInDungeon >*
      mutable_team_state();
  const ::sg::SailorInDungeon& team_state(int index) const;
  ::sg::SailorInDungeon* add_team_state();
  const ::google::protobuf::RepeatedPtrField< ::sg::SailorInDungeon >&
      team_state() const;

  // repeated int32 destory_facilitys = 8;
  int destory_facilitys_size() const;
  void clear_destory_facilitys();
  static const int kDestoryFacilitysFieldNumber = 8;
  ::google::protobuf::int32 destory_facilitys(int index) const;
  void set_destory_facilitys(int index, ::google::protobuf::int32 value);
  void add_destory_facilitys(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      destory_facilitys() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_destory_facilitys();

  // repeated .sg.FightManual new_manual = 14;
  int new_manual_size() const;
  void clear_new_manual();
  static const int kNewManualFieldNumber = 14;
  ::sg::FightManual* mutable_new_manual(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::FightManual >*
      mutable_new_manual();
  const ::sg::FightManual& new_manual(int index) const;
  ::sg::FightManual* add_new_manual();
  const ::google::protobuf::RepeatedPtrField< ::sg::FightManual >&
      new_manual() const;

  // repeated .sg.MonsterInDungeon monsters = 16;
  int monsters_size() const;
  void clear_monsters();
  static const int kMonstersFieldNumber = 16;
  ::sg::MonsterInDungeon* mutable_monsters(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::MonsterInDungeon >*
      mutable_monsters();
  const ::sg::MonsterInDungeon& monsters(int index) const;
  ::sg::MonsterInDungeon* add_monsters();
  const ::google::protobuf::RepeatedPtrField< ::sg::MonsterInDungeon >&
      monsters() const;

  // repeated .sg.Enemy enemys = 17;
  int enemys_size() const;
  void clear_enemys();
  static const int kEnemysFieldNumber = 17;
  ::sg::Enemy* mutable_enemys(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::Enemy >*
      mutable_enemys();
  const ::sg::Enemy& enemys(int index) const;
  ::sg::Enemy* add_enemys();
  const ::google::protobuf::RepeatedPtrField< ::sg::Enemy >&
      enemys() const;

  // repeated .sg.DungeonAltar altars = 18;
  int altars_size() const;
  void clear_altars();
  static const int kAltarsFieldNumber = 18;
  ::sg::DungeonAltar* mutable_altars(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::DungeonAltar >*
      mutable_altars();
  const ::sg::DungeonAltar& altars(int index) const;
  ::sg::DungeonAltar* add_altars();
  const ::google::protobuf::RepeatedPtrField< ::sg::DungeonAltar >&
      altars() const;

  // repeated .sg.pb_pair_int_int take_items = 19;
  int take_items_size() const;
  void clear_take_items();
  static const int kTakeItemsFieldNumber = 19;
  ::sg::pb_pair_int_int* mutable_take_items(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int >*
      mutable_take_items();
  const ::sg::pb_pair_int_int& take_items(int index) const;
  ::sg::pb_pair_int_int* add_take_items();
  const ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int >&
      take_items() const;

  // optional uint64 target_id = 3;
  bool has_target_id() const;
  void clear_target_id();
  static const int kTargetIdFieldNumber = 3;
  ::google::protobuf::uint64 target_id() const;
  void set_target_id(::google::protobuf::uint64 value);

  // optional int32 battle_result = 7;
  bool has_battle_result() const;
  void clear_battle_result();
  static const int kBattleResultFieldNumber = 7;
  ::google::protobuf::int32 battle_result() const;
  void set_battle_result(::google::protobuf::int32 value);

  // optional int32 path_choice = 9;
  bool has_path_choice() const;
  void clear_path_choice();
  static const int kPathChoiceFieldNumber = 9;
  ::google::protobuf::int32 path_choice() const;
  void set_path_choice(::google::protobuf::int32 value);

  // optional int32 hunt_animal = 10;
  bool has_hunt_animal() const;
  void clear_hunt_animal();
  static const int kHuntAnimalFieldNumber = 10;
  ::google::protobuf::int32 hunt_animal() const;
  void set_hunt_animal(::google::protobuf::int32 value);

  // optional int32 enemy_typeid = 11;
  bool has_enemy_typeid() const;
  void clear_enemy_typeid();
  static const int kEnemyTypeidFieldNumber = 11;
  ::google::protobuf::int32 enemy_typeid() const;
  void set_enemy_typeid(::google::protobuf::int32 value);

  // optional int32 treasure_id = 12;
  bool has_treasure_id() const;
  void clear_treasure_id();
  static const int kTreasureIdFieldNumber = 12;
  ::google::protobuf::int32 treasure_id() const;
  void set_treasure_id(::google::protobuf::int32 value);

  // optional int32 pve_model_id = 13;
  bool has_pve_model_id() const;
  void clear_pve_model_id();
  static const int kPveModelIdFieldNumber = 13;
  ::google::protobuf::int32 pve_model_id() const;
  void set_pve_model_id(::google::protobuf::int32 value);

  // optional bool debug_tag = 15;
  bool has_debug_tag() const;
  void clear_debug_tag();
  static const int kDebugTagFieldNumber = 15;
  bool debug_tag() const;
  void set_debug_tag(bool value);

  // required .sg.PVEBattleService.PVE_CMD cmd = 1;
  bool has_cmd() const;
  void clear_cmd();
  static const int kCmdFieldNumber = 1;
  ::sg::PVEBattleService_PVE_CMD cmd() const;
  void set_cmd(::sg::PVEBattleService_PVE_CMD value);

  // @@protoc_insertion_point(class_scope:sg.PVEBattleService.PVEBattleRequest)
 private:
  void set_has_cmd();
  void clear_has_cmd();
  void set_has_target_id();
  void clear_has_target_id();
  void set_has_battle_result();
  void clear_has_battle_result();
  void set_has_path_choice();
  void clear_has_path_choice();
  void set_has_hunt_animal();
  void clear_has_hunt_animal();
  void set_has_enemy_typeid();
  void clear_has_enemy_typeid();
  void set_has_treasure_id();
  void clear_has_treasure_id();
  void set_has_pve_model_id();
  void clear_has_pve_model_id();
  void set_has_debug_tag();
  void clear_has_debug_tag();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > used_sailor_;
  ::google::protobuf::RepeatedPtrField< ::sg::UserDungeonOperation > operation_list_;
  ::google::protobuf::RepeatedPtrField< ::sg::SailorInDungeon > team_state_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > destory_facilitys_;
  ::google::protobuf::RepeatedPtrField< ::sg::FightManual > new_manual_;
  ::google::protobuf::RepeatedPtrField< ::sg::MonsterInDungeon > monsters_;
  ::google::protobuf::RepeatedPtrField< ::sg::Enemy > enemys_;
  ::google::protobuf::RepeatedPtrField< ::sg::DungeonAltar > altars_;
  ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int > take_items_;
  ::google::protobuf::uint64 target_id_;
  ::google::protobuf::int32 battle_result_;
  ::google::protobuf::int32 path_choice_;
  ::google::protobuf::int32 hunt_animal_;
  ::google::protobuf::int32 enemy_typeid_;
  ::google::protobuf::int32 treasure_id_;
  ::google::protobuf::int32 pve_model_id_;
  bool debug_tag_;
  int cmd_;
  friend struct ::protobuf_PVE_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PVEBattleService_PVEBattleResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.PVEBattleService.PVEBattleResponse) */ {
 public:
  PVEBattleService_PVEBattleResponse();
  virtual ~PVEBattleService_PVEBattleResponse();

  PVEBattleService_PVEBattleResponse(const PVEBattleService_PVEBattleResponse& from);

  inline PVEBattleService_PVEBattleResponse& operator=(const PVEBattleService_PVEBattleResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PVEBattleService_PVEBattleResponse(PVEBattleService_PVEBattleResponse&& from) noexcept
    : PVEBattleService_PVEBattleResponse() {
    *this = ::std::move(from);
  }

  inline PVEBattleService_PVEBattleResponse& operator=(PVEBattleService_PVEBattleResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const PVEBattleService_PVEBattleResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PVEBattleService_PVEBattleResponse* internal_default_instance() {
    return reinterpret_cast<const PVEBattleService_PVEBattleResponse*>(
               &_PVEBattleService_PVEBattleResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void UnsafeArenaSwap(PVEBattleService_PVEBattleResponse* other);
  void Swap(PVEBattleService_PVEBattleResponse* other);
  friend void swap(PVEBattleService_PVEBattleResponse& a, PVEBattleService_PVEBattleResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PVEBattleService_PVEBattleResponse* New() const final {
    return CreateMaybeMessage<PVEBattleService_PVEBattleResponse>(NULL);
  }

  PVEBattleService_PVEBattleResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PVEBattleService_PVEBattleResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PVEBattleService_PVEBattleResponse& from);
  void MergeFrom(const PVEBattleService_PVEBattleResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PVEBattleService_PVEBattleResponse* other);
  protected:
  explicit PVEBattleService_PVEBattleResponse(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sg.FightManual found_manual = 9;
  int found_manual_size() const;
  void clear_found_manual();
  static const int kFoundManualFieldNumber = 9;
  ::sg::FightManual* mutable_found_manual(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::FightManual >*
      mutable_found_manual();
  const ::sg::FightManual& found_manual(int index) const;
  ::sg::FightManual* add_found_manual();
  const ::google::protobuf::RepeatedPtrField< ::sg::FightManual >&
      found_manual() const;

  // repeated int64 saved_npc = 10;
  int saved_npc_size() const;
  void clear_saved_npc();
  static const int kSavedNpcFieldNumber = 10;
  ::google::protobuf::int64 saved_npc(int index) const;
  void set_saved_npc(int index, ::google::protobuf::int64 value);
  void add_saved_npc(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      saved_npc() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_saved_npc();

  // repeated int64 saved_customer = 11;
  int saved_customer_size() const;
  void clear_saved_customer();
  static const int kSavedCustomerFieldNumber = 11;
  ::google::protobuf::int64 saved_customer(int index) const;
  void set_saved_customer(int index, ::google::protobuf::int64 value);
  void add_saved_customer(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      saved_customer() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_saved_customer();

  // optional bytes map_data = 8;
  bool has_map_data() const;
  void clear_map_data();
  static const int kMapDataFieldNumber = 8;
  const ::std::string& map_data() const;
  void set_map_data(const ::std::string& value);
  #if LANG_CXX11
  void set_map_data(::std::string&& value);
  #endif
  void set_map_data(const char* value);
  void set_map_data(const void* value, size_t size);
  ::std::string* mutable_map_data();
  ::std::string* release_map_data();
  void set_allocated_map_data(::std::string* map_data);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_map_data();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_map_data(
      ::std::string* map_data);

  // optional .sg.DungeonContent content = 2;
  bool has_content() const;
  void clear_content();
  static const int kContentFieldNumber = 2;
  private:
  const ::sg::DungeonContent& _internal_content() const;
  public:
  const ::sg::DungeonContent& content() const;
  ::sg::DungeonContent* release_content();
  ::sg::DungeonContent* mutable_content();
  void set_allocated_content(::sg::DungeonContent* content);
  void unsafe_arena_set_allocated_content(
      ::sg::DungeonContent* content);
  ::sg::DungeonContent* unsafe_arena_release_content();

  // optional .sg.UserDungeonInformation user_info = 4;
  bool has_user_info() const;
  void clear_user_info();
  static const int kUserInfoFieldNumber = 4;
  private:
  const ::sg::UserDungeonInformation& _internal_user_info() const;
  public:
  const ::sg::UserDungeonInformation& user_info() const;
  ::sg::UserDungeonInformation* release_user_info();
  ::sg::UserDungeonInformation* mutable_user_info();
  void set_allocated_user_info(::sg::UserDungeonInformation* user_info);
  void unsafe_arena_set_allocated_user_info(
      ::sg::UserDungeonInformation* user_info);
  ::sg::UserDungeonInformation* unsafe_arena_release_user_info();

  // optional .sg.Reward reward = 5;
  bool has_reward() const;
  void clear_reward();
  static const int kRewardFieldNumber = 5;
  private:
  const ::sg::Reward& _internal_reward() const;
  public:
  const ::sg::Reward& reward() const;
  ::sg::Reward* release_reward();
  ::sg::Reward* mutable_reward();
  void set_allocated_reward(::sg::Reward* reward);
  void unsafe_arena_set_allocated_reward(
      ::sg::Reward* reward);
  ::sg::Reward* unsafe_arena_release_reward();

  // optional .sg.Reward lose = 12;
  bool has_lose() const;
  void clear_lose();
  static const int kLoseFieldNumber = 12;
  private:
  const ::sg::Reward& _internal_lose() const;
  public:
  const ::sg::Reward& lose() const;
  ::sg::Reward* release_lose();
  ::sg::Reward* mutable_lose();
  void set_allocated_lose(::sg::Reward* lose);
  void unsafe_arena_set_allocated_lose(
      ::sg::Reward* lose);
  ::sg::Reward* unsafe_arena_release_lose();

  // optional .sg.Reward finish_reward = 13;
  bool has_finish_reward() const;
  void clear_finish_reward();
  static const int kFinishRewardFieldNumber = 13;
  private:
  const ::sg::Reward& _internal_finish_reward() const;
  public:
  const ::sg::Reward& finish_reward() const;
  ::sg::Reward* release_finish_reward();
  ::sg::Reward* mutable_finish_reward();
  void set_allocated_finish_reward(::sg::Reward* finish_reward);
  void unsafe_arena_set_allocated_finish_reward(
      ::sg::Reward* finish_reward);
  ::sg::Reward* unsafe_arena_release_finish_reward();

  // optional .sg.UserTeamData user_team = 14;
  bool has_user_team() const;
  void clear_user_team();
  static const int kUserTeamFieldNumber = 14;
  private:
  const ::sg::UserTeamData& _internal_user_team() const;
  public:
  const ::sg::UserTeamData& user_team() const;
  ::sg::UserTeamData* release_user_team();
  ::sg::UserTeamData* mutable_user_team();
  void set_allocated_user_team(::sg::UserTeamData* user_team);
  void unsafe_arena_set_allocated_user_team(
      ::sg::UserTeamData* user_team);
  ::sg::UserTeamData* unsafe_arena_release_user_team();

  // required int32 result = 1;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::google::protobuf::int32 result() const;
  void set_result(::google::protobuf::int32 value);

  // optional int32 cost_viality = 3;
  bool has_cost_viality() const;
  void clear_cost_viality();
  static const int kCostVialityFieldNumber = 3;
  ::google::protobuf::int32 cost_viality() const;
  void set_cost_viality(::google::protobuf::int32 value);

  // optional int32 dungeon_id = 6;
  bool has_dungeon_id() const;
  void clear_dungeon_id();
  static const int kDungeonIdFieldNumber = 6;
  ::google::protobuf::int32 dungeon_id() const;
  void set_dungeon_id(::google::protobuf::int32 value);

  // optional int32 pve_map_type = 7;
  bool has_pve_map_type() const;
  void clear_pve_map_type();
  static const int kPveMapTypeFieldNumber = 7;
  ::google::protobuf::int32 pve_map_type() const;
  void set_pve_map_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.PVEBattleService.PVEBattleResponse)
 private:
  void set_has_result();
  void clear_has_result();
  void set_has_content();
  void clear_has_content();
  void set_has_cost_viality();
  void clear_has_cost_viality();
  void set_has_user_info();
  void clear_has_user_info();
  void set_has_reward();
  void clear_has_reward();
  void set_has_dungeon_id();
  void clear_has_dungeon_id();
  void set_has_pve_map_type();
  void clear_has_pve_map_type();
  void set_has_map_data();
  void clear_has_map_data();
  void set_has_lose();
  void clear_has_lose();
  void set_has_finish_reward();
  void clear_has_finish_reward();
  void set_has_user_team();
  void clear_has_user_team();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::FightManual > found_manual_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > saved_npc_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > saved_customer_;
  ::google::protobuf::internal::ArenaStringPtr map_data_;
  ::sg::DungeonContent* content_;
  ::sg::UserDungeonInformation* user_info_;
  ::sg::Reward* reward_;
  ::sg::Reward* lose_;
  ::sg::Reward* finish_reward_;
  ::sg::UserTeamData* user_team_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 cost_viality_;
  ::google::protobuf::int32 dungeon_id_;
  ::google::protobuf::int32 pve_map_type_;
  friend struct ::protobuf_PVE_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PVEBattleService : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.PVEBattleService) */ {
 public:
  PVEBattleService();
  virtual ~PVEBattleService();

  PVEBattleService(const PVEBattleService& from);

  inline PVEBattleService& operator=(const PVEBattleService& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PVEBattleService(PVEBattleService&& from) noexcept
    : PVEBattleService() {
    *this = ::std::move(from);
  }

  inline PVEBattleService& operator=(PVEBattleService&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const PVEBattleService& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PVEBattleService* internal_default_instance() {
    return reinterpret_cast<const PVEBattleService*>(
               &_PVEBattleService_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void UnsafeArenaSwap(PVEBattleService* other);
  void Swap(PVEBattleService* other);
  friend void swap(PVEBattleService& a, PVEBattleService& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PVEBattleService* New() const final {
    return CreateMaybeMessage<PVEBattleService>(NULL);
  }

  PVEBattleService* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PVEBattleService>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PVEBattleService& from);
  void MergeFrom(const PVEBattleService& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PVEBattleService* other);
  protected:
  explicit PVEBattleService(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PVEBattleService_PVEBattleRequest PVEBattleRequest;
  typedef PVEBattleService_PVEBattleResponse PVEBattleResponse;

  typedef PVEBattleService_PVE_CMD PVE_CMD;
  static const PVE_CMD START =
    PVEBattleService_PVE_CMD_START;
  static const PVE_CMD TO_NEXT =
    PVEBattleService_PVE_CMD_TO_NEXT;
  static const PVE_CMD OVER =
    PVEBattleService_PVE_CMD_OVER;
  static const PVE_CMD RESTORE =
    PVEBattleService_PVE_CMD_RESTORE;
  static const PVE_CMD ATTACK_ENTRY =
    PVEBattleService_PVE_CMD_ATTACK_ENTRY;
  static const PVE_CMD ATTACK_OVER =
    PVEBattleService_PVE_CMD_ATTACK_OVER;
  static const PVE_CMD CHECK_CAN_FIGHT =
    PVEBattleService_PVE_CMD_CHECK_CAN_FIGHT;
  static const PVE_CMD HUNT_START =
    PVEBattleService_PVE_CMD_HUNT_START;
  static const PVE_CMD HUNT_OVER =
    PVEBattleService_PVE_CMD_HUNT_OVER;
  static const PVE_CMD TREASURE_BATTLE_START =
    PVEBattleService_PVE_CMD_TREASURE_BATTLE_START;
  static const PVE_CMD TREASURE_BATTLE_OVER =
    PVEBattleService_PVE_CMD_TREASURE_BATTLE_OVER;
  static const PVE_CMD QUERY_FIGHT_MANUAL =
    PVEBattleService_PVE_CMD_QUERY_FIGHT_MANUAL;
  static const PVE_CMD REVIVE =
    PVEBattleService_PVE_CMD_REVIVE;
  static const PVE_CMD ATTACK_MODEL_START =
    PVEBattleService_PVE_CMD_ATTACK_MODEL_START;
  static const PVE_CMD ATTACK_MODEL_OVER =
    PVEBattleService_PVE_CMD_ATTACK_MODEL_OVER;
  static const PVE_CMD SHIP_EVENT_START =
    PVEBattleService_PVE_CMD_SHIP_EVENT_START;
  static const PVE_CMD SHIP_EVENT_OVER =
    PVEBattleService_PVE_CMD_SHIP_EVENT_OVER;
  static const PVE_CMD NAVIGATION_EVENT_START =
    PVEBattleService_PVE_CMD_NAVIGATION_EVENT_START;
  static const PVE_CMD NAVIGATION_EVENT_DOING =
    PVEBattleService_PVE_CMD_NAVIGATION_EVENT_DOING;
  static const PVE_CMD NAVIGATION_EVENT_OVER =
    PVEBattleService_PVE_CMD_NAVIGATION_EVENT_OVER;
  static const PVE_CMD MAELSTROM_EVENT_START =
    PVEBattleService_PVE_CMD_MAELSTROM_EVENT_START;
  static const PVE_CMD MAELSTROM_EVENT_DOING =
    PVEBattleService_PVE_CMD_MAELSTROM_EVENT_DOING;
  static const PVE_CMD MAELSTROM_EVENT_OVER =
    PVEBattleService_PVE_CMD_MAELSTROM_EVENT_OVER;
  static const PVE_CMD OPEN_CHEST =
    PVEBattleService_PVE_CMD_OPEN_CHEST;
  static const PVE_CMD INVADE_START =
    PVEBattleService_PVE_CMD_INVADE_START;
  static const PVE_CMD REVENGE_START =
    PVEBattleService_PVE_CMD_REVENGE_START;
  static inline bool PVE_CMD_IsValid(int value) {
    return PVEBattleService_PVE_CMD_IsValid(value);
  }
  static const PVE_CMD PVE_CMD_MIN =
    PVEBattleService_PVE_CMD_PVE_CMD_MIN;
  static const PVE_CMD PVE_CMD_MAX =
    PVEBattleService_PVE_CMD_PVE_CMD_MAX;
  static const int PVE_CMD_ARRAYSIZE =
    PVEBattleService_PVE_CMD_PVE_CMD_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PVE_CMD_descriptor() {
    return PVEBattleService_PVE_CMD_descriptor();
  }
  static inline const ::std::string& PVE_CMD_Name(PVE_CMD value) {
    return PVEBattleService_PVE_CMD_Name(value);
  }
  static inline bool PVE_CMD_Parse(const ::std::string& name,
      PVE_CMD* value) {
    return PVEBattleService_PVE_CMD_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .sg.PVEBattleService.PVEBattleRequest req = 1;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 1;
  private:
  const ::sg::PVEBattleService_PVEBattleRequest& _internal_req() const;
  public:
  const ::sg::PVEBattleService_PVEBattleRequest& req() const;
  ::sg::PVEBattleService_PVEBattleRequest* release_req();
  ::sg::PVEBattleService_PVEBattleRequest* mutable_req();
  void set_allocated_req(::sg::PVEBattleService_PVEBattleRequest* req);
  void unsafe_arena_set_allocated_req(
      ::sg::PVEBattleService_PVEBattleRequest* req);
  ::sg::PVEBattleService_PVEBattleRequest* unsafe_arena_release_req();

  // optional .sg.PVEBattleService.PVEBattleResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  private:
  const ::sg::PVEBattleService_PVEBattleResponse& _internal_resp() const;
  public:
  const ::sg::PVEBattleService_PVEBattleResponse& resp() const;
  ::sg::PVEBattleService_PVEBattleResponse* release_resp();
  ::sg::PVEBattleService_PVEBattleResponse* mutable_resp();
  void set_allocated_resp(::sg::PVEBattleService_PVEBattleResponse* resp);
  void unsafe_arena_set_allocated_resp(
      ::sg::PVEBattleService_PVEBattleResponse* resp);
  ::sg::PVEBattleService_PVEBattleResponse* unsafe_arena_release_resp();

  // @@protoc_insertion_point(class_scope:sg.PVEBattleService)
 private:
  void set_has_req();
  void clear_has_req();
  void set_has_resp();
  void clear_has_resp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::sg::PVEBattleService_PVEBattleRequest* req_;
  ::sg::PVEBattleService_PVEBattleResponse* resp_;
  friend struct ::protobuf_PVE_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DungeonInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.DungeonInfo) */ {
 public:
  DungeonInfo();
  virtual ~DungeonInfo();

  DungeonInfo(const DungeonInfo& from);

  inline DungeonInfo& operator=(const DungeonInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DungeonInfo(DungeonInfo&& from) noexcept
    : DungeonInfo() {
    *this = ::std::move(from);
  }

  inline DungeonInfo& operator=(DungeonInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const DungeonInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DungeonInfo* internal_default_instance() {
    return reinterpret_cast<const DungeonInfo*>(
               &_DungeonInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void UnsafeArenaSwap(DungeonInfo* other);
  void Swap(DungeonInfo* other);
  friend void swap(DungeonInfo& a, DungeonInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DungeonInfo* New() const final {
    return CreateMaybeMessage<DungeonInfo>(NULL);
  }

  DungeonInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DungeonInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DungeonInfo& from);
  void MergeFrom(const DungeonInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DungeonInfo* other);
  protected:
  explicit DungeonInfo(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 reward_received = 5;
  int reward_received_size() const;
  void clear_reward_received();
  static const int kRewardReceivedFieldNumber = 5;
  ::google::protobuf::int32 reward_received(int index) const;
  void set_reward_received(int index, ::google::protobuf::int32 value);
  void add_reward_received(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      reward_received() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_reward_received();

  // repeated int32 open_chest = 7;
  int open_chest_size() const;
  void clear_open_chest();
  static const int kOpenChestFieldNumber = 7;
  ::google::protobuf::int32 open_chest(int index) const;
  void set_open_chest(int index, ::google::protobuf::int32 value);
  void add_open_chest(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      open_chest() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_open_chest();

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // required int32 state = 2;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 2;
  ::google::protobuf::int32 state() const;
  void set_state(::google::protobuf::int32 value);

  // optional int32 clear_times = 3;
  bool has_clear_times() const;
  void clear_clear_times();
  static const int kClearTimesFieldNumber = 3;
  ::google::protobuf::int32 clear_times() const;
  void set_clear_times(::google::protobuf::int32 value);

  // optional int32 max_layer = 4;
  bool has_max_layer() const;
  void clear_max_layer();
  static const int kMaxLayerFieldNumber = 4;
  ::google::protobuf::int32 max_layer() const;
  void set_max_layer(::google::protobuf::int32 value);

  // optional int32 daily_times = 6;
  bool has_daily_times() const;
  void clear_daily_times();
  static const int kDailyTimesFieldNumber = 6;
  ::google::protobuf::int32 daily_times() const;
  void set_daily_times(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.DungeonInfo)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_state();
  void clear_has_state();
  void set_has_clear_times();
  void clear_has_clear_times();
  void set_has_max_layer();
  void clear_has_max_layer();
  void set_has_daily_times();
  void clear_has_daily_times();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > reward_received_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > open_chest_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 state_;
  ::google::protobuf::int32 clear_times_;
  ::google::protobuf::int32 max_layer_;
  ::google::protobuf::int32 daily_times_;
  friend struct ::protobuf_PVE_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserDungeonService_UserDungeonRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.UserDungeonService.UserDungeonRequest) */ {
 public:
  UserDungeonService_UserDungeonRequest();
  virtual ~UserDungeonService_UserDungeonRequest();

  UserDungeonService_UserDungeonRequest(const UserDungeonService_UserDungeonRequest& from);

  inline UserDungeonService_UserDungeonRequest& operator=(const UserDungeonService_UserDungeonRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserDungeonService_UserDungeonRequest(UserDungeonService_UserDungeonRequest&& from) noexcept
    : UserDungeonService_UserDungeonRequest() {
    *this = ::std::move(from);
  }

  inline UserDungeonService_UserDungeonRequest& operator=(UserDungeonService_UserDungeonRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserDungeonService_UserDungeonRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserDungeonService_UserDungeonRequest* internal_default_instance() {
    return reinterpret_cast<const UserDungeonService_UserDungeonRequest*>(
               &_UserDungeonService_UserDungeonRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void UnsafeArenaSwap(UserDungeonService_UserDungeonRequest* other);
  void Swap(UserDungeonService_UserDungeonRequest* other);
  friend void swap(UserDungeonService_UserDungeonRequest& a, UserDungeonService_UserDungeonRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserDungeonService_UserDungeonRequest* New() const final {
    return CreateMaybeMessage<UserDungeonService_UserDungeonRequest>(NULL);
  }

  UserDungeonService_UserDungeonRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserDungeonService_UserDungeonRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserDungeonService_UserDungeonRequest& from);
  void MergeFrom(const UserDungeonService_UserDungeonRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserDungeonService_UserDungeonRequest* other);
  protected:
  explicit UserDungeonService_UserDungeonRequest(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 dungeon_id = 2;
  bool has_dungeon_id() const;
  void clear_dungeon_id();
  static const int kDungeonIdFieldNumber = 2;
  ::google::protobuf::int32 dungeon_id() const;
  void set_dungeon_id(::google::protobuf::int32 value);

  // optional int32 event_id = 3;
  bool has_event_id() const;
  void clear_event_id();
  static const int kEventIdFieldNumber = 3;
  ::google::protobuf::int32 event_id() const;
  void set_event_id(::google::protobuf::int32 value);

  // optional int32 layer = 4;
  bool has_layer() const;
  void clear_layer();
  static const int kLayerFieldNumber = 4;
  ::google::protobuf::int32 layer() const;
  void set_layer(::google::protobuf::int32 value);

  // required .sg.UserDungeonService.DUNGEON_CMD cmd = 1;
  bool has_cmd() const;
  void clear_cmd();
  static const int kCmdFieldNumber = 1;
  ::sg::UserDungeonService_DUNGEON_CMD cmd() const;
  void set_cmd(::sg::UserDungeonService_DUNGEON_CMD value);

  // @@protoc_insertion_point(class_scope:sg.UserDungeonService.UserDungeonRequest)
 private:
  void set_has_cmd();
  void clear_has_cmd();
  void set_has_dungeon_id();
  void clear_has_dungeon_id();
  void set_has_event_id();
  void clear_has_event_id();
  void set_has_layer();
  void clear_has_layer();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 dungeon_id_;
  ::google::protobuf::int32 event_id_;
  ::google::protobuf::int32 layer_;
  int cmd_;
  friend struct ::protobuf_PVE_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserDungeonService_UserDungeonResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.UserDungeonService.UserDungeonResponse) */ {
 public:
  UserDungeonService_UserDungeonResponse();
  virtual ~UserDungeonService_UserDungeonResponse();

  UserDungeonService_UserDungeonResponse(const UserDungeonService_UserDungeonResponse& from);

  inline UserDungeonService_UserDungeonResponse& operator=(const UserDungeonService_UserDungeonResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserDungeonService_UserDungeonResponse(UserDungeonService_UserDungeonResponse&& from) noexcept
    : UserDungeonService_UserDungeonResponse() {
    *this = ::std::move(from);
  }

  inline UserDungeonService_UserDungeonResponse& operator=(UserDungeonService_UserDungeonResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserDungeonService_UserDungeonResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserDungeonService_UserDungeonResponse* internal_default_instance() {
    return reinterpret_cast<const UserDungeonService_UserDungeonResponse*>(
               &_UserDungeonService_UserDungeonResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  void UnsafeArenaSwap(UserDungeonService_UserDungeonResponse* other);
  void Swap(UserDungeonService_UserDungeonResponse* other);
  friend void swap(UserDungeonService_UserDungeonResponse& a, UserDungeonService_UserDungeonResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserDungeonService_UserDungeonResponse* New() const final {
    return CreateMaybeMessage<UserDungeonService_UserDungeonResponse>(NULL);
  }

  UserDungeonService_UserDungeonResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserDungeonService_UserDungeonResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserDungeonService_UserDungeonResponse& from);
  void MergeFrom(const UserDungeonService_UserDungeonResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserDungeonService_UserDungeonResponse* other);
  protected:
  explicit UserDungeonService_UserDungeonResponse(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sg.DungeonEvent events = 2;
  int events_size() const;
  void clear_events();
  static const int kEventsFieldNumber = 2;
  ::sg::DungeonEvent* mutable_events(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::DungeonEvent >*
      mutable_events();
  const ::sg::DungeonEvent& events(int index) const;
  ::sg::DungeonEvent* add_events();
  const ::google::protobuf::RepeatedPtrField< ::sg::DungeonEvent >&
      events() const;

  // repeated .sg.DungeonInfo dungeons = 3;
  int dungeons_size() const;
  void clear_dungeons();
  static const int kDungeonsFieldNumber = 3;
  ::sg::DungeonInfo* mutable_dungeons(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::DungeonInfo >*
      mutable_dungeons();
  const ::sg::DungeonInfo& dungeons(int index) const;
  ::sg::DungeonInfo* add_dungeons();
  const ::google::protobuf::RepeatedPtrField< ::sg::DungeonInfo >&
      dungeons() const;

  // repeated .sg.pb_pair_int_int saved_customer = 6;
  int saved_customer_size() const;
  void clear_saved_customer();
  static const int kSavedCustomerFieldNumber = 6;
  ::sg::pb_pair_int_int* mutable_saved_customer(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int >*
      mutable_saved_customer();
  const ::sg::pb_pair_int_int& saved_customer(int index) const;
  ::sg::pb_pair_int_int* add_saved_customer();
  const ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int >&
      saved_customer() const;

  // optional .sg.Reward reward = 4;
  bool has_reward() const;
  void clear_reward();
  static const int kRewardFieldNumber = 4;
  private:
  const ::sg::Reward& _internal_reward() const;
  public:
  const ::sg::Reward& reward() const;
  ::sg::Reward* release_reward();
  ::sg::Reward* mutable_reward();
  void set_allocated_reward(::sg::Reward* reward);
  void unsafe_arena_set_allocated_reward(
      ::sg::Reward* reward);
  ::sg::Reward* unsafe_arena_release_reward();

  // required int32 result = 1;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::google::protobuf::int32 result() const;
  void set_result(::google::protobuf::int32 value);

  // optional int32 cost_viality = 5;
  bool has_cost_viality() const;
  void clear_cost_viality();
  static const int kCostVialityFieldNumber = 5;
  ::google::protobuf::int32 cost_viality() const;
  void set_cost_viality(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.UserDungeonService.UserDungeonResponse)
 private:
  void set_has_result();
  void clear_has_result();
  void set_has_reward();
  void clear_has_reward();
  void set_has_cost_viality();
  void clear_has_cost_viality();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::DungeonEvent > events_;
  ::google::protobuf::RepeatedPtrField< ::sg::DungeonInfo > dungeons_;
  ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int > saved_customer_;
  ::sg::Reward* reward_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 cost_viality_;
  friend struct ::protobuf_PVE_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserDungeonService : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.UserDungeonService) */ {
 public:
  UserDungeonService();
  virtual ~UserDungeonService();

  UserDungeonService(const UserDungeonService& from);

  inline UserDungeonService& operator=(const UserDungeonService& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserDungeonService(UserDungeonService&& from) noexcept
    : UserDungeonService() {
    *this = ::std::move(from);
  }

  inline UserDungeonService& operator=(UserDungeonService&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserDungeonService& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserDungeonService* internal_default_instance() {
    return reinterpret_cast<const UserDungeonService*>(
               &_UserDungeonService_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  void UnsafeArenaSwap(UserDungeonService* other);
  void Swap(UserDungeonService* other);
  friend void swap(UserDungeonService& a, UserDungeonService& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserDungeonService* New() const final {
    return CreateMaybeMessage<UserDungeonService>(NULL);
  }

  UserDungeonService* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserDungeonService>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserDungeonService& from);
  void MergeFrom(const UserDungeonService& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserDungeonService* other);
  protected:
  explicit UserDungeonService(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UserDungeonService_UserDungeonRequest UserDungeonRequest;
  typedef UserDungeonService_UserDungeonResponse UserDungeonResponse;

  typedef UserDungeonService_DUNGEON_CMD DUNGEON_CMD;
  static const DUNGEON_CMD QUERY_EVENT =
    UserDungeonService_DUNGEON_CMD_QUERY_EVENT;
  static const DUNGEON_CMD QUERY_DUNGEON =
    UserDungeonService_DUNGEON_CMD_QUERY_DUNGEON;
  static const DUNGEON_CMD FAST_FINISH =
    UserDungeonService_DUNGEON_CMD_FAST_FINISH;
  static const DUNGEON_CMD GET_EVENT_REWARD =
    UserDungeonService_DUNGEON_CMD_GET_EVENT_REWARD;
  static const DUNGEON_CMD GET_FINAL_REWARD =
    UserDungeonService_DUNGEON_CMD_GET_FINAL_REWARD;
  static const DUNGEON_CMD UNLOCK_DUNGEON =
    UserDungeonService_DUNGEON_CMD_UNLOCK_DUNGEON;
  static const DUNGEON_CMD GET_LAYER_REWARD =
    UserDungeonService_DUNGEON_CMD_GET_LAYER_REWARD;
  static inline bool DUNGEON_CMD_IsValid(int value) {
    return UserDungeonService_DUNGEON_CMD_IsValid(value);
  }
  static const DUNGEON_CMD DUNGEON_CMD_MIN =
    UserDungeonService_DUNGEON_CMD_DUNGEON_CMD_MIN;
  static const DUNGEON_CMD DUNGEON_CMD_MAX =
    UserDungeonService_DUNGEON_CMD_DUNGEON_CMD_MAX;
  static const int DUNGEON_CMD_ARRAYSIZE =
    UserDungeonService_DUNGEON_CMD_DUNGEON_CMD_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DUNGEON_CMD_descriptor() {
    return UserDungeonService_DUNGEON_CMD_descriptor();
  }
  static inline const ::std::string& DUNGEON_CMD_Name(DUNGEON_CMD value) {
    return UserDungeonService_DUNGEON_CMD_Name(value);
  }
  static inline bool DUNGEON_CMD_Parse(const ::std::string& name,
      DUNGEON_CMD* value) {
    return UserDungeonService_DUNGEON_CMD_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .sg.UserDungeonService.UserDungeonRequest req = 1;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 1;
  private:
  const ::sg::UserDungeonService_UserDungeonRequest& _internal_req() const;
  public:
  const ::sg::UserDungeonService_UserDungeonRequest& req() const;
  ::sg::UserDungeonService_UserDungeonRequest* release_req();
  ::sg::UserDungeonService_UserDungeonRequest* mutable_req();
  void set_allocated_req(::sg::UserDungeonService_UserDungeonRequest* req);
  void unsafe_arena_set_allocated_req(
      ::sg::UserDungeonService_UserDungeonRequest* req);
  ::sg::UserDungeonService_UserDungeonRequest* unsafe_arena_release_req();

  // optional .sg.UserDungeonService.UserDungeonResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  private:
  const ::sg::UserDungeonService_UserDungeonResponse& _internal_resp() const;
  public:
  const ::sg::UserDungeonService_UserDungeonResponse& resp() const;
  ::sg::UserDungeonService_UserDungeonResponse* release_resp();
  ::sg::UserDungeonService_UserDungeonResponse* mutable_resp();
  void set_allocated_resp(::sg::UserDungeonService_UserDungeonResponse* resp);
  void unsafe_arena_set_allocated_resp(
      ::sg::UserDungeonService_UserDungeonResponse* resp);
  ::sg::UserDungeonService_UserDungeonResponse* unsafe_arena_release_resp();

  // @@protoc_insertion_point(class_scope:sg.UserDungeonService)
 private:
  void set_has_req();
  void clear_has_req();
  void set_has_resp();
  void clear_has_resp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::sg::UserDungeonService_UserDungeonRequest* req_;
  ::sg::UserDungeonService_UserDungeonResponse* resp_;
  friend struct ::protobuf_PVE_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SailorInDungeon

// required int32 id = 1;
inline bool SailorInDungeon::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SailorInDungeon::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SailorInDungeon::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SailorInDungeon::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 SailorInDungeon::id() const {
  // @@protoc_insertion_point(field_get:sg.SailorInDungeon.id)
  return id_;
}
inline void SailorInDungeon::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:sg.SailorInDungeon.id)
}

// required int32 typeid = 2;
inline bool SailorInDungeon::has_typeid_() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SailorInDungeon::set_has_typeid_() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SailorInDungeon::clear_has_typeid_() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SailorInDungeon::clear_typeid_() {
  typeid__ = 0;
  clear_has_typeid_();
}
inline ::google::protobuf::int32 SailorInDungeon::typeid_() const {
  // @@protoc_insertion_point(field_get:sg.SailorInDungeon.typeid)
  return typeid__;
}
inline void SailorInDungeon::set_typeid_(::google::protobuf::int32 value) {
  set_has_typeid_();
  typeid__ = value;
  // @@protoc_insertion_point(field_set:sg.SailorInDungeon.typeid)
}

// required int32 state = 3;
inline bool SailorInDungeon::has_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SailorInDungeon::set_has_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SailorInDungeon::clear_has_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SailorInDungeon::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 SailorInDungeon::state() const {
  // @@protoc_insertion_point(field_get:sg.SailorInDungeon.state)
  return state_;
}
inline void SailorInDungeon::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:sg.SailorInDungeon.state)
}

// required int32 index = 4;
inline bool SailorInDungeon::has_index() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SailorInDungeon::set_has_index() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SailorInDungeon::clear_has_index() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SailorInDungeon::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 SailorInDungeon::index() const {
  // @@protoc_insertion_point(field_get:sg.SailorInDungeon.index)
  return index_;
}
inline void SailorInDungeon::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:sg.SailorInDungeon.index)
}

// required int32 level = 5;
inline bool SailorInDungeon::has_level() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SailorInDungeon::set_has_level() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SailorInDungeon::clear_has_level() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SailorInDungeon::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 SailorInDungeon::level() const {
  // @@protoc_insertion_point(field_get:sg.SailorInDungeon.level)
  return level_;
}
inline void SailorInDungeon::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:sg.SailorInDungeon.level)
}

// required int32 star = 6;
inline bool SailorInDungeon::has_star() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SailorInDungeon::set_has_star() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SailorInDungeon::clear_has_star() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SailorInDungeon::clear_star() {
  star_ = 0;
  clear_has_star();
}
inline ::google::protobuf::int32 SailorInDungeon::star() const {
  // @@protoc_insertion_point(field_get:sg.SailorInDungeon.star)
  return star_;
}
inline void SailorInDungeon::set_star(::google::protobuf::int32 value) {
  set_has_star();
  star_ = value;
  // @@protoc_insertion_point(field_set:sg.SailorInDungeon.star)
}

// repeated .sg.pb_pair_int_float attribute = 7;
inline int SailorInDungeon::attribute_size() const {
  return attribute_.size();
}
inline ::sg::pb_pair_int_float* SailorInDungeon::mutable_attribute(int index) {
  // @@protoc_insertion_point(field_mutable:sg.SailorInDungeon.attribute)
  return attribute_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_float >*
SailorInDungeon::mutable_attribute() {
  // @@protoc_insertion_point(field_mutable_list:sg.SailorInDungeon.attribute)
  return &attribute_;
}
inline const ::sg::pb_pair_int_float& SailorInDungeon::attribute(int index) const {
  // @@protoc_insertion_point(field_get:sg.SailorInDungeon.attribute)
  return attribute_.Get(index);
}
inline ::sg::pb_pair_int_float* SailorInDungeon::add_attribute() {
  // @@protoc_insertion_point(field_add:sg.SailorInDungeon.attribute)
  return attribute_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_float >&
SailorInDungeon::attribute() const {
  // @@protoc_insertion_point(field_list:sg.SailorInDungeon.attribute)
  return attribute_;
}

// repeated .sg.pb_pair_int_int buff = 8;
inline int SailorInDungeon::buff_size() const {
  return buff_.size();
}
inline ::sg::pb_pair_int_int* SailorInDungeon::mutable_buff(int index) {
  // @@protoc_insertion_point(field_mutable:sg.SailorInDungeon.buff)
  return buff_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int >*
SailorInDungeon::mutable_buff() {
  // @@protoc_insertion_point(field_mutable_list:sg.SailorInDungeon.buff)
  return &buff_;
}
inline const ::sg::pb_pair_int_int& SailorInDungeon::buff(int index) const {
  // @@protoc_insertion_point(field_get:sg.SailorInDungeon.buff)
  return buff_.Get(index);
}
inline ::sg::pb_pair_int_int* SailorInDungeon::add_buff() {
  // @@protoc_insertion_point(field_add:sg.SailorInDungeon.buff)
  return buff_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int >&
SailorInDungeon::buff() const {
  // @@protoc_insertion_point(field_list:sg.SailorInDungeon.buff)
  return buff_;
}

// repeated .sg.pb_pair_int_float fight_attribute = 9;
inline int SailorInDungeon::fight_attribute_size() const {
  return fight_attribute_.size();
}
inline ::sg::pb_pair_int_float* SailorInDungeon::mutable_fight_attribute(int index) {
  // @@protoc_insertion_point(field_mutable:sg.SailorInDungeon.fight_attribute)
  return fight_attribute_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_float >*
SailorInDungeon::mutable_fight_attribute() {
  // @@protoc_insertion_point(field_mutable_list:sg.SailorInDungeon.fight_attribute)
  return &fight_attribute_;
}
inline const ::sg::pb_pair_int_float& SailorInDungeon::fight_attribute(int index) const {
  // @@protoc_insertion_point(field_get:sg.SailorInDungeon.fight_attribute)
  return fight_attribute_.Get(index);
}
inline ::sg::pb_pair_int_float* SailorInDungeon::add_fight_attribute() {
  // @@protoc_insertion_point(field_add:sg.SailorInDungeon.fight_attribute)
  return fight_attribute_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_float >&
SailorInDungeon::fight_attribute() const {
  // @@protoc_insertion_point(field_list:sg.SailorInDungeon.fight_attribute)
  return fight_attribute_;
}

// repeated .sg.pb_pair_string_int special_attribute = 10;
inline int SailorInDungeon::special_attribute_size() const {
  return special_attribute_.size();
}
inline ::sg::pb_pair_string_int* SailorInDungeon::mutable_special_attribute(int index) {
  // @@protoc_insertion_point(field_mutable:sg.SailorInDungeon.special_attribute)
  return special_attribute_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_string_int >*
SailorInDungeon::mutable_special_attribute() {
  // @@protoc_insertion_point(field_mutable_list:sg.SailorInDungeon.special_attribute)
  return &special_attribute_;
}
inline const ::sg::pb_pair_string_int& SailorInDungeon::special_attribute(int index) const {
  // @@protoc_insertion_point(field_get:sg.SailorInDungeon.special_attribute)
  return special_attribute_.Get(index);
}
inline ::sg::pb_pair_string_int* SailorInDungeon::add_special_attribute() {
  // @@protoc_insertion_point(field_add:sg.SailorInDungeon.special_attribute)
  return special_attribute_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_string_int >&
SailorInDungeon::special_attribute() const {
  // @@protoc_insertion_point(field_list:sg.SailorInDungeon.special_attribute)
  return special_attribute_;
}

// repeated .sg.pb_pair_int64_int skill = 11;
inline int SailorInDungeon::skill_size() const {
  return skill_.size();
}
inline ::sg::pb_pair_int64_int* SailorInDungeon::mutable_skill(int index) {
  // @@protoc_insertion_point(field_mutable:sg.SailorInDungeon.skill)
  return skill_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int64_int >*
SailorInDungeon::mutable_skill() {
  // @@protoc_insertion_point(field_mutable_list:sg.SailorInDungeon.skill)
  return &skill_;
}
inline const ::sg::pb_pair_int64_int& SailorInDungeon::skill(int index) const {
  // @@protoc_insertion_point(field_get:sg.SailorInDungeon.skill)
  return skill_.Get(index);
}
inline ::sg::pb_pair_int64_int* SailorInDungeon::add_skill() {
  // @@protoc_insertion_point(field_add:sg.SailorInDungeon.skill)
  return skill_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int64_int >&
SailorInDungeon::skill() const {
  // @@protoc_insertion_point(field_list:sg.SailorInDungeon.skill)
  return skill_;
}

// optional .sg.SailorTalent talent = 12;
inline bool SailorInDungeon::has_talent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SailorInDungeon::set_has_talent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SailorInDungeon::clear_has_talent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::sg::SailorTalent& SailorInDungeon::_internal_talent() const {
  return *talent_;
}
inline const ::sg::SailorTalent& SailorInDungeon::talent() const {
  const ::sg::SailorTalent* p = talent_;
  // @@protoc_insertion_point(field_get:sg.SailorInDungeon.talent)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::SailorTalent*>(
      &::sg::_SailorTalent_default_instance_);
}
inline ::sg::SailorTalent* SailorInDungeon::release_talent() {
  // @@protoc_insertion_point(field_release:sg.SailorInDungeon.talent)
  clear_has_talent();
  ::sg::SailorTalent* temp = talent_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  talent_ = NULL;
  return temp;
}
inline ::sg::SailorTalent* SailorInDungeon::unsafe_arena_release_talent() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.SailorInDungeon.talent)
  clear_has_talent();
  ::sg::SailorTalent* temp = talent_;
  talent_ = NULL;
  return temp;
}
inline ::sg::SailorTalent* SailorInDungeon::mutable_talent() {
  set_has_talent();
  if (talent_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::SailorTalent>(GetArenaNoVirtual());
    talent_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.SailorInDungeon.talent)
  return talent_;
}
inline void SailorInDungeon::set_allocated_talent(::sg::SailorTalent* talent) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(talent_);
  }
  if (talent) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(talent)->GetArena();
    if (message_arena != submessage_arena) {
      talent = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, talent, submessage_arena);
    }
    set_has_talent();
  } else {
    clear_has_talent();
  }
  talent_ = talent;
  // @@protoc_insertion_point(field_set_allocated:sg.SailorInDungeon.talent)
}

// optional float hp_remain = 13;
inline bool SailorInDungeon::has_hp_remain() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SailorInDungeon::set_has_hp_remain() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SailorInDungeon::clear_has_hp_remain() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SailorInDungeon::clear_hp_remain() {
  hp_remain_ = 0;
  clear_has_hp_remain();
}
inline float SailorInDungeon::hp_remain() const {
  // @@protoc_insertion_point(field_get:sg.SailorInDungeon.hp_remain)
  return hp_remain_;
}
inline void SailorInDungeon::set_hp_remain(float value) {
  set_has_hp_remain();
  hp_remain_ = value;
  // @@protoc_insertion_point(field_set:sg.SailorInDungeon.hp_remain)
}

// optional int32 place = 14;
inline bool SailorInDungeon::has_place() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SailorInDungeon::set_has_place() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SailorInDungeon::clear_has_place() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SailorInDungeon::clear_place() {
  place_ = 0;
  clear_has_place();
}
inline ::google::protobuf::int32 SailorInDungeon::place() const {
  // @@protoc_insertion_point(field_get:sg.SailorInDungeon.place)
  return place_;
}
inline void SailorInDungeon::set_place(::google::protobuf::int32 value) {
  set_has_place();
  place_ = value;
  // @@protoc_insertion_point(field_set:sg.SailorInDungeon.place)
}

// optional int32 hunger = 15;
inline bool SailorInDungeon::has_hunger() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SailorInDungeon::set_has_hunger() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SailorInDungeon::clear_has_hunger() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SailorInDungeon::clear_hunger() {
  hunger_ = 0;
  clear_has_hunger();
}
inline ::google::protobuf::int32 SailorInDungeon::hunger() const {
  // @@protoc_insertion_point(field_get:sg.SailorInDungeon.hunger)
  return hunger_;
}
inline void SailorInDungeon::set_hunger(::google::protobuf::int32 value) {
  set_has_hunger();
  hunger_ = value;
  // @@protoc_insertion_point(field_set:sg.SailorInDungeon.hunger)
}

// -------------------------------------------------------------------

// MonsterInDungeon

// required int32 id = 1;
inline bool MonsterInDungeon::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MonsterInDungeon::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MonsterInDungeon::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MonsterInDungeon::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 MonsterInDungeon::id() const {
  // @@protoc_insertion_point(field_get:sg.MonsterInDungeon.id)
  return id_;
}
inline void MonsterInDungeon::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:sg.MonsterInDungeon.id)
}

// required int32 typeid = 2;
inline bool MonsterInDungeon::has_typeid_() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MonsterInDungeon::set_has_typeid_() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MonsterInDungeon::clear_has_typeid_() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MonsterInDungeon::clear_typeid_() {
  typeid__ = 0;
  clear_has_typeid_();
}
inline ::google::protobuf::int32 MonsterInDungeon::typeid_() const {
  // @@protoc_insertion_point(field_get:sg.MonsterInDungeon.typeid)
  return typeid__;
}
inline void MonsterInDungeon::set_typeid_(::google::protobuf::int32 value) {
  set_has_typeid_();
  typeid__ = value;
  // @@protoc_insertion_point(field_set:sg.MonsterInDungeon.typeid)
}

// required int32 state = 3;
inline bool MonsterInDungeon::has_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MonsterInDungeon::set_has_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MonsterInDungeon::clear_has_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MonsterInDungeon::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 MonsterInDungeon::state() const {
  // @@protoc_insertion_point(field_get:sg.MonsterInDungeon.state)
  return state_;
}
inline void MonsterInDungeon::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:sg.MonsterInDungeon.state)
}

// required int32 level = 4;
inline bool MonsterInDungeon::has_level() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MonsterInDungeon::set_has_level() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MonsterInDungeon::clear_has_level() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MonsterInDungeon::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 MonsterInDungeon::level() const {
  // @@protoc_insertion_point(field_get:sg.MonsterInDungeon.level)
  return level_;
}
inline void MonsterInDungeon::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:sg.MonsterInDungeon.level)
}

// repeated .sg.pb_pair_int_float attribute = 7;
inline int MonsterInDungeon::attribute_size() const {
  return attribute_.size();
}
inline ::sg::pb_pair_int_float* MonsterInDungeon::mutable_attribute(int index) {
  // @@protoc_insertion_point(field_mutable:sg.MonsterInDungeon.attribute)
  return attribute_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_float >*
MonsterInDungeon::mutable_attribute() {
  // @@protoc_insertion_point(field_mutable_list:sg.MonsterInDungeon.attribute)
  return &attribute_;
}
inline const ::sg::pb_pair_int_float& MonsterInDungeon::attribute(int index) const {
  // @@protoc_insertion_point(field_get:sg.MonsterInDungeon.attribute)
  return attribute_.Get(index);
}
inline ::sg::pb_pair_int_float* MonsterInDungeon::add_attribute() {
  // @@protoc_insertion_point(field_add:sg.MonsterInDungeon.attribute)
  return attribute_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_float >&
MonsterInDungeon::attribute() const {
  // @@protoc_insertion_point(field_list:sg.MonsterInDungeon.attribute)
  return attribute_;
}

// repeated .sg.pb_pair_int_int buff = 8;
inline int MonsterInDungeon::buff_size() const {
  return buff_.size();
}
inline ::sg::pb_pair_int_int* MonsterInDungeon::mutable_buff(int index) {
  // @@protoc_insertion_point(field_mutable:sg.MonsterInDungeon.buff)
  return buff_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int >*
MonsterInDungeon::mutable_buff() {
  // @@protoc_insertion_point(field_mutable_list:sg.MonsterInDungeon.buff)
  return &buff_;
}
inline const ::sg::pb_pair_int_int& MonsterInDungeon::buff(int index) const {
  // @@protoc_insertion_point(field_get:sg.MonsterInDungeon.buff)
  return buff_.Get(index);
}
inline ::sg::pb_pair_int_int* MonsterInDungeon::add_buff() {
  // @@protoc_insertion_point(field_add:sg.MonsterInDungeon.buff)
  return buff_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int >&
MonsterInDungeon::buff() const {
  // @@protoc_insertion_point(field_list:sg.MonsterInDungeon.buff)
  return buff_;
}

// repeated .sg.pb_pair_int64_int skill = 11;
inline int MonsterInDungeon::skill_size() const {
  return skill_.size();
}
inline ::sg::pb_pair_int64_int* MonsterInDungeon::mutable_skill(int index) {
  // @@protoc_insertion_point(field_mutable:sg.MonsterInDungeon.skill)
  return skill_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int64_int >*
MonsterInDungeon::mutable_skill() {
  // @@protoc_insertion_point(field_mutable_list:sg.MonsterInDungeon.skill)
  return &skill_;
}
inline const ::sg::pb_pair_int64_int& MonsterInDungeon::skill(int index) const {
  // @@protoc_insertion_point(field_get:sg.MonsterInDungeon.skill)
  return skill_.Get(index);
}
inline ::sg::pb_pair_int64_int* MonsterInDungeon::add_skill() {
  // @@protoc_insertion_point(field_add:sg.MonsterInDungeon.skill)
  return skill_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int64_int >&
MonsterInDungeon::skill() const {
  // @@protoc_insertion_point(field_list:sg.MonsterInDungeon.skill)
  return skill_;
}

// optional float hp_remain = 13;
inline bool MonsterInDungeon::has_hp_remain() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MonsterInDungeon::set_has_hp_remain() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MonsterInDungeon::clear_has_hp_remain() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MonsterInDungeon::clear_hp_remain() {
  hp_remain_ = 0;
  clear_has_hp_remain();
}
inline float MonsterInDungeon::hp_remain() const {
  // @@protoc_insertion_point(field_get:sg.MonsterInDungeon.hp_remain)
  return hp_remain_;
}
inline void MonsterInDungeon::set_hp_remain(float value) {
  set_has_hp_remain();
  hp_remain_ = value;
  // @@protoc_insertion_point(field_set:sg.MonsterInDungeon.hp_remain)
}

// -------------------------------------------------------------------

// Enemy

// required int32 id = 1;
inline bool Enemy::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Enemy::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Enemy::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Enemy::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Enemy::id() const {
  // @@protoc_insertion_point(field_get:sg.Enemy.id)
  return id_;
}
inline void Enemy::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:sg.Enemy.id)
}

// required int32 type = 2;
inline bool Enemy::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Enemy::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Enemy::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Enemy::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 Enemy::type() const {
  // @@protoc_insertion_point(field_get:sg.Enemy.type)
  return type_;
}
inline void Enemy::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:sg.Enemy.type)
}

// optional int32 seat = 3;
inline bool Enemy::has_seat() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Enemy::set_has_seat() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Enemy::clear_has_seat() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Enemy::clear_seat() {
  seat_ = 0;
  clear_has_seat();
}
inline ::google::protobuf::int32 Enemy::seat() const {
  // @@protoc_insertion_point(field_get:sg.Enemy.seat)
  return seat_;
}
inline void Enemy::set_seat(::google::protobuf::int32 value) {
  set_has_seat();
  seat_ = value;
  // @@protoc_insertion_point(field_set:sg.Enemy.seat)
}

// optional .sg.SailorInDungeon sailor_data = 4;
inline bool Enemy::has_sailor_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Enemy::set_has_sailor_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Enemy::clear_has_sailor_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Enemy::clear_sailor_data() {
  if (sailor_data_ != NULL) sailor_data_->Clear();
  clear_has_sailor_data();
}
inline const ::sg::SailorInDungeon& Enemy::_internal_sailor_data() const {
  return *sailor_data_;
}
inline const ::sg::SailorInDungeon& Enemy::sailor_data() const {
  const ::sg::SailorInDungeon* p = sailor_data_;
  // @@protoc_insertion_point(field_get:sg.Enemy.sailor_data)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::SailorInDungeon*>(
      &::sg::_SailorInDungeon_default_instance_);
}
inline ::sg::SailorInDungeon* Enemy::release_sailor_data() {
  // @@protoc_insertion_point(field_release:sg.Enemy.sailor_data)
  clear_has_sailor_data();
  ::sg::SailorInDungeon* temp = sailor_data_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  sailor_data_ = NULL;
  return temp;
}
inline ::sg::SailorInDungeon* Enemy::unsafe_arena_release_sailor_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.Enemy.sailor_data)
  clear_has_sailor_data();
  ::sg::SailorInDungeon* temp = sailor_data_;
  sailor_data_ = NULL;
  return temp;
}
inline ::sg::SailorInDungeon* Enemy::mutable_sailor_data() {
  set_has_sailor_data();
  if (sailor_data_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::SailorInDungeon>(GetArenaNoVirtual());
    sailor_data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.Enemy.sailor_data)
  return sailor_data_;
}
inline void Enemy::set_allocated_sailor_data(::sg::SailorInDungeon* sailor_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sailor_data_;
  }
  if (sailor_data) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(sailor_data);
    if (message_arena != submessage_arena) {
      sailor_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sailor_data, submessage_arena);
    }
    set_has_sailor_data();
  } else {
    clear_has_sailor_data();
  }
  sailor_data_ = sailor_data;
  // @@protoc_insertion_point(field_set_allocated:sg.Enemy.sailor_data)
}

// optional .sg.MonsterInDungeon monster_data = 5;
inline bool Enemy::has_monster_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Enemy::set_has_monster_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Enemy::clear_has_monster_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Enemy::clear_monster_data() {
  if (monster_data_ != NULL) monster_data_->Clear();
  clear_has_monster_data();
}
inline const ::sg::MonsterInDungeon& Enemy::_internal_monster_data() const {
  return *monster_data_;
}
inline const ::sg::MonsterInDungeon& Enemy::monster_data() const {
  const ::sg::MonsterInDungeon* p = monster_data_;
  // @@protoc_insertion_point(field_get:sg.Enemy.monster_data)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::MonsterInDungeon*>(
      &::sg::_MonsterInDungeon_default_instance_);
}
inline ::sg::MonsterInDungeon* Enemy::release_monster_data() {
  // @@protoc_insertion_point(field_release:sg.Enemy.monster_data)
  clear_has_monster_data();
  ::sg::MonsterInDungeon* temp = monster_data_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  monster_data_ = NULL;
  return temp;
}
inline ::sg::MonsterInDungeon* Enemy::unsafe_arena_release_monster_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.Enemy.monster_data)
  clear_has_monster_data();
  ::sg::MonsterInDungeon* temp = monster_data_;
  monster_data_ = NULL;
  return temp;
}
inline ::sg::MonsterInDungeon* Enemy::mutable_monster_data() {
  set_has_monster_data();
  if (monster_data_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::MonsterInDungeon>(GetArenaNoVirtual());
    monster_data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.Enemy.monster_data)
  return monster_data_;
}
inline void Enemy::set_allocated_monster_data(::sg::MonsterInDungeon* monster_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete monster_data_;
  }
  if (monster_data) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(monster_data);
    if (message_arena != submessage_arena) {
      monster_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, monster_data, submessage_arena);
    }
    set_has_monster_data();
  } else {
    clear_has_monster_data();
  }
  monster_data_ = monster_data;
  // @@protoc_insertion_point(field_set_allocated:sg.Enemy.monster_data)
}

// repeated int32 contain_elements = 6;
inline int Enemy::contain_elements_size() const {
  return contain_elements_.size();
}
inline void Enemy::clear_contain_elements() {
  contain_elements_.Clear();
}
inline ::google::protobuf::int32 Enemy::contain_elements(int index) const {
  // @@protoc_insertion_point(field_get:sg.Enemy.contain_elements)
  return contain_elements_.Get(index);
}
inline void Enemy::set_contain_elements(int index, ::google::protobuf::int32 value) {
  contain_elements_.Set(index, value);
  // @@protoc_insertion_point(field_set:sg.Enemy.contain_elements)
}
inline void Enemy::add_contain_elements(::google::protobuf::int32 value) {
  contain_elements_.Add(value);
  // @@protoc_insertion_point(field_add:sg.Enemy.contain_elements)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Enemy::contain_elements() const {
  // @@protoc_insertion_point(field_list:sg.Enemy.contain_elements)
  return contain_elements_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Enemy::mutable_contain_elements() {
  // @@protoc_insertion_point(field_mutable_list:sg.Enemy.contain_elements)
  return &contain_elements_;
}

// -------------------------------------------------------------------

// DungeonAltar_Relic

// required int32 typeid = 1;
inline bool DungeonAltar_Relic::has_typeid_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DungeonAltar_Relic::set_has_typeid_() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DungeonAltar_Relic::clear_has_typeid_() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DungeonAltar_Relic::clear_typeid_() {
  typeid__ = 0;
  clear_has_typeid_();
}
inline ::google::protobuf::int32 DungeonAltar_Relic::typeid_() const {
  // @@protoc_insertion_point(field_get:sg.DungeonAltar.Relic.typeid)
  return typeid__;
}
inline void DungeonAltar_Relic::set_typeid_(::google::protobuf::int32 value) {
  set_has_typeid_();
  typeid__ = value;
  // @@protoc_insertion_point(field_set:sg.DungeonAltar.Relic.typeid)
}

// repeated .sg.pb_pair_int_int skills = 2;
inline int DungeonAltar_Relic::skills_size() const {
  return skills_.size();
}
inline ::sg::pb_pair_int_int* DungeonAltar_Relic::mutable_skills(int index) {
  // @@protoc_insertion_point(field_mutable:sg.DungeonAltar.Relic.skills)
  return skills_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int >*
DungeonAltar_Relic::mutable_skills() {
  // @@protoc_insertion_point(field_mutable_list:sg.DungeonAltar.Relic.skills)
  return &skills_;
}
inline const ::sg::pb_pair_int_int& DungeonAltar_Relic::skills(int index) const {
  // @@protoc_insertion_point(field_get:sg.DungeonAltar.Relic.skills)
  return skills_.Get(index);
}
inline ::sg::pb_pair_int_int* DungeonAltar_Relic::add_skills() {
  // @@protoc_insertion_point(field_add:sg.DungeonAltar.Relic.skills)
  return skills_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int >&
DungeonAltar_Relic::skills() const {
  // @@protoc_insertion_point(field_list:sg.DungeonAltar.Relic.skills)
  return skills_;
}

// -------------------------------------------------------------------

// DungeonAltar

// required int32 typeid = 1;
inline bool DungeonAltar::has_typeid_() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DungeonAltar::set_has_typeid_() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DungeonAltar::clear_has_typeid_() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DungeonAltar::clear_typeid_() {
  typeid__ = 0;
  clear_has_typeid_();
}
inline ::google::protobuf::int32 DungeonAltar::typeid_() const {
  // @@protoc_insertion_point(field_get:sg.DungeonAltar.typeid)
  return typeid__;
}
inline void DungeonAltar::set_typeid_(::google::protobuf::int32 value) {
  set_has_typeid_();
  typeid__ = value;
  // @@protoc_insertion_point(field_set:sg.DungeonAltar.typeid)
}

// required int32 state = 2;
inline bool DungeonAltar::has_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DungeonAltar::set_has_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DungeonAltar::clear_has_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DungeonAltar::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 DungeonAltar::state() const {
  // @@protoc_insertion_point(field_get:sg.DungeonAltar.state)
  return state_;
}
inline void DungeonAltar::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:sg.DungeonAltar.state)
}

// optional .sg.DungeonAltar.Relic relic = 3;
inline bool DungeonAltar::has_relic() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DungeonAltar::set_has_relic() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DungeonAltar::clear_has_relic() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DungeonAltar::clear_relic() {
  if (relic_ != NULL) relic_->Clear();
  clear_has_relic();
}
inline const ::sg::DungeonAltar_Relic& DungeonAltar::_internal_relic() const {
  return *relic_;
}
inline const ::sg::DungeonAltar_Relic& DungeonAltar::relic() const {
  const ::sg::DungeonAltar_Relic* p = relic_;
  // @@protoc_insertion_point(field_get:sg.DungeonAltar.relic)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::DungeonAltar_Relic*>(
      &::sg::_DungeonAltar_Relic_default_instance_);
}
inline ::sg::DungeonAltar_Relic* DungeonAltar::release_relic() {
  // @@protoc_insertion_point(field_release:sg.DungeonAltar.relic)
  clear_has_relic();
  ::sg::DungeonAltar_Relic* temp = relic_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  relic_ = NULL;
  return temp;
}
inline ::sg::DungeonAltar_Relic* DungeonAltar::unsafe_arena_release_relic() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.DungeonAltar.relic)
  clear_has_relic();
  ::sg::DungeonAltar_Relic* temp = relic_;
  relic_ = NULL;
  return temp;
}
inline ::sg::DungeonAltar_Relic* DungeonAltar::mutable_relic() {
  set_has_relic();
  if (relic_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::DungeonAltar_Relic>(GetArenaNoVirtual());
    relic_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.DungeonAltar.relic)
  return relic_;
}
inline void DungeonAltar::set_allocated_relic(::sg::DungeonAltar_Relic* relic) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete relic_;
  }
  if (relic) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(relic);
    if (message_arena != submessage_arena) {
      relic = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, relic, submessage_arena);
    }
    set_has_relic();
  } else {
    clear_has_relic();
  }
  relic_ = relic;
  // @@protoc_insertion_point(field_set_allocated:sg.DungeonAltar.relic)
}

// optional .sg.MonsterInDungeon monster = 4;
inline bool DungeonAltar::has_monster() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DungeonAltar::set_has_monster() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DungeonAltar::clear_has_monster() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DungeonAltar::clear_monster() {
  if (monster_ != NULL) monster_->Clear();
  clear_has_monster();
}
inline const ::sg::MonsterInDungeon& DungeonAltar::_internal_monster() const {
  return *monster_;
}
inline const ::sg::MonsterInDungeon& DungeonAltar::monster() const {
  const ::sg::MonsterInDungeon* p = monster_;
  // @@protoc_insertion_point(field_get:sg.DungeonAltar.monster)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::MonsterInDungeon*>(
      &::sg::_MonsterInDungeon_default_instance_);
}
inline ::sg::MonsterInDungeon* DungeonAltar::release_monster() {
  // @@protoc_insertion_point(field_release:sg.DungeonAltar.monster)
  clear_has_monster();
  ::sg::MonsterInDungeon* temp = monster_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  monster_ = NULL;
  return temp;
}
inline ::sg::MonsterInDungeon* DungeonAltar::unsafe_arena_release_monster() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.DungeonAltar.monster)
  clear_has_monster();
  ::sg::MonsterInDungeon* temp = monster_;
  monster_ = NULL;
  return temp;
}
inline ::sg::MonsterInDungeon* DungeonAltar::mutable_monster() {
  set_has_monster();
  if (monster_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::MonsterInDungeon>(GetArenaNoVirtual());
    monster_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.DungeonAltar.monster)
  return monster_;
}
inline void DungeonAltar::set_allocated_monster(::sg::MonsterInDungeon* monster) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete monster_;
  }
  if (monster) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(monster);
    if (message_arena != submessage_arena) {
      monster = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, monster, submessage_arena);
    }
    set_has_monster();
  } else {
    clear_has_monster();
  }
  monster_ = monster;
  // @@protoc_insertion_point(field_set_allocated:sg.DungeonAltar.monster)
}

// -------------------------------------------------------------------

// ElementProperty_RoomData_RoomEffect

// optional int32 enter_effect = 1;
inline bool ElementProperty_RoomData_RoomEffect::has_enter_effect() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ElementProperty_RoomData_RoomEffect::set_has_enter_effect() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ElementProperty_RoomData_RoomEffect::clear_has_enter_effect() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ElementProperty_RoomData_RoomEffect::clear_enter_effect() {
  enter_effect_ = 0;
  clear_has_enter_effect();
}
inline ::google::protobuf::int32 ElementProperty_RoomData_RoomEffect::enter_effect() const {
  // @@protoc_insertion_point(field_get:sg.ElementProperty.RoomData.RoomEffect.enter_effect)
  return enter_effect_;
}
inline void ElementProperty_RoomData_RoomEffect::set_enter_effect(::google::protobuf::int32 value) {
  set_has_enter_effect();
  enter_effect_ = value;
  // @@protoc_insertion_point(field_set:sg.ElementProperty.RoomData.RoomEffect.enter_effect)
}

// optional int32 effect_id = 2;
inline bool ElementProperty_RoomData_RoomEffect::has_effect_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ElementProperty_RoomData_RoomEffect::set_has_effect_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ElementProperty_RoomData_RoomEffect::clear_has_effect_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ElementProperty_RoomData_RoomEffect::clear_effect_id() {
  effect_id_ = 0;
  clear_has_effect_id();
}
inline ::google::protobuf::int32 ElementProperty_RoomData_RoomEffect::effect_id() const {
  // @@protoc_insertion_point(field_get:sg.ElementProperty.RoomData.RoomEffect.effect_id)
  return effect_id_;
}
inline void ElementProperty_RoomData_RoomEffect::set_effect_id(::google::protobuf::int32 value) {
  set_has_effect_id();
  effect_id_ = value;
  // @@protoc_insertion_point(field_set:sg.ElementProperty.RoomData.RoomEffect.effect_id)
}

// optional int32 effect_value = 3;
inline bool ElementProperty_RoomData_RoomEffect::has_effect_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ElementProperty_RoomData_RoomEffect::set_has_effect_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ElementProperty_RoomData_RoomEffect::clear_has_effect_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ElementProperty_RoomData_RoomEffect::clear_effect_value() {
  effect_value_ = 0;
  clear_has_effect_value();
}
inline ::google::protobuf::int32 ElementProperty_RoomData_RoomEffect::effect_value() const {
  // @@protoc_insertion_point(field_get:sg.ElementProperty.RoomData.RoomEffect.effect_value)
  return effect_value_;
}
inline void ElementProperty_RoomData_RoomEffect::set_effect_value(::google::protobuf::int32 value) {
  set_has_effect_value();
  effect_value_ = value;
  // @@protoc_insertion_point(field_set:sg.ElementProperty.RoomData.RoomEffect.effect_value)
}

// optional float effect_value_ratio = 4;
inline bool ElementProperty_RoomData_RoomEffect::has_effect_value_ratio() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ElementProperty_RoomData_RoomEffect::set_has_effect_value_ratio() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ElementProperty_RoomData_RoomEffect::clear_has_effect_value_ratio() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ElementProperty_RoomData_RoomEffect::clear_effect_value_ratio() {
  effect_value_ratio_ = 0;
  clear_has_effect_value_ratio();
}
inline float ElementProperty_RoomData_RoomEffect::effect_value_ratio() const {
  // @@protoc_insertion_point(field_get:sg.ElementProperty.RoomData.RoomEffect.effect_value_ratio)
  return effect_value_ratio_;
}
inline void ElementProperty_RoomData_RoomEffect::set_effect_value_ratio(float value) {
  set_has_effect_value_ratio();
  effect_value_ratio_ = value;
  // @@protoc_insertion_point(field_set:sg.ElementProperty.RoomData.RoomEffect.effect_value_ratio)
}

// repeated .sg.Item contain = 5;
inline int ElementProperty_RoomData_RoomEffect::contain_size() const {
  return contain_.size();
}
inline ::sg::Item* ElementProperty_RoomData_RoomEffect::mutable_contain(int index) {
  // @@protoc_insertion_point(field_mutable:sg.ElementProperty.RoomData.RoomEffect.contain)
  return contain_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::Item >*
ElementProperty_RoomData_RoomEffect::mutable_contain() {
  // @@protoc_insertion_point(field_mutable_list:sg.ElementProperty.RoomData.RoomEffect.contain)
  return &contain_;
}
inline const ::sg::Item& ElementProperty_RoomData_RoomEffect::contain(int index) const {
  // @@protoc_insertion_point(field_get:sg.ElementProperty.RoomData.RoomEffect.contain)
  return contain_.Get(index);
}
inline ::sg::Item* ElementProperty_RoomData_RoomEffect::add_contain() {
  // @@protoc_insertion_point(field_add:sg.ElementProperty.RoomData.RoomEffect.contain)
  return contain_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::Item >&
ElementProperty_RoomData_RoomEffect::contain() const {
  // @@protoc_insertion_point(field_list:sg.ElementProperty.RoomData.RoomEffect.contain)
  return contain_;
}

// repeated .sg.Equip equips = 6;
inline int ElementProperty_RoomData_RoomEffect::equips_size() const {
  return equips_.size();
}
inline ::sg::Equip* ElementProperty_RoomData_RoomEffect::mutable_equips(int index) {
  // @@protoc_insertion_point(field_mutable:sg.ElementProperty.RoomData.RoomEffect.equips)
  return equips_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::Equip >*
ElementProperty_RoomData_RoomEffect::mutable_equips() {
  // @@protoc_insertion_point(field_mutable_list:sg.ElementProperty.RoomData.RoomEffect.equips)
  return &equips_;
}
inline const ::sg::Equip& ElementProperty_RoomData_RoomEffect::equips(int index) const {
  // @@protoc_insertion_point(field_get:sg.ElementProperty.RoomData.RoomEffect.equips)
  return equips_.Get(index);
}
inline ::sg::Equip* ElementProperty_RoomData_RoomEffect::add_equips() {
  // @@protoc_insertion_point(field_add:sg.ElementProperty.RoomData.RoomEffect.equips)
  return equips_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::Equip >&
ElementProperty_RoomData_RoomEffect::equips() const {
  // @@protoc_insertion_point(field_list:sg.ElementProperty.RoomData.RoomEffect.equips)
  return equips_;
}

// -------------------------------------------------------------------

// ElementProperty_RoomData

// required int32 roomid = 1;
inline bool ElementProperty_RoomData::has_roomid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ElementProperty_RoomData::set_has_roomid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ElementProperty_RoomData::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ElementProperty_RoomData::clear_roomid() {
  roomid_ = 0;
  clear_has_roomid();
}
inline ::google::protobuf::int32 ElementProperty_RoomData::roomid() const {
  // @@protoc_insertion_point(field_get:sg.ElementProperty.RoomData.roomid)
  return roomid_;
}
inline void ElementProperty_RoomData::set_roomid(::google::protobuf::int32 value) {
  set_has_roomid();
  roomid_ = value;
  // @@protoc_insertion_point(field_set:sg.ElementProperty.RoomData.roomid)
}

// optional int32 type = 2;
inline bool ElementProperty_RoomData::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ElementProperty_RoomData::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ElementProperty_RoomData::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ElementProperty_RoomData::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ElementProperty_RoomData::type() const {
  // @@protoc_insertion_point(field_get:sg.ElementProperty.RoomData.type)
  return type_;
}
inline void ElementProperty_RoomData::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:sg.ElementProperty.RoomData.type)
}

// optional int32 state = 3;
inline bool ElementProperty_RoomData::has_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ElementProperty_RoomData::set_has_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ElementProperty_RoomData::clear_has_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ElementProperty_RoomData::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 ElementProperty_RoomData::state() const {
  // @@protoc_insertion_point(field_get:sg.ElementProperty.RoomData.state)
  return state_;
}
inline void ElementProperty_RoomData::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:sg.ElementProperty.RoomData.state)
}

// repeated .sg.ElementProperty.RoomData.RoomEffect effects = 4;
inline int ElementProperty_RoomData::effects_size() const {
  return effects_.size();
}
inline void ElementProperty_RoomData::clear_effects() {
  effects_.Clear();
}
inline ::sg::ElementProperty_RoomData_RoomEffect* ElementProperty_RoomData::mutable_effects(int index) {
  // @@protoc_insertion_point(field_mutable:sg.ElementProperty.RoomData.effects)
  return effects_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::ElementProperty_RoomData_RoomEffect >*
ElementProperty_RoomData::mutable_effects() {
  // @@protoc_insertion_point(field_mutable_list:sg.ElementProperty.RoomData.effects)
  return &effects_;
}
inline const ::sg::ElementProperty_RoomData_RoomEffect& ElementProperty_RoomData::effects(int index) const {
  // @@protoc_insertion_point(field_get:sg.ElementProperty.RoomData.effects)
  return effects_.Get(index);
}
inline ::sg::ElementProperty_RoomData_RoomEffect* ElementProperty_RoomData::add_effects() {
  // @@protoc_insertion_point(field_add:sg.ElementProperty.RoomData.effects)
  return effects_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::ElementProperty_RoomData_RoomEffect >&
ElementProperty_RoomData::effects() const {
  // @@protoc_insertion_point(field_list:sg.ElementProperty.RoomData.effects)
  return effects_;
}

// -------------------------------------------------------------------

// ElementProperty

// optional int32 index = 1;
inline bool ElementProperty::has_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ElementProperty::set_has_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ElementProperty::clear_has_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ElementProperty::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 ElementProperty::index() const {
  // @@protoc_insertion_point(field_get:sg.ElementProperty.index)
  return index_;
}
inline void ElementProperty::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:sg.ElementProperty.index)
}

// optional int32 num = 2;
inline bool ElementProperty::has_num() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ElementProperty::set_has_num() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ElementProperty::clear_has_num() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ElementProperty::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 ElementProperty::num() const {
  // @@protoc_insertion_point(field_get:sg.ElementProperty.num)
  return num_;
}
inline void ElementProperty::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
  // @@protoc_insertion_point(field_set:sg.ElementProperty.num)
}

// optional int32 exp = 3;
inline bool ElementProperty::has_exp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ElementProperty::set_has_exp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ElementProperty::clear_has_exp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ElementProperty::clear_exp() {
  exp_ = 0;
  clear_has_exp();
}
inline ::google::protobuf::int32 ElementProperty::exp() const {
  // @@protoc_insertion_point(field_get:sg.ElementProperty.exp)
  return exp_;
}
inline void ElementProperty::set_exp(::google::protobuf::int32 value) {
  set_has_exp();
  exp_ = value;
  // @@protoc_insertion_point(field_set:sg.ElementProperty.exp)
}

// optional int32 pos_x = 4;
inline bool ElementProperty::has_pos_x() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ElementProperty::set_has_pos_x() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ElementProperty::clear_has_pos_x() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ElementProperty::clear_pos_x() {
  pos_x_ = 0;
  clear_has_pos_x();
}
inline ::google::protobuf::int32 ElementProperty::pos_x() const {
  // @@protoc_insertion_point(field_get:sg.ElementProperty.pos_x)
  return pos_x_;
}
inline void ElementProperty::set_pos_x(::google::protobuf::int32 value) {
  set_has_pos_x();
  pos_x_ = value;
  // @@protoc_insertion_point(field_set:sg.ElementProperty.pos_x)
}

// optional int32 pos_y = 5;
inline bool ElementProperty::has_pos_y() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ElementProperty::set_has_pos_y() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ElementProperty::clear_has_pos_y() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ElementProperty::clear_pos_y() {
  pos_y_ = 0;
  clear_has_pos_y();
}
inline ::google::protobuf::int32 ElementProperty::pos_y() const {
  // @@protoc_insertion_point(field_get:sg.ElementProperty.pos_y)
  return pos_y_;
}
inline void ElementProperty::set_pos_y(::google::protobuf::int32 value) {
  set_has_pos_y();
  pos_y_ = value;
  // @@protoc_insertion_point(field_set:sg.ElementProperty.pos_y)
}

// optional int32 lock_id = 6;
inline bool ElementProperty::has_lock_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ElementProperty::set_has_lock_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ElementProperty::clear_has_lock_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ElementProperty::clear_lock_id() {
  lock_id_ = 0;
  clear_has_lock_id();
}
inline ::google::protobuf::int32 ElementProperty::lock_id() const {
  // @@protoc_insertion_point(field_get:sg.ElementProperty.lock_id)
  return lock_id_;
}
inline void ElementProperty::set_lock_id(::google::protobuf::int32 value) {
  set_has_lock_id();
  lock_id_ = value;
  // @@protoc_insertion_point(field_set:sg.ElementProperty.lock_id)
}

// optional int32 room_id = 7;
inline bool ElementProperty::has_room_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ElementProperty::set_has_room_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ElementProperty::clear_has_room_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ElementProperty::clear_room_id() {
  room_id_ = 0;
  clear_has_room_id();
}
inline ::google::protobuf::int32 ElementProperty::room_id() const {
  // @@protoc_insertion_point(field_get:sg.ElementProperty.room_id)
  return room_id_;
}
inline void ElementProperty::set_room_id(::google::protobuf::int32 value) {
  set_has_room_id();
  room_id_ = value;
  // @@protoc_insertion_point(field_set:sg.ElementProperty.room_id)
}

// optional int32 change_model = 8;
inline bool ElementProperty::has_change_model() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ElementProperty::set_has_change_model() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ElementProperty::clear_has_change_model() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ElementProperty::clear_change_model() {
  change_model_ = 0;
  clear_has_change_model();
}
inline ::google::protobuf::int32 ElementProperty::change_model() const {
  // @@protoc_insertion_point(field_get:sg.ElementProperty.change_model)
  return change_model_;
}
inline void ElementProperty::set_change_model(::google::protobuf::int32 value) {
  set_has_change_model();
  change_model_ = value;
  // @@protoc_insertion_point(field_set:sg.ElementProperty.change_model)
}

// optional int32 trigger_id = 9;
inline bool ElementProperty::has_trigger_id() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ElementProperty::set_has_trigger_id() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ElementProperty::clear_has_trigger_id() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ElementProperty::clear_trigger_id() {
  trigger_id_ = 0;
  clear_has_trigger_id();
}
inline ::google::protobuf::int32 ElementProperty::trigger_id() const {
  // @@protoc_insertion_point(field_get:sg.ElementProperty.trigger_id)
  return trigger_id_;
}
inline void ElementProperty::set_trigger_id(::google::protobuf::int32 value) {
  set_has_trigger_id();
  trigger_id_ = value;
  // @@protoc_insertion_point(field_set:sg.ElementProperty.trigger_id)
}

// optional int32 clean_up_reward_tag = 10;
inline bool ElementProperty::has_clean_up_reward_tag() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ElementProperty::set_has_clean_up_reward_tag() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ElementProperty::clear_has_clean_up_reward_tag() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ElementProperty::clear_clean_up_reward_tag() {
  clean_up_reward_tag_ = 0;
  clear_has_clean_up_reward_tag();
}
inline ::google::protobuf::int32 ElementProperty::clean_up_reward_tag() const {
  // @@protoc_insertion_point(field_get:sg.ElementProperty.clean_up_reward_tag)
  return clean_up_reward_tag_;
}
inline void ElementProperty::set_clean_up_reward_tag(::google::protobuf::int32 value) {
  set_has_clean_up_reward_tag();
  clean_up_reward_tag_ = value;
  // @@protoc_insertion_point(field_set:sg.ElementProperty.clean_up_reward_tag)
}

// optional int32 belong_facility = 11;
inline bool ElementProperty::has_belong_facility() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ElementProperty::set_has_belong_facility() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ElementProperty::clear_has_belong_facility() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ElementProperty::clear_belong_facility() {
  belong_facility_ = 0;
  clear_has_belong_facility();
}
inline ::google::protobuf::int32 ElementProperty::belong_facility() const {
  // @@protoc_insertion_point(field_get:sg.ElementProperty.belong_facility)
  return belong_facility_;
}
inline void ElementProperty::set_belong_facility(::google::protobuf::int32 value) {
  set_has_belong_facility();
  belong_facility_ = value;
  // @@protoc_insertion_point(field_set:sg.ElementProperty.belong_facility)
}

// optional bytes map_data = 12;
inline bool ElementProperty::has_map_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ElementProperty::set_has_map_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ElementProperty::clear_has_map_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ElementProperty::clear_map_data() {
  map_data_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_map_data();
}
inline const ::std::string& ElementProperty::map_data() const {
  // @@protoc_insertion_point(field_get:sg.ElementProperty.map_data)
  return map_data_.Get();
}
inline void ElementProperty::set_map_data(const ::std::string& value) {
  set_has_map_data();
  map_data_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:sg.ElementProperty.map_data)
}
#if LANG_CXX11
inline void ElementProperty::set_map_data(::std::string&& value) {
  set_has_map_data();
  map_data_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:sg.ElementProperty.map_data)
}
#endif
inline void ElementProperty::set_map_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_map_data();
  map_data_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:sg.ElementProperty.map_data)
}
inline void ElementProperty::set_map_data(const void* value,
    size_t size) {
  set_has_map_data();
  map_data_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:sg.ElementProperty.map_data)
}
inline ::std::string* ElementProperty::mutable_map_data() {
  set_has_map_data();
  // @@protoc_insertion_point(field_mutable:sg.ElementProperty.map_data)
  return map_data_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* ElementProperty::release_map_data() {
  // @@protoc_insertion_point(field_release:sg.ElementProperty.map_data)
  if (!has_map_data()) {
    return NULL;
  }
  clear_has_map_data();
  return map_data_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void ElementProperty::set_allocated_map_data(::std::string* map_data) {
  if (map_data != NULL) {
    set_has_map_data();
  } else {
    clear_has_map_data();
  }
  map_data_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), map_data,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:sg.ElementProperty.map_data)
}
inline ::std::string* ElementProperty::unsafe_arena_release_map_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.ElementProperty.map_data)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_map_data();
  return map_data_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void ElementProperty::unsafe_arena_set_allocated_map_data(
    ::std::string* map_data) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (map_data != NULL) {
    set_has_map_data();
  } else {
    clear_has_map_data();
  }
  map_data_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      map_data, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sg.ElementProperty.map_data)
}

// optional int32 unlock_room = 13;
inline bool ElementProperty::has_unlock_room() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ElementProperty::set_has_unlock_room() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ElementProperty::clear_has_unlock_room() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ElementProperty::clear_unlock_room() {
  unlock_room_ = 0;
  clear_has_unlock_room();
}
inline ::google::protobuf::int32 ElementProperty::unlock_room() const {
  // @@protoc_insertion_point(field_get:sg.ElementProperty.unlock_room)
  return unlock_room_;
}
inline void ElementProperty::set_unlock_room(::google::protobuf::int32 value) {
  set_has_unlock_room();
  unlock_room_ = value;
  // @@protoc_insertion_point(field_set:sg.ElementProperty.unlock_room)
}

// repeated int32 locked_room = 14;
inline int ElementProperty::locked_room_size() const {
  return locked_room_.size();
}
inline void ElementProperty::clear_locked_room() {
  locked_room_.Clear();
}
inline ::google::protobuf::int32 ElementProperty::locked_room(int index) const {
  // @@protoc_insertion_point(field_get:sg.ElementProperty.locked_room)
  return locked_room_.Get(index);
}
inline void ElementProperty::set_locked_room(int index, ::google::protobuf::int32 value) {
  locked_room_.Set(index, value);
  // @@protoc_insertion_point(field_set:sg.ElementProperty.locked_room)
}
inline void ElementProperty::add_locked_room(::google::protobuf::int32 value) {
  locked_room_.Add(value);
  // @@protoc_insertion_point(field_add:sg.ElementProperty.locked_room)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ElementProperty::locked_room() const {
  // @@protoc_insertion_point(field_list:sg.ElementProperty.locked_room)
  return locked_room_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ElementProperty::mutable_locked_room() {
  // @@protoc_insertion_point(field_mutable_list:sg.ElementProperty.locked_room)
  return &locked_room_;
}

// optional int64 trigger_event = 15;
inline bool ElementProperty::has_trigger_event() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ElementProperty::set_has_trigger_event() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ElementProperty::clear_has_trigger_event() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ElementProperty::clear_trigger_event() {
  trigger_event_ = GOOGLE_LONGLONG(0);
  clear_has_trigger_event();
}
inline ::google::protobuf::int64 ElementProperty::trigger_event() const {
  // @@protoc_insertion_point(field_get:sg.ElementProperty.trigger_event)
  return trigger_event_;
}
inline void ElementProperty::set_trigger_event(::google::protobuf::int64 value) {
  set_has_trigger_event();
  trigger_event_ = value;
  // @@protoc_insertion_point(field_set:sg.ElementProperty.trigger_event)
}

// optional .sg.ElementProperty.RoomData room_data = 16;
inline bool ElementProperty::has_room_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ElementProperty::set_has_room_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ElementProperty::clear_has_room_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ElementProperty::clear_room_data() {
  if (room_data_ != NULL) room_data_->Clear();
  clear_has_room_data();
}
inline const ::sg::ElementProperty_RoomData& ElementProperty::_internal_room_data() const {
  return *room_data_;
}
inline const ::sg::ElementProperty_RoomData& ElementProperty::room_data() const {
  const ::sg::ElementProperty_RoomData* p = room_data_;
  // @@protoc_insertion_point(field_get:sg.ElementProperty.room_data)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::ElementProperty_RoomData*>(
      &::sg::_ElementProperty_RoomData_default_instance_);
}
inline ::sg::ElementProperty_RoomData* ElementProperty::release_room_data() {
  // @@protoc_insertion_point(field_release:sg.ElementProperty.room_data)
  clear_has_room_data();
  ::sg::ElementProperty_RoomData* temp = room_data_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  room_data_ = NULL;
  return temp;
}
inline ::sg::ElementProperty_RoomData* ElementProperty::unsafe_arena_release_room_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.ElementProperty.room_data)
  clear_has_room_data();
  ::sg::ElementProperty_RoomData* temp = room_data_;
  room_data_ = NULL;
  return temp;
}
inline ::sg::ElementProperty_RoomData* ElementProperty::mutable_room_data() {
  set_has_room_data();
  if (room_data_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::ElementProperty_RoomData>(GetArenaNoVirtual());
    room_data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.ElementProperty.room_data)
  return room_data_;
}
inline void ElementProperty::set_allocated_room_data(::sg::ElementProperty_RoomData* room_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete room_data_;
  }
  if (room_data) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(room_data);
    if (message_arena != submessage_arena) {
      room_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, room_data, submessage_arena);
    }
    set_has_room_data();
  } else {
    clear_has_room_data();
  }
  room_data_ = room_data;
  // @@protoc_insertion_point(field_set_allocated:sg.ElementProperty.room_data)
}

// optional int32 state = 17;
inline bool ElementProperty::has_state() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ElementProperty::set_has_state() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ElementProperty::clear_has_state() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ElementProperty::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 ElementProperty::state() const {
  // @@protoc_insertion_point(field_get:sg.ElementProperty.state)
  return state_;
}
inline void ElementProperty::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:sg.ElementProperty.state)
}

// -------------------------------------------------------------------

// FightManual

// required int32 type = 1;
inline bool FightManual::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FightManual::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FightManual::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FightManual::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 FightManual::type() const {
  // @@protoc_insertion_point(field_get:sg.FightManual.type)
  return type_;
}
inline void FightManual::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:sg.FightManual.type)
}

// repeated int32 typeid = 2;
inline int FightManual::typeid__size() const {
  return typeid__.size();
}
inline void FightManual::clear_typeid_() {
  typeid__.Clear();
}
inline ::google::protobuf::int32 FightManual::typeid_(int index) const {
  // @@protoc_insertion_point(field_get:sg.FightManual.typeid)
  return typeid__.Get(index);
}
inline void FightManual::set_typeid_(int index, ::google::protobuf::int32 value) {
  typeid__.Set(index, value);
  // @@protoc_insertion_point(field_set:sg.FightManual.typeid)
}
inline void FightManual::add_typeid_(::google::protobuf::int32 value) {
  typeid__.Add(value);
  // @@protoc_insertion_point(field_add:sg.FightManual.typeid)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
FightManual::typeid_() const {
  // @@protoc_insertion_point(field_list:sg.FightManual.typeid)
  return typeid__;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
FightManual::mutable_typeid_() {
  // @@protoc_insertion_point(field_mutable_list:sg.FightManual.typeid)
  return &typeid__;
}

// -------------------------------------------------------------------

// DungeonElement_Exchange_Exchange_Item

// required int32 item_type = 1;
inline bool DungeonElement_Exchange_Exchange_Item::has_item_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DungeonElement_Exchange_Exchange_Item::set_has_item_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DungeonElement_Exchange_Exchange_Item::clear_has_item_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DungeonElement_Exchange_Exchange_Item::clear_item_type() {
  item_type_ = 0;
  clear_has_item_type();
}
inline ::google::protobuf::int32 DungeonElement_Exchange_Exchange_Item::item_type() const {
  // @@protoc_insertion_point(field_get:sg.DungeonElement.Exchange.Exchange_Item.item_type)
  return item_type_;
}
inline void DungeonElement_Exchange_Exchange_Item::set_item_type(::google::protobuf::int32 value) {
  set_has_item_type();
  item_type_ = value;
  // @@protoc_insertion_point(field_set:sg.DungeonElement.Exchange.Exchange_Item.item_type)
}

// optional int32 id = 2;
inline bool DungeonElement_Exchange_Exchange_Item::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DungeonElement_Exchange_Exchange_Item::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DungeonElement_Exchange_Exchange_Item::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DungeonElement_Exchange_Exchange_Item::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 DungeonElement_Exchange_Exchange_Item::id() const {
  // @@protoc_insertion_point(field_get:sg.DungeonElement.Exchange.Exchange_Item.id)
  return id_;
}
inline void DungeonElement_Exchange_Exchange_Item::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:sg.DungeonElement.Exchange.Exchange_Item.id)
}

// optional int32 type = 3;
inline bool DungeonElement_Exchange_Exchange_Item::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DungeonElement_Exchange_Exchange_Item::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DungeonElement_Exchange_Exchange_Item::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DungeonElement_Exchange_Exchange_Item::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 DungeonElement_Exchange_Exchange_Item::type() const {
  // @@protoc_insertion_point(field_get:sg.DungeonElement.Exchange.Exchange_Item.type)
  return type_;
}
inline void DungeonElement_Exchange_Exchange_Item::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:sg.DungeonElement.Exchange.Exchange_Item.type)
}

// optional uint64 typeid = 4;
inline bool DungeonElement_Exchange_Exchange_Item::has_typeid_() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DungeonElement_Exchange_Exchange_Item::set_has_typeid_() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DungeonElement_Exchange_Exchange_Item::clear_has_typeid_() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DungeonElement_Exchange_Exchange_Item::clear_typeid_() {
  typeid__ = GOOGLE_ULONGLONG(0);
  clear_has_typeid_();
}
inline ::google::protobuf::uint64 DungeonElement_Exchange_Exchange_Item::typeid_() const {
  // @@protoc_insertion_point(field_get:sg.DungeonElement.Exchange.Exchange_Item.typeid)
  return typeid__;
}
inline void DungeonElement_Exchange_Exchange_Item::set_typeid_(::google::protobuf::uint64 value) {
  set_has_typeid_();
  typeid__ = value;
  // @@protoc_insertion_point(field_set:sg.DungeonElement.Exchange.Exchange_Item.typeid)
}

// optional uint64 value = 5;
inline bool DungeonElement_Exchange_Exchange_Item::has_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DungeonElement_Exchange_Exchange_Item::set_has_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DungeonElement_Exchange_Exchange_Item::clear_has_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DungeonElement_Exchange_Exchange_Item::clear_value() {
  value_ = GOOGLE_ULONGLONG(0);
  clear_has_value();
}
inline ::google::protobuf::uint64 DungeonElement_Exchange_Exchange_Item::value() const {
  // @@protoc_insertion_point(field_get:sg.DungeonElement.Exchange.Exchange_Item.value)
  return value_;
}
inline void DungeonElement_Exchange_Exchange_Item::set_value(::google::protobuf::uint64 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:sg.DungeonElement.Exchange.Exchange_Item.value)
}

// -------------------------------------------------------------------

// DungeonElement_Exchange

// required int32 id = 1;
inline bool DungeonElement_Exchange::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DungeonElement_Exchange::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DungeonElement_Exchange::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DungeonElement_Exchange::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 DungeonElement_Exchange::id() const {
  // @@protoc_insertion_point(field_get:sg.DungeonElement.Exchange.id)
  return id_;
}
inline void DungeonElement_Exchange::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:sg.DungeonElement.Exchange.id)
}

// required int32 typeid = 2;
inline bool DungeonElement_Exchange::has_typeid_() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DungeonElement_Exchange::set_has_typeid_() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DungeonElement_Exchange::clear_has_typeid_() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DungeonElement_Exchange::clear_typeid_() {
  typeid__ = 0;
  clear_has_typeid_();
}
inline ::google::protobuf::int32 DungeonElement_Exchange::typeid_() const {
  // @@protoc_insertion_point(field_get:sg.DungeonElement.Exchange.typeid)
  return typeid__;
}
inline void DungeonElement_Exchange::set_typeid_(::google::protobuf::int32 value) {
  set_has_typeid_();
  typeid__ = value;
  // @@protoc_insertion_point(field_set:sg.DungeonElement.Exchange.typeid)
}

// required int32 index = 3;
inline bool DungeonElement_Exchange::has_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DungeonElement_Exchange::set_has_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DungeonElement_Exchange::clear_has_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DungeonElement_Exchange::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 DungeonElement_Exchange::index() const {
  // @@protoc_insertion_point(field_get:sg.DungeonElement.Exchange.index)
  return index_;
}
inline void DungeonElement_Exchange::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:sg.DungeonElement.Exchange.index)
}

// repeated .sg.DungeonElement.Exchange.Exchange_Item cost = 4;
inline int DungeonElement_Exchange::cost_size() const {
  return cost_.size();
}
inline void DungeonElement_Exchange::clear_cost() {
  cost_.Clear();
}
inline ::sg::DungeonElement_Exchange_Exchange_Item* DungeonElement_Exchange::mutable_cost(int index) {
  // @@protoc_insertion_point(field_mutable:sg.DungeonElement.Exchange.cost)
  return cost_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::DungeonElement_Exchange_Exchange_Item >*
DungeonElement_Exchange::mutable_cost() {
  // @@protoc_insertion_point(field_mutable_list:sg.DungeonElement.Exchange.cost)
  return &cost_;
}
inline const ::sg::DungeonElement_Exchange_Exchange_Item& DungeonElement_Exchange::cost(int index) const {
  // @@protoc_insertion_point(field_get:sg.DungeonElement.Exchange.cost)
  return cost_.Get(index);
}
inline ::sg::DungeonElement_Exchange_Exchange_Item* DungeonElement_Exchange::add_cost() {
  // @@protoc_insertion_point(field_add:sg.DungeonElement.Exchange.cost)
  return cost_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::DungeonElement_Exchange_Exchange_Item >&
DungeonElement_Exchange::cost() const {
  // @@protoc_insertion_point(field_list:sg.DungeonElement.Exchange.cost)
  return cost_;
}

// repeated .sg.DungeonElement.Exchange.Exchange_Item get = 5;
inline int DungeonElement_Exchange::get_size() const {
  return get_.size();
}
inline void DungeonElement_Exchange::clear_get() {
  get_.Clear();
}
inline ::sg::DungeonElement_Exchange_Exchange_Item* DungeonElement_Exchange::mutable_get(int index) {
  // @@protoc_insertion_point(field_mutable:sg.DungeonElement.Exchange.get)
  return get_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::DungeonElement_Exchange_Exchange_Item >*
DungeonElement_Exchange::mutable_get() {
  // @@protoc_insertion_point(field_mutable_list:sg.DungeonElement.Exchange.get)
  return &get_;
}
inline const ::sg::DungeonElement_Exchange_Exchange_Item& DungeonElement_Exchange::get(int index) const {
  // @@protoc_insertion_point(field_get:sg.DungeonElement.Exchange.get)
  return get_.Get(index);
}
inline ::sg::DungeonElement_Exchange_Exchange_Item* DungeonElement_Exchange::add_get() {
  // @@protoc_insertion_point(field_add:sg.DungeonElement.Exchange.get)
  return get_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::DungeonElement_Exchange_Exchange_Item >&
DungeonElement_Exchange::get() const {
  // @@protoc_insertion_point(field_list:sg.DungeonElement.Exchange.get)
  return get_;
}

// -------------------------------------------------------------------

// DungeonElement

// required int32 id = 1;
inline bool DungeonElement::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DungeonElement::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DungeonElement::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DungeonElement::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 DungeonElement::id() const {
  // @@protoc_insertion_point(field_get:sg.DungeonElement.id)
  return id_;
}
inline void DungeonElement::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:sg.DungeonElement.id)
}

// required int32 owner_id = 2;
inline bool DungeonElement::has_owner_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DungeonElement::set_has_owner_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DungeonElement::clear_has_owner_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DungeonElement::clear_owner_id() {
  owner_id_ = 0;
  clear_has_owner_id();
}
inline ::google::protobuf::int32 DungeonElement::owner_id() const {
  // @@protoc_insertion_point(field_get:sg.DungeonElement.owner_id)
  return owner_id_;
}
inline void DungeonElement::set_owner_id(::google::protobuf::int32 value) {
  set_has_owner_id();
  owner_id_ = value;
  // @@protoc_insertion_point(field_set:sg.DungeonElement.owner_id)
}

// required int32 type = 3;
inline bool DungeonElement::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DungeonElement::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DungeonElement::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DungeonElement::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 DungeonElement::type() const {
  // @@protoc_insertion_point(field_get:sg.DungeonElement.type)
  return type_;
}
inline void DungeonElement::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:sg.DungeonElement.type)
}

// required int64 typeid_ = 4;
inline bool DungeonElement::has_typeid_() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DungeonElement::set_has_typeid_() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DungeonElement::clear_has_typeid_() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DungeonElement::clear_typeid_() {
  typeid__ = GOOGLE_LONGLONG(0);
  clear_has_typeid_();
}
inline ::google::protobuf::int64 DungeonElement::typeid_() const {
  // @@protoc_insertion_point(field_get:sg.DungeonElement.typeid_)
  return typeid__;
}
inline void DungeonElement::set_typeid_(::google::protobuf::int64 value) {
  set_has_typeid_();
  typeid__ = value;
  // @@protoc_insertion_point(field_set:sg.DungeonElement.typeid_)
}

// optional .sg.ElementProperty property = 5;
inline bool DungeonElement::has_property() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DungeonElement::set_has_property() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DungeonElement::clear_has_property() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DungeonElement::clear_property() {
  if (property_ != NULL) property_->Clear();
  clear_has_property();
}
inline const ::sg::ElementProperty& DungeonElement::_internal_property() const {
  return *property_;
}
inline const ::sg::ElementProperty& DungeonElement::property() const {
  const ::sg::ElementProperty* p = property_;
  // @@protoc_insertion_point(field_get:sg.DungeonElement.property)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::ElementProperty*>(
      &::sg::_ElementProperty_default_instance_);
}
inline ::sg::ElementProperty* DungeonElement::release_property() {
  // @@protoc_insertion_point(field_release:sg.DungeonElement.property)
  clear_has_property();
  ::sg::ElementProperty* temp = property_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  property_ = NULL;
  return temp;
}
inline ::sg::ElementProperty* DungeonElement::unsafe_arena_release_property() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.DungeonElement.property)
  clear_has_property();
  ::sg::ElementProperty* temp = property_;
  property_ = NULL;
  return temp;
}
inline ::sg::ElementProperty* DungeonElement::mutable_property() {
  set_has_property();
  if (property_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::ElementProperty>(GetArenaNoVirtual());
    property_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.DungeonElement.property)
  return property_;
}
inline void DungeonElement::set_allocated_property(::sg::ElementProperty* property) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete property_;
  }
  if (property) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(property);
    if (message_arena != submessage_arena) {
      property = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, property, submessage_arena);
    }
    set_has_property();
  } else {
    clear_has_property();
  }
  property_ = property;
  // @@protoc_insertion_point(field_set_allocated:sg.DungeonElement.property)
}

// repeated .sg.DungeonElement.Exchange exchange_list = 6;
inline int DungeonElement::exchange_list_size() const {
  return exchange_list_.size();
}
inline void DungeonElement::clear_exchange_list() {
  exchange_list_.Clear();
}
inline ::sg::DungeonElement_Exchange* DungeonElement::mutable_exchange_list(int index) {
  // @@protoc_insertion_point(field_mutable:sg.DungeonElement.exchange_list)
  return exchange_list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::DungeonElement_Exchange >*
DungeonElement::mutable_exchange_list() {
  // @@protoc_insertion_point(field_mutable_list:sg.DungeonElement.exchange_list)
  return &exchange_list_;
}
inline const ::sg::DungeonElement_Exchange& DungeonElement::exchange_list(int index) const {
  // @@protoc_insertion_point(field_get:sg.DungeonElement.exchange_list)
  return exchange_list_.Get(index);
}
inline ::sg::DungeonElement_Exchange* DungeonElement::add_exchange_list() {
  // @@protoc_insertion_point(field_add:sg.DungeonElement.exchange_list)
  return exchange_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::DungeonElement_Exchange >&
DungeonElement::exchange_list() const {
  // @@protoc_insertion_point(field_list:sg.DungeonElement.exchange_list)
  return exchange_list_;
}

// repeated int32 elements = 7;
inline int DungeonElement::elements_size() const {
  return elements_.size();
}
inline void DungeonElement::clear_elements() {
  elements_.Clear();
}
inline ::google::protobuf::int32 DungeonElement::elements(int index) const {
  // @@protoc_insertion_point(field_get:sg.DungeonElement.elements)
  return elements_.Get(index);
}
inline void DungeonElement::set_elements(int index, ::google::protobuf::int32 value) {
  elements_.Set(index, value);
  // @@protoc_insertion_point(field_set:sg.DungeonElement.elements)
}
inline void DungeonElement::add_elements(::google::protobuf::int32 value) {
  elements_.Add(value);
  // @@protoc_insertion_point(field_add:sg.DungeonElement.elements)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
DungeonElement::elements() const {
  // @@protoc_insertion_point(field_list:sg.DungeonElement.elements)
  return elements_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
DungeonElement::mutable_elements() {
  // @@protoc_insertion_point(field_mutable_list:sg.DungeonElement.elements)
  return &elements_;
}

// -------------------------------------------------------------------

// DungeonContent_PathBranch

// required int32 id = 1;
inline bool DungeonContent_PathBranch::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DungeonContent_PathBranch::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DungeonContent_PathBranch::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DungeonContent_PathBranch::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 DungeonContent_PathBranch::id() const {
  // @@protoc_insertion_point(field_get:sg.DungeonContent.PathBranch.id)
  return id_;
}
inline void DungeonContent_PathBranch::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:sg.DungeonContent.PathBranch.id)
}

// repeated .sg.pb_pair_int_int layer_change = 2;
inline int DungeonContent_PathBranch::layer_change_size() const {
  return layer_change_.size();
}
inline ::sg::pb_pair_int_int* DungeonContent_PathBranch::mutable_layer_change(int index) {
  // @@protoc_insertion_point(field_mutable:sg.DungeonContent.PathBranch.layer_change)
  return layer_change_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int >*
DungeonContent_PathBranch::mutable_layer_change() {
  // @@protoc_insertion_point(field_mutable_list:sg.DungeonContent.PathBranch.layer_change)
  return &layer_change_;
}
inline const ::sg::pb_pair_int_int& DungeonContent_PathBranch::layer_change(int index) const {
  // @@protoc_insertion_point(field_get:sg.DungeonContent.PathBranch.layer_change)
  return layer_change_.Get(index);
}
inline ::sg::pb_pair_int_int* DungeonContent_PathBranch::add_layer_change() {
  // @@protoc_insertion_point(field_add:sg.DungeonContent.PathBranch.layer_change)
  return layer_change_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int >&
DungeonContent_PathBranch::layer_change() const {
  // @@protoc_insertion_point(field_list:sg.DungeonContent.PathBranch.layer_change)
  return layer_change_;
}

// -------------------------------------------------------------------

// DungeonContent

// required int32 now_layer = 1;
inline bool DungeonContent::has_now_layer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DungeonContent::set_has_now_layer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DungeonContent::clear_has_now_layer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DungeonContent::clear_now_layer() {
  now_layer_ = 0;
  clear_has_now_layer();
}
inline ::google::protobuf::int32 DungeonContent::now_layer() const {
  // @@protoc_insertion_point(field_get:sg.DungeonContent.now_layer)
  return now_layer_;
}
inline void DungeonContent::set_now_layer(::google::protobuf::int32 value) {
  set_has_now_layer();
  now_layer_ = value;
  // @@protoc_insertion_point(field_set:sg.DungeonContent.now_layer)
}

// required int32 style = 2;
inline bool DungeonContent::has_style() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DungeonContent::set_has_style() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DungeonContent::clear_has_style() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DungeonContent::clear_style() {
  style_ = 0;
  clear_has_style();
}
inline ::google::protobuf::int32 DungeonContent::style() const {
  // @@protoc_insertion_point(field_get:sg.DungeonContent.style)
  return style_;
}
inline void DungeonContent::set_style(::google::protobuf::int32 value) {
  set_has_style();
  style_ = value;
  // @@protoc_insertion_point(field_set:sg.DungeonContent.style)
}

// required int32 monster_level = 3;
inline bool DungeonContent::has_monster_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DungeonContent::set_has_monster_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DungeonContent::clear_has_monster_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DungeonContent::clear_monster_level() {
  monster_level_ = 0;
  clear_has_monster_level();
}
inline ::google::protobuf::int32 DungeonContent::monster_level() const {
  // @@protoc_insertion_point(field_get:sg.DungeonContent.monster_level)
  return monster_level_;
}
inline void DungeonContent::set_monster_level(::google::protobuf::int32 value) {
  set_has_monster_level();
  monster_level_ = value;
  // @@protoc_insertion_point(field_set:sg.DungeonContent.monster_level)
}

// repeated .sg.DungeonElement elements = 4;
inline int DungeonContent::elements_size() const {
  return elements_.size();
}
inline void DungeonContent::clear_elements() {
  elements_.Clear();
}
inline ::sg::DungeonElement* DungeonContent::mutable_elements(int index) {
  // @@protoc_insertion_point(field_mutable:sg.DungeonContent.elements)
  return elements_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::DungeonElement >*
DungeonContent::mutable_elements() {
  // @@protoc_insertion_point(field_mutable_list:sg.DungeonContent.elements)
  return &elements_;
}
inline const ::sg::DungeonElement& DungeonContent::elements(int index) const {
  // @@protoc_insertion_point(field_get:sg.DungeonContent.elements)
  return elements_.Get(index);
}
inline ::sg::DungeonElement* DungeonContent::add_elements() {
  // @@protoc_insertion_point(field_add:sg.DungeonContent.elements)
  return elements_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::DungeonElement >&
DungeonContent::elements() const {
  // @@protoc_insertion_point(field_list:sg.DungeonContent.elements)
  return elements_;
}

// repeated .sg.DungeonContent.PathBranch path_choice = 5;
inline int DungeonContent::path_choice_size() const {
  return path_choice_.size();
}
inline void DungeonContent::clear_path_choice() {
  path_choice_.Clear();
}
inline ::sg::DungeonContent_PathBranch* DungeonContent::mutable_path_choice(int index) {
  // @@protoc_insertion_point(field_mutable:sg.DungeonContent.path_choice)
  return path_choice_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::DungeonContent_PathBranch >*
DungeonContent::mutable_path_choice() {
  // @@protoc_insertion_point(field_mutable_list:sg.DungeonContent.path_choice)
  return &path_choice_;
}
inline const ::sg::DungeonContent_PathBranch& DungeonContent::path_choice(int index) const {
  // @@protoc_insertion_point(field_get:sg.DungeonContent.path_choice)
  return path_choice_.Get(index);
}
inline ::sg::DungeonContent_PathBranch* DungeonContent::add_path_choice() {
  // @@protoc_insertion_point(field_add:sg.DungeonContent.path_choice)
  return path_choice_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::DungeonContent_PathBranch >&
DungeonContent::path_choice() const {
  // @@protoc_insertion_point(field_list:sg.DungeonContent.path_choice)
  return path_choice_;
}

// optional int32 real_layer = 6;
inline bool DungeonContent::has_real_layer() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DungeonContent::set_has_real_layer() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DungeonContent::clear_has_real_layer() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DungeonContent::clear_real_layer() {
  real_layer_ = 0;
  clear_has_real_layer();
}
inline ::google::protobuf::int32 DungeonContent::real_layer() const {
  // @@protoc_insertion_point(field_get:sg.DungeonContent.real_layer)
  return real_layer_;
}
inline void DungeonContent::set_real_layer(::google::protobuf::int32 value) {
  set_has_real_layer();
  real_layer_ = value;
  // @@protoc_insertion_point(field_set:sg.DungeonContent.real_layer)
}

// optional int32 model_id = 7;
inline bool DungeonContent::has_model_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DungeonContent::set_has_model_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DungeonContent::clear_has_model_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DungeonContent::clear_model_id() {
  model_id_ = 0;
  clear_has_model_id();
}
inline ::google::protobuf::int32 DungeonContent::model_id() const {
  // @@protoc_insertion_point(field_get:sg.DungeonContent.model_id)
  return model_id_;
}
inline void DungeonContent::set_model_id(::google::protobuf::int32 value) {
  set_has_model_id();
  model_id_ = value;
  // @@protoc_insertion_point(field_set:sg.DungeonContent.model_id)
}

// repeated .sg.Enemy enemys = 8;
inline int DungeonContent::enemys_size() const {
  return enemys_.size();
}
inline void DungeonContent::clear_enemys() {
  enemys_.Clear();
}
inline ::sg::Enemy* DungeonContent::mutable_enemys(int index) {
  // @@protoc_insertion_point(field_mutable:sg.DungeonContent.enemys)
  return enemys_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::Enemy >*
DungeonContent::mutable_enemys() {
  // @@protoc_insertion_point(field_mutable_list:sg.DungeonContent.enemys)
  return &enemys_;
}
inline const ::sg::Enemy& DungeonContent::enemys(int index) const {
  // @@protoc_insertion_point(field_get:sg.DungeonContent.enemys)
  return enemys_.Get(index);
}
inline ::sg::Enemy* DungeonContent::add_enemys() {
  // @@protoc_insertion_point(field_add:sg.DungeonContent.enemys)
  return enemys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::Enemy >&
DungeonContent::enemys() const {
  // @@protoc_insertion_point(field_list:sg.DungeonContent.enemys)
  return enemys_;
}

// -------------------------------------------------------------------

// UserTeamData

// required int32 user_level = 1;
inline bool UserTeamData::has_user_level() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserTeamData::set_has_user_level() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserTeamData::clear_has_user_level() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserTeamData::clear_user_level() {
  user_level_ = 0;
  clear_has_user_level();
}
inline ::google::protobuf::int32 UserTeamData::user_level() const {
  // @@protoc_insertion_point(field_get:sg.UserTeamData.user_level)
  return user_level_;
}
inline void UserTeamData::set_user_level(::google::protobuf::int32 value) {
  set_has_user_level();
  user_level_ = value;
  // @@protoc_insertion_point(field_set:sg.UserTeamData.user_level)
}

// repeated .sg.SailorInDungeon team = 2;
inline int UserTeamData::team_size() const {
  return team_.size();
}
inline void UserTeamData::clear_team() {
  team_.Clear();
}
inline ::sg::SailorInDungeon* UserTeamData::mutable_team(int index) {
  // @@protoc_insertion_point(field_mutable:sg.UserTeamData.team)
  return team_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::SailorInDungeon >*
UserTeamData::mutable_team() {
  // @@protoc_insertion_point(field_mutable_list:sg.UserTeamData.team)
  return &team_;
}
inline const ::sg::SailorInDungeon& UserTeamData::team(int index) const {
  // @@protoc_insertion_point(field_get:sg.UserTeamData.team)
  return team_.Get(index);
}
inline ::sg::SailorInDungeon* UserTeamData::add_team() {
  // @@protoc_insertion_point(field_add:sg.UserTeamData.team)
  return team_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::SailorInDungeon >&
UserTeamData::team() const {
  // @@protoc_insertion_point(field_list:sg.UserTeamData.team)
  return team_;
}

// repeated .sg.pb_pair_int_int talents = 3;
inline int UserTeamData::talents_size() const {
  return talents_.size();
}
inline ::sg::pb_pair_int_int* UserTeamData::mutable_talents(int index) {
  // @@protoc_insertion_point(field_mutable:sg.UserTeamData.talents)
  return talents_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int >*
UserTeamData::mutable_talents() {
  // @@protoc_insertion_point(field_mutable_list:sg.UserTeamData.talents)
  return &talents_;
}
inline const ::sg::pb_pair_int_int& UserTeamData::talents(int index) const {
  // @@protoc_insertion_point(field_get:sg.UserTeamData.talents)
  return talents_.Get(index);
}
inline ::sg::pb_pair_int_int* UserTeamData::add_talents() {
  // @@protoc_insertion_point(field_add:sg.UserTeamData.talents)
  return talents_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int >&
UserTeamData::talents() const {
  // @@protoc_insertion_point(field_list:sg.UserTeamData.talents)
  return talents_;
}

// -------------------------------------------------------------------

// UserDungeonInformation_ElementCount

// required int32 type = 1;
inline bool UserDungeonInformation_ElementCount::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserDungeonInformation_ElementCount::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserDungeonInformation_ElementCount::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserDungeonInformation_ElementCount::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 UserDungeonInformation_ElementCount::type() const {
  // @@protoc_insertion_point(field_get:sg.UserDungeonInformation.ElementCount.type)
  return type_;
}
inline void UserDungeonInformation_ElementCount::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:sg.UserDungeonInformation.ElementCount.type)
}

// required int32 typeid = 2;
inline bool UserDungeonInformation_ElementCount::has_typeid_() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserDungeonInformation_ElementCount::set_has_typeid_() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserDungeonInformation_ElementCount::clear_has_typeid_() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserDungeonInformation_ElementCount::clear_typeid_() {
  typeid__ = 0;
  clear_has_typeid_();
}
inline ::google::protobuf::int32 UserDungeonInformation_ElementCount::typeid_() const {
  // @@protoc_insertion_point(field_get:sg.UserDungeonInformation.ElementCount.typeid)
  return typeid__;
}
inline void UserDungeonInformation_ElementCount::set_typeid_(::google::protobuf::int32 value) {
  set_has_typeid_();
  typeid__ = value;
  // @@protoc_insertion_point(field_set:sg.UserDungeonInformation.ElementCount.typeid)
}

// required int32 num = 3;
inline bool UserDungeonInformation_ElementCount::has_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserDungeonInformation_ElementCount::set_has_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserDungeonInformation_ElementCount::clear_has_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserDungeonInformation_ElementCount::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 UserDungeonInformation_ElementCount::num() const {
  // @@protoc_insertion_point(field_get:sg.UserDungeonInformation.ElementCount.num)
  return num_;
}
inline void UserDungeonInformation_ElementCount::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
  // @@protoc_insertion_point(field_set:sg.UserDungeonInformation.ElementCount.num)
}

// -------------------------------------------------------------------

// UserDungeonInformation

// optional int32 revive_times = 1;
inline bool UserDungeonInformation::has_revive_times() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserDungeonInformation::set_has_revive_times() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserDungeonInformation::clear_has_revive_times() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserDungeonInformation::clear_revive_times() {
  revive_times_ = 0;
  clear_has_revive_times();
}
inline ::google::protobuf::int32 UserDungeonInformation::revive_times() const {
  // @@protoc_insertion_point(field_get:sg.UserDungeonInformation.revive_times)
  return revive_times_;
}
inline void UserDungeonInformation::set_revive_times(::google::protobuf::int32 value) {
  set_has_revive_times();
  revive_times_ = value;
  // @@protoc_insertion_point(field_set:sg.UserDungeonInformation.revive_times)
}

// repeated .sg.pb_pair_int_int talents = 3;
inline int UserDungeonInformation::talents_size() const {
  return talents_.size();
}
inline ::sg::pb_pair_int_int* UserDungeonInformation::mutable_talents(int index) {
  // @@protoc_insertion_point(field_mutable:sg.UserDungeonInformation.talents)
  return talents_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int >*
UserDungeonInformation::mutable_talents() {
  // @@protoc_insertion_point(field_mutable_list:sg.UserDungeonInformation.talents)
  return &talents_;
}
inline const ::sg::pb_pair_int_int& UserDungeonInformation::talents(int index) const {
  // @@protoc_insertion_point(field_get:sg.UserDungeonInformation.talents)
  return talents_.Get(index);
}
inline ::sg::pb_pair_int_int* UserDungeonInformation::add_talents() {
  // @@protoc_insertion_point(field_add:sg.UserDungeonInformation.talents)
  return talents_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int >&
UserDungeonInformation::talents() const {
  // @@protoc_insertion_point(field_list:sg.UserDungeonInformation.talents)
  return talents_;
}

// repeated .sg.pb_pair_int_int packages = 4;
inline int UserDungeonInformation::packages_size() const {
  return packages_.size();
}
inline ::sg::pb_pair_int_int* UserDungeonInformation::mutable_packages(int index) {
  // @@protoc_insertion_point(field_mutable:sg.UserDungeonInformation.packages)
  return packages_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int >*
UserDungeonInformation::mutable_packages() {
  // @@protoc_insertion_point(field_mutable_list:sg.UserDungeonInformation.packages)
  return &packages_;
}
inline const ::sg::pb_pair_int_int& UserDungeonInformation::packages(int index) const {
  // @@protoc_insertion_point(field_get:sg.UserDungeonInformation.packages)
  return packages_.Get(index);
}
inline ::sg::pb_pair_int_int* UserDungeonInformation::add_packages() {
  // @@protoc_insertion_point(field_add:sg.UserDungeonInformation.packages)
  return packages_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int >&
UserDungeonInformation::packages() const {
  // @@protoc_insertion_point(field_list:sg.UserDungeonInformation.packages)
  return packages_;
}

// repeated int64 saved_npc = 5;
inline int UserDungeonInformation::saved_npc_size() const {
  return saved_npc_.size();
}
inline void UserDungeonInformation::clear_saved_npc() {
  saved_npc_.Clear();
}
inline ::google::protobuf::int64 UserDungeonInformation::saved_npc(int index) const {
  // @@protoc_insertion_point(field_get:sg.UserDungeonInformation.saved_npc)
  return saved_npc_.Get(index);
}
inline void UserDungeonInformation::set_saved_npc(int index, ::google::protobuf::int64 value) {
  saved_npc_.Set(index, value);
  // @@protoc_insertion_point(field_set:sg.UserDungeonInformation.saved_npc)
}
inline void UserDungeonInformation::add_saved_npc(::google::protobuf::int64 value) {
  saved_npc_.Add(value);
  // @@protoc_insertion_point(field_add:sg.UserDungeonInformation.saved_npc)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
UserDungeonInformation::saved_npc() const {
  // @@protoc_insertion_point(field_list:sg.UserDungeonInformation.saved_npc)
  return saved_npc_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
UserDungeonInformation::mutable_saved_npc() {
  // @@protoc_insertion_point(field_mutable_list:sg.UserDungeonInformation.saved_npc)
  return &saved_npc_;
}

// repeated int64 saved_customers = 6;
inline int UserDungeonInformation::saved_customers_size() const {
  return saved_customers_.size();
}
inline void UserDungeonInformation::clear_saved_customers() {
  saved_customers_.Clear();
}
inline ::google::protobuf::int64 UserDungeonInformation::saved_customers(int index) const {
  // @@protoc_insertion_point(field_get:sg.UserDungeonInformation.saved_customers)
  return saved_customers_.Get(index);
}
inline void UserDungeonInformation::set_saved_customers(int index, ::google::protobuf::int64 value) {
  saved_customers_.Set(index, value);
  // @@protoc_insertion_point(field_set:sg.UserDungeonInformation.saved_customers)
}
inline void UserDungeonInformation::add_saved_customers(::google::protobuf::int64 value) {
  saved_customers_.Add(value);
  // @@protoc_insertion_point(field_add:sg.UserDungeonInformation.saved_customers)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
UserDungeonInformation::saved_customers() const {
  // @@protoc_insertion_point(field_list:sg.UserDungeonInformation.saved_customers)
  return saved_customers_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
UserDungeonInformation::mutable_saved_customers() {
  // @@protoc_insertion_point(field_mutable_list:sg.UserDungeonInformation.saved_customers)
  return &saved_customers_;
}

// repeated int64 triggered_event = 7;
inline int UserDungeonInformation::triggered_event_size() const {
  return triggered_event_.size();
}
inline void UserDungeonInformation::clear_triggered_event() {
  triggered_event_.Clear();
}
inline ::google::protobuf::int64 UserDungeonInformation::triggered_event(int index) const {
  // @@protoc_insertion_point(field_get:sg.UserDungeonInformation.triggered_event)
  return triggered_event_.Get(index);
}
inline void UserDungeonInformation::set_triggered_event(int index, ::google::protobuf::int64 value) {
  triggered_event_.Set(index, value);
  // @@protoc_insertion_point(field_set:sg.UserDungeonInformation.triggered_event)
}
inline void UserDungeonInformation::add_triggered_event(::google::protobuf::int64 value) {
  triggered_event_.Add(value);
  // @@protoc_insertion_point(field_add:sg.UserDungeonInformation.triggered_event)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
UserDungeonInformation::triggered_event() const {
  // @@protoc_insertion_point(field_list:sg.UserDungeonInformation.triggered_event)
  return triggered_event_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
UserDungeonInformation::mutable_triggered_event() {
  // @@protoc_insertion_point(field_mutable_list:sg.UserDungeonInformation.triggered_event)
  return &triggered_event_;
}

// optional int32 occupation = 8;
inline bool UserDungeonInformation::has_occupation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserDungeonInformation::set_has_occupation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserDungeonInformation::clear_has_occupation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserDungeonInformation::clear_occupation() {
  occupation_ = 0;
  clear_has_occupation();
}
inline ::google::protobuf::int32 UserDungeonInformation::occupation() const {
  // @@protoc_insertion_point(field_get:sg.UserDungeonInformation.occupation)
  return occupation_;
}
inline void UserDungeonInformation::set_occupation(::google::protobuf::int32 value) {
  set_has_occupation();
  occupation_ = value;
  // @@protoc_insertion_point(field_set:sg.UserDungeonInformation.occupation)
}

// repeated .sg.pb_pair_int_int secret_room_distribute = 9;
inline int UserDungeonInformation::secret_room_distribute_size() const {
  return secret_room_distribute_.size();
}
inline ::sg::pb_pair_int_int* UserDungeonInformation::mutable_secret_room_distribute(int index) {
  // @@protoc_insertion_point(field_mutable:sg.UserDungeonInformation.secret_room_distribute)
  return secret_room_distribute_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int >*
UserDungeonInformation::mutable_secret_room_distribute() {
  // @@protoc_insertion_point(field_mutable_list:sg.UserDungeonInformation.secret_room_distribute)
  return &secret_room_distribute_;
}
inline const ::sg::pb_pair_int_int& UserDungeonInformation::secret_room_distribute(int index) const {
  // @@protoc_insertion_point(field_get:sg.UserDungeonInformation.secret_room_distribute)
  return secret_room_distribute_.Get(index);
}
inline ::sg::pb_pair_int_int* UserDungeonInformation::add_secret_room_distribute() {
  // @@protoc_insertion_point(field_add:sg.UserDungeonInformation.secret_room_distribute)
  return secret_room_distribute_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int >&
UserDungeonInformation::secret_room_distribute() const {
  // @@protoc_insertion_point(field_list:sg.UserDungeonInformation.secret_room_distribute)
  return secret_room_distribute_;
}

// repeated .sg.pb_pair_int_int layer_change = 10;
inline int UserDungeonInformation::layer_change_size() const {
  return layer_change_.size();
}
inline ::sg::pb_pair_int_int* UserDungeonInformation::mutable_layer_change(int index) {
  // @@protoc_insertion_point(field_mutable:sg.UserDungeonInformation.layer_change)
  return layer_change_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int >*
UserDungeonInformation::mutable_layer_change() {
  // @@protoc_insertion_point(field_mutable_list:sg.UserDungeonInformation.layer_change)
  return &layer_change_;
}
inline const ::sg::pb_pair_int_int& UserDungeonInformation::layer_change(int index) const {
  // @@protoc_insertion_point(field_get:sg.UserDungeonInformation.layer_change)
  return layer_change_.Get(index);
}
inline ::sg::pb_pair_int_int* UserDungeonInformation::add_layer_change() {
  // @@protoc_insertion_point(field_add:sg.UserDungeonInformation.layer_change)
  return layer_change_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int >&
UserDungeonInformation::layer_change() const {
  // @@protoc_insertion_point(field_list:sg.UserDungeonInformation.layer_change)
  return layer_change_;
}

// repeated .sg.MonsterInDungeon friendly_monsters = 11;
inline int UserDungeonInformation::friendly_monsters_size() const {
  return friendly_monsters_.size();
}
inline void UserDungeonInformation::clear_friendly_monsters() {
  friendly_monsters_.Clear();
}
inline ::sg::MonsterInDungeon* UserDungeonInformation::mutable_friendly_monsters(int index) {
  // @@protoc_insertion_point(field_mutable:sg.UserDungeonInformation.friendly_monsters)
  return friendly_monsters_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::MonsterInDungeon >*
UserDungeonInformation::mutable_friendly_monsters() {
  // @@protoc_insertion_point(field_mutable_list:sg.UserDungeonInformation.friendly_monsters)
  return &friendly_monsters_;
}
inline const ::sg::MonsterInDungeon& UserDungeonInformation::friendly_monsters(int index) const {
  // @@protoc_insertion_point(field_get:sg.UserDungeonInformation.friendly_monsters)
  return friendly_monsters_.Get(index);
}
inline ::sg::MonsterInDungeon* UserDungeonInformation::add_friendly_monsters() {
  // @@protoc_insertion_point(field_add:sg.UserDungeonInformation.friendly_monsters)
  return friendly_monsters_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::MonsterInDungeon >&
UserDungeonInformation::friendly_monsters() const {
  // @@protoc_insertion_point(field_list:sg.UserDungeonInformation.friendly_monsters)
  return friendly_monsters_;
}

// repeated .sg.DungeonAltar altars = 12;
inline int UserDungeonInformation::altars_size() const {
  return altars_.size();
}
inline void UserDungeonInformation::clear_altars() {
  altars_.Clear();
}
inline ::sg::DungeonAltar* UserDungeonInformation::mutable_altars(int index) {
  // @@protoc_insertion_point(field_mutable:sg.UserDungeonInformation.altars)
  return altars_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::DungeonAltar >*
UserDungeonInformation::mutable_altars() {
  // @@protoc_insertion_point(field_mutable_list:sg.UserDungeonInformation.altars)
  return &altars_;
}
inline const ::sg::DungeonAltar& UserDungeonInformation::altars(int index) const {
  // @@protoc_insertion_point(field_get:sg.UserDungeonInformation.altars)
  return altars_.Get(index);
}
inline ::sg::DungeonAltar* UserDungeonInformation::add_altars() {
  // @@protoc_insertion_point(field_add:sg.UserDungeonInformation.altars)
  return altars_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::DungeonAltar >&
UserDungeonInformation::altars() const {
  // @@protoc_insertion_point(field_list:sg.UserDungeonInformation.altars)
  return altars_;
}

// repeated .sg.UserDungeonInformation.ElementCount element_count = 13;
inline int UserDungeonInformation::element_count_size() const {
  return element_count_.size();
}
inline void UserDungeonInformation::clear_element_count() {
  element_count_.Clear();
}
inline ::sg::UserDungeonInformation_ElementCount* UserDungeonInformation::mutable_element_count(int index) {
  // @@protoc_insertion_point(field_mutable:sg.UserDungeonInformation.element_count)
  return element_count_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::UserDungeonInformation_ElementCount >*
UserDungeonInformation::mutable_element_count() {
  // @@protoc_insertion_point(field_mutable_list:sg.UserDungeonInformation.element_count)
  return &element_count_;
}
inline const ::sg::UserDungeonInformation_ElementCount& UserDungeonInformation::element_count(int index) const {
  // @@protoc_insertion_point(field_get:sg.UserDungeonInformation.element_count)
  return element_count_.Get(index);
}
inline ::sg::UserDungeonInformation_ElementCount* UserDungeonInformation::add_element_count() {
  // @@protoc_insertion_point(field_add:sg.UserDungeonInformation.element_count)
  return element_count_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::UserDungeonInformation_ElementCount >&
UserDungeonInformation::element_count() const {
  // @@protoc_insertion_point(field_list:sg.UserDungeonInformation.element_count)
  return element_count_;
}

// -------------------------------------------------------------------

// UserDungeonOperation

// required int32 operation_type = 1;
inline bool UserDungeonOperation::has_operation_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserDungeonOperation::set_has_operation_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserDungeonOperation::clear_has_operation_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserDungeonOperation::clear_operation_type() {
  operation_type_ = 0;
  clear_has_operation_type();
}
inline ::google::protobuf::int32 UserDungeonOperation::operation_type() const {
  // @@protoc_insertion_point(field_get:sg.UserDungeonOperation.operation_type)
  return operation_type_;
}
inline void UserDungeonOperation::set_operation_type(::google::protobuf::int32 value) {
  set_has_operation_type();
  operation_type_ = value;
  // @@protoc_insertion_point(field_set:sg.UserDungeonOperation.operation_type)
}

// optional int32 target_element = 2;
inline bool UserDungeonOperation::has_target_element() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserDungeonOperation::set_has_target_element() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserDungeonOperation::clear_has_target_element() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserDungeonOperation::clear_target_element() {
  target_element_ = 0;
  clear_has_target_element();
}
inline ::google::protobuf::int32 UserDungeonOperation::target_element() const {
  // @@protoc_insertion_point(field_get:sg.UserDungeonOperation.target_element)
  return target_element_;
}
inline void UserDungeonOperation::set_target_element(::google::protobuf::int32 value) {
  set_has_target_element();
  target_element_ = value;
  // @@protoc_insertion_point(field_set:sg.UserDungeonOperation.target_element)
}

// optional int32 operation_param = 3;
inline bool UserDungeonOperation::has_operation_param() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserDungeonOperation::set_has_operation_param() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserDungeonOperation::clear_has_operation_param() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserDungeonOperation::clear_operation_param() {
  operation_param_ = 0;
  clear_has_operation_param();
}
inline ::google::protobuf::int32 UserDungeonOperation::operation_param() const {
  // @@protoc_insertion_point(field_get:sg.UserDungeonOperation.operation_param)
  return operation_param_;
}
inline void UserDungeonOperation::set_operation_param(::google::protobuf::int32 value) {
  set_has_operation_param();
  operation_param_ = value;
  // @@protoc_insertion_point(field_set:sg.UserDungeonOperation.operation_param)
}

// optional bytes data = 4;
inline bool UserDungeonOperation::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserDungeonOperation::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserDungeonOperation::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserDungeonOperation::clear_data() {
  data_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_data();
}
inline const ::std::string& UserDungeonOperation::data() const {
  // @@protoc_insertion_point(field_get:sg.UserDungeonOperation.data)
  return data_.Get();
}
inline void UserDungeonOperation::set_data(const ::std::string& value) {
  set_has_data();
  data_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:sg.UserDungeonOperation.data)
}
#if LANG_CXX11
inline void UserDungeonOperation::set_data(::std::string&& value) {
  set_has_data();
  data_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:sg.UserDungeonOperation.data)
}
#endif
inline void UserDungeonOperation::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_data();
  data_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:sg.UserDungeonOperation.data)
}
inline void UserDungeonOperation::set_data(const void* value,
    size_t size) {
  set_has_data();
  data_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:sg.UserDungeonOperation.data)
}
inline ::std::string* UserDungeonOperation::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:sg.UserDungeonOperation.data)
  return data_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* UserDungeonOperation::release_data() {
  // @@protoc_insertion_point(field_release:sg.UserDungeonOperation.data)
  if (!has_data()) {
    return NULL;
  }
  clear_has_data();
  return data_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void UserDungeonOperation::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:sg.UserDungeonOperation.data)
}
inline ::std::string* UserDungeonOperation::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.UserDungeonOperation.data)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_data();
  return data_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void UserDungeonOperation::unsafe_arena_set_allocated_data(
    ::std::string* data) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      data, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sg.UserDungeonOperation.data)
}

// -------------------------------------------------------------------

// DungeonEvent

// required int32 id = 1;
inline bool DungeonEvent::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DungeonEvent::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DungeonEvent::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DungeonEvent::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 DungeonEvent::id() const {
  // @@protoc_insertion_point(field_get:sg.DungeonEvent.id)
  return id_;
}
inline void DungeonEvent::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:sg.DungeonEvent.id)
}

// required int32 state = 2;
inline bool DungeonEvent::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DungeonEvent::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DungeonEvent::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DungeonEvent::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 DungeonEvent::state() const {
  // @@protoc_insertion_point(field_get:sg.DungeonEvent.state)
  return state_;
}
inline void DungeonEvent::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:sg.DungeonEvent.state)
}

// required int32 finish_value = 3;
inline bool DungeonEvent::has_finish_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DungeonEvent::set_has_finish_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DungeonEvent::clear_has_finish_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DungeonEvent::clear_finish_value() {
  finish_value_ = 0;
  clear_has_finish_value();
}
inline ::google::protobuf::int32 DungeonEvent::finish_value() const {
  // @@protoc_insertion_point(field_get:sg.DungeonEvent.finish_value)
  return finish_value_;
}
inline void DungeonEvent::set_finish_value(::google::protobuf::int32 value) {
  set_has_finish_value();
  finish_value_ = value;
  // @@protoc_insertion_point(field_set:sg.DungeonEvent.finish_value)
}

// optional int32 require_value = 4;
inline bool DungeonEvent::has_require_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DungeonEvent::set_has_require_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DungeonEvent::clear_has_require_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DungeonEvent::clear_require_value() {
  require_value_ = 0;
  clear_has_require_value();
}
inline ::google::protobuf::int32 DungeonEvent::require_value() const {
  // @@protoc_insertion_point(field_get:sg.DungeonEvent.require_value)
  return require_value_;
}
inline void DungeonEvent::set_require_value(::google::protobuf::int32 value) {
  set_has_require_value();
  require_value_ = value;
  // @@protoc_insertion_point(field_set:sg.DungeonEvent.require_value)
}

// -------------------------------------------------------------------

// ShipData

// required bytes userid = 1;
inline bool ShipData::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShipData::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShipData::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShipData::clear_userid() {
  userid_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_userid();
}
inline const ::std::string& ShipData::userid() const {
  // @@protoc_insertion_point(field_get:sg.ShipData.userid)
  return userid_.Get();
}
inline void ShipData::set_userid(const ::std::string& value) {
  set_has_userid();
  userid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:sg.ShipData.userid)
}
#if LANG_CXX11
inline void ShipData::set_userid(::std::string&& value) {
  set_has_userid();
  userid_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:sg.ShipData.userid)
}
#endif
inline void ShipData::set_userid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_userid();
  userid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:sg.ShipData.userid)
}
inline void ShipData::set_userid(const void* value,
    size_t size) {
  set_has_userid();
  userid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:sg.ShipData.userid)
}
inline ::std::string* ShipData::mutable_userid() {
  set_has_userid();
  // @@protoc_insertion_point(field_mutable:sg.ShipData.userid)
  return userid_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* ShipData::release_userid() {
  // @@protoc_insertion_point(field_release:sg.ShipData.userid)
  if (!has_userid()) {
    return NULL;
  }
  clear_has_userid();
  return userid_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void ShipData::set_allocated_userid(::std::string* userid) {
  if (userid != NULL) {
    set_has_userid();
  } else {
    clear_has_userid();
  }
  userid_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), userid,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:sg.ShipData.userid)
}
inline ::std::string* ShipData::unsafe_arena_release_userid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.ShipData.userid)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_userid();
  return userid_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void ShipData::unsafe_arena_set_allocated_userid(
    ::std::string* userid) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (userid != NULL) {
    set_has_userid();
  } else {
    clear_has_userid();
  }
  userid_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      userid, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sg.ShipData.userid)
}

// required int32 ship_model = 2;
inline bool ShipData::has_ship_model() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ShipData::set_has_ship_model() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ShipData::clear_has_ship_model() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ShipData::clear_ship_model() {
  ship_model_ = 0;
  clear_has_ship_model();
}
inline ::google::protobuf::int32 ShipData::ship_model() const {
  // @@protoc_insertion_point(field_get:sg.ShipData.ship_model)
  return ship_model_;
}
inline void ShipData::set_ship_model(::google::protobuf::int32 value) {
  set_has_ship_model();
  ship_model_ = value;
  // @@protoc_insertion_point(field_set:sg.ShipData.ship_model)
}

// optional bytes rooms = 3;
inline bool ShipData::has_rooms() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShipData::set_has_rooms() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShipData::clear_has_rooms() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShipData::clear_rooms() {
  rooms_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_rooms();
}
inline const ::std::string& ShipData::rooms() const {
  // @@protoc_insertion_point(field_get:sg.ShipData.rooms)
  return rooms_.Get();
}
inline void ShipData::set_rooms(const ::std::string& value) {
  set_has_rooms();
  rooms_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:sg.ShipData.rooms)
}
#if LANG_CXX11
inline void ShipData::set_rooms(::std::string&& value) {
  set_has_rooms();
  rooms_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:sg.ShipData.rooms)
}
#endif
inline void ShipData::set_rooms(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_rooms();
  rooms_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:sg.ShipData.rooms)
}
inline void ShipData::set_rooms(const void* value,
    size_t size) {
  set_has_rooms();
  rooms_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:sg.ShipData.rooms)
}
inline ::std::string* ShipData::mutable_rooms() {
  set_has_rooms();
  // @@protoc_insertion_point(field_mutable:sg.ShipData.rooms)
  return rooms_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* ShipData::release_rooms() {
  // @@protoc_insertion_point(field_release:sg.ShipData.rooms)
  if (!has_rooms()) {
    return NULL;
  }
  clear_has_rooms();
  return rooms_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void ShipData::set_allocated_rooms(::std::string* rooms) {
  if (rooms != NULL) {
    set_has_rooms();
  } else {
    clear_has_rooms();
  }
  rooms_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), rooms,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:sg.ShipData.rooms)
}
inline ::std::string* ShipData::unsafe_arena_release_rooms() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.ShipData.rooms)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_rooms();
  return rooms_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void ShipData::unsafe_arena_set_allocated_rooms(
    ::std::string* rooms) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (rooms != NULL) {
    set_has_rooms();
  } else {
    clear_has_rooms();
  }
  rooms_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      rooms, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sg.ShipData.rooms)
}

// optional bytes ship_tiles = 4;
inline bool ShipData::has_ship_tiles() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShipData::set_has_ship_tiles() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ShipData::clear_has_ship_tiles() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ShipData::clear_ship_tiles() {
  ship_tiles_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_ship_tiles();
}
inline const ::std::string& ShipData::ship_tiles() const {
  // @@protoc_insertion_point(field_get:sg.ShipData.ship_tiles)
  return ship_tiles_.Get();
}
inline void ShipData::set_ship_tiles(const ::std::string& value) {
  set_has_ship_tiles();
  ship_tiles_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:sg.ShipData.ship_tiles)
}
#if LANG_CXX11
inline void ShipData::set_ship_tiles(::std::string&& value) {
  set_has_ship_tiles();
  ship_tiles_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:sg.ShipData.ship_tiles)
}
#endif
inline void ShipData::set_ship_tiles(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ship_tiles();
  ship_tiles_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:sg.ShipData.ship_tiles)
}
inline void ShipData::set_ship_tiles(const void* value,
    size_t size) {
  set_has_ship_tiles();
  ship_tiles_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:sg.ShipData.ship_tiles)
}
inline ::std::string* ShipData::mutable_ship_tiles() {
  set_has_ship_tiles();
  // @@protoc_insertion_point(field_mutable:sg.ShipData.ship_tiles)
  return ship_tiles_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* ShipData::release_ship_tiles() {
  // @@protoc_insertion_point(field_release:sg.ShipData.ship_tiles)
  if (!has_ship_tiles()) {
    return NULL;
  }
  clear_has_ship_tiles();
  return ship_tiles_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void ShipData::set_allocated_ship_tiles(::std::string* ship_tiles) {
  if (ship_tiles != NULL) {
    set_has_ship_tiles();
  } else {
    clear_has_ship_tiles();
  }
  ship_tiles_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ship_tiles,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:sg.ShipData.ship_tiles)
}
inline ::std::string* ShipData::unsafe_arena_release_ship_tiles() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.ShipData.ship_tiles)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_ship_tiles();
  return ship_tiles_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void ShipData::unsafe_arena_set_allocated_ship_tiles(
    ::std::string* ship_tiles) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (ship_tiles != NULL) {
    set_has_ship_tiles();
  } else {
    clear_has_ship_tiles();
  }
  ship_tiles_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ship_tiles, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sg.ShipData.ship_tiles)
}

// required bytes facilitys = 5;
inline bool ShipData::has_facilitys() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ShipData::set_has_facilitys() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ShipData::clear_has_facilitys() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ShipData::clear_facilitys() {
  facilitys_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_facilitys();
}
inline const ::std::string& ShipData::facilitys() const {
  // @@protoc_insertion_point(field_get:sg.ShipData.facilitys)
  return facilitys_.Get();
}
inline void ShipData::set_facilitys(const ::std::string& value) {
  set_has_facilitys();
  facilitys_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:sg.ShipData.facilitys)
}
#if LANG_CXX11
inline void ShipData::set_facilitys(::std::string&& value) {
  set_has_facilitys();
  facilitys_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:sg.ShipData.facilitys)
}
#endif
inline void ShipData::set_facilitys(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_facilitys();
  facilitys_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:sg.ShipData.facilitys)
}
inline void ShipData::set_facilitys(const void* value,
    size_t size) {
  set_has_facilitys();
  facilitys_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:sg.ShipData.facilitys)
}
inline ::std::string* ShipData::mutable_facilitys() {
  set_has_facilitys();
  // @@protoc_insertion_point(field_mutable:sg.ShipData.facilitys)
  return facilitys_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* ShipData::release_facilitys() {
  // @@protoc_insertion_point(field_release:sg.ShipData.facilitys)
  if (!has_facilitys()) {
    return NULL;
  }
  clear_has_facilitys();
  return facilitys_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void ShipData::set_allocated_facilitys(::std::string* facilitys) {
  if (facilitys != NULL) {
    set_has_facilitys();
  } else {
    clear_has_facilitys();
  }
  facilitys_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), facilitys,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:sg.ShipData.facilitys)
}
inline ::std::string* ShipData::unsafe_arena_release_facilitys() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.ShipData.facilitys)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_facilitys();
  return facilitys_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void ShipData::unsafe_arena_set_allocated_facilitys(
    ::std::string* facilitys) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (facilitys != NULL) {
    set_has_facilitys();
  } else {
    clear_has_facilitys();
  }
  facilitys_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      facilitys, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sg.ShipData.facilitys)
}

// repeated .sg.Sailor sailors = 6;
inline int ShipData::sailors_size() const {
  return sailors_.size();
}
inline ::sg::Sailor* ShipData::mutable_sailors(int index) {
  // @@protoc_insertion_point(field_mutable:sg.ShipData.sailors)
  return sailors_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::Sailor >*
ShipData::mutable_sailors() {
  // @@protoc_insertion_point(field_mutable_list:sg.ShipData.sailors)
  return &sailors_;
}
inline const ::sg::Sailor& ShipData::sailors(int index) const {
  // @@protoc_insertion_point(field_get:sg.ShipData.sailors)
  return sailors_.Get(index);
}
inline ::sg::Sailor* ShipData::add_sailors() {
  // @@protoc_insertion_point(field_add:sg.ShipData.sailors)
  return sailors_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::Sailor >&
ShipData::sailors() const {
  // @@protoc_insertion_point(field_list:sg.ShipData.sailors)
  return sailors_;
}

// -------------------------------------------------------------------

// PveFacility

// required int32 id = 1;
inline bool PveFacility::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PveFacility::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PveFacility::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PveFacility::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 PveFacility::id() const {
  // @@protoc_insertion_point(field_get:sg.PveFacility.id)
  return id_;
}
inline void PveFacility::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:sg.PveFacility.id)
}

// required int32 typeid = 2;
inline bool PveFacility::has_typeid_() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PveFacility::set_has_typeid_() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PveFacility::clear_has_typeid_() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PveFacility::clear_typeid_() {
  typeid__ = 0;
  clear_has_typeid_();
}
inline ::google::protobuf::int32 PveFacility::typeid_() const {
  // @@protoc_insertion_point(field_get:sg.PveFacility.typeid)
  return typeid__;
}
inline void PveFacility::set_typeid_(::google::protobuf::int32 value) {
  set_has_typeid_();
  typeid__ = value;
  // @@protoc_insertion_point(field_set:sg.PveFacility.typeid)
}

// optional int32 x = 3;
inline bool PveFacility::has_x() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PveFacility::set_has_x() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PveFacility::clear_has_x() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PveFacility::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 PveFacility::x() const {
  // @@protoc_insertion_point(field_get:sg.PveFacility.x)
  return x_;
}
inline void PveFacility::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:sg.PveFacility.x)
}

// optional int32 y = 4;
inline bool PveFacility::has_y() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PveFacility::set_has_y() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PveFacility::clear_has_y() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PveFacility::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 PveFacility::y() const {
  // @@protoc_insertion_point(field_get:sg.PveFacility.y)
  return y_;
}
inline void PveFacility::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:sg.PveFacility.y)
}

// repeated .sg.Item contain = 5;
inline int PveFacility::contain_size() const {
  return contain_.size();
}
inline ::sg::Item* PveFacility::mutable_contain(int index) {
  // @@protoc_insertion_point(field_mutable:sg.PveFacility.contain)
  return contain_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::Item >*
PveFacility::mutable_contain() {
  // @@protoc_insertion_point(field_mutable_list:sg.PveFacility.contain)
  return &contain_;
}
inline const ::sg::Item& PveFacility::contain(int index) const {
  // @@protoc_insertion_point(field_get:sg.PveFacility.contain)
  return contain_.Get(index);
}
inline ::sg::Item* PveFacility::add_contain() {
  // @@protoc_insertion_point(field_add:sg.PveFacility.contain)
  return contain_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::Item >&
PveFacility::contain() const {
  // @@protoc_insertion_point(field_list:sg.PveFacility.contain)
  return contain_;
}

// -------------------------------------------------------------------

// PveMapData

// required int32 model_id = 2;
inline bool PveMapData::has_model_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PveMapData::set_has_model_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PveMapData::clear_has_model_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PveMapData::clear_model_id() {
  model_id_ = 0;
  clear_has_model_id();
}
inline ::google::protobuf::int32 PveMapData::model_id() const {
  // @@protoc_insertion_point(field_get:sg.PveMapData.model_id)
  return model_id_;
}
inline void PveMapData::set_model_id(::google::protobuf::int32 value) {
  set_has_model_id();
  model_id_ = value;
  // @@protoc_insertion_point(field_set:sg.PveMapData.model_id)
}

// required int32 width = 3;
inline bool PveMapData::has_width() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PveMapData::set_has_width() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PveMapData::clear_has_width() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PveMapData::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline ::google::protobuf::int32 PveMapData::width() const {
  // @@protoc_insertion_point(field_get:sg.PveMapData.width)
  return width_;
}
inline void PveMapData::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:sg.PveMapData.width)
}

// required int32 height = 4;
inline bool PveMapData::has_height() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PveMapData::set_has_height() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PveMapData::clear_has_height() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PveMapData::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline ::google::protobuf::int32 PveMapData::height() const {
  // @@protoc_insertion_point(field_get:sg.PveMapData.height)
  return height_;
}
inline void PveMapData::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:sg.PveMapData.height)
}

// optional bytes rooms = 5;
inline bool PveMapData::has_rooms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PveMapData::set_has_rooms() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PveMapData::clear_has_rooms() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PveMapData::clear_rooms() {
  rooms_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_rooms();
}
inline const ::std::string& PveMapData::rooms() const {
  // @@protoc_insertion_point(field_get:sg.PveMapData.rooms)
  return rooms_.Get();
}
inline void PveMapData::set_rooms(const ::std::string& value) {
  set_has_rooms();
  rooms_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:sg.PveMapData.rooms)
}
#if LANG_CXX11
inline void PveMapData::set_rooms(::std::string&& value) {
  set_has_rooms();
  rooms_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:sg.PveMapData.rooms)
}
#endif
inline void PveMapData::set_rooms(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_rooms();
  rooms_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:sg.PveMapData.rooms)
}
inline void PveMapData::set_rooms(const void* value,
    size_t size) {
  set_has_rooms();
  rooms_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:sg.PveMapData.rooms)
}
inline ::std::string* PveMapData::mutable_rooms() {
  set_has_rooms();
  // @@protoc_insertion_point(field_mutable:sg.PveMapData.rooms)
  return rooms_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* PveMapData::release_rooms() {
  // @@protoc_insertion_point(field_release:sg.PveMapData.rooms)
  if (!has_rooms()) {
    return NULL;
  }
  clear_has_rooms();
  return rooms_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void PveMapData::set_allocated_rooms(::std::string* rooms) {
  if (rooms != NULL) {
    set_has_rooms();
  } else {
    clear_has_rooms();
  }
  rooms_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), rooms,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:sg.PveMapData.rooms)
}
inline ::std::string* PveMapData::unsafe_arena_release_rooms() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.PveMapData.rooms)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_rooms();
  return rooms_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void PveMapData::unsafe_arena_set_allocated_rooms(
    ::std::string* rooms) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (rooms != NULL) {
    set_has_rooms();
  } else {
    clear_has_rooms();
  }
  rooms_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      rooms, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sg.PveMapData.rooms)
}

// optional bytes map_tiles = 6;
inline bool PveMapData::has_map_tiles() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PveMapData::set_has_map_tiles() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PveMapData::clear_has_map_tiles() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PveMapData::clear_map_tiles() {
  map_tiles_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_map_tiles();
}
inline const ::std::string& PveMapData::map_tiles() const {
  // @@protoc_insertion_point(field_get:sg.PveMapData.map_tiles)
  return map_tiles_.Get();
}
inline void PveMapData::set_map_tiles(const ::std::string& value) {
  set_has_map_tiles();
  map_tiles_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:sg.PveMapData.map_tiles)
}
#if LANG_CXX11
inline void PveMapData::set_map_tiles(::std::string&& value) {
  set_has_map_tiles();
  map_tiles_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:sg.PveMapData.map_tiles)
}
#endif
inline void PveMapData::set_map_tiles(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_map_tiles();
  map_tiles_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:sg.PveMapData.map_tiles)
}
inline void PveMapData::set_map_tiles(const void* value,
    size_t size) {
  set_has_map_tiles();
  map_tiles_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:sg.PveMapData.map_tiles)
}
inline ::std::string* PveMapData::mutable_map_tiles() {
  set_has_map_tiles();
  // @@protoc_insertion_point(field_mutable:sg.PveMapData.map_tiles)
  return map_tiles_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* PveMapData::release_map_tiles() {
  // @@protoc_insertion_point(field_release:sg.PveMapData.map_tiles)
  if (!has_map_tiles()) {
    return NULL;
  }
  clear_has_map_tiles();
  return map_tiles_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void PveMapData::set_allocated_map_tiles(::std::string* map_tiles) {
  if (map_tiles != NULL) {
    set_has_map_tiles();
  } else {
    clear_has_map_tiles();
  }
  map_tiles_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), map_tiles,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:sg.PveMapData.map_tiles)
}
inline ::std::string* PveMapData::unsafe_arena_release_map_tiles() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.PveMapData.map_tiles)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_map_tiles();
  return map_tiles_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void PveMapData::unsafe_arena_set_allocated_map_tiles(
    ::std::string* map_tiles) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (map_tiles != NULL) {
    set_has_map_tiles();
  } else {
    clear_has_map_tiles();
  }
  map_tiles_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      map_tiles, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sg.PveMapData.map_tiles)
}

// repeated .sg.PveFacility facilitys = 7;
inline int PveMapData::facilitys_size() const {
  return facilitys_.size();
}
inline void PveMapData::clear_facilitys() {
  facilitys_.Clear();
}
inline ::sg::PveFacility* PveMapData::mutable_facilitys(int index) {
  // @@protoc_insertion_point(field_mutable:sg.PveMapData.facilitys)
  return facilitys_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::PveFacility >*
PveMapData::mutable_facilitys() {
  // @@protoc_insertion_point(field_mutable_list:sg.PveMapData.facilitys)
  return &facilitys_;
}
inline const ::sg::PveFacility& PveMapData::facilitys(int index) const {
  // @@protoc_insertion_point(field_get:sg.PveMapData.facilitys)
  return facilitys_.Get(index);
}
inline ::sg::PveFacility* PveMapData::add_facilitys() {
  // @@protoc_insertion_point(field_add:sg.PveMapData.facilitys)
  return facilitys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::PveFacility >&
PveMapData::facilitys() const {
  // @@protoc_insertion_point(field_list:sg.PveMapData.facilitys)
  return facilitys_;
}

// -------------------------------------------------------------------

// PvePlayerMapData

// required .sg.ShipData shipdata = 1;
inline bool PvePlayerMapData::has_shipdata() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PvePlayerMapData::set_has_shipdata() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PvePlayerMapData::clear_has_shipdata() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PvePlayerMapData::clear_shipdata() {
  if (shipdata_ != NULL) shipdata_->Clear();
  clear_has_shipdata();
}
inline const ::sg::ShipData& PvePlayerMapData::_internal_shipdata() const {
  return *shipdata_;
}
inline const ::sg::ShipData& PvePlayerMapData::shipdata() const {
  const ::sg::ShipData* p = shipdata_;
  // @@protoc_insertion_point(field_get:sg.PvePlayerMapData.shipdata)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::ShipData*>(
      &::sg::_ShipData_default_instance_);
}
inline ::sg::ShipData* PvePlayerMapData::release_shipdata() {
  // @@protoc_insertion_point(field_release:sg.PvePlayerMapData.shipdata)
  clear_has_shipdata();
  ::sg::ShipData* temp = shipdata_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  shipdata_ = NULL;
  return temp;
}
inline ::sg::ShipData* PvePlayerMapData::unsafe_arena_release_shipdata() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.PvePlayerMapData.shipdata)
  clear_has_shipdata();
  ::sg::ShipData* temp = shipdata_;
  shipdata_ = NULL;
  return temp;
}
inline ::sg::ShipData* PvePlayerMapData::mutable_shipdata() {
  set_has_shipdata();
  if (shipdata_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::ShipData>(GetArenaNoVirtual());
    shipdata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.PvePlayerMapData.shipdata)
  return shipdata_;
}
inline void PvePlayerMapData::set_allocated_shipdata(::sg::ShipData* shipdata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete shipdata_;
  }
  if (shipdata) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(shipdata);
    if (message_arena != submessage_arena) {
      shipdata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, shipdata, submessage_arena);
    }
    set_has_shipdata();
  } else {
    clear_has_shipdata();
  }
  shipdata_ = shipdata;
  // @@protoc_insertion_point(field_set_allocated:sg.PvePlayerMapData.shipdata)
}

// repeated .sg.PveFacility facilitys = 2;
inline int PvePlayerMapData::facilitys_size() const {
  return facilitys_.size();
}
inline void PvePlayerMapData::clear_facilitys() {
  facilitys_.Clear();
}
inline ::sg::PveFacility* PvePlayerMapData::mutable_facilitys(int index) {
  // @@protoc_insertion_point(field_mutable:sg.PvePlayerMapData.facilitys)
  return facilitys_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::PveFacility >*
PvePlayerMapData::mutable_facilitys() {
  // @@protoc_insertion_point(field_mutable_list:sg.PvePlayerMapData.facilitys)
  return &facilitys_;
}
inline const ::sg::PveFacility& PvePlayerMapData::facilitys(int index) const {
  // @@protoc_insertion_point(field_get:sg.PvePlayerMapData.facilitys)
  return facilitys_.Get(index);
}
inline ::sg::PveFacility* PvePlayerMapData::add_facilitys() {
  // @@protoc_insertion_point(field_add:sg.PvePlayerMapData.facilitys)
  return facilitys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::PveFacility >&
PvePlayerMapData::facilitys() const {
  // @@protoc_insertion_point(field_list:sg.PvePlayerMapData.facilitys)
  return facilitys_;
}

// -------------------------------------------------------------------

// PveDefenderData

// required bytes userid = 1;
inline bool PveDefenderData::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PveDefenderData::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PveDefenderData::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PveDefenderData::clear_userid() {
  userid_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_userid();
}
inline const ::std::string& PveDefenderData::userid() const {
  // @@protoc_insertion_point(field_get:sg.PveDefenderData.userid)
  return userid_.Get();
}
inline void PveDefenderData::set_userid(const ::std::string& value) {
  set_has_userid();
  userid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:sg.PveDefenderData.userid)
}
#if LANG_CXX11
inline void PveDefenderData::set_userid(::std::string&& value) {
  set_has_userid();
  userid_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:sg.PveDefenderData.userid)
}
#endif
inline void PveDefenderData::set_userid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_userid();
  userid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:sg.PveDefenderData.userid)
}
inline void PveDefenderData::set_userid(const void* value,
    size_t size) {
  set_has_userid();
  userid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:sg.PveDefenderData.userid)
}
inline ::std::string* PveDefenderData::mutable_userid() {
  set_has_userid();
  // @@protoc_insertion_point(field_mutable:sg.PveDefenderData.userid)
  return userid_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* PveDefenderData::release_userid() {
  // @@protoc_insertion_point(field_release:sg.PveDefenderData.userid)
  if (!has_userid()) {
    return NULL;
  }
  clear_has_userid();
  return userid_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void PveDefenderData::set_allocated_userid(::std::string* userid) {
  if (userid != NULL) {
    set_has_userid();
  } else {
    clear_has_userid();
  }
  userid_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), userid,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:sg.PveDefenderData.userid)
}
inline ::std::string* PveDefenderData::unsafe_arena_release_userid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.PveDefenderData.userid)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_userid();
  return userid_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void PveDefenderData::unsafe_arena_set_allocated_userid(
    ::std::string* userid) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (userid != NULL) {
    set_has_userid();
  } else {
    clear_has_userid();
  }
  userid_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      userid, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sg.PveDefenderData.userid)
}

// repeated .sg.Sailor defend_team = 2;
inline int PveDefenderData::defend_team_size() const {
  return defend_team_.size();
}
inline ::sg::Sailor* PveDefenderData::mutable_defend_team(int index) {
  // @@protoc_insertion_point(field_mutable:sg.PveDefenderData.defend_team)
  return defend_team_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::Sailor >*
PveDefenderData::mutable_defend_team() {
  // @@protoc_insertion_point(field_mutable_list:sg.PveDefenderData.defend_team)
  return &defend_team_;
}
inline const ::sg::Sailor& PveDefenderData::defend_team(int index) const {
  // @@protoc_insertion_point(field_get:sg.PveDefenderData.defend_team)
  return defend_team_.Get(index);
}
inline ::sg::Sailor* PveDefenderData::add_defend_team() {
  // @@protoc_insertion_point(field_add:sg.PveDefenderData.defend_team)
  return defend_team_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::Sailor >&
PveDefenderData::defend_team() const {
  // @@protoc_insertion_point(field_list:sg.PveDefenderData.defend_team)
  return defend_team_;
}

// -------------------------------------------------------------------

// PVEBattleService_PVEBattleRequest

// required .sg.PVEBattleService.PVE_CMD cmd = 1;
inline bool PVEBattleService_PVEBattleRequest::has_cmd() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PVEBattleService_PVEBattleRequest::set_has_cmd() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PVEBattleService_PVEBattleRequest::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PVEBattleService_PVEBattleRequest::clear_cmd() {
  cmd_ = 1;
  clear_has_cmd();
}
inline ::sg::PVEBattleService_PVE_CMD PVEBattleService_PVEBattleRequest::cmd() const {
  // @@protoc_insertion_point(field_get:sg.PVEBattleService.PVEBattleRequest.cmd)
  return static_cast< ::sg::PVEBattleService_PVE_CMD >(cmd_);
}
inline void PVEBattleService_PVEBattleRequest::set_cmd(::sg::PVEBattleService_PVE_CMD value) {
  assert(::sg::PVEBattleService_PVE_CMD_IsValid(value));
  set_has_cmd();
  cmd_ = value;
  // @@protoc_insertion_point(field_set:sg.PVEBattleService.PVEBattleRequest.cmd)
}

// optional uint64 target_id = 3;
inline bool PVEBattleService_PVEBattleRequest::has_target_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PVEBattleService_PVEBattleRequest::set_has_target_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PVEBattleService_PVEBattleRequest::clear_has_target_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PVEBattleService_PVEBattleRequest::clear_target_id() {
  target_id_ = GOOGLE_ULONGLONG(0);
  clear_has_target_id();
}
inline ::google::protobuf::uint64 PVEBattleService_PVEBattleRequest::target_id() const {
  // @@protoc_insertion_point(field_get:sg.PVEBattleService.PVEBattleRequest.target_id)
  return target_id_;
}
inline void PVEBattleService_PVEBattleRequest::set_target_id(::google::protobuf::uint64 value) {
  set_has_target_id();
  target_id_ = value;
  // @@protoc_insertion_point(field_set:sg.PVEBattleService.PVEBattleRequest.target_id)
}

// repeated int32 used_sailor = 4;
inline int PVEBattleService_PVEBattleRequest::used_sailor_size() const {
  return used_sailor_.size();
}
inline void PVEBattleService_PVEBattleRequest::clear_used_sailor() {
  used_sailor_.Clear();
}
inline ::google::protobuf::int32 PVEBattleService_PVEBattleRequest::used_sailor(int index) const {
  // @@protoc_insertion_point(field_get:sg.PVEBattleService.PVEBattleRequest.used_sailor)
  return used_sailor_.Get(index);
}
inline void PVEBattleService_PVEBattleRequest::set_used_sailor(int index, ::google::protobuf::int32 value) {
  used_sailor_.Set(index, value);
  // @@protoc_insertion_point(field_set:sg.PVEBattleService.PVEBattleRequest.used_sailor)
}
inline void PVEBattleService_PVEBattleRequest::add_used_sailor(::google::protobuf::int32 value) {
  used_sailor_.Add(value);
  // @@protoc_insertion_point(field_add:sg.PVEBattleService.PVEBattleRequest.used_sailor)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PVEBattleService_PVEBattleRequest::used_sailor() const {
  // @@protoc_insertion_point(field_list:sg.PVEBattleService.PVEBattleRequest.used_sailor)
  return used_sailor_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PVEBattleService_PVEBattleRequest::mutable_used_sailor() {
  // @@protoc_insertion_point(field_mutable_list:sg.PVEBattleService.PVEBattleRequest.used_sailor)
  return &used_sailor_;
}

// repeated .sg.UserDungeonOperation operation_list = 5;
inline int PVEBattleService_PVEBattleRequest::operation_list_size() const {
  return operation_list_.size();
}
inline void PVEBattleService_PVEBattleRequest::clear_operation_list() {
  operation_list_.Clear();
}
inline ::sg::UserDungeonOperation* PVEBattleService_PVEBattleRequest::mutable_operation_list(int index) {
  // @@protoc_insertion_point(field_mutable:sg.PVEBattleService.PVEBattleRequest.operation_list)
  return operation_list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::UserDungeonOperation >*
PVEBattleService_PVEBattleRequest::mutable_operation_list() {
  // @@protoc_insertion_point(field_mutable_list:sg.PVEBattleService.PVEBattleRequest.operation_list)
  return &operation_list_;
}
inline const ::sg::UserDungeonOperation& PVEBattleService_PVEBattleRequest::operation_list(int index) const {
  // @@protoc_insertion_point(field_get:sg.PVEBattleService.PVEBattleRequest.operation_list)
  return operation_list_.Get(index);
}
inline ::sg::UserDungeonOperation* PVEBattleService_PVEBattleRequest::add_operation_list() {
  // @@protoc_insertion_point(field_add:sg.PVEBattleService.PVEBattleRequest.operation_list)
  return operation_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::UserDungeonOperation >&
PVEBattleService_PVEBattleRequest::operation_list() const {
  // @@protoc_insertion_point(field_list:sg.PVEBattleService.PVEBattleRequest.operation_list)
  return operation_list_;
}

// repeated .sg.SailorInDungeon team_state = 6;
inline int PVEBattleService_PVEBattleRequest::team_state_size() const {
  return team_state_.size();
}
inline void PVEBattleService_PVEBattleRequest::clear_team_state() {
  team_state_.Clear();
}
inline ::sg::SailorInDungeon* PVEBattleService_PVEBattleRequest::mutable_team_state(int index) {
  // @@protoc_insertion_point(field_mutable:sg.PVEBattleService.PVEBattleRequest.team_state)
  return team_state_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::SailorInDungeon >*
PVEBattleService_PVEBattleRequest::mutable_team_state() {
  // @@protoc_insertion_point(field_mutable_list:sg.PVEBattleService.PVEBattleRequest.team_state)
  return &team_state_;
}
inline const ::sg::SailorInDungeon& PVEBattleService_PVEBattleRequest::team_state(int index) const {
  // @@protoc_insertion_point(field_get:sg.PVEBattleService.PVEBattleRequest.team_state)
  return team_state_.Get(index);
}
inline ::sg::SailorInDungeon* PVEBattleService_PVEBattleRequest::add_team_state() {
  // @@protoc_insertion_point(field_add:sg.PVEBattleService.PVEBattleRequest.team_state)
  return team_state_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::SailorInDungeon >&
PVEBattleService_PVEBattleRequest::team_state() const {
  // @@protoc_insertion_point(field_list:sg.PVEBattleService.PVEBattleRequest.team_state)
  return team_state_;
}

// optional int32 battle_result = 7;
inline bool PVEBattleService_PVEBattleRequest::has_battle_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PVEBattleService_PVEBattleRequest::set_has_battle_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PVEBattleService_PVEBattleRequest::clear_has_battle_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PVEBattleService_PVEBattleRequest::clear_battle_result() {
  battle_result_ = 0;
  clear_has_battle_result();
}
inline ::google::protobuf::int32 PVEBattleService_PVEBattleRequest::battle_result() const {
  // @@protoc_insertion_point(field_get:sg.PVEBattleService.PVEBattleRequest.battle_result)
  return battle_result_;
}
inline void PVEBattleService_PVEBattleRequest::set_battle_result(::google::protobuf::int32 value) {
  set_has_battle_result();
  battle_result_ = value;
  // @@protoc_insertion_point(field_set:sg.PVEBattleService.PVEBattleRequest.battle_result)
}

// repeated int32 destory_facilitys = 8;
inline int PVEBattleService_PVEBattleRequest::destory_facilitys_size() const {
  return destory_facilitys_.size();
}
inline void PVEBattleService_PVEBattleRequest::clear_destory_facilitys() {
  destory_facilitys_.Clear();
}
inline ::google::protobuf::int32 PVEBattleService_PVEBattleRequest::destory_facilitys(int index) const {
  // @@protoc_insertion_point(field_get:sg.PVEBattleService.PVEBattleRequest.destory_facilitys)
  return destory_facilitys_.Get(index);
}
inline void PVEBattleService_PVEBattleRequest::set_destory_facilitys(int index, ::google::protobuf::int32 value) {
  destory_facilitys_.Set(index, value);
  // @@protoc_insertion_point(field_set:sg.PVEBattleService.PVEBattleRequest.destory_facilitys)
}
inline void PVEBattleService_PVEBattleRequest::add_destory_facilitys(::google::protobuf::int32 value) {
  destory_facilitys_.Add(value);
  // @@protoc_insertion_point(field_add:sg.PVEBattleService.PVEBattleRequest.destory_facilitys)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PVEBattleService_PVEBattleRequest::destory_facilitys() const {
  // @@protoc_insertion_point(field_list:sg.PVEBattleService.PVEBattleRequest.destory_facilitys)
  return destory_facilitys_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PVEBattleService_PVEBattleRequest::mutable_destory_facilitys() {
  // @@protoc_insertion_point(field_mutable_list:sg.PVEBattleService.PVEBattleRequest.destory_facilitys)
  return &destory_facilitys_;
}

// optional int32 path_choice = 9;
inline bool PVEBattleService_PVEBattleRequest::has_path_choice() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PVEBattleService_PVEBattleRequest::set_has_path_choice() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PVEBattleService_PVEBattleRequest::clear_has_path_choice() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PVEBattleService_PVEBattleRequest::clear_path_choice() {
  path_choice_ = 0;
  clear_has_path_choice();
}
inline ::google::protobuf::int32 PVEBattleService_PVEBattleRequest::path_choice() const {
  // @@protoc_insertion_point(field_get:sg.PVEBattleService.PVEBattleRequest.path_choice)
  return path_choice_;
}
inline void PVEBattleService_PVEBattleRequest::set_path_choice(::google::protobuf::int32 value) {
  set_has_path_choice();
  path_choice_ = value;
  // @@protoc_insertion_point(field_set:sg.PVEBattleService.PVEBattleRequest.path_choice)
}

// optional int32 hunt_animal = 10;
inline bool PVEBattleService_PVEBattleRequest::has_hunt_animal() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PVEBattleService_PVEBattleRequest::set_has_hunt_animal() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PVEBattleService_PVEBattleRequest::clear_has_hunt_animal() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PVEBattleService_PVEBattleRequest::clear_hunt_animal() {
  hunt_animal_ = 0;
  clear_has_hunt_animal();
}
inline ::google::protobuf::int32 PVEBattleService_PVEBattleRequest::hunt_animal() const {
  // @@protoc_insertion_point(field_get:sg.PVEBattleService.PVEBattleRequest.hunt_animal)
  return hunt_animal_;
}
inline void PVEBattleService_PVEBattleRequest::set_hunt_animal(::google::protobuf::int32 value) {
  set_has_hunt_animal();
  hunt_animal_ = value;
  // @@protoc_insertion_point(field_set:sg.PVEBattleService.PVEBattleRequest.hunt_animal)
}

// optional int32 enemy_typeid = 11;
inline bool PVEBattleService_PVEBattleRequest::has_enemy_typeid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PVEBattleService_PVEBattleRequest::set_has_enemy_typeid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PVEBattleService_PVEBattleRequest::clear_has_enemy_typeid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PVEBattleService_PVEBattleRequest::clear_enemy_typeid() {
  enemy_typeid_ = 0;
  clear_has_enemy_typeid();
}
inline ::google::protobuf::int32 PVEBattleService_PVEBattleRequest::enemy_typeid() const {
  // @@protoc_insertion_point(field_get:sg.PVEBattleService.PVEBattleRequest.enemy_typeid)
  return enemy_typeid_;
}
inline void PVEBattleService_PVEBattleRequest::set_enemy_typeid(::google::protobuf::int32 value) {
  set_has_enemy_typeid();
  enemy_typeid_ = value;
  // @@protoc_insertion_point(field_set:sg.PVEBattleService.PVEBattleRequest.enemy_typeid)
}

// optional int32 treasure_id = 12;
inline bool PVEBattleService_PVEBattleRequest::has_treasure_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PVEBattleService_PVEBattleRequest::set_has_treasure_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PVEBattleService_PVEBattleRequest::clear_has_treasure_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PVEBattleService_PVEBattleRequest::clear_treasure_id() {
  treasure_id_ = 0;
  clear_has_treasure_id();
}
inline ::google::protobuf::int32 PVEBattleService_PVEBattleRequest::treasure_id() const {
  // @@protoc_insertion_point(field_get:sg.PVEBattleService.PVEBattleRequest.treasure_id)
  return treasure_id_;
}
inline void PVEBattleService_PVEBattleRequest::set_treasure_id(::google::protobuf::int32 value) {
  set_has_treasure_id();
  treasure_id_ = value;
  // @@protoc_insertion_point(field_set:sg.PVEBattleService.PVEBattleRequest.treasure_id)
}

// optional int32 pve_model_id = 13;
inline bool PVEBattleService_PVEBattleRequest::has_pve_model_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PVEBattleService_PVEBattleRequest::set_has_pve_model_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PVEBattleService_PVEBattleRequest::clear_has_pve_model_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PVEBattleService_PVEBattleRequest::clear_pve_model_id() {
  pve_model_id_ = 0;
  clear_has_pve_model_id();
}
inline ::google::protobuf::int32 PVEBattleService_PVEBattleRequest::pve_model_id() const {
  // @@protoc_insertion_point(field_get:sg.PVEBattleService.PVEBattleRequest.pve_model_id)
  return pve_model_id_;
}
inline void PVEBattleService_PVEBattleRequest::set_pve_model_id(::google::protobuf::int32 value) {
  set_has_pve_model_id();
  pve_model_id_ = value;
  // @@protoc_insertion_point(field_set:sg.PVEBattleService.PVEBattleRequest.pve_model_id)
}

// repeated .sg.FightManual new_manual = 14;
inline int PVEBattleService_PVEBattleRequest::new_manual_size() const {
  return new_manual_.size();
}
inline void PVEBattleService_PVEBattleRequest::clear_new_manual() {
  new_manual_.Clear();
}
inline ::sg::FightManual* PVEBattleService_PVEBattleRequest::mutable_new_manual(int index) {
  // @@protoc_insertion_point(field_mutable:sg.PVEBattleService.PVEBattleRequest.new_manual)
  return new_manual_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::FightManual >*
PVEBattleService_PVEBattleRequest::mutable_new_manual() {
  // @@protoc_insertion_point(field_mutable_list:sg.PVEBattleService.PVEBattleRequest.new_manual)
  return &new_manual_;
}
inline const ::sg::FightManual& PVEBattleService_PVEBattleRequest::new_manual(int index) const {
  // @@protoc_insertion_point(field_get:sg.PVEBattleService.PVEBattleRequest.new_manual)
  return new_manual_.Get(index);
}
inline ::sg::FightManual* PVEBattleService_PVEBattleRequest::add_new_manual() {
  // @@protoc_insertion_point(field_add:sg.PVEBattleService.PVEBattleRequest.new_manual)
  return new_manual_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::FightManual >&
PVEBattleService_PVEBattleRequest::new_manual() const {
  // @@protoc_insertion_point(field_list:sg.PVEBattleService.PVEBattleRequest.new_manual)
  return new_manual_;
}

// optional bool debug_tag = 15;
inline bool PVEBattleService_PVEBattleRequest::has_debug_tag() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PVEBattleService_PVEBattleRequest::set_has_debug_tag() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PVEBattleService_PVEBattleRequest::clear_has_debug_tag() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PVEBattleService_PVEBattleRequest::clear_debug_tag() {
  debug_tag_ = false;
  clear_has_debug_tag();
}
inline bool PVEBattleService_PVEBattleRequest::debug_tag() const {
  // @@protoc_insertion_point(field_get:sg.PVEBattleService.PVEBattleRequest.debug_tag)
  return debug_tag_;
}
inline void PVEBattleService_PVEBattleRequest::set_debug_tag(bool value) {
  set_has_debug_tag();
  debug_tag_ = value;
  // @@protoc_insertion_point(field_set:sg.PVEBattleService.PVEBattleRequest.debug_tag)
}

// repeated .sg.MonsterInDungeon monsters = 16;
inline int PVEBattleService_PVEBattleRequest::monsters_size() const {
  return monsters_.size();
}
inline void PVEBattleService_PVEBattleRequest::clear_monsters() {
  monsters_.Clear();
}
inline ::sg::MonsterInDungeon* PVEBattleService_PVEBattleRequest::mutable_monsters(int index) {
  // @@protoc_insertion_point(field_mutable:sg.PVEBattleService.PVEBattleRequest.monsters)
  return monsters_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::MonsterInDungeon >*
PVEBattleService_PVEBattleRequest::mutable_monsters() {
  // @@protoc_insertion_point(field_mutable_list:sg.PVEBattleService.PVEBattleRequest.monsters)
  return &monsters_;
}
inline const ::sg::MonsterInDungeon& PVEBattleService_PVEBattleRequest::monsters(int index) const {
  // @@protoc_insertion_point(field_get:sg.PVEBattleService.PVEBattleRequest.monsters)
  return monsters_.Get(index);
}
inline ::sg::MonsterInDungeon* PVEBattleService_PVEBattleRequest::add_monsters() {
  // @@protoc_insertion_point(field_add:sg.PVEBattleService.PVEBattleRequest.monsters)
  return monsters_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::MonsterInDungeon >&
PVEBattleService_PVEBattleRequest::monsters() const {
  // @@protoc_insertion_point(field_list:sg.PVEBattleService.PVEBattleRequest.monsters)
  return monsters_;
}

// repeated .sg.Enemy enemys = 17;
inline int PVEBattleService_PVEBattleRequest::enemys_size() const {
  return enemys_.size();
}
inline void PVEBattleService_PVEBattleRequest::clear_enemys() {
  enemys_.Clear();
}
inline ::sg::Enemy* PVEBattleService_PVEBattleRequest::mutable_enemys(int index) {
  // @@protoc_insertion_point(field_mutable:sg.PVEBattleService.PVEBattleRequest.enemys)
  return enemys_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::Enemy >*
PVEBattleService_PVEBattleRequest::mutable_enemys() {
  // @@protoc_insertion_point(field_mutable_list:sg.PVEBattleService.PVEBattleRequest.enemys)
  return &enemys_;
}
inline const ::sg::Enemy& PVEBattleService_PVEBattleRequest::enemys(int index) const {
  // @@protoc_insertion_point(field_get:sg.PVEBattleService.PVEBattleRequest.enemys)
  return enemys_.Get(index);
}
inline ::sg::Enemy* PVEBattleService_PVEBattleRequest::add_enemys() {
  // @@protoc_insertion_point(field_add:sg.PVEBattleService.PVEBattleRequest.enemys)
  return enemys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::Enemy >&
PVEBattleService_PVEBattleRequest::enemys() const {
  // @@protoc_insertion_point(field_list:sg.PVEBattleService.PVEBattleRequest.enemys)
  return enemys_;
}

// repeated .sg.DungeonAltar altars = 18;
inline int PVEBattleService_PVEBattleRequest::altars_size() const {
  return altars_.size();
}
inline void PVEBattleService_PVEBattleRequest::clear_altars() {
  altars_.Clear();
}
inline ::sg::DungeonAltar* PVEBattleService_PVEBattleRequest::mutable_altars(int index) {
  // @@protoc_insertion_point(field_mutable:sg.PVEBattleService.PVEBattleRequest.altars)
  return altars_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::DungeonAltar >*
PVEBattleService_PVEBattleRequest::mutable_altars() {
  // @@protoc_insertion_point(field_mutable_list:sg.PVEBattleService.PVEBattleRequest.altars)
  return &altars_;
}
inline const ::sg::DungeonAltar& PVEBattleService_PVEBattleRequest::altars(int index) const {
  // @@protoc_insertion_point(field_get:sg.PVEBattleService.PVEBattleRequest.altars)
  return altars_.Get(index);
}
inline ::sg::DungeonAltar* PVEBattleService_PVEBattleRequest::add_altars() {
  // @@protoc_insertion_point(field_add:sg.PVEBattleService.PVEBattleRequest.altars)
  return altars_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::DungeonAltar >&
PVEBattleService_PVEBattleRequest::altars() const {
  // @@protoc_insertion_point(field_list:sg.PVEBattleService.PVEBattleRequest.altars)
  return altars_;
}

// repeated .sg.pb_pair_int_int take_items = 19;
inline int PVEBattleService_PVEBattleRequest::take_items_size() const {
  return take_items_.size();
}
inline ::sg::pb_pair_int_int* PVEBattleService_PVEBattleRequest::mutable_take_items(int index) {
  // @@protoc_insertion_point(field_mutable:sg.PVEBattleService.PVEBattleRequest.take_items)
  return take_items_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int >*
PVEBattleService_PVEBattleRequest::mutable_take_items() {
  // @@protoc_insertion_point(field_mutable_list:sg.PVEBattleService.PVEBattleRequest.take_items)
  return &take_items_;
}
inline const ::sg::pb_pair_int_int& PVEBattleService_PVEBattleRequest::take_items(int index) const {
  // @@protoc_insertion_point(field_get:sg.PVEBattleService.PVEBattleRequest.take_items)
  return take_items_.Get(index);
}
inline ::sg::pb_pair_int_int* PVEBattleService_PVEBattleRequest::add_take_items() {
  // @@protoc_insertion_point(field_add:sg.PVEBattleService.PVEBattleRequest.take_items)
  return take_items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int >&
PVEBattleService_PVEBattleRequest::take_items() const {
  // @@protoc_insertion_point(field_list:sg.PVEBattleService.PVEBattleRequest.take_items)
  return take_items_;
}

// -------------------------------------------------------------------

// PVEBattleService_PVEBattleResponse

// required int32 result = 1;
inline bool PVEBattleService_PVEBattleResponse::has_result() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PVEBattleService_PVEBattleResponse::set_has_result() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PVEBattleService_PVEBattleResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PVEBattleService_PVEBattleResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 PVEBattleService_PVEBattleResponse::result() const {
  // @@protoc_insertion_point(field_get:sg.PVEBattleService.PVEBattleResponse.result)
  return result_;
}
inline void PVEBattleService_PVEBattleResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:sg.PVEBattleService.PVEBattleResponse.result)
}

// optional .sg.DungeonContent content = 2;
inline bool PVEBattleService_PVEBattleResponse::has_content() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PVEBattleService_PVEBattleResponse::set_has_content() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PVEBattleService_PVEBattleResponse::clear_has_content() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PVEBattleService_PVEBattleResponse::clear_content() {
  if (content_ != NULL) content_->Clear();
  clear_has_content();
}
inline const ::sg::DungeonContent& PVEBattleService_PVEBattleResponse::_internal_content() const {
  return *content_;
}
inline const ::sg::DungeonContent& PVEBattleService_PVEBattleResponse::content() const {
  const ::sg::DungeonContent* p = content_;
  // @@protoc_insertion_point(field_get:sg.PVEBattleService.PVEBattleResponse.content)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::DungeonContent*>(
      &::sg::_DungeonContent_default_instance_);
}
inline ::sg::DungeonContent* PVEBattleService_PVEBattleResponse::release_content() {
  // @@protoc_insertion_point(field_release:sg.PVEBattleService.PVEBattleResponse.content)
  clear_has_content();
  ::sg::DungeonContent* temp = content_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  content_ = NULL;
  return temp;
}
inline ::sg::DungeonContent* PVEBattleService_PVEBattleResponse::unsafe_arena_release_content() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.PVEBattleService.PVEBattleResponse.content)
  clear_has_content();
  ::sg::DungeonContent* temp = content_;
  content_ = NULL;
  return temp;
}
inline ::sg::DungeonContent* PVEBattleService_PVEBattleResponse::mutable_content() {
  set_has_content();
  if (content_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::DungeonContent>(GetArenaNoVirtual());
    content_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.PVEBattleService.PVEBattleResponse.content)
  return content_;
}
inline void PVEBattleService_PVEBattleResponse::set_allocated_content(::sg::DungeonContent* content) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete content_;
  }
  if (content) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(content);
    if (message_arena != submessage_arena) {
      content = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, content, submessage_arena);
    }
    set_has_content();
  } else {
    clear_has_content();
  }
  content_ = content;
  // @@protoc_insertion_point(field_set_allocated:sg.PVEBattleService.PVEBattleResponse.content)
}

// optional int32 cost_viality = 3;
inline bool PVEBattleService_PVEBattleResponse::has_cost_viality() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PVEBattleService_PVEBattleResponse::set_has_cost_viality() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PVEBattleService_PVEBattleResponse::clear_has_cost_viality() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PVEBattleService_PVEBattleResponse::clear_cost_viality() {
  cost_viality_ = 0;
  clear_has_cost_viality();
}
inline ::google::protobuf::int32 PVEBattleService_PVEBattleResponse::cost_viality() const {
  // @@protoc_insertion_point(field_get:sg.PVEBattleService.PVEBattleResponse.cost_viality)
  return cost_viality_;
}
inline void PVEBattleService_PVEBattleResponse::set_cost_viality(::google::protobuf::int32 value) {
  set_has_cost_viality();
  cost_viality_ = value;
  // @@protoc_insertion_point(field_set:sg.PVEBattleService.PVEBattleResponse.cost_viality)
}

// optional .sg.UserDungeonInformation user_info = 4;
inline bool PVEBattleService_PVEBattleResponse::has_user_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PVEBattleService_PVEBattleResponse::set_has_user_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PVEBattleService_PVEBattleResponse::clear_has_user_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PVEBattleService_PVEBattleResponse::clear_user_info() {
  if (user_info_ != NULL) user_info_->Clear();
  clear_has_user_info();
}
inline const ::sg::UserDungeonInformation& PVEBattleService_PVEBattleResponse::_internal_user_info() const {
  return *user_info_;
}
inline const ::sg::UserDungeonInformation& PVEBattleService_PVEBattleResponse::user_info() const {
  const ::sg::UserDungeonInformation* p = user_info_;
  // @@protoc_insertion_point(field_get:sg.PVEBattleService.PVEBattleResponse.user_info)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::UserDungeonInformation*>(
      &::sg::_UserDungeonInformation_default_instance_);
}
inline ::sg::UserDungeonInformation* PVEBattleService_PVEBattleResponse::release_user_info() {
  // @@protoc_insertion_point(field_release:sg.PVEBattleService.PVEBattleResponse.user_info)
  clear_has_user_info();
  ::sg::UserDungeonInformation* temp = user_info_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  user_info_ = NULL;
  return temp;
}
inline ::sg::UserDungeonInformation* PVEBattleService_PVEBattleResponse::unsafe_arena_release_user_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.PVEBattleService.PVEBattleResponse.user_info)
  clear_has_user_info();
  ::sg::UserDungeonInformation* temp = user_info_;
  user_info_ = NULL;
  return temp;
}
inline ::sg::UserDungeonInformation* PVEBattleService_PVEBattleResponse::mutable_user_info() {
  set_has_user_info();
  if (user_info_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::UserDungeonInformation>(GetArenaNoVirtual());
    user_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.PVEBattleService.PVEBattleResponse.user_info)
  return user_info_;
}
inline void PVEBattleService_PVEBattleResponse::set_allocated_user_info(::sg::UserDungeonInformation* user_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete user_info_;
  }
  if (user_info) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(user_info);
    if (message_arena != submessage_arena) {
      user_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user_info, submessage_arena);
    }
    set_has_user_info();
  } else {
    clear_has_user_info();
  }
  user_info_ = user_info;
  // @@protoc_insertion_point(field_set_allocated:sg.PVEBattleService.PVEBattleResponse.user_info)
}

// optional .sg.Reward reward = 5;
inline bool PVEBattleService_PVEBattleResponse::has_reward() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PVEBattleService_PVEBattleResponse::set_has_reward() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PVEBattleService_PVEBattleResponse::clear_has_reward() {
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::sg::Reward& PVEBattleService_PVEBattleResponse::_internal_reward() const {
  return *reward_;
}
inline const ::sg::Reward& PVEBattleService_PVEBattleResponse::reward() const {
  const ::sg::Reward* p = reward_;
  // @@protoc_insertion_point(field_get:sg.PVEBattleService.PVEBattleResponse.reward)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::Reward*>(
      &::sg::_Reward_default_instance_);
}
inline ::sg::Reward* PVEBattleService_PVEBattleResponse::release_reward() {
  // @@protoc_insertion_point(field_release:sg.PVEBattleService.PVEBattleResponse.reward)
  clear_has_reward();
  ::sg::Reward* temp = reward_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  reward_ = NULL;
  return temp;
}
inline ::sg::Reward* PVEBattleService_PVEBattleResponse::unsafe_arena_release_reward() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.PVEBattleService.PVEBattleResponse.reward)
  clear_has_reward();
  ::sg::Reward* temp = reward_;
  reward_ = NULL;
  return temp;
}
inline ::sg::Reward* PVEBattleService_PVEBattleResponse::mutable_reward() {
  set_has_reward();
  if (reward_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::Reward>(GetArenaNoVirtual());
    reward_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.PVEBattleService.PVEBattleResponse.reward)
  return reward_;
}
inline void PVEBattleService_PVEBattleResponse::set_allocated_reward(::sg::Reward* reward) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(reward_);
  }
  if (reward) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(reward)->GetArena();
    if (message_arena != submessage_arena) {
      reward = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, reward, submessage_arena);
    }
    set_has_reward();
  } else {
    clear_has_reward();
  }
  reward_ = reward;
  // @@protoc_insertion_point(field_set_allocated:sg.PVEBattleService.PVEBattleResponse.reward)
}

// optional int32 dungeon_id = 6;
inline bool PVEBattleService_PVEBattleResponse::has_dungeon_id() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PVEBattleService_PVEBattleResponse::set_has_dungeon_id() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PVEBattleService_PVEBattleResponse::clear_has_dungeon_id() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PVEBattleService_PVEBattleResponse::clear_dungeon_id() {
  dungeon_id_ = 0;
  clear_has_dungeon_id();
}
inline ::google::protobuf::int32 PVEBattleService_PVEBattleResponse::dungeon_id() const {
  // @@protoc_insertion_point(field_get:sg.PVEBattleService.PVEBattleResponse.dungeon_id)
  return dungeon_id_;
}
inline void PVEBattleService_PVEBattleResponse::set_dungeon_id(::google::protobuf::int32 value) {
  set_has_dungeon_id();
  dungeon_id_ = value;
  // @@protoc_insertion_point(field_set:sg.PVEBattleService.PVEBattleResponse.dungeon_id)
}

// optional int32 pve_map_type = 7;
inline bool PVEBattleService_PVEBattleResponse::has_pve_map_type() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PVEBattleService_PVEBattleResponse::set_has_pve_map_type() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PVEBattleService_PVEBattleResponse::clear_has_pve_map_type() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PVEBattleService_PVEBattleResponse::clear_pve_map_type() {
  pve_map_type_ = 0;
  clear_has_pve_map_type();
}
inline ::google::protobuf::int32 PVEBattleService_PVEBattleResponse::pve_map_type() const {
  // @@protoc_insertion_point(field_get:sg.PVEBattleService.PVEBattleResponse.pve_map_type)
  return pve_map_type_;
}
inline void PVEBattleService_PVEBattleResponse::set_pve_map_type(::google::protobuf::int32 value) {
  set_has_pve_map_type();
  pve_map_type_ = value;
  // @@protoc_insertion_point(field_set:sg.PVEBattleService.PVEBattleResponse.pve_map_type)
}

// optional bytes map_data = 8;
inline bool PVEBattleService_PVEBattleResponse::has_map_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PVEBattleService_PVEBattleResponse::set_has_map_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PVEBattleService_PVEBattleResponse::clear_has_map_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PVEBattleService_PVEBattleResponse::clear_map_data() {
  map_data_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_map_data();
}
inline const ::std::string& PVEBattleService_PVEBattleResponse::map_data() const {
  // @@protoc_insertion_point(field_get:sg.PVEBattleService.PVEBattleResponse.map_data)
  return map_data_.Get();
}
inline void PVEBattleService_PVEBattleResponse::set_map_data(const ::std::string& value) {
  set_has_map_data();
  map_data_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:sg.PVEBattleService.PVEBattleResponse.map_data)
}
#if LANG_CXX11
inline void PVEBattleService_PVEBattleResponse::set_map_data(::std::string&& value) {
  set_has_map_data();
  map_data_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:sg.PVEBattleService.PVEBattleResponse.map_data)
}
#endif
inline void PVEBattleService_PVEBattleResponse::set_map_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_map_data();
  map_data_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:sg.PVEBattleService.PVEBattleResponse.map_data)
}
inline void PVEBattleService_PVEBattleResponse::set_map_data(const void* value,
    size_t size) {
  set_has_map_data();
  map_data_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:sg.PVEBattleService.PVEBattleResponse.map_data)
}
inline ::std::string* PVEBattleService_PVEBattleResponse::mutable_map_data() {
  set_has_map_data();
  // @@protoc_insertion_point(field_mutable:sg.PVEBattleService.PVEBattleResponse.map_data)
  return map_data_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* PVEBattleService_PVEBattleResponse::release_map_data() {
  // @@protoc_insertion_point(field_release:sg.PVEBattleService.PVEBattleResponse.map_data)
  if (!has_map_data()) {
    return NULL;
  }
  clear_has_map_data();
  return map_data_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void PVEBattleService_PVEBattleResponse::set_allocated_map_data(::std::string* map_data) {
  if (map_data != NULL) {
    set_has_map_data();
  } else {
    clear_has_map_data();
  }
  map_data_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), map_data,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:sg.PVEBattleService.PVEBattleResponse.map_data)
}
inline ::std::string* PVEBattleService_PVEBattleResponse::unsafe_arena_release_map_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.PVEBattleService.PVEBattleResponse.map_data)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_map_data();
  return map_data_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void PVEBattleService_PVEBattleResponse::unsafe_arena_set_allocated_map_data(
    ::std::string* map_data) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (map_data != NULL) {
    set_has_map_data();
  } else {
    clear_has_map_data();
  }
  map_data_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      map_data, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sg.PVEBattleService.PVEBattleResponse.map_data)
}

// repeated .sg.FightManual found_manual = 9;
inline int PVEBattleService_PVEBattleResponse::found_manual_size() const {
  return found_manual_.size();
}
inline void PVEBattleService_PVEBattleResponse::clear_found_manual() {
  found_manual_.Clear();
}
inline ::sg::FightManual* PVEBattleService_PVEBattleResponse::mutable_found_manual(int index) {
  // @@protoc_insertion_point(field_mutable:sg.PVEBattleService.PVEBattleResponse.found_manual)
  return found_manual_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::FightManual >*
PVEBattleService_PVEBattleResponse::mutable_found_manual() {
  // @@protoc_insertion_point(field_mutable_list:sg.PVEBattleService.PVEBattleResponse.found_manual)
  return &found_manual_;
}
inline const ::sg::FightManual& PVEBattleService_PVEBattleResponse::found_manual(int index) const {
  // @@protoc_insertion_point(field_get:sg.PVEBattleService.PVEBattleResponse.found_manual)
  return found_manual_.Get(index);
}
inline ::sg::FightManual* PVEBattleService_PVEBattleResponse::add_found_manual() {
  // @@protoc_insertion_point(field_add:sg.PVEBattleService.PVEBattleResponse.found_manual)
  return found_manual_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::FightManual >&
PVEBattleService_PVEBattleResponse::found_manual() const {
  // @@protoc_insertion_point(field_list:sg.PVEBattleService.PVEBattleResponse.found_manual)
  return found_manual_;
}

// repeated int64 saved_npc = 10;
inline int PVEBattleService_PVEBattleResponse::saved_npc_size() const {
  return saved_npc_.size();
}
inline void PVEBattleService_PVEBattleResponse::clear_saved_npc() {
  saved_npc_.Clear();
}
inline ::google::protobuf::int64 PVEBattleService_PVEBattleResponse::saved_npc(int index) const {
  // @@protoc_insertion_point(field_get:sg.PVEBattleService.PVEBattleResponse.saved_npc)
  return saved_npc_.Get(index);
}
inline void PVEBattleService_PVEBattleResponse::set_saved_npc(int index, ::google::protobuf::int64 value) {
  saved_npc_.Set(index, value);
  // @@protoc_insertion_point(field_set:sg.PVEBattleService.PVEBattleResponse.saved_npc)
}
inline void PVEBattleService_PVEBattleResponse::add_saved_npc(::google::protobuf::int64 value) {
  saved_npc_.Add(value);
  // @@protoc_insertion_point(field_add:sg.PVEBattleService.PVEBattleResponse.saved_npc)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
PVEBattleService_PVEBattleResponse::saved_npc() const {
  // @@protoc_insertion_point(field_list:sg.PVEBattleService.PVEBattleResponse.saved_npc)
  return saved_npc_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
PVEBattleService_PVEBattleResponse::mutable_saved_npc() {
  // @@protoc_insertion_point(field_mutable_list:sg.PVEBattleService.PVEBattleResponse.saved_npc)
  return &saved_npc_;
}

// repeated int64 saved_customer = 11;
inline int PVEBattleService_PVEBattleResponse::saved_customer_size() const {
  return saved_customer_.size();
}
inline void PVEBattleService_PVEBattleResponse::clear_saved_customer() {
  saved_customer_.Clear();
}
inline ::google::protobuf::int64 PVEBattleService_PVEBattleResponse::saved_customer(int index) const {
  // @@protoc_insertion_point(field_get:sg.PVEBattleService.PVEBattleResponse.saved_customer)
  return saved_customer_.Get(index);
}
inline void PVEBattleService_PVEBattleResponse::set_saved_customer(int index, ::google::protobuf::int64 value) {
  saved_customer_.Set(index, value);
  // @@protoc_insertion_point(field_set:sg.PVEBattleService.PVEBattleResponse.saved_customer)
}
inline void PVEBattleService_PVEBattleResponse::add_saved_customer(::google::protobuf::int64 value) {
  saved_customer_.Add(value);
  // @@protoc_insertion_point(field_add:sg.PVEBattleService.PVEBattleResponse.saved_customer)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
PVEBattleService_PVEBattleResponse::saved_customer() const {
  // @@protoc_insertion_point(field_list:sg.PVEBattleService.PVEBattleResponse.saved_customer)
  return saved_customer_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
PVEBattleService_PVEBattleResponse::mutable_saved_customer() {
  // @@protoc_insertion_point(field_mutable_list:sg.PVEBattleService.PVEBattleResponse.saved_customer)
  return &saved_customer_;
}

// optional .sg.Reward lose = 12;
inline bool PVEBattleService_PVEBattleResponse::has_lose() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PVEBattleService_PVEBattleResponse::set_has_lose() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PVEBattleService_PVEBattleResponse::clear_has_lose() {
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::sg::Reward& PVEBattleService_PVEBattleResponse::_internal_lose() const {
  return *lose_;
}
inline const ::sg::Reward& PVEBattleService_PVEBattleResponse::lose() const {
  const ::sg::Reward* p = lose_;
  // @@protoc_insertion_point(field_get:sg.PVEBattleService.PVEBattleResponse.lose)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::Reward*>(
      &::sg::_Reward_default_instance_);
}
inline ::sg::Reward* PVEBattleService_PVEBattleResponse::release_lose() {
  // @@protoc_insertion_point(field_release:sg.PVEBattleService.PVEBattleResponse.lose)
  clear_has_lose();
  ::sg::Reward* temp = lose_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  lose_ = NULL;
  return temp;
}
inline ::sg::Reward* PVEBattleService_PVEBattleResponse::unsafe_arena_release_lose() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.PVEBattleService.PVEBattleResponse.lose)
  clear_has_lose();
  ::sg::Reward* temp = lose_;
  lose_ = NULL;
  return temp;
}
inline ::sg::Reward* PVEBattleService_PVEBattleResponse::mutable_lose() {
  set_has_lose();
  if (lose_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::Reward>(GetArenaNoVirtual());
    lose_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.PVEBattleService.PVEBattleResponse.lose)
  return lose_;
}
inline void PVEBattleService_PVEBattleResponse::set_allocated_lose(::sg::Reward* lose) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(lose_);
  }
  if (lose) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(lose)->GetArena();
    if (message_arena != submessage_arena) {
      lose = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, lose, submessage_arena);
    }
    set_has_lose();
  } else {
    clear_has_lose();
  }
  lose_ = lose;
  // @@protoc_insertion_point(field_set_allocated:sg.PVEBattleService.PVEBattleResponse.lose)
}

// optional .sg.Reward finish_reward = 13;
inline bool PVEBattleService_PVEBattleResponse::has_finish_reward() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PVEBattleService_PVEBattleResponse::set_has_finish_reward() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PVEBattleService_PVEBattleResponse::clear_has_finish_reward() {
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::sg::Reward& PVEBattleService_PVEBattleResponse::_internal_finish_reward() const {
  return *finish_reward_;
}
inline const ::sg::Reward& PVEBattleService_PVEBattleResponse::finish_reward() const {
  const ::sg::Reward* p = finish_reward_;
  // @@protoc_insertion_point(field_get:sg.PVEBattleService.PVEBattleResponse.finish_reward)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::Reward*>(
      &::sg::_Reward_default_instance_);
}
inline ::sg::Reward* PVEBattleService_PVEBattleResponse::release_finish_reward() {
  // @@protoc_insertion_point(field_release:sg.PVEBattleService.PVEBattleResponse.finish_reward)
  clear_has_finish_reward();
  ::sg::Reward* temp = finish_reward_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  finish_reward_ = NULL;
  return temp;
}
inline ::sg::Reward* PVEBattleService_PVEBattleResponse::unsafe_arena_release_finish_reward() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.PVEBattleService.PVEBattleResponse.finish_reward)
  clear_has_finish_reward();
  ::sg::Reward* temp = finish_reward_;
  finish_reward_ = NULL;
  return temp;
}
inline ::sg::Reward* PVEBattleService_PVEBattleResponse::mutable_finish_reward() {
  set_has_finish_reward();
  if (finish_reward_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::Reward>(GetArenaNoVirtual());
    finish_reward_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.PVEBattleService.PVEBattleResponse.finish_reward)
  return finish_reward_;
}
inline void PVEBattleService_PVEBattleResponse::set_allocated_finish_reward(::sg::Reward* finish_reward) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(finish_reward_);
  }
  if (finish_reward) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(finish_reward)->GetArena();
    if (message_arena != submessage_arena) {
      finish_reward = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, finish_reward, submessage_arena);
    }
    set_has_finish_reward();
  } else {
    clear_has_finish_reward();
  }
  finish_reward_ = finish_reward;
  // @@protoc_insertion_point(field_set_allocated:sg.PVEBattleService.PVEBattleResponse.finish_reward)
}

// optional .sg.UserTeamData user_team = 14;
inline bool PVEBattleService_PVEBattleResponse::has_user_team() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PVEBattleService_PVEBattleResponse::set_has_user_team() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PVEBattleService_PVEBattleResponse::clear_has_user_team() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PVEBattleService_PVEBattleResponse::clear_user_team() {
  if (user_team_ != NULL) user_team_->Clear();
  clear_has_user_team();
}
inline const ::sg::UserTeamData& PVEBattleService_PVEBattleResponse::_internal_user_team() const {
  return *user_team_;
}
inline const ::sg::UserTeamData& PVEBattleService_PVEBattleResponse::user_team() const {
  const ::sg::UserTeamData* p = user_team_;
  // @@protoc_insertion_point(field_get:sg.PVEBattleService.PVEBattleResponse.user_team)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::UserTeamData*>(
      &::sg::_UserTeamData_default_instance_);
}
inline ::sg::UserTeamData* PVEBattleService_PVEBattleResponse::release_user_team() {
  // @@protoc_insertion_point(field_release:sg.PVEBattleService.PVEBattleResponse.user_team)
  clear_has_user_team();
  ::sg::UserTeamData* temp = user_team_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  user_team_ = NULL;
  return temp;
}
inline ::sg::UserTeamData* PVEBattleService_PVEBattleResponse::unsafe_arena_release_user_team() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.PVEBattleService.PVEBattleResponse.user_team)
  clear_has_user_team();
  ::sg::UserTeamData* temp = user_team_;
  user_team_ = NULL;
  return temp;
}
inline ::sg::UserTeamData* PVEBattleService_PVEBattleResponse::mutable_user_team() {
  set_has_user_team();
  if (user_team_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::UserTeamData>(GetArenaNoVirtual());
    user_team_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.PVEBattleService.PVEBattleResponse.user_team)
  return user_team_;
}
inline void PVEBattleService_PVEBattleResponse::set_allocated_user_team(::sg::UserTeamData* user_team) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete user_team_;
  }
  if (user_team) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(user_team);
    if (message_arena != submessage_arena) {
      user_team = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user_team, submessage_arena);
    }
    set_has_user_team();
  } else {
    clear_has_user_team();
  }
  user_team_ = user_team;
  // @@protoc_insertion_point(field_set_allocated:sg.PVEBattleService.PVEBattleResponse.user_team)
}

// -------------------------------------------------------------------

// PVEBattleService

// optional .sg.PVEBattleService.PVEBattleRequest req = 1;
inline bool PVEBattleService::has_req() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PVEBattleService::set_has_req() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PVEBattleService::clear_has_req() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PVEBattleService::clear_req() {
  if (req_ != NULL) req_->Clear();
  clear_has_req();
}
inline const ::sg::PVEBattleService_PVEBattleRequest& PVEBattleService::_internal_req() const {
  return *req_;
}
inline const ::sg::PVEBattleService_PVEBattleRequest& PVEBattleService::req() const {
  const ::sg::PVEBattleService_PVEBattleRequest* p = req_;
  // @@protoc_insertion_point(field_get:sg.PVEBattleService.req)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::PVEBattleService_PVEBattleRequest*>(
      &::sg::_PVEBattleService_PVEBattleRequest_default_instance_);
}
inline ::sg::PVEBattleService_PVEBattleRequest* PVEBattleService::release_req() {
  // @@protoc_insertion_point(field_release:sg.PVEBattleService.req)
  clear_has_req();
  ::sg::PVEBattleService_PVEBattleRequest* temp = req_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  req_ = NULL;
  return temp;
}
inline ::sg::PVEBattleService_PVEBattleRequest* PVEBattleService::unsafe_arena_release_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.PVEBattleService.req)
  clear_has_req();
  ::sg::PVEBattleService_PVEBattleRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline ::sg::PVEBattleService_PVEBattleRequest* PVEBattleService::mutable_req() {
  set_has_req();
  if (req_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::PVEBattleService_PVEBattleRequest>(GetArenaNoVirtual());
    req_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.PVEBattleService.req)
  return req_;
}
inline void PVEBattleService::set_allocated_req(::sg::PVEBattleService_PVEBattleRequest* req) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete req_;
  }
  if (req) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(req);
    if (message_arena != submessage_arena) {
      req = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, req, submessage_arena);
    }
    set_has_req();
  } else {
    clear_has_req();
  }
  req_ = req;
  // @@protoc_insertion_point(field_set_allocated:sg.PVEBattleService.req)
}

// optional .sg.PVEBattleService.PVEBattleResponse resp = 2;
inline bool PVEBattleService::has_resp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PVEBattleService::set_has_resp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PVEBattleService::clear_has_resp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PVEBattleService::clear_resp() {
  if (resp_ != NULL) resp_->Clear();
  clear_has_resp();
}
inline const ::sg::PVEBattleService_PVEBattleResponse& PVEBattleService::_internal_resp() const {
  return *resp_;
}
inline const ::sg::PVEBattleService_PVEBattleResponse& PVEBattleService::resp() const {
  const ::sg::PVEBattleService_PVEBattleResponse* p = resp_;
  // @@protoc_insertion_point(field_get:sg.PVEBattleService.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::PVEBattleService_PVEBattleResponse*>(
      &::sg::_PVEBattleService_PVEBattleResponse_default_instance_);
}
inline ::sg::PVEBattleService_PVEBattleResponse* PVEBattleService::release_resp() {
  // @@protoc_insertion_point(field_release:sg.PVEBattleService.resp)
  clear_has_resp();
  ::sg::PVEBattleService_PVEBattleResponse* temp = resp_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  resp_ = NULL;
  return temp;
}
inline ::sg::PVEBattleService_PVEBattleResponse* PVEBattleService::unsafe_arena_release_resp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.PVEBattleService.resp)
  clear_has_resp();
  ::sg::PVEBattleService_PVEBattleResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline ::sg::PVEBattleService_PVEBattleResponse* PVEBattleService::mutable_resp() {
  set_has_resp();
  if (resp_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::PVEBattleService_PVEBattleResponse>(GetArenaNoVirtual());
    resp_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.PVEBattleService.resp)
  return resp_;
}
inline void PVEBattleService::set_allocated_resp(::sg::PVEBattleService_PVEBattleResponse* resp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete resp_;
  }
  if (resp) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(resp);
    if (message_arena != submessage_arena) {
      resp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, resp, submessage_arena);
    }
    set_has_resp();
  } else {
    clear_has_resp();
  }
  resp_ = resp;
  // @@protoc_insertion_point(field_set_allocated:sg.PVEBattleService.resp)
}

// -------------------------------------------------------------------

// DungeonInfo

// required int32 id = 1;
inline bool DungeonInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DungeonInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DungeonInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DungeonInfo::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 DungeonInfo::id() const {
  // @@protoc_insertion_point(field_get:sg.DungeonInfo.id)
  return id_;
}
inline void DungeonInfo::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:sg.DungeonInfo.id)
}

// required int32 state = 2;
inline bool DungeonInfo::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DungeonInfo::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DungeonInfo::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DungeonInfo::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 DungeonInfo::state() const {
  // @@protoc_insertion_point(field_get:sg.DungeonInfo.state)
  return state_;
}
inline void DungeonInfo::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:sg.DungeonInfo.state)
}

// optional int32 clear_times = 3;
inline bool DungeonInfo::has_clear_times() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DungeonInfo::set_has_clear_times() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DungeonInfo::clear_has_clear_times() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DungeonInfo::clear_clear_times() {
  clear_times_ = 0;
  clear_has_clear_times();
}
inline ::google::protobuf::int32 DungeonInfo::clear_times() const {
  // @@protoc_insertion_point(field_get:sg.DungeonInfo.clear_times)
  return clear_times_;
}
inline void DungeonInfo::set_clear_times(::google::protobuf::int32 value) {
  set_has_clear_times();
  clear_times_ = value;
  // @@protoc_insertion_point(field_set:sg.DungeonInfo.clear_times)
}

// optional int32 max_layer = 4;
inline bool DungeonInfo::has_max_layer() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DungeonInfo::set_has_max_layer() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DungeonInfo::clear_has_max_layer() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DungeonInfo::clear_max_layer() {
  max_layer_ = 0;
  clear_has_max_layer();
}
inline ::google::protobuf::int32 DungeonInfo::max_layer() const {
  // @@protoc_insertion_point(field_get:sg.DungeonInfo.max_layer)
  return max_layer_;
}
inline void DungeonInfo::set_max_layer(::google::protobuf::int32 value) {
  set_has_max_layer();
  max_layer_ = value;
  // @@protoc_insertion_point(field_set:sg.DungeonInfo.max_layer)
}

// repeated int32 reward_received = 5;
inline int DungeonInfo::reward_received_size() const {
  return reward_received_.size();
}
inline void DungeonInfo::clear_reward_received() {
  reward_received_.Clear();
}
inline ::google::protobuf::int32 DungeonInfo::reward_received(int index) const {
  // @@protoc_insertion_point(field_get:sg.DungeonInfo.reward_received)
  return reward_received_.Get(index);
}
inline void DungeonInfo::set_reward_received(int index, ::google::protobuf::int32 value) {
  reward_received_.Set(index, value);
  // @@protoc_insertion_point(field_set:sg.DungeonInfo.reward_received)
}
inline void DungeonInfo::add_reward_received(::google::protobuf::int32 value) {
  reward_received_.Add(value);
  // @@protoc_insertion_point(field_add:sg.DungeonInfo.reward_received)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
DungeonInfo::reward_received() const {
  // @@protoc_insertion_point(field_list:sg.DungeonInfo.reward_received)
  return reward_received_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
DungeonInfo::mutable_reward_received() {
  // @@protoc_insertion_point(field_mutable_list:sg.DungeonInfo.reward_received)
  return &reward_received_;
}

// optional int32 daily_times = 6;
inline bool DungeonInfo::has_daily_times() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DungeonInfo::set_has_daily_times() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DungeonInfo::clear_has_daily_times() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DungeonInfo::clear_daily_times() {
  daily_times_ = 0;
  clear_has_daily_times();
}
inline ::google::protobuf::int32 DungeonInfo::daily_times() const {
  // @@protoc_insertion_point(field_get:sg.DungeonInfo.daily_times)
  return daily_times_;
}
inline void DungeonInfo::set_daily_times(::google::protobuf::int32 value) {
  set_has_daily_times();
  daily_times_ = value;
  // @@protoc_insertion_point(field_set:sg.DungeonInfo.daily_times)
}

// repeated int32 open_chest = 7;
inline int DungeonInfo::open_chest_size() const {
  return open_chest_.size();
}
inline void DungeonInfo::clear_open_chest() {
  open_chest_.Clear();
}
inline ::google::protobuf::int32 DungeonInfo::open_chest(int index) const {
  // @@protoc_insertion_point(field_get:sg.DungeonInfo.open_chest)
  return open_chest_.Get(index);
}
inline void DungeonInfo::set_open_chest(int index, ::google::protobuf::int32 value) {
  open_chest_.Set(index, value);
  // @@protoc_insertion_point(field_set:sg.DungeonInfo.open_chest)
}
inline void DungeonInfo::add_open_chest(::google::protobuf::int32 value) {
  open_chest_.Add(value);
  // @@protoc_insertion_point(field_add:sg.DungeonInfo.open_chest)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
DungeonInfo::open_chest() const {
  // @@protoc_insertion_point(field_list:sg.DungeonInfo.open_chest)
  return open_chest_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
DungeonInfo::mutable_open_chest() {
  // @@protoc_insertion_point(field_mutable_list:sg.DungeonInfo.open_chest)
  return &open_chest_;
}

// -------------------------------------------------------------------

// UserDungeonService_UserDungeonRequest

// required .sg.UserDungeonService.DUNGEON_CMD cmd = 1;
inline bool UserDungeonService_UserDungeonRequest::has_cmd() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserDungeonService_UserDungeonRequest::set_has_cmd() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserDungeonService_UserDungeonRequest::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserDungeonService_UserDungeonRequest::clear_cmd() {
  cmd_ = 1;
  clear_has_cmd();
}
inline ::sg::UserDungeonService_DUNGEON_CMD UserDungeonService_UserDungeonRequest::cmd() const {
  // @@protoc_insertion_point(field_get:sg.UserDungeonService.UserDungeonRequest.cmd)
  return static_cast< ::sg::UserDungeonService_DUNGEON_CMD >(cmd_);
}
inline void UserDungeonService_UserDungeonRequest::set_cmd(::sg::UserDungeonService_DUNGEON_CMD value) {
  assert(::sg::UserDungeonService_DUNGEON_CMD_IsValid(value));
  set_has_cmd();
  cmd_ = value;
  // @@protoc_insertion_point(field_set:sg.UserDungeonService.UserDungeonRequest.cmd)
}

// optional int32 dungeon_id = 2;
inline bool UserDungeonService_UserDungeonRequest::has_dungeon_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserDungeonService_UserDungeonRequest::set_has_dungeon_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserDungeonService_UserDungeonRequest::clear_has_dungeon_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserDungeonService_UserDungeonRequest::clear_dungeon_id() {
  dungeon_id_ = 0;
  clear_has_dungeon_id();
}
inline ::google::protobuf::int32 UserDungeonService_UserDungeonRequest::dungeon_id() const {
  // @@protoc_insertion_point(field_get:sg.UserDungeonService.UserDungeonRequest.dungeon_id)
  return dungeon_id_;
}
inline void UserDungeonService_UserDungeonRequest::set_dungeon_id(::google::protobuf::int32 value) {
  set_has_dungeon_id();
  dungeon_id_ = value;
  // @@protoc_insertion_point(field_set:sg.UserDungeonService.UserDungeonRequest.dungeon_id)
}

// optional int32 event_id = 3;
inline bool UserDungeonService_UserDungeonRequest::has_event_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserDungeonService_UserDungeonRequest::set_has_event_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserDungeonService_UserDungeonRequest::clear_has_event_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserDungeonService_UserDungeonRequest::clear_event_id() {
  event_id_ = 0;
  clear_has_event_id();
}
inline ::google::protobuf::int32 UserDungeonService_UserDungeonRequest::event_id() const {
  // @@protoc_insertion_point(field_get:sg.UserDungeonService.UserDungeonRequest.event_id)
  return event_id_;
}
inline void UserDungeonService_UserDungeonRequest::set_event_id(::google::protobuf::int32 value) {
  set_has_event_id();
  event_id_ = value;
  // @@protoc_insertion_point(field_set:sg.UserDungeonService.UserDungeonRequest.event_id)
}

// optional int32 layer = 4;
inline bool UserDungeonService_UserDungeonRequest::has_layer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserDungeonService_UserDungeonRequest::set_has_layer() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserDungeonService_UserDungeonRequest::clear_has_layer() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserDungeonService_UserDungeonRequest::clear_layer() {
  layer_ = 0;
  clear_has_layer();
}
inline ::google::protobuf::int32 UserDungeonService_UserDungeonRequest::layer() const {
  // @@protoc_insertion_point(field_get:sg.UserDungeonService.UserDungeonRequest.layer)
  return layer_;
}
inline void UserDungeonService_UserDungeonRequest::set_layer(::google::protobuf::int32 value) {
  set_has_layer();
  layer_ = value;
  // @@protoc_insertion_point(field_set:sg.UserDungeonService.UserDungeonRequest.layer)
}

// -------------------------------------------------------------------

// UserDungeonService_UserDungeonResponse

// required int32 result = 1;
inline bool UserDungeonService_UserDungeonResponse::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserDungeonService_UserDungeonResponse::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserDungeonService_UserDungeonResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserDungeonService_UserDungeonResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 UserDungeonService_UserDungeonResponse::result() const {
  // @@protoc_insertion_point(field_get:sg.UserDungeonService.UserDungeonResponse.result)
  return result_;
}
inline void UserDungeonService_UserDungeonResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:sg.UserDungeonService.UserDungeonResponse.result)
}

// repeated .sg.DungeonEvent events = 2;
inline int UserDungeonService_UserDungeonResponse::events_size() const {
  return events_.size();
}
inline void UserDungeonService_UserDungeonResponse::clear_events() {
  events_.Clear();
}
inline ::sg::DungeonEvent* UserDungeonService_UserDungeonResponse::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:sg.UserDungeonService.UserDungeonResponse.events)
  return events_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::DungeonEvent >*
UserDungeonService_UserDungeonResponse::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:sg.UserDungeonService.UserDungeonResponse.events)
  return &events_;
}
inline const ::sg::DungeonEvent& UserDungeonService_UserDungeonResponse::events(int index) const {
  // @@protoc_insertion_point(field_get:sg.UserDungeonService.UserDungeonResponse.events)
  return events_.Get(index);
}
inline ::sg::DungeonEvent* UserDungeonService_UserDungeonResponse::add_events() {
  // @@protoc_insertion_point(field_add:sg.UserDungeonService.UserDungeonResponse.events)
  return events_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::DungeonEvent >&
UserDungeonService_UserDungeonResponse::events() const {
  // @@protoc_insertion_point(field_list:sg.UserDungeonService.UserDungeonResponse.events)
  return events_;
}

// repeated .sg.DungeonInfo dungeons = 3;
inline int UserDungeonService_UserDungeonResponse::dungeons_size() const {
  return dungeons_.size();
}
inline void UserDungeonService_UserDungeonResponse::clear_dungeons() {
  dungeons_.Clear();
}
inline ::sg::DungeonInfo* UserDungeonService_UserDungeonResponse::mutable_dungeons(int index) {
  // @@protoc_insertion_point(field_mutable:sg.UserDungeonService.UserDungeonResponse.dungeons)
  return dungeons_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::DungeonInfo >*
UserDungeonService_UserDungeonResponse::mutable_dungeons() {
  // @@protoc_insertion_point(field_mutable_list:sg.UserDungeonService.UserDungeonResponse.dungeons)
  return &dungeons_;
}
inline const ::sg::DungeonInfo& UserDungeonService_UserDungeonResponse::dungeons(int index) const {
  // @@protoc_insertion_point(field_get:sg.UserDungeonService.UserDungeonResponse.dungeons)
  return dungeons_.Get(index);
}
inline ::sg::DungeonInfo* UserDungeonService_UserDungeonResponse::add_dungeons() {
  // @@protoc_insertion_point(field_add:sg.UserDungeonService.UserDungeonResponse.dungeons)
  return dungeons_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::DungeonInfo >&
UserDungeonService_UserDungeonResponse::dungeons() const {
  // @@protoc_insertion_point(field_list:sg.UserDungeonService.UserDungeonResponse.dungeons)
  return dungeons_;
}

// optional .sg.Reward reward = 4;
inline bool UserDungeonService_UserDungeonResponse::has_reward() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserDungeonService_UserDungeonResponse::set_has_reward() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserDungeonService_UserDungeonResponse::clear_has_reward() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::sg::Reward& UserDungeonService_UserDungeonResponse::_internal_reward() const {
  return *reward_;
}
inline const ::sg::Reward& UserDungeonService_UserDungeonResponse::reward() const {
  const ::sg::Reward* p = reward_;
  // @@protoc_insertion_point(field_get:sg.UserDungeonService.UserDungeonResponse.reward)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::Reward*>(
      &::sg::_Reward_default_instance_);
}
inline ::sg::Reward* UserDungeonService_UserDungeonResponse::release_reward() {
  // @@protoc_insertion_point(field_release:sg.UserDungeonService.UserDungeonResponse.reward)
  clear_has_reward();
  ::sg::Reward* temp = reward_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  reward_ = NULL;
  return temp;
}
inline ::sg::Reward* UserDungeonService_UserDungeonResponse::unsafe_arena_release_reward() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.UserDungeonService.UserDungeonResponse.reward)
  clear_has_reward();
  ::sg::Reward* temp = reward_;
  reward_ = NULL;
  return temp;
}
inline ::sg::Reward* UserDungeonService_UserDungeonResponse::mutable_reward() {
  set_has_reward();
  if (reward_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::Reward>(GetArenaNoVirtual());
    reward_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.UserDungeonService.UserDungeonResponse.reward)
  return reward_;
}
inline void UserDungeonService_UserDungeonResponse::set_allocated_reward(::sg::Reward* reward) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(reward_);
  }
  if (reward) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(reward)->GetArena();
    if (message_arena != submessage_arena) {
      reward = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, reward, submessage_arena);
    }
    set_has_reward();
  } else {
    clear_has_reward();
  }
  reward_ = reward;
  // @@protoc_insertion_point(field_set_allocated:sg.UserDungeonService.UserDungeonResponse.reward)
}

// optional int32 cost_viality = 5;
inline bool UserDungeonService_UserDungeonResponse::has_cost_viality() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserDungeonService_UserDungeonResponse::set_has_cost_viality() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserDungeonService_UserDungeonResponse::clear_has_cost_viality() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserDungeonService_UserDungeonResponse::clear_cost_viality() {
  cost_viality_ = 0;
  clear_has_cost_viality();
}
inline ::google::protobuf::int32 UserDungeonService_UserDungeonResponse::cost_viality() const {
  // @@protoc_insertion_point(field_get:sg.UserDungeonService.UserDungeonResponse.cost_viality)
  return cost_viality_;
}
inline void UserDungeonService_UserDungeonResponse::set_cost_viality(::google::protobuf::int32 value) {
  set_has_cost_viality();
  cost_viality_ = value;
  // @@protoc_insertion_point(field_set:sg.UserDungeonService.UserDungeonResponse.cost_viality)
}

// repeated .sg.pb_pair_int_int saved_customer = 6;
inline int UserDungeonService_UserDungeonResponse::saved_customer_size() const {
  return saved_customer_.size();
}
inline ::sg::pb_pair_int_int* UserDungeonService_UserDungeonResponse::mutable_saved_customer(int index) {
  // @@protoc_insertion_point(field_mutable:sg.UserDungeonService.UserDungeonResponse.saved_customer)
  return saved_customer_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int >*
UserDungeonService_UserDungeonResponse::mutable_saved_customer() {
  // @@protoc_insertion_point(field_mutable_list:sg.UserDungeonService.UserDungeonResponse.saved_customer)
  return &saved_customer_;
}
inline const ::sg::pb_pair_int_int& UserDungeonService_UserDungeonResponse::saved_customer(int index) const {
  // @@protoc_insertion_point(field_get:sg.UserDungeonService.UserDungeonResponse.saved_customer)
  return saved_customer_.Get(index);
}
inline ::sg::pb_pair_int_int* UserDungeonService_UserDungeonResponse::add_saved_customer() {
  // @@protoc_insertion_point(field_add:sg.UserDungeonService.UserDungeonResponse.saved_customer)
  return saved_customer_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int >&
UserDungeonService_UserDungeonResponse::saved_customer() const {
  // @@protoc_insertion_point(field_list:sg.UserDungeonService.UserDungeonResponse.saved_customer)
  return saved_customer_;
}

// -------------------------------------------------------------------

// UserDungeonService

// optional .sg.UserDungeonService.UserDungeonRequest req = 1;
inline bool UserDungeonService::has_req() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserDungeonService::set_has_req() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserDungeonService::clear_has_req() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserDungeonService::clear_req() {
  if (req_ != NULL) req_->Clear();
  clear_has_req();
}
inline const ::sg::UserDungeonService_UserDungeonRequest& UserDungeonService::_internal_req() const {
  return *req_;
}
inline const ::sg::UserDungeonService_UserDungeonRequest& UserDungeonService::req() const {
  const ::sg::UserDungeonService_UserDungeonRequest* p = req_;
  // @@protoc_insertion_point(field_get:sg.UserDungeonService.req)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::UserDungeonService_UserDungeonRequest*>(
      &::sg::_UserDungeonService_UserDungeonRequest_default_instance_);
}
inline ::sg::UserDungeonService_UserDungeonRequest* UserDungeonService::release_req() {
  // @@protoc_insertion_point(field_release:sg.UserDungeonService.req)
  clear_has_req();
  ::sg::UserDungeonService_UserDungeonRequest* temp = req_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  req_ = NULL;
  return temp;
}
inline ::sg::UserDungeonService_UserDungeonRequest* UserDungeonService::unsafe_arena_release_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.UserDungeonService.req)
  clear_has_req();
  ::sg::UserDungeonService_UserDungeonRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline ::sg::UserDungeonService_UserDungeonRequest* UserDungeonService::mutable_req() {
  set_has_req();
  if (req_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::UserDungeonService_UserDungeonRequest>(GetArenaNoVirtual());
    req_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.UserDungeonService.req)
  return req_;
}
inline void UserDungeonService::set_allocated_req(::sg::UserDungeonService_UserDungeonRequest* req) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete req_;
  }
  if (req) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(req);
    if (message_arena != submessage_arena) {
      req = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, req, submessage_arena);
    }
    set_has_req();
  } else {
    clear_has_req();
  }
  req_ = req;
  // @@protoc_insertion_point(field_set_allocated:sg.UserDungeonService.req)
}

// optional .sg.UserDungeonService.UserDungeonResponse resp = 2;
inline bool UserDungeonService::has_resp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserDungeonService::set_has_resp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserDungeonService::clear_has_resp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserDungeonService::clear_resp() {
  if (resp_ != NULL) resp_->Clear();
  clear_has_resp();
}
inline const ::sg::UserDungeonService_UserDungeonResponse& UserDungeonService::_internal_resp() const {
  return *resp_;
}
inline const ::sg::UserDungeonService_UserDungeonResponse& UserDungeonService::resp() const {
  const ::sg::UserDungeonService_UserDungeonResponse* p = resp_;
  // @@protoc_insertion_point(field_get:sg.UserDungeonService.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::UserDungeonService_UserDungeonResponse*>(
      &::sg::_UserDungeonService_UserDungeonResponse_default_instance_);
}
inline ::sg::UserDungeonService_UserDungeonResponse* UserDungeonService::release_resp() {
  // @@protoc_insertion_point(field_release:sg.UserDungeonService.resp)
  clear_has_resp();
  ::sg::UserDungeonService_UserDungeonResponse* temp = resp_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  resp_ = NULL;
  return temp;
}
inline ::sg::UserDungeonService_UserDungeonResponse* UserDungeonService::unsafe_arena_release_resp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.UserDungeonService.resp)
  clear_has_resp();
  ::sg::UserDungeonService_UserDungeonResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline ::sg::UserDungeonService_UserDungeonResponse* UserDungeonService::mutable_resp() {
  set_has_resp();
  if (resp_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::UserDungeonService_UserDungeonResponse>(GetArenaNoVirtual());
    resp_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.UserDungeonService.resp)
  return resp_;
}
inline void UserDungeonService::set_allocated_resp(::sg::UserDungeonService_UserDungeonResponse* resp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete resp_;
  }
  if (resp) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(resp);
    if (message_arena != submessage_arena) {
      resp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, resp, submessage_arena);
    }
    set_has_resp();
  } else {
    clear_has_resp();
  }
  resp_ = resp;
  // @@protoc_insertion_point(field_set_allocated:sg.UserDungeonService.resp)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace sg

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::sg::PVEBattleService_PVE_CMD> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::PVEBattleService_PVE_CMD>() {
  return ::sg::PVEBattleService_PVE_CMD_descriptor();
}
template <> struct is_proto_enum< ::sg::UserDungeonService_DUNGEON_CMD> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::UserDungeonService_DUNGEON_CMD>() {
  return ::sg::UserDungeonService_DUNGEON_CMD_descriptor();
}
template <> struct is_proto_enum< ::sg::DUNGEON_SPECIAL_EVENT> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::DUNGEON_SPECIAL_EVENT>() {
  return ::sg::DUNGEON_SPECIAL_EVENT_descriptor();
}
template <> struct is_proto_enum< ::sg::PVE_BATTLE_RESULT> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::PVE_BATTLE_RESULT>() {
  return ::sg::PVE_BATTLE_RESULT_descriptor();
}
template <> struct is_proto_enum< ::sg::DUNGEON_STATE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::DUNGEON_STATE>() {
  return ::sg::DUNGEON_STATE_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_PVE_2eproto
