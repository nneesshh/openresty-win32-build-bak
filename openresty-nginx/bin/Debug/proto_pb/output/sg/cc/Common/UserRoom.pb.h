// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: UserRoom.proto

#ifndef PROTOBUF_INCLUDED_UserRoom_2eproto
#define PROTOBUF_INCLUDED_UserRoom_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "BaseStruct.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_UserRoom_2eproto 

namespace protobuf_UserRoom_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[3];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_UserRoom_2eproto
namespace sg {
class UserRoomService;
class UserRoomServiceDefaultTypeInternal;
extern UserRoomServiceDefaultTypeInternal _UserRoomService_default_instance_;
class UserRoomService_UserRoomRequest;
class UserRoomService_UserRoomRequestDefaultTypeInternal;
extern UserRoomService_UserRoomRequestDefaultTypeInternal _UserRoomService_UserRoomRequest_default_instance_;
class UserRoomService_UserRoomResponse;
class UserRoomService_UserRoomResponseDefaultTypeInternal;
extern UserRoomService_UserRoomResponseDefaultTypeInternal _UserRoomService_UserRoomResponse_default_instance_;
}  // namespace sg
namespace google {
namespace protobuf {
template<> ::sg::UserRoomService* Arena::CreateMaybeMessage<::sg::UserRoomService>(Arena*);
template<> ::sg::UserRoomService_UserRoomRequest* Arena::CreateMaybeMessage<::sg::UserRoomService_UserRoomRequest>(Arena*);
template<> ::sg::UserRoomService_UserRoomResponse* Arena::CreateMaybeMessage<::sg::UserRoomService_UserRoomResponse>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace sg {

enum UserRoomService_ROOM_CMD {
  UserRoomService_ROOM_CMD_QUERY = 1,
  UserRoomService_ROOM_CMD_CHANGE = 2
};
bool UserRoomService_ROOM_CMD_IsValid(int value);
const UserRoomService_ROOM_CMD UserRoomService_ROOM_CMD_ROOM_CMD_MIN = UserRoomService_ROOM_CMD_QUERY;
const UserRoomService_ROOM_CMD UserRoomService_ROOM_CMD_ROOM_CMD_MAX = UserRoomService_ROOM_CMD_CHANGE;
const int UserRoomService_ROOM_CMD_ROOM_CMD_ARRAYSIZE = UserRoomService_ROOM_CMD_ROOM_CMD_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserRoomService_ROOM_CMD_descriptor();
inline const ::std::string& UserRoomService_ROOM_CMD_Name(UserRoomService_ROOM_CMD value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserRoomService_ROOM_CMD_descriptor(), value);
}
inline bool UserRoomService_ROOM_CMD_Parse(
    const ::std::string& name, UserRoomService_ROOM_CMD* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserRoomService_ROOM_CMD>(
    UserRoomService_ROOM_CMD_descriptor(), name, value);
}
// ===================================================================

class UserRoomService_UserRoomRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.UserRoomService.UserRoomRequest) */ {
 public:
  UserRoomService_UserRoomRequest();
  virtual ~UserRoomService_UserRoomRequest();

  UserRoomService_UserRoomRequest(const UserRoomService_UserRoomRequest& from);

  inline UserRoomService_UserRoomRequest& operator=(const UserRoomService_UserRoomRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserRoomService_UserRoomRequest(UserRoomService_UserRoomRequest&& from) noexcept
    : UserRoomService_UserRoomRequest() {
    *this = ::std::move(from);
  }

  inline UserRoomService_UserRoomRequest& operator=(UserRoomService_UserRoomRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserRoomService_UserRoomRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserRoomService_UserRoomRequest* internal_default_instance() {
    return reinterpret_cast<const UserRoomService_UserRoomRequest*>(
               &_UserRoomService_UserRoomRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void UnsafeArenaSwap(UserRoomService_UserRoomRequest* other);
  void Swap(UserRoomService_UserRoomRequest* other);
  friend void swap(UserRoomService_UserRoomRequest& a, UserRoomService_UserRoomRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserRoomService_UserRoomRequest* New() const final {
    return CreateMaybeMessage<UserRoomService_UserRoomRequest>(NULL);
  }

  UserRoomService_UserRoomRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserRoomService_UserRoomRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserRoomService_UserRoomRequest& from);
  void MergeFrom(const UserRoomService_UserRoomRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserRoomService_UserRoomRequest* other);
  protected:
  explicit UserRoomService_UserRoomRequest(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sg.UserRoom rooms = 4;
  int rooms_size() const;
  void clear_rooms();
  static const int kRoomsFieldNumber = 4;
  ::sg::UserRoom* mutable_rooms(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::UserRoom >*
      mutable_rooms();
  const ::sg::UserRoom& rooms(int index) const;
  ::sg::UserRoom* add_rooms();
  const ::google::protobuf::RepeatedPtrField< ::sg::UserRoom >&
      rooms() const;

  // required .sg.UserRoomService.ROOM_CMD cmd = 1;
  bool has_cmd() const;
  void clear_cmd();
  static const int kCmdFieldNumber = 1;
  ::sg::UserRoomService_ROOM_CMD cmd() const;
  void set_cmd(::sg::UserRoomService_ROOM_CMD value);

  // @@protoc_insertion_point(class_scope:sg.UserRoomService.UserRoomRequest)
 private:
  void set_has_cmd();
  void clear_has_cmd();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::UserRoom > rooms_;
  int cmd_;
  friend struct ::protobuf_UserRoom_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserRoomService_UserRoomResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.UserRoomService.UserRoomResponse) */ {
 public:
  UserRoomService_UserRoomResponse();
  virtual ~UserRoomService_UserRoomResponse();

  UserRoomService_UserRoomResponse(const UserRoomService_UserRoomResponse& from);

  inline UserRoomService_UserRoomResponse& operator=(const UserRoomService_UserRoomResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserRoomService_UserRoomResponse(UserRoomService_UserRoomResponse&& from) noexcept
    : UserRoomService_UserRoomResponse() {
    *this = ::std::move(from);
  }

  inline UserRoomService_UserRoomResponse& operator=(UserRoomService_UserRoomResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserRoomService_UserRoomResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserRoomService_UserRoomResponse* internal_default_instance() {
    return reinterpret_cast<const UserRoomService_UserRoomResponse*>(
               &_UserRoomService_UserRoomResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void UnsafeArenaSwap(UserRoomService_UserRoomResponse* other);
  void Swap(UserRoomService_UserRoomResponse* other);
  friend void swap(UserRoomService_UserRoomResponse& a, UserRoomService_UserRoomResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserRoomService_UserRoomResponse* New() const final {
    return CreateMaybeMessage<UserRoomService_UserRoomResponse>(NULL);
  }

  UserRoomService_UserRoomResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserRoomService_UserRoomResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserRoomService_UserRoomResponse& from);
  void MergeFrom(const UserRoomService_UserRoomResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserRoomService_UserRoomResponse* other);
  protected:
  explicit UserRoomService_UserRoomResponse(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sg.UserRoom rooms = 4;
  int rooms_size() const;
  void clear_rooms();
  static const int kRoomsFieldNumber = 4;
  ::sg::UserRoom* mutable_rooms(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::UserRoom >*
      mutable_rooms();
  const ::sg::UserRoom& rooms(int index) const;
  ::sg::UserRoom* add_rooms();
  const ::google::protobuf::RepeatedPtrField< ::sg::UserRoom >&
      rooms() const;

  // required int32 result = 1;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::google::protobuf::int32 result() const;
  void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.UserRoomService.UserRoomResponse)
 private:
  void set_has_result();
  void clear_has_result();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::UserRoom > rooms_;
  ::google::protobuf::int32 result_;
  friend struct ::protobuf_UserRoom_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserRoomService : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.UserRoomService) */ {
 public:
  UserRoomService();
  virtual ~UserRoomService();

  UserRoomService(const UserRoomService& from);

  inline UserRoomService& operator=(const UserRoomService& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserRoomService(UserRoomService&& from) noexcept
    : UserRoomService() {
    *this = ::std::move(from);
  }

  inline UserRoomService& operator=(UserRoomService&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserRoomService& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserRoomService* internal_default_instance() {
    return reinterpret_cast<const UserRoomService*>(
               &_UserRoomService_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void UnsafeArenaSwap(UserRoomService* other);
  void Swap(UserRoomService* other);
  friend void swap(UserRoomService& a, UserRoomService& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserRoomService* New() const final {
    return CreateMaybeMessage<UserRoomService>(NULL);
  }

  UserRoomService* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserRoomService>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserRoomService& from);
  void MergeFrom(const UserRoomService& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserRoomService* other);
  protected:
  explicit UserRoomService(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UserRoomService_UserRoomRequest UserRoomRequest;
  typedef UserRoomService_UserRoomResponse UserRoomResponse;

  typedef UserRoomService_ROOM_CMD ROOM_CMD;
  static const ROOM_CMD QUERY =
    UserRoomService_ROOM_CMD_QUERY;
  static const ROOM_CMD CHANGE =
    UserRoomService_ROOM_CMD_CHANGE;
  static inline bool ROOM_CMD_IsValid(int value) {
    return UserRoomService_ROOM_CMD_IsValid(value);
  }
  static const ROOM_CMD ROOM_CMD_MIN =
    UserRoomService_ROOM_CMD_ROOM_CMD_MIN;
  static const ROOM_CMD ROOM_CMD_MAX =
    UserRoomService_ROOM_CMD_ROOM_CMD_MAX;
  static const int ROOM_CMD_ARRAYSIZE =
    UserRoomService_ROOM_CMD_ROOM_CMD_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ROOM_CMD_descriptor() {
    return UserRoomService_ROOM_CMD_descriptor();
  }
  static inline const ::std::string& ROOM_CMD_Name(ROOM_CMD value) {
    return UserRoomService_ROOM_CMD_Name(value);
  }
  static inline bool ROOM_CMD_Parse(const ::std::string& name,
      ROOM_CMD* value) {
    return UserRoomService_ROOM_CMD_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .sg.UserRoomService.UserRoomRequest req = 1;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 1;
  private:
  const ::sg::UserRoomService_UserRoomRequest& _internal_req() const;
  public:
  const ::sg::UserRoomService_UserRoomRequest& req() const;
  ::sg::UserRoomService_UserRoomRequest* release_req();
  ::sg::UserRoomService_UserRoomRequest* mutable_req();
  void set_allocated_req(::sg::UserRoomService_UserRoomRequest* req);
  void unsafe_arena_set_allocated_req(
      ::sg::UserRoomService_UserRoomRequest* req);
  ::sg::UserRoomService_UserRoomRequest* unsafe_arena_release_req();

  // optional .sg.UserRoomService.UserRoomResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  private:
  const ::sg::UserRoomService_UserRoomResponse& _internal_resp() const;
  public:
  const ::sg::UserRoomService_UserRoomResponse& resp() const;
  ::sg::UserRoomService_UserRoomResponse* release_resp();
  ::sg::UserRoomService_UserRoomResponse* mutable_resp();
  void set_allocated_resp(::sg::UserRoomService_UserRoomResponse* resp);
  void unsafe_arena_set_allocated_resp(
      ::sg::UserRoomService_UserRoomResponse* resp);
  ::sg::UserRoomService_UserRoomResponse* unsafe_arena_release_resp();

  // @@protoc_insertion_point(class_scope:sg.UserRoomService)
 private:
  void set_has_req();
  void clear_has_req();
  void set_has_resp();
  void clear_has_resp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::sg::UserRoomService_UserRoomRequest* req_;
  ::sg::UserRoomService_UserRoomResponse* resp_;
  friend struct ::protobuf_UserRoom_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// UserRoomService_UserRoomRequest

// required .sg.UserRoomService.ROOM_CMD cmd = 1;
inline bool UserRoomService_UserRoomRequest::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserRoomService_UserRoomRequest::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserRoomService_UserRoomRequest::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserRoomService_UserRoomRequest::clear_cmd() {
  cmd_ = 1;
  clear_has_cmd();
}
inline ::sg::UserRoomService_ROOM_CMD UserRoomService_UserRoomRequest::cmd() const {
  // @@protoc_insertion_point(field_get:sg.UserRoomService.UserRoomRequest.cmd)
  return static_cast< ::sg::UserRoomService_ROOM_CMD >(cmd_);
}
inline void UserRoomService_UserRoomRequest::set_cmd(::sg::UserRoomService_ROOM_CMD value) {
  assert(::sg::UserRoomService_ROOM_CMD_IsValid(value));
  set_has_cmd();
  cmd_ = value;
  // @@protoc_insertion_point(field_set:sg.UserRoomService.UserRoomRequest.cmd)
}

// repeated .sg.UserRoom rooms = 4;
inline int UserRoomService_UserRoomRequest::rooms_size() const {
  return rooms_.size();
}
inline ::sg::UserRoom* UserRoomService_UserRoomRequest::mutable_rooms(int index) {
  // @@protoc_insertion_point(field_mutable:sg.UserRoomService.UserRoomRequest.rooms)
  return rooms_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::UserRoom >*
UserRoomService_UserRoomRequest::mutable_rooms() {
  // @@protoc_insertion_point(field_mutable_list:sg.UserRoomService.UserRoomRequest.rooms)
  return &rooms_;
}
inline const ::sg::UserRoom& UserRoomService_UserRoomRequest::rooms(int index) const {
  // @@protoc_insertion_point(field_get:sg.UserRoomService.UserRoomRequest.rooms)
  return rooms_.Get(index);
}
inline ::sg::UserRoom* UserRoomService_UserRoomRequest::add_rooms() {
  // @@protoc_insertion_point(field_add:sg.UserRoomService.UserRoomRequest.rooms)
  return rooms_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::UserRoom >&
UserRoomService_UserRoomRequest::rooms() const {
  // @@protoc_insertion_point(field_list:sg.UserRoomService.UserRoomRequest.rooms)
  return rooms_;
}

// -------------------------------------------------------------------

// UserRoomService_UserRoomResponse

// required int32 result = 1;
inline bool UserRoomService_UserRoomResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserRoomService_UserRoomResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserRoomService_UserRoomResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserRoomService_UserRoomResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 UserRoomService_UserRoomResponse::result() const {
  // @@protoc_insertion_point(field_get:sg.UserRoomService.UserRoomResponse.result)
  return result_;
}
inline void UserRoomService_UserRoomResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:sg.UserRoomService.UserRoomResponse.result)
}

// repeated .sg.UserRoom rooms = 4;
inline int UserRoomService_UserRoomResponse::rooms_size() const {
  return rooms_.size();
}
inline ::sg::UserRoom* UserRoomService_UserRoomResponse::mutable_rooms(int index) {
  // @@protoc_insertion_point(field_mutable:sg.UserRoomService.UserRoomResponse.rooms)
  return rooms_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::UserRoom >*
UserRoomService_UserRoomResponse::mutable_rooms() {
  // @@protoc_insertion_point(field_mutable_list:sg.UserRoomService.UserRoomResponse.rooms)
  return &rooms_;
}
inline const ::sg::UserRoom& UserRoomService_UserRoomResponse::rooms(int index) const {
  // @@protoc_insertion_point(field_get:sg.UserRoomService.UserRoomResponse.rooms)
  return rooms_.Get(index);
}
inline ::sg::UserRoom* UserRoomService_UserRoomResponse::add_rooms() {
  // @@protoc_insertion_point(field_add:sg.UserRoomService.UserRoomResponse.rooms)
  return rooms_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::UserRoom >&
UserRoomService_UserRoomResponse::rooms() const {
  // @@protoc_insertion_point(field_list:sg.UserRoomService.UserRoomResponse.rooms)
  return rooms_;
}

// -------------------------------------------------------------------

// UserRoomService

// optional .sg.UserRoomService.UserRoomRequest req = 1;
inline bool UserRoomService::has_req() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserRoomService::set_has_req() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserRoomService::clear_has_req() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserRoomService::clear_req() {
  if (req_ != NULL) req_->Clear();
  clear_has_req();
}
inline const ::sg::UserRoomService_UserRoomRequest& UserRoomService::_internal_req() const {
  return *req_;
}
inline const ::sg::UserRoomService_UserRoomRequest& UserRoomService::req() const {
  const ::sg::UserRoomService_UserRoomRequest* p = req_;
  // @@protoc_insertion_point(field_get:sg.UserRoomService.req)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::UserRoomService_UserRoomRequest*>(
      &::sg::_UserRoomService_UserRoomRequest_default_instance_);
}
inline ::sg::UserRoomService_UserRoomRequest* UserRoomService::release_req() {
  // @@protoc_insertion_point(field_release:sg.UserRoomService.req)
  clear_has_req();
  ::sg::UserRoomService_UserRoomRequest* temp = req_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  req_ = NULL;
  return temp;
}
inline ::sg::UserRoomService_UserRoomRequest* UserRoomService::unsafe_arena_release_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.UserRoomService.req)
  clear_has_req();
  ::sg::UserRoomService_UserRoomRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline ::sg::UserRoomService_UserRoomRequest* UserRoomService::mutable_req() {
  set_has_req();
  if (req_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::UserRoomService_UserRoomRequest>(GetArenaNoVirtual());
    req_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.UserRoomService.req)
  return req_;
}
inline void UserRoomService::set_allocated_req(::sg::UserRoomService_UserRoomRequest* req) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete req_;
  }
  if (req) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(req);
    if (message_arena != submessage_arena) {
      req = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, req, submessage_arena);
    }
    set_has_req();
  } else {
    clear_has_req();
  }
  req_ = req;
  // @@protoc_insertion_point(field_set_allocated:sg.UserRoomService.req)
}

// optional .sg.UserRoomService.UserRoomResponse resp = 2;
inline bool UserRoomService::has_resp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserRoomService::set_has_resp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserRoomService::clear_has_resp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserRoomService::clear_resp() {
  if (resp_ != NULL) resp_->Clear();
  clear_has_resp();
}
inline const ::sg::UserRoomService_UserRoomResponse& UserRoomService::_internal_resp() const {
  return *resp_;
}
inline const ::sg::UserRoomService_UserRoomResponse& UserRoomService::resp() const {
  const ::sg::UserRoomService_UserRoomResponse* p = resp_;
  // @@protoc_insertion_point(field_get:sg.UserRoomService.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::UserRoomService_UserRoomResponse*>(
      &::sg::_UserRoomService_UserRoomResponse_default_instance_);
}
inline ::sg::UserRoomService_UserRoomResponse* UserRoomService::release_resp() {
  // @@protoc_insertion_point(field_release:sg.UserRoomService.resp)
  clear_has_resp();
  ::sg::UserRoomService_UserRoomResponse* temp = resp_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  resp_ = NULL;
  return temp;
}
inline ::sg::UserRoomService_UserRoomResponse* UserRoomService::unsafe_arena_release_resp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.UserRoomService.resp)
  clear_has_resp();
  ::sg::UserRoomService_UserRoomResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline ::sg::UserRoomService_UserRoomResponse* UserRoomService::mutable_resp() {
  set_has_resp();
  if (resp_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::UserRoomService_UserRoomResponse>(GetArenaNoVirtual());
    resp_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.UserRoomService.resp)
  return resp_;
}
inline void UserRoomService::set_allocated_resp(::sg::UserRoomService_UserRoomResponse* resp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete resp_;
  }
  if (resp) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(resp);
    if (message_arena != submessage_arena) {
      resp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, resp, submessage_arena);
    }
    set_has_resp();
  } else {
    clear_has_resp();
  }
  resp_ = resp;
  // @@protoc_insertion_point(field_set_allocated:sg.UserRoomService.resp)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace sg

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::sg::UserRoomService_ROOM_CMD> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::UserRoomService_ROOM_CMD>() {
  return ::sg::UserRoomService_ROOM_CMD_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_UserRoom_2eproto
