// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Mail.proto

#ifndef PROTOBUF_INCLUDED_Mail_2eproto
#define PROTOBUF_INCLUDED_Mail_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "BaseStruct.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_Mail_2eproto 

namespace protobuf_Mail_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[10];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_Mail_2eproto
namespace sg {
class ItemAny;
class ItemAnyDefaultTypeInternal;
extern ItemAnyDefaultTypeInternal _ItemAny_default_instance_;
class ItemAnyList;
class ItemAnyListDefaultTypeInternal;
extern ItemAnyListDefaultTypeInternal _ItemAnyList_default_instance_;
class ItemDrop;
class ItemDropDefaultTypeInternal;
extern ItemDropDefaultTypeInternal _ItemDrop_default_instance_;
class ItemDropList;
class ItemDropListDefaultTypeInternal;
extern ItemDropListDefaultTypeInternal _ItemDropList_default_instance_;
class MailData;
class MailDataDefaultTypeInternal;
extern MailDataDefaultTypeInternal _MailData_default_instance_;
class MailDataList;
class MailDataListDefaultTypeInternal;
extern MailDataListDefaultTypeInternal _MailDataList_default_instance_;
class MailboxService;
class MailboxServiceDefaultTypeInternal;
extern MailboxServiceDefaultTypeInternal _MailboxService_default_instance_;
class MailboxService_MailboxRequest;
class MailboxService_MailboxRequestDefaultTypeInternal;
extern MailboxService_MailboxRequestDefaultTypeInternal _MailboxService_MailboxRequest_default_instance_;
class MailboxService_MailboxResponse;
class MailboxService_MailboxResponseDefaultTypeInternal;
extern MailboxService_MailboxResponseDefaultTypeInternal _MailboxService_MailboxResponse_default_instance_;
class NewMailNotify;
class NewMailNotifyDefaultTypeInternal;
extern NewMailNotifyDefaultTypeInternal _NewMailNotify_default_instance_;
}  // namespace sg
namespace google {
namespace protobuf {
template<> ::sg::ItemAny* Arena::CreateMaybeMessage<::sg::ItemAny>(Arena*);
template<> ::sg::ItemAnyList* Arena::CreateMaybeMessage<::sg::ItemAnyList>(Arena*);
template<> ::sg::ItemDrop* Arena::CreateMaybeMessage<::sg::ItemDrop>(Arena*);
template<> ::sg::ItemDropList* Arena::CreateMaybeMessage<::sg::ItemDropList>(Arena*);
template<> ::sg::MailData* Arena::CreateMaybeMessage<::sg::MailData>(Arena*);
template<> ::sg::MailDataList* Arena::CreateMaybeMessage<::sg::MailDataList>(Arena*);
template<> ::sg::MailboxService* Arena::CreateMaybeMessage<::sg::MailboxService>(Arena*);
template<> ::sg::MailboxService_MailboxRequest* Arena::CreateMaybeMessage<::sg::MailboxService_MailboxRequest>(Arena*);
template<> ::sg::MailboxService_MailboxResponse* Arena::CreateMaybeMessage<::sg::MailboxService_MailboxResponse>(Arena*);
template<> ::sg::NewMailNotify* Arena::CreateMaybeMessage<::sg::NewMailNotify>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace sg {

enum ItemAny_ITEM_TYPE {
  ItemAny_ITEM_TYPE_ITEM_NONE = 0,
  ItemAny_ITEM_TYPE_ITEM_RESOURCE = 1
};
bool ItemAny_ITEM_TYPE_IsValid(int value);
const ItemAny_ITEM_TYPE ItemAny_ITEM_TYPE_ITEM_TYPE_MIN = ItemAny_ITEM_TYPE_ITEM_NONE;
const ItemAny_ITEM_TYPE ItemAny_ITEM_TYPE_ITEM_TYPE_MAX = ItemAny_ITEM_TYPE_ITEM_RESOURCE;
const int ItemAny_ITEM_TYPE_ITEM_TYPE_ARRAYSIZE = ItemAny_ITEM_TYPE_ITEM_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* ItemAny_ITEM_TYPE_descriptor();
inline const ::std::string& ItemAny_ITEM_TYPE_Name(ItemAny_ITEM_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    ItemAny_ITEM_TYPE_descriptor(), value);
}
inline bool ItemAny_ITEM_TYPE_Parse(
    const ::std::string& name, ItemAny_ITEM_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ItemAny_ITEM_TYPE>(
    ItemAny_ITEM_TYPE_descriptor(), name, value);
}
enum MailData_MAIL_TYPE {
  MailData_MAIL_TYPE_MAIL_TYPE_UNKNOWN = 0,
  MailData_MAIL_TYPE_MAIL_TYPE_COMPENSATE = 1,
  MailData_MAIL_TYPE_MAIL_TYPE_FIRST_CHARGE = 2,
  MailData_MAIL_TYPE_MAIL_TYPE_MONTH_CARD = 3,
  MailData_MAIL_TYPE_MAIL_TYPE_RANKING_REWARD = 4,
  MailData_MAIL_TYPE_MAIL_TYPE_GUILD = 5,
  MailData_MAIL_TYPE_MAIL_TYPE_LV_SHOPPING = 6
};
bool MailData_MAIL_TYPE_IsValid(int value);
const MailData_MAIL_TYPE MailData_MAIL_TYPE_MAIL_TYPE_MIN = MailData_MAIL_TYPE_MAIL_TYPE_UNKNOWN;
const MailData_MAIL_TYPE MailData_MAIL_TYPE_MAIL_TYPE_MAX = MailData_MAIL_TYPE_MAIL_TYPE_LV_SHOPPING;
const int MailData_MAIL_TYPE_MAIL_TYPE_ARRAYSIZE = MailData_MAIL_TYPE_MAIL_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* MailData_MAIL_TYPE_descriptor();
inline const ::std::string& MailData_MAIL_TYPE_Name(MailData_MAIL_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    MailData_MAIL_TYPE_descriptor(), value);
}
inline bool MailData_MAIL_TYPE_Parse(
    const ::std::string& name, MailData_MAIL_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MailData_MAIL_TYPE>(
    MailData_MAIL_TYPE_descriptor(), name, value);
}
enum MailData_MAIL_STATE {
  MailData_MAIL_STATE_BURN = -1,
  MailData_MAIL_STATE_INVALID = 0,
  MailData_MAIL_STATE_UNREAD = 1,
  MailData_MAIL_STATE_READ = 2,
  MailData_MAIL_STATE_ACCEPT = 3
};
bool MailData_MAIL_STATE_IsValid(int value);
const MailData_MAIL_STATE MailData_MAIL_STATE_MAIL_STATE_MIN = MailData_MAIL_STATE_BURN;
const MailData_MAIL_STATE MailData_MAIL_STATE_MAIL_STATE_MAX = MailData_MAIL_STATE_ACCEPT;
const int MailData_MAIL_STATE_MAIL_STATE_ARRAYSIZE = MailData_MAIL_STATE_MAIL_STATE_MAX + 1;

const ::google::protobuf::EnumDescriptor* MailData_MAIL_STATE_descriptor();
inline const ::std::string& MailData_MAIL_STATE_Name(MailData_MAIL_STATE value) {
  return ::google::protobuf::internal::NameOfEnum(
    MailData_MAIL_STATE_descriptor(), value);
}
inline bool MailData_MAIL_STATE_Parse(
    const ::std::string& name, MailData_MAIL_STATE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MailData_MAIL_STATE>(
    MailData_MAIL_STATE_descriptor(), name, value);
}
enum MailboxService_MAILBOX_COMMAND {
  MailboxService_MAILBOX_COMMAND_QUERY = 1,
  MailboxService_MAILBOX_COMMAND_READ = 2,
  MailboxService_MAILBOX_COMMAND_ACCEPT = 3,
  MailboxService_MAILBOX_COMMAND_BURN = 4,
  MailboxService_MAILBOX_COMMAND_ACCEPT_ALL = 5,
  MailboxService_MAILBOX_COMMAND_BURN_ALL = 6
};
bool MailboxService_MAILBOX_COMMAND_IsValid(int value);
const MailboxService_MAILBOX_COMMAND MailboxService_MAILBOX_COMMAND_MAILBOX_COMMAND_MIN = MailboxService_MAILBOX_COMMAND_QUERY;
const MailboxService_MAILBOX_COMMAND MailboxService_MAILBOX_COMMAND_MAILBOX_COMMAND_MAX = MailboxService_MAILBOX_COMMAND_BURN_ALL;
const int MailboxService_MAILBOX_COMMAND_MAILBOX_COMMAND_ARRAYSIZE = MailboxService_MAILBOX_COMMAND_MAILBOX_COMMAND_MAX + 1;

const ::google::protobuf::EnumDescriptor* MailboxService_MAILBOX_COMMAND_descriptor();
inline const ::std::string& MailboxService_MAILBOX_COMMAND_Name(MailboxService_MAILBOX_COMMAND value) {
  return ::google::protobuf::internal::NameOfEnum(
    MailboxService_MAILBOX_COMMAND_descriptor(), value);
}
inline bool MailboxService_MAILBOX_COMMAND_Parse(
    const ::std::string& name, MailboxService_MAILBOX_COMMAND* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MailboxService_MAILBOX_COMMAND>(
    MailboxService_MAILBOX_COMMAND_descriptor(), name, value);
}
// ===================================================================

class ItemAny : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.ItemAny) */ {
 public:
  ItemAny();
  virtual ~ItemAny();

  ItemAny(const ItemAny& from);

  inline ItemAny& operator=(const ItemAny& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ItemAny(ItemAny&& from) noexcept
    : ItemAny() {
    *this = ::std::move(from);
  }

  inline ItemAny& operator=(ItemAny&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const ItemAny& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ItemAny* internal_default_instance() {
    return reinterpret_cast<const ItemAny*>(
               &_ItemAny_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void UnsafeArenaSwap(ItemAny* other);
  void Swap(ItemAny* other);
  friend void swap(ItemAny& a, ItemAny& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ItemAny* New() const final {
    return CreateMaybeMessage<ItemAny>(NULL);
  }

  ItemAny* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ItemAny>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ItemAny& from);
  void MergeFrom(const ItemAny& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemAny* other);
  protected:
  explicit ItemAny(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ItemAny_ITEM_TYPE ITEM_TYPE;
  static const ITEM_TYPE ITEM_NONE =
    ItemAny_ITEM_TYPE_ITEM_NONE;
  static const ITEM_TYPE ITEM_RESOURCE =
    ItemAny_ITEM_TYPE_ITEM_RESOURCE;
  static inline bool ITEM_TYPE_IsValid(int value) {
    return ItemAny_ITEM_TYPE_IsValid(value);
  }
  static const ITEM_TYPE ITEM_TYPE_MIN =
    ItemAny_ITEM_TYPE_ITEM_TYPE_MIN;
  static const ITEM_TYPE ITEM_TYPE_MAX =
    ItemAny_ITEM_TYPE_ITEM_TYPE_MAX;
  static const int ITEM_TYPE_ARRAYSIZE =
    ItemAny_ITEM_TYPE_ITEM_TYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ITEM_TYPE_descriptor() {
    return ItemAny_ITEM_TYPE_descriptor();
  }
  static inline const ::std::string& ITEM_TYPE_Name(ITEM_TYPE value) {
    return ItemAny_ITEM_TYPE_Name(value);
  }
  static inline bool ITEM_TYPE_Parse(const ::std::string& name,
      ITEM_TYPE* value) {
    return ItemAny_ITEM_TYPE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required uint64 item_typeid = 2;
  bool has_item_typeid() const;
  void clear_item_typeid();
  static const int kItemTypeidFieldNumber = 2;
  ::google::protobuf::uint64 item_typeid() const;
  void set_item_typeid(::google::protobuf::uint64 value);

  // required uint32 item_type = 1;
  bool has_item_type() const;
  void clear_item_type();
  static const int kItemTypeFieldNumber = 1;
  ::google::protobuf::uint32 item_type() const;
  void set_item_type(::google::protobuf::uint32 value);

  // optional int32 val = 3;
  bool has_val() const;
  void clear_val();
  static const int kValFieldNumber = 3;
  ::google::protobuf::int32 val() const;
  void set_val(::google::protobuf::int32 value);

  // optional float probability = 4;
  bool has_probability() const;
  void clear_probability();
  static const int kProbabilityFieldNumber = 4;
  float probability() const;
  void set_probability(float value);

  // @@protoc_insertion_point(class_scope:sg.ItemAny)
 private:
  void set_has_item_type();
  void clear_has_item_type();
  void set_has_item_typeid();
  void clear_has_item_typeid();
  void set_has_val();
  void clear_has_val();
  void set_has_probability();
  void clear_has_probability();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 item_typeid_;
  ::google::protobuf::uint32 item_type_;
  ::google::protobuf::int32 val_;
  float probability_;
  friend struct ::protobuf_Mail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ItemAnyList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.ItemAnyList) */ {
 public:
  ItemAnyList();
  virtual ~ItemAnyList();

  ItemAnyList(const ItemAnyList& from);

  inline ItemAnyList& operator=(const ItemAnyList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ItemAnyList(ItemAnyList&& from) noexcept
    : ItemAnyList() {
    *this = ::std::move(from);
  }

  inline ItemAnyList& operator=(ItemAnyList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const ItemAnyList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ItemAnyList* internal_default_instance() {
    return reinterpret_cast<const ItemAnyList*>(
               &_ItemAnyList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void UnsafeArenaSwap(ItemAnyList* other);
  void Swap(ItemAnyList* other);
  friend void swap(ItemAnyList& a, ItemAnyList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ItemAnyList* New() const final {
    return CreateMaybeMessage<ItemAnyList>(NULL);
  }

  ItemAnyList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ItemAnyList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ItemAnyList& from);
  void MergeFrom(const ItemAnyList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemAnyList* other);
  protected:
  explicit ItemAnyList(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sg.ItemAny list = 1;
  int list_size() const;
  void clear_list();
  static const int kListFieldNumber = 1;
  ::sg::ItemAny* mutable_list(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::ItemAny >*
      mutable_list();
  const ::sg::ItemAny& list(int index) const;
  ::sg::ItemAny* add_list();
  const ::google::protobuf::RepeatedPtrField< ::sg::ItemAny >&
      list() const;

  // @@protoc_insertion_point(class_scope:sg.ItemAnyList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::ItemAny > list_;
  friend struct ::protobuf_Mail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ItemDrop : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.ItemDrop) */ {
 public:
  ItemDrop();
  virtual ~ItemDrop();

  ItemDrop(const ItemDrop& from);

  inline ItemDrop& operator=(const ItemDrop& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ItemDrop(ItemDrop&& from) noexcept
    : ItemDrop() {
    *this = ::std::move(from);
  }

  inline ItemDrop& operator=(ItemDrop&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const ItemDrop& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ItemDrop* internal_default_instance() {
    return reinterpret_cast<const ItemDrop*>(
               &_ItemDrop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void UnsafeArenaSwap(ItemDrop* other);
  void Swap(ItemDrop* other);
  friend void swap(ItemDrop& a, ItemDrop& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ItemDrop* New() const final {
    return CreateMaybeMessage<ItemDrop>(NULL);
  }

  ItemDrop* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ItemDrop>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ItemDrop& from);
  void MergeFrom(const ItemDrop& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemDrop* other);
  protected:
  explicit ItemDrop(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 drop_typeid = 1;
  bool has_drop_typeid() const;
  void clear_drop_typeid();
  static const int kDropTypeidFieldNumber = 1;
  ::google::protobuf::uint64 drop_typeid() const;
  void set_drop_typeid(::google::protobuf::uint64 value);

  // optional int32 drop_num = 2;
  bool has_drop_num() const;
  void clear_drop_num();
  static const int kDropNumFieldNumber = 2;
  ::google::protobuf::int32 drop_num() const;
  void set_drop_num(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.ItemDrop)
 private:
  void set_has_drop_typeid();
  void clear_has_drop_typeid();
  void set_has_drop_num();
  void clear_has_drop_num();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 drop_typeid_;
  ::google::protobuf::int32 drop_num_;
  friend struct ::protobuf_Mail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ItemDropList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.ItemDropList) */ {
 public:
  ItemDropList();
  virtual ~ItemDropList();

  ItemDropList(const ItemDropList& from);

  inline ItemDropList& operator=(const ItemDropList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ItemDropList(ItemDropList&& from) noexcept
    : ItemDropList() {
    *this = ::std::move(from);
  }

  inline ItemDropList& operator=(ItemDropList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const ItemDropList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ItemDropList* internal_default_instance() {
    return reinterpret_cast<const ItemDropList*>(
               &_ItemDropList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void UnsafeArenaSwap(ItemDropList* other);
  void Swap(ItemDropList* other);
  friend void swap(ItemDropList& a, ItemDropList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ItemDropList* New() const final {
    return CreateMaybeMessage<ItemDropList>(NULL);
  }

  ItemDropList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ItemDropList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ItemDropList& from);
  void MergeFrom(const ItemDropList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemDropList* other);
  protected:
  explicit ItemDropList(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sg.ItemDrop list = 1;
  int list_size() const;
  void clear_list();
  static const int kListFieldNumber = 1;
  ::sg::ItemDrop* mutable_list(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::ItemDrop >*
      mutable_list();
  const ::sg::ItemDrop& list(int index) const;
  ::sg::ItemDrop* add_list();
  const ::google::protobuf::RepeatedPtrField< ::sg::ItemDrop >&
      list() const;

  // @@protoc_insertion_point(class_scope:sg.ItemDropList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::ItemDrop > list_;
  friend struct ::protobuf_Mail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MailData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.MailData) */ {
 public:
  MailData();
  virtual ~MailData();

  MailData(const MailData& from);

  inline MailData& operator=(const MailData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MailData(MailData&& from) noexcept
    : MailData() {
    *this = ::std::move(from);
  }

  inline MailData& operator=(MailData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const MailData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MailData* internal_default_instance() {
    return reinterpret_cast<const MailData*>(
               &_MailData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void UnsafeArenaSwap(MailData* other);
  void Swap(MailData* other);
  friend void swap(MailData& a, MailData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MailData* New() const final {
    return CreateMaybeMessage<MailData>(NULL);
  }

  MailData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MailData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MailData& from);
  void MergeFrom(const MailData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MailData* other);
  protected:
  explicit MailData(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MailData_MAIL_TYPE MAIL_TYPE;
  static const MAIL_TYPE MAIL_TYPE_UNKNOWN =
    MailData_MAIL_TYPE_MAIL_TYPE_UNKNOWN;
  static const MAIL_TYPE MAIL_TYPE_COMPENSATE =
    MailData_MAIL_TYPE_MAIL_TYPE_COMPENSATE;
  static const MAIL_TYPE MAIL_TYPE_FIRST_CHARGE =
    MailData_MAIL_TYPE_MAIL_TYPE_FIRST_CHARGE;
  static const MAIL_TYPE MAIL_TYPE_MONTH_CARD =
    MailData_MAIL_TYPE_MAIL_TYPE_MONTH_CARD;
  static const MAIL_TYPE MAIL_TYPE_RANKING_REWARD =
    MailData_MAIL_TYPE_MAIL_TYPE_RANKING_REWARD;
  static const MAIL_TYPE MAIL_TYPE_GUILD =
    MailData_MAIL_TYPE_MAIL_TYPE_GUILD;
  static const MAIL_TYPE MAIL_TYPE_LV_SHOPPING =
    MailData_MAIL_TYPE_MAIL_TYPE_LV_SHOPPING;
  static inline bool MAIL_TYPE_IsValid(int value) {
    return MailData_MAIL_TYPE_IsValid(value);
  }
  static const MAIL_TYPE MAIL_TYPE_MIN =
    MailData_MAIL_TYPE_MAIL_TYPE_MIN;
  static const MAIL_TYPE MAIL_TYPE_MAX =
    MailData_MAIL_TYPE_MAIL_TYPE_MAX;
  static const int MAIL_TYPE_ARRAYSIZE =
    MailData_MAIL_TYPE_MAIL_TYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MAIL_TYPE_descriptor() {
    return MailData_MAIL_TYPE_descriptor();
  }
  static inline const ::std::string& MAIL_TYPE_Name(MAIL_TYPE value) {
    return MailData_MAIL_TYPE_Name(value);
  }
  static inline bool MAIL_TYPE_Parse(const ::std::string& name,
      MAIL_TYPE* value) {
    return MailData_MAIL_TYPE_Parse(name, value);
  }

  typedef MailData_MAIL_STATE MAIL_STATE;
  static const MAIL_STATE BURN =
    MailData_MAIL_STATE_BURN;
  static const MAIL_STATE INVALID =
    MailData_MAIL_STATE_INVALID;
  static const MAIL_STATE UNREAD =
    MailData_MAIL_STATE_UNREAD;
  static const MAIL_STATE READ =
    MailData_MAIL_STATE_READ;
  static const MAIL_STATE ACCEPT =
    MailData_MAIL_STATE_ACCEPT;
  static inline bool MAIL_STATE_IsValid(int value) {
    return MailData_MAIL_STATE_IsValid(value);
  }
  static const MAIL_STATE MAIL_STATE_MIN =
    MailData_MAIL_STATE_MAIL_STATE_MIN;
  static const MAIL_STATE MAIL_STATE_MAX =
    MailData_MAIL_STATE_MAIL_STATE_MAX;
  static const int MAIL_STATE_ARRAYSIZE =
    MailData_MAIL_STATE_MAIL_STATE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MAIL_STATE_descriptor() {
    return MailData_MAIL_STATE_descriptor();
  }
  static inline const ::std::string& MAIL_STATE_Name(MAIL_STATE value) {
    return MailData_MAIL_STATE_Name(value);
  }
  static inline bool MAIL_STATE_Parse(const ::std::string& name,
      MAIL_STATE* value) {
    return MailData_MAIL_STATE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required bytes subject = 11;
  bool has_subject() const;
  void clear_subject();
  static const int kSubjectFieldNumber = 11;
  const ::std::string& subject() const;
  void set_subject(const ::std::string& value);
  #if LANG_CXX11
  void set_subject(::std::string&& value);
  #endif
  void set_subject(const char* value);
  void set_subject(const void* value, size_t size);
  ::std::string* mutable_subject();
  ::std::string* release_subject();
  void set_allocated_subject(::std::string* subject);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_subject();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_subject(
      ::std::string* subject);

  // required bytes content = 12;
  bool has_content() const;
  void clear_content();
  static const int kContentFieldNumber = 12;
  const ::std::string& content() const;
  void set_content(const ::std::string& value);
  #if LANG_CXX11
  void set_content(::std::string&& value);
  #endif
  void set_content(const char* value);
  void set_content(const void* value, size_t size);
  ::std::string* mutable_content();
  ::std::string* release_content();
  void set_allocated_content(::std::string* content);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_content();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_content(
      ::std::string* content);

  // required .sg.ItemAnyList attachment_list = 21;
  bool has_attachment_list() const;
  void clear_attachment_list();
  static const int kAttachmentListFieldNumber = 21;
  private:
  const ::sg::ItemAnyList& _internal_attachment_list() const;
  public:
  const ::sg::ItemAnyList& attachment_list() const;
  ::sg::ItemAnyList* release_attachment_list();
  ::sg::ItemAnyList* mutable_attachment_list();
  void set_allocated_attachment_list(::sg::ItemAnyList* attachment_list);
  void unsafe_arena_set_allocated_attachment_list(
      ::sg::ItemAnyList* attachment_list);
  ::sg::ItemAnyList* unsafe_arena_release_attachment_list();

  // required int64 mailid = 1;
  bool has_mailid() const;
  void clear_mailid();
  static const int kMailidFieldNumber = 1;
  ::google::protobuf::int64 mailid() const;
  void set_mailid(::google::protobuf::int64 value);

  // required .sg.MailData.MAIL_TYPE type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::sg::MailData_MAIL_TYPE type() const;
  void set_type(::sg::MailData_MAIL_TYPE value);

  // required sfixed64 createtime = 31;
  bool has_createtime() const;
  void clear_createtime();
  static const int kCreatetimeFieldNumber = 31;
  ::google::protobuf::int64 createtime() const;
  void set_createtime(::google::protobuf::int64 value);

  // required sfixed64 burntime = 32;
  bool has_burntime() const;
  void clear_burntime();
  static const int kBurntimeFieldNumber = 32;
  ::google::protobuf::int64 burntime() const;
  void set_burntime(::google::protobuf::int64 value);

  // required .sg.MailData.MAIL_STATE state = 3;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 3;
  ::sg::MailData_MAIL_STATE state() const;
  void set_state(::sg::MailData_MAIL_STATE value);

  // @@protoc_insertion_point(class_scope:sg.MailData)
 private:
  void set_has_mailid();
  void clear_has_mailid();
  void set_has_type();
  void clear_has_type();
  void set_has_state();
  void clear_has_state();
  void set_has_subject();
  void clear_has_subject();
  void set_has_content();
  void clear_has_content();
  void set_has_attachment_list();
  void clear_has_attachment_list();
  void set_has_createtime();
  void clear_has_createtime();
  void set_has_burntime();
  void clear_has_burntime();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr subject_;
  ::google::protobuf::internal::ArenaStringPtr content_;
  ::sg::ItemAnyList* attachment_list_;
  ::google::protobuf::int64 mailid_;
  int type_;
  ::google::protobuf::int64 createtime_;
  ::google::protobuf::int64 burntime_;
  int state_;
  friend struct ::protobuf_Mail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MailDataList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.MailDataList) */ {
 public:
  MailDataList();
  virtual ~MailDataList();

  MailDataList(const MailDataList& from);

  inline MailDataList& operator=(const MailDataList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MailDataList(MailDataList&& from) noexcept
    : MailDataList() {
    *this = ::std::move(from);
  }

  inline MailDataList& operator=(MailDataList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const MailDataList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MailDataList* internal_default_instance() {
    return reinterpret_cast<const MailDataList*>(
               &_MailDataList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void UnsafeArenaSwap(MailDataList* other);
  void Swap(MailDataList* other);
  friend void swap(MailDataList& a, MailDataList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MailDataList* New() const final {
    return CreateMaybeMessage<MailDataList>(NULL);
  }

  MailDataList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MailDataList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MailDataList& from);
  void MergeFrom(const MailDataList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MailDataList* other);
  protected:
  explicit MailDataList(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sg.MailData list = 1;
  int list_size() const;
  void clear_list();
  static const int kListFieldNumber = 1;
  ::sg::MailData* mutable_list(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::MailData >*
      mutable_list();
  const ::sg::MailData& list(int index) const;
  ::sg::MailData* add_list();
  const ::google::protobuf::RepeatedPtrField< ::sg::MailData >&
      list() const;

  // @@protoc_insertion_point(class_scope:sg.MailDataList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::MailData > list_;
  friend struct ::protobuf_Mail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MailboxService_MailboxRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.MailboxService.MailboxRequest) */ {
 public:
  MailboxService_MailboxRequest();
  virtual ~MailboxService_MailboxRequest();

  MailboxService_MailboxRequest(const MailboxService_MailboxRequest& from);

  inline MailboxService_MailboxRequest& operator=(const MailboxService_MailboxRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MailboxService_MailboxRequest(MailboxService_MailboxRequest&& from) noexcept
    : MailboxService_MailboxRequest() {
    *this = ::std::move(from);
  }

  inline MailboxService_MailboxRequest& operator=(MailboxService_MailboxRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const MailboxService_MailboxRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MailboxService_MailboxRequest* internal_default_instance() {
    return reinterpret_cast<const MailboxService_MailboxRequest*>(
               &_MailboxService_MailboxRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void UnsafeArenaSwap(MailboxService_MailboxRequest* other);
  void Swap(MailboxService_MailboxRequest* other);
  friend void swap(MailboxService_MailboxRequest& a, MailboxService_MailboxRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MailboxService_MailboxRequest* New() const final {
    return CreateMaybeMessage<MailboxService_MailboxRequest>(NULL);
  }

  MailboxService_MailboxRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MailboxService_MailboxRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MailboxService_MailboxRequest& from);
  void MergeFrom(const MailboxService_MailboxRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MailboxService_MailboxRequest* other);
  protected:
  explicit MailboxService_MailboxRequest(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 mailid = 2;
  bool has_mailid() const;
  void clear_mailid();
  static const int kMailidFieldNumber = 2;
  ::google::protobuf::uint64 mailid() const;
  void set_mailid(::google::protobuf::uint64 value);

  // required .sg.MailboxService.MAILBOX_COMMAND cmd = 1;
  bool has_cmd() const;
  void clear_cmd();
  static const int kCmdFieldNumber = 1;
  ::sg::MailboxService_MAILBOX_COMMAND cmd() const;
  void set_cmd(::sg::MailboxService_MAILBOX_COMMAND value);

  // @@protoc_insertion_point(class_scope:sg.MailboxService.MailboxRequest)
 private:
  void set_has_cmd();
  void clear_has_cmd();
  void set_has_mailid();
  void clear_has_mailid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 mailid_;
  int cmd_;
  friend struct ::protobuf_Mail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MailboxService_MailboxResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.MailboxService.MailboxResponse) */ {
 public:
  MailboxService_MailboxResponse();
  virtual ~MailboxService_MailboxResponse();

  MailboxService_MailboxResponse(const MailboxService_MailboxResponse& from);

  inline MailboxService_MailboxResponse& operator=(const MailboxService_MailboxResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MailboxService_MailboxResponse(MailboxService_MailboxResponse&& from) noexcept
    : MailboxService_MailboxResponse() {
    *this = ::std::move(from);
  }

  inline MailboxService_MailboxResponse& operator=(MailboxService_MailboxResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const MailboxService_MailboxResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MailboxService_MailboxResponse* internal_default_instance() {
    return reinterpret_cast<const MailboxService_MailboxResponse*>(
               &_MailboxService_MailboxResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void UnsafeArenaSwap(MailboxService_MailboxResponse* other);
  void Swap(MailboxService_MailboxResponse* other);
  friend void swap(MailboxService_MailboxResponse& a, MailboxService_MailboxResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MailboxService_MailboxResponse* New() const final {
    return CreateMaybeMessage<MailboxService_MailboxResponse>(NULL);
  }

  MailboxService_MailboxResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MailboxService_MailboxResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MailboxService_MailboxResponse& from);
  void MergeFrom(const MailboxService_MailboxResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MailboxService_MailboxResponse* other);
  protected:
  explicit MailboxService_MailboxResponse(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sg.Reward out_drop_list = 11;
  int out_drop_list_size() const;
  void clear_out_drop_list();
  static const int kOutDropListFieldNumber = 11;
  ::sg::Reward* mutable_out_drop_list(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::Reward >*
      mutable_out_drop_list();
  const ::sg::Reward& out_drop_list(int index) const;
  ::sg::Reward* add_out_drop_list();
  const ::google::protobuf::RepeatedPtrField< ::sg::Reward >&
      out_drop_list() const;

  // optional .sg.MailDataList mail_list = 2;
  bool has_mail_list() const;
  void clear_mail_list();
  static const int kMailListFieldNumber = 2;
  private:
  const ::sg::MailDataList& _internal_mail_list() const;
  public:
  const ::sg::MailDataList& mail_list() const;
  ::sg::MailDataList* release_mail_list();
  ::sg::MailDataList* mutable_mail_list();
  void set_allocated_mail_list(::sg::MailDataList* mail_list);
  void unsafe_arena_set_allocated_mail_list(
      ::sg::MailDataList* mail_list);
  ::sg::MailDataList* unsafe_arena_release_mail_list();

  // optional int32 result = 1;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::google::protobuf::int32 result() const;
  void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.MailboxService.MailboxResponse)
 private:
  void set_has_result();
  void clear_has_result();
  void set_has_mail_list();
  void clear_has_mail_list();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::Reward > out_drop_list_;
  ::sg::MailDataList* mail_list_;
  ::google::protobuf::int32 result_;
  friend struct ::protobuf_Mail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MailboxService : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.MailboxService) */ {
 public:
  MailboxService();
  virtual ~MailboxService();

  MailboxService(const MailboxService& from);

  inline MailboxService& operator=(const MailboxService& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MailboxService(MailboxService&& from) noexcept
    : MailboxService() {
    *this = ::std::move(from);
  }

  inline MailboxService& operator=(MailboxService&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const MailboxService& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MailboxService* internal_default_instance() {
    return reinterpret_cast<const MailboxService*>(
               &_MailboxService_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void UnsafeArenaSwap(MailboxService* other);
  void Swap(MailboxService* other);
  friend void swap(MailboxService& a, MailboxService& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MailboxService* New() const final {
    return CreateMaybeMessage<MailboxService>(NULL);
  }

  MailboxService* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MailboxService>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MailboxService& from);
  void MergeFrom(const MailboxService& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MailboxService* other);
  protected:
  explicit MailboxService(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MailboxService_MailboxRequest MailboxRequest;
  typedef MailboxService_MailboxResponse MailboxResponse;

  typedef MailboxService_MAILBOX_COMMAND MAILBOX_COMMAND;
  static const MAILBOX_COMMAND QUERY =
    MailboxService_MAILBOX_COMMAND_QUERY;
  static const MAILBOX_COMMAND READ =
    MailboxService_MAILBOX_COMMAND_READ;
  static const MAILBOX_COMMAND ACCEPT =
    MailboxService_MAILBOX_COMMAND_ACCEPT;
  static const MAILBOX_COMMAND BURN =
    MailboxService_MAILBOX_COMMAND_BURN;
  static const MAILBOX_COMMAND ACCEPT_ALL =
    MailboxService_MAILBOX_COMMAND_ACCEPT_ALL;
  static const MAILBOX_COMMAND BURN_ALL =
    MailboxService_MAILBOX_COMMAND_BURN_ALL;
  static inline bool MAILBOX_COMMAND_IsValid(int value) {
    return MailboxService_MAILBOX_COMMAND_IsValid(value);
  }
  static const MAILBOX_COMMAND MAILBOX_COMMAND_MIN =
    MailboxService_MAILBOX_COMMAND_MAILBOX_COMMAND_MIN;
  static const MAILBOX_COMMAND MAILBOX_COMMAND_MAX =
    MailboxService_MAILBOX_COMMAND_MAILBOX_COMMAND_MAX;
  static const int MAILBOX_COMMAND_ARRAYSIZE =
    MailboxService_MAILBOX_COMMAND_MAILBOX_COMMAND_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MAILBOX_COMMAND_descriptor() {
    return MailboxService_MAILBOX_COMMAND_descriptor();
  }
  static inline const ::std::string& MAILBOX_COMMAND_Name(MAILBOX_COMMAND value) {
    return MailboxService_MAILBOX_COMMAND_Name(value);
  }
  static inline bool MAILBOX_COMMAND_Parse(const ::std::string& name,
      MAILBOX_COMMAND* value) {
    return MailboxService_MAILBOX_COMMAND_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .sg.MailboxService.MailboxRequest req = 1;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 1;
  private:
  const ::sg::MailboxService_MailboxRequest& _internal_req() const;
  public:
  const ::sg::MailboxService_MailboxRequest& req() const;
  ::sg::MailboxService_MailboxRequest* release_req();
  ::sg::MailboxService_MailboxRequest* mutable_req();
  void set_allocated_req(::sg::MailboxService_MailboxRequest* req);
  void unsafe_arena_set_allocated_req(
      ::sg::MailboxService_MailboxRequest* req);
  ::sg::MailboxService_MailboxRequest* unsafe_arena_release_req();

  // optional .sg.MailboxService.MailboxResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  private:
  const ::sg::MailboxService_MailboxResponse& _internal_resp() const;
  public:
  const ::sg::MailboxService_MailboxResponse& resp() const;
  ::sg::MailboxService_MailboxResponse* release_resp();
  ::sg::MailboxService_MailboxResponse* mutable_resp();
  void set_allocated_resp(::sg::MailboxService_MailboxResponse* resp);
  void unsafe_arena_set_allocated_resp(
      ::sg::MailboxService_MailboxResponse* resp);
  ::sg::MailboxService_MailboxResponse* unsafe_arena_release_resp();

  // @@protoc_insertion_point(class_scope:sg.MailboxService)
 private:
  void set_has_req();
  void clear_has_req();
  void set_has_resp();
  void clear_has_resp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::sg::MailboxService_MailboxRequest* req_;
  ::sg::MailboxService_MailboxResponse* resp_;
  friend struct ::protobuf_Mail_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NewMailNotify : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.NewMailNotify) */ {
 public:
  NewMailNotify();
  virtual ~NewMailNotify();

  NewMailNotify(const NewMailNotify& from);

  inline NewMailNotify& operator=(const NewMailNotify& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NewMailNotify(NewMailNotify&& from) noexcept
    : NewMailNotify() {
    *this = ::std::move(from);
  }

  inline NewMailNotify& operator=(NewMailNotify&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const NewMailNotify& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NewMailNotify* internal_default_instance() {
    return reinterpret_cast<const NewMailNotify*>(
               &_NewMailNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void UnsafeArenaSwap(NewMailNotify* other);
  void Swap(NewMailNotify* other);
  friend void swap(NewMailNotify& a, NewMailNotify& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NewMailNotify* New() const final {
    return CreateMaybeMessage<NewMailNotify>(NULL);
  }

  NewMailNotify* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NewMailNotify>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NewMailNotify& from);
  void MergeFrom(const NewMailNotify& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewMailNotify* other);
  protected:
  explicit NewMailNotify(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .sg.MailDataList mail_list = 1;
  bool has_mail_list() const;
  void clear_mail_list();
  static const int kMailListFieldNumber = 1;
  private:
  const ::sg::MailDataList& _internal_mail_list() const;
  public:
  const ::sg::MailDataList& mail_list() const;
  ::sg::MailDataList* release_mail_list();
  ::sg::MailDataList* mutable_mail_list();
  void set_allocated_mail_list(::sg::MailDataList* mail_list);
  void unsafe_arena_set_allocated_mail_list(
      ::sg::MailDataList* mail_list);
  ::sg::MailDataList* unsafe_arena_release_mail_list();

  // @@protoc_insertion_point(class_scope:sg.NewMailNotify)
 private:
  void set_has_mail_list();
  void clear_has_mail_list();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::sg::MailDataList* mail_list_;
  friend struct ::protobuf_Mail_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ItemAny

// required uint32 item_type = 1;
inline bool ItemAny::has_item_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ItemAny::set_has_item_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ItemAny::clear_has_item_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ItemAny::clear_item_type() {
  item_type_ = 0u;
  clear_has_item_type();
}
inline ::google::protobuf::uint32 ItemAny::item_type() const {
  // @@protoc_insertion_point(field_get:sg.ItemAny.item_type)
  return item_type_;
}
inline void ItemAny::set_item_type(::google::protobuf::uint32 value) {
  set_has_item_type();
  item_type_ = value;
  // @@protoc_insertion_point(field_set:sg.ItemAny.item_type)
}

// required uint64 item_typeid = 2;
inline bool ItemAny::has_item_typeid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ItemAny::set_has_item_typeid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ItemAny::clear_has_item_typeid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ItemAny::clear_item_typeid() {
  item_typeid_ = GOOGLE_ULONGLONG(0);
  clear_has_item_typeid();
}
inline ::google::protobuf::uint64 ItemAny::item_typeid() const {
  // @@protoc_insertion_point(field_get:sg.ItemAny.item_typeid)
  return item_typeid_;
}
inline void ItemAny::set_item_typeid(::google::protobuf::uint64 value) {
  set_has_item_typeid();
  item_typeid_ = value;
  // @@protoc_insertion_point(field_set:sg.ItemAny.item_typeid)
}

// optional int32 val = 3;
inline bool ItemAny::has_val() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ItemAny::set_has_val() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ItemAny::clear_has_val() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ItemAny::clear_val() {
  val_ = 0;
  clear_has_val();
}
inline ::google::protobuf::int32 ItemAny::val() const {
  // @@protoc_insertion_point(field_get:sg.ItemAny.val)
  return val_;
}
inline void ItemAny::set_val(::google::protobuf::int32 value) {
  set_has_val();
  val_ = value;
  // @@protoc_insertion_point(field_set:sg.ItemAny.val)
}

// optional float probability = 4;
inline bool ItemAny::has_probability() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ItemAny::set_has_probability() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ItemAny::clear_has_probability() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ItemAny::clear_probability() {
  probability_ = 0;
  clear_has_probability();
}
inline float ItemAny::probability() const {
  // @@protoc_insertion_point(field_get:sg.ItemAny.probability)
  return probability_;
}
inline void ItemAny::set_probability(float value) {
  set_has_probability();
  probability_ = value;
  // @@protoc_insertion_point(field_set:sg.ItemAny.probability)
}

// -------------------------------------------------------------------

// ItemAnyList

// repeated .sg.ItemAny list = 1;
inline int ItemAnyList::list_size() const {
  return list_.size();
}
inline void ItemAnyList::clear_list() {
  list_.Clear();
}
inline ::sg::ItemAny* ItemAnyList::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:sg.ItemAnyList.list)
  return list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::ItemAny >*
ItemAnyList::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:sg.ItemAnyList.list)
  return &list_;
}
inline const ::sg::ItemAny& ItemAnyList::list(int index) const {
  // @@protoc_insertion_point(field_get:sg.ItemAnyList.list)
  return list_.Get(index);
}
inline ::sg::ItemAny* ItemAnyList::add_list() {
  // @@protoc_insertion_point(field_add:sg.ItemAnyList.list)
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::ItemAny >&
ItemAnyList::list() const {
  // @@protoc_insertion_point(field_list:sg.ItemAnyList.list)
  return list_;
}

// -------------------------------------------------------------------

// ItemDrop

// required uint64 drop_typeid = 1;
inline bool ItemDrop::has_drop_typeid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ItemDrop::set_has_drop_typeid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ItemDrop::clear_has_drop_typeid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ItemDrop::clear_drop_typeid() {
  drop_typeid_ = GOOGLE_ULONGLONG(0);
  clear_has_drop_typeid();
}
inline ::google::protobuf::uint64 ItemDrop::drop_typeid() const {
  // @@protoc_insertion_point(field_get:sg.ItemDrop.drop_typeid)
  return drop_typeid_;
}
inline void ItemDrop::set_drop_typeid(::google::protobuf::uint64 value) {
  set_has_drop_typeid();
  drop_typeid_ = value;
  // @@protoc_insertion_point(field_set:sg.ItemDrop.drop_typeid)
}

// optional int32 drop_num = 2;
inline bool ItemDrop::has_drop_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ItemDrop::set_has_drop_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ItemDrop::clear_has_drop_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ItemDrop::clear_drop_num() {
  drop_num_ = 0;
  clear_has_drop_num();
}
inline ::google::protobuf::int32 ItemDrop::drop_num() const {
  // @@protoc_insertion_point(field_get:sg.ItemDrop.drop_num)
  return drop_num_;
}
inline void ItemDrop::set_drop_num(::google::protobuf::int32 value) {
  set_has_drop_num();
  drop_num_ = value;
  // @@protoc_insertion_point(field_set:sg.ItemDrop.drop_num)
}

// -------------------------------------------------------------------

// ItemDropList

// repeated .sg.ItemDrop list = 1;
inline int ItemDropList::list_size() const {
  return list_.size();
}
inline void ItemDropList::clear_list() {
  list_.Clear();
}
inline ::sg::ItemDrop* ItemDropList::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:sg.ItemDropList.list)
  return list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::ItemDrop >*
ItemDropList::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:sg.ItemDropList.list)
  return &list_;
}
inline const ::sg::ItemDrop& ItemDropList::list(int index) const {
  // @@protoc_insertion_point(field_get:sg.ItemDropList.list)
  return list_.Get(index);
}
inline ::sg::ItemDrop* ItemDropList::add_list() {
  // @@protoc_insertion_point(field_add:sg.ItemDropList.list)
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::ItemDrop >&
ItemDropList::list() const {
  // @@protoc_insertion_point(field_list:sg.ItemDropList.list)
  return list_;
}

// -------------------------------------------------------------------

// MailData

// required int64 mailid = 1;
inline bool MailData::has_mailid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MailData::set_has_mailid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MailData::clear_has_mailid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MailData::clear_mailid() {
  mailid_ = GOOGLE_LONGLONG(0);
  clear_has_mailid();
}
inline ::google::protobuf::int64 MailData::mailid() const {
  // @@protoc_insertion_point(field_get:sg.MailData.mailid)
  return mailid_;
}
inline void MailData::set_mailid(::google::protobuf::int64 value) {
  set_has_mailid();
  mailid_ = value;
  // @@protoc_insertion_point(field_set:sg.MailData.mailid)
}

// required .sg.MailData.MAIL_TYPE type = 2;
inline bool MailData::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MailData::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MailData::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MailData::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::sg::MailData_MAIL_TYPE MailData::type() const {
  // @@protoc_insertion_point(field_get:sg.MailData.type)
  return static_cast< ::sg::MailData_MAIL_TYPE >(type_);
}
inline void MailData::set_type(::sg::MailData_MAIL_TYPE value) {
  assert(::sg::MailData_MAIL_TYPE_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:sg.MailData.type)
}

// required .sg.MailData.MAIL_STATE state = 3;
inline bool MailData::has_state() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MailData::set_has_state() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MailData::clear_has_state() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MailData::clear_state() {
  state_ = -1;
  clear_has_state();
}
inline ::sg::MailData_MAIL_STATE MailData::state() const {
  // @@protoc_insertion_point(field_get:sg.MailData.state)
  return static_cast< ::sg::MailData_MAIL_STATE >(state_);
}
inline void MailData::set_state(::sg::MailData_MAIL_STATE value) {
  assert(::sg::MailData_MAIL_STATE_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:sg.MailData.state)
}

// required bytes subject = 11;
inline bool MailData::has_subject() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MailData::set_has_subject() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MailData::clear_has_subject() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MailData::clear_subject() {
  subject_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_subject();
}
inline const ::std::string& MailData::subject() const {
  // @@protoc_insertion_point(field_get:sg.MailData.subject)
  return subject_.Get();
}
inline void MailData::set_subject(const ::std::string& value) {
  set_has_subject();
  subject_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:sg.MailData.subject)
}
#if LANG_CXX11
inline void MailData::set_subject(::std::string&& value) {
  set_has_subject();
  subject_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:sg.MailData.subject)
}
#endif
inline void MailData::set_subject(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_subject();
  subject_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:sg.MailData.subject)
}
inline void MailData::set_subject(const void* value,
    size_t size) {
  set_has_subject();
  subject_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:sg.MailData.subject)
}
inline ::std::string* MailData::mutable_subject() {
  set_has_subject();
  // @@protoc_insertion_point(field_mutable:sg.MailData.subject)
  return subject_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* MailData::release_subject() {
  // @@protoc_insertion_point(field_release:sg.MailData.subject)
  if (!has_subject()) {
    return NULL;
  }
  clear_has_subject();
  return subject_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void MailData::set_allocated_subject(::std::string* subject) {
  if (subject != NULL) {
    set_has_subject();
  } else {
    clear_has_subject();
  }
  subject_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), subject,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:sg.MailData.subject)
}
inline ::std::string* MailData::unsafe_arena_release_subject() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.MailData.subject)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_subject();
  return subject_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void MailData::unsafe_arena_set_allocated_subject(
    ::std::string* subject) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (subject != NULL) {
    set_has_subject();
  } else {
    clear_has_subject();
  }
  subject_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      subject, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sg.MailData.subject)
}

// required bytes content = 12;
inline bool MailData::has_content() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MailData::set_has_content() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MailData::clear_has_content() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MailData::clear_content() {
  content_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_content();
}
inline const ::std::string& MailData::content() const {
  // @@protoc_insertion_point(field_get:sg.MailData.content)
  return content_.Get();
}
inline void MailData::set_content(const ::std::string& value) {
  set_has_content();
  content_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:sg.MailData.content)
}
#if LANG_CXX11
inline void MailData::set_content(::std::string&& value) {
  set_has_content();
  content_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:sg.MailData.content)
}
#endif
inline void MailData::set_content(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_content();
  content_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:sg.MailData.content)
}
inline void MailData::set_content(const void* value,
    size_t size) {
  set_has_content();
  content_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:sg.MailData.content)
}
inline ::std::string* MailData::mutable_content() {
  set_has_content();
  // @@protoc_insertion_point(field_mutable:sg.MailData.content)
  return content_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* MailData::release_content() {
  // @@protoc_insertion_point(field_release:sg.MailData.content)
  if (!has_content()) {
    return NULL;
  }
  clear_has_content();
  return content_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void MailData::set_allocated_content(::std::string* content) {
  if (content != NULL) {
    set_has_content();
  } else {
    clear_has_content();
  }
  content_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), content,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:sg.MailData.content)
}
inline ::std::string* MailData::unsafe_arena_release_content() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.MailData.content)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_content();
  return content_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void MailData::unsafe_arena_set_allocated_content(
    ::std::string* content) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (content != NULL) {
    set_has_content();
  } else {
    clear_has_content();
  }
  content_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      content, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sg.MailData.content)
}

// required .sg.ItemAnyList attachment_list = 21;
inline bool MailData::has_attachment_list() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MailData::set_has_attachment_list() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MailData::clear_has_attachment_list() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MailData::clear_attachment_list() {
  if (attachment_list_ != NULL) attachment_list_->Clear();
  clear_has_attachment_list();
}
inline const ::sg::ItemAnyList& MailData::_internal_attachment_list() const {
  return *attachment_list_;
}
inline const ::sg::ItemAnyList& MailData::attachment_list() const {
  const ::sg::ItemAnyList* p = attachment_list_;
  // @@protoc_insertion_point(field_get:sg.MailData.attachment_list)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::ItemAnyList*>(
      &::sg::_ItemAnyList_default_instance_);
}
inline ::sg::ItemAnyList* MailData::release_attachment_list() {
  // @@protoc_insertion_point(field_release:sg.MailData.attachment_list)
  clear_has_attachment_list();
  ::sg::ItemAnyList* temp = attachment_list_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  attachment_list_ = NULL;
  return temp;
}
inline ::sg::ItemAnyList* MailData::unsafe_arena_release_attachment_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.MailData.attachment_list)
  clear_has_attachment_list();
  ::sg::ItemAnyList* temp = attachment_list_;
  attachment_list_ = NULL;
  return temp;
}
inline ::sg::ItemAnyList* MailData::mutable_attachment_list() {
  set_has_attachment_list();
  if (attachment_list_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::ItemAnyList>(GetArenaNoVirtual());
    attachment_list_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.MailData.attachment_list)
  return attachment_list_;
}
inline void MailData::set_allocated_attachment_list(::sg::ItemAnyList* attachment_list) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete attachment_list_;
  }
  if (attachment_list) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(attachment_list);
    if (message_arena != submessage_arena) {
      attachment_list = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, attachment_list, submessage_arena);
    }
    set_has_attachment_list();
  } else {
    clear_has_attachment_list();
  }
  attachment_list_ = attachment_list;
  // @@protoc_insertion_point(field_set_allocated:sg.MailData.attachment_list)
}

// required sfixed64 createtime = 31;
inline bool MailData::has_createtime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MailData::set_has_createtime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MailData::clear_has_createtime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MailData::clear_createtime() {
  createtime_ = GOOGLE_LONGLONG(0);
  clear_has_createtime();
}
inline ::google::protobuf::int64 MailData::createtime() const {
  // @@protoc_insertion_point(field_get:sg.MailData.createtime)
  return createtime_;
}
inline void MailData::set_createtime(::google::protobuf::int64 value) {
  set_has_createtime();
  createtime_ = value;
  // @@protoc_insertion_point(field_set:sg.MailData.createtime)
}

// required sfixed64 burntime = 32;
inline bool MailData::has_burntime() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MailData::set_has_burntime() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MailData::clear_has_burntime() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MailData::clear_burntime() {
  burntime_ = GOOGLE_LONGLONG(0);
  clear_has_burntime();
}
inline ::google::protobuf::int64 MailData::burntime() const {
  // @@protoc_insertion_point(field_get:sg.MailData.burntime)
  return burntime_;
}
inline void MailData::set_burntime(::google::protobuf::int64 value) {
  set_has_burntime();
  burntime_ = value;
  // @@protoc_insertion_point(field_set:sg.MailData.burntime)
}

// -------------------------------------------------------------------

// MailDataList

// repeated .sg.MailData list = 1;
inline int MailDataList::list_size() const {
  return list_.size();
}
inline void MailDataList::clear_list() {
  list_.Clear();
}
inline ::sg::MailData* MailDataList::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:sg.MailDataList.list)
  return list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::MailData >*
MailDataList::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:sg.MailDataList.list)
  return &list_;
}
inline const ::sg::MailData& MailDataList::list(int index) const {
  // @@protoc_insertion_point(field_get:sg.MailDataList.list)
  return list_.Get(index);
}
inline ::sg::MailData* MailDataList::add_list() {
  // @@protoc_insertion_point(field_add:sg.MailDataList.list)
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::MailData >&
MailDataList::list() const {
  // @@protoc_insertion_point(field_list:sg.MailDataList.list)
  return list_;
}

// -------------------------------------------------------------------

// MailboxService_MailboxRequest

// required .sg.MailboxService.MAILBOX_COMMAND cmd = 1;
inline bool MailboxService_MailboxRequest::has_cmd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MailboxService_MailboxRequest::set_has_cmd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MailboxService_MailboxRequest::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MailboxService_MailboxRequest::clear_cmd() {
  cmd_ = 1;
  clear_has_cmd();
}
inline ::sg::MailboxService_MAILBOX_COMMAND MailboxService_MailboxRequest::cmd() const {
  // @@protoc_insertion_point(field_get:sg.MailboxService.MailboxRequest.cmd)
  return static_cast< ::sg::MailboxService_MAILBOX_COMMAND >(cmd_);
}
inline void MailboxService_MailboxRequest::set_cmd(::sg::MailboxService_MAILBOX_COMMAND value) {
  assert(::sg::MailboxService_MAILBOX_COMMAND_IsValid(value));
  set_has_cmd();
  cmd_ = value;
  // @@protoc_insertion_point(field_set:sg.MailboxService.MailboxRequest.cmd)
}

// optional uint64 mailid = 2;
inline bool MailboxService_MailboxRequest::has_mailid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MailboxService_MailboxRequest::set_has_mailid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MailboxService_MailboxRequest::clear_has_mailid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MailboxService_MailboxRequest::clear_mailid() {
  mailid_ = GOOGLE_ULONGLONG(0);
  clear_has_mailid();
}
inline ::google::protobuf::uint64 MailboxService_MailboxRequest::mailid() const {
  // @@protoc_insertion_point(field_get:sg.MailboxService.MailboxRequest.mailid)
  return mailid_;
}
inline void MailboxService_MailboxRequest::set_mailid(::google::protobuf::uint64 value) {
  set_has_mailid();
  mailid_ = value;
  // @@protoc_insertion_point(field_set:sg.MailboxService.MailboxRequest.mailid)
}

// -------------------------------------------------------------------

// MailboxService_MailboxResponse

// optional int32 result = 1;
inline bool MailboxService_MailboxResponse::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MailboxService_MailboxResponse::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MailboxService_MailboxResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MailboxService_MailboxResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 MailboxService_MailboxResponse::result() const {
  // @@protoc_insertion_point(field_get:sg.MailboxService.MailboxResponse.result)
  return result_;
}
inline void MailboxService_MailboxResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:sg.MailboxService.MailboxResponse.result)
}

// optional .sg.MailDataList mail_list = 2;
inline bool MailboxService_MailboxResponse::has_mail_list() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MailboxService_MailboxResponse::set_has_mail_list() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MailboxService_MailboxResponse::clear_has_mail_list() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MailboxService_MailboxResponse::clear_mail_list() {
  if (mail_list_ != NULL) mail_list_->Clear();
  clear_has_mail_list();
}
inline const ::sg::MailDataList& MailboxService_MailboxResponse::_internal_mail_list() const {
  return *mail_list_;
}
inline const ::sg::MailDataList& MailboxService_MailboxResponse::mail_list() const {
  const ::sg::MailDataList* p = mail_list_;
  // @@protoc_insertion_point(field_get:sg.MailboxService.MailboxResponse.mail_list)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::MailDataList*>(
      &::sg::_MailDataList_default_instance_);
}
inline ::sg::MailDataList* MailboxService_MailboxResponse::release_mail_list() {
  // @@protoc_insertion_point(field_release:sg.MailboxService.MailboxResponse.mail_list)
  clear_has_mail_list();
  ::sg::MailDataList* temp = mail_list_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  mail_list_ = NULL;
  return temp;
}
inline ::sg::MailDataList* MailboxService_MailboxResponse::unsafe_arena_release_mail_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.MailboxService.MailboxResponse.mail_list)
  clear_has_mail_list();
  ::sg::MailDataList* temp = mail_list_;
  mail_list_ = NULL;
  return temp;
}
inline ::sg::MailDataList* MailboxService_MailboxResponse::mutable_mail_list() {
  set_has_mail_list();
  if (mail_list_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::MailDataList>(GetArenaNoVirtual());
    mail_list_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.MailboxService.MailboxResponse.mail_list)
  return mail_list_;
}
inline void MailboxService_MailboxResponse::set_allocated_mail_list(::sg::MailDataList* mail_list) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete mail_list_;
  }
  if (mail_list) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(mail_list);
    if (message_arena != submessage_arena) {
      mail_list = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, mail_list, submessage_arena);
    }
    set_has_mail_list();
  } else {
    clear_has_mail_list();
  }
  mail_list_ = mail_list;
  // @@protoc_insertion_point(field_set_allocated:sg.MailboxService.MailboxResponse.mail_list)
}

// repeated .sg.Reward out_drop_list = 11;
inline int MailboxService_MailboxResponse::out_drop_list_size() const {
  return out_drop_list_.size();
}
inline ::sg::Reward* MailboxService_MailboxResponse::mutable_out_drop_list(int index) {
  // @@protoc_insertion_point(field_mutable:sg.MailboxService.MailboxResponse.out_drop_list)
  return out_drop_list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::Reward >*
MailboxService_MailboxResponse::mutable_out_drop_list() {
  // @@protoc_insertion_point(field_mutable_list:sg.MailboxService.MailboxResponse.out_drop_list)
  return &out_drop_list_;
}
inline const ::sg::Reward& MailboxService_MailboxResponse::out_drop_list(int index) const {
  // @@protoc_insertion_point(field_get:sg.MailboxService.MailboxResponse.out_drop_list)
  return out_drop_list_.Get(index);
}
inline ::sg::Reward* MailboxService_MailboxResponse::add_out_drop_list() {
  // @@protoc_insertion_point(field_add:sg.MailboxService.MailboxResponse.out_drop_list)
  return out_drop_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::Reward >&
MailboxService_MailboxResponse::out_drop_list() const {
  // @@protoc_insertion_point(field_list:sg.MailboxService.MailboxResponse.out_drop_list)
  return out_drop_list_;
}

// -------------------------------------------------------------------

// MailboxService

// optional .sg.MailboxService.MailboxRequest req = 1;
inline bool MailboxService::has_req() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MailboxService::set_has_req() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MailboxService::clear_has_req() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MailboxService::clear_req() {
  if (req_ != NULL) req_->Clear();
  clear_has_req();
}
inline const ::sg::MailboxService_MailboxRequest& MailboxService::_internal_req() const {
  return *req_;
}
inline const ::sg::MailboxService_MailboxRequest& MailboxService::req() const {
  const ::sg::MailboxService_MailboxRequest* p = req_;
  // @@protoc_insertion_point(field_get:sg.MailboxService.req)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::MailboxService_MailboxRequest*>(
      &::sg::_MailboxService_MailboxRequest_default_instance_);
}
inline ::sg::MailboxService_MailboxRequest* MailboxService::release_req() {
  // @@protoc_insertion_point(field_release:sg.MailboxService.req)
  clear_has_req();
  ::sg::MailboxService_MailboxRequest* temp = req_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  req_ = NULL;
  return temp;
}
inline ::sg::MailboxService_MailboxRequest* MailboxService::unsafe_arena_release_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.MailboxService.req)
  clear_has_req();
  ::sg::MailboxService_MailboxRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline ::sg::MailboxService_MailboxRequest* MailboxService::mutable_req() {
  set_has_req();
  if (req_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::MailboxService_MailboxRequest>(GetArenaNoVirtual());
    req_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.MailboxService.req)
  return req_;
}
inline void MailboxService::set_allocated_req(::sg::MailboxService_MailboxRequest* req) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete req_;
  }
  if (req) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(req);
    if (message_arena != submessage_arena) {
      req = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, req, submessage_arena);
    }
    set_has_req();
  } else {
    clear_has_req();
  }
  req_ = req;
  // @@protoc_insertion_point(field_set_allocated:sg.MailboxService.req)
}

// optional .sg.MailboxService.MailboxResponse resp = 2;
inline bool MailboxService::has_resp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MailboxService::set_has_resp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MailboxService::clear_has_resp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MailboxService::clear_resp() {
  if (resp_ != NULL) resp_->Clear();
  clear_has_resp();
}
inline const ::sg::MailboxService_MailboxResponse& MailboxService::_internal_resp() const {
  return *resp_;
}
inline const ::sg::MailboxService_MailboxResponse& MailboxService::resp() const {
  const ::sg::MailboxService_MailboxResponse* p = resp_;
  // @@protoc_insertion_point(field_get:sg.MailboxService.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::MailboxService_MailboxResponse*>(
      &::sg::_MailboxService_MailboxResponse_default_instance_);
}
inline ::sg::MailboxService_MailboxResponse* MailboxService::release_resp() {
  // @@protoc_insertion_point(field_release:sg.MailboxService.resp)
  clear_has_resp();
  ::sg::MailboxService_MailboxResponse* temp = resp_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  resp_ = NULL;
  return temp;
}
inline ::sg::MailboxService_MailboxResponse* MailboxService::unsafe_arena_release_resp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.MailboxService.resp)
  clear_has_resp();
  ::sg::MailboxService_MailboxResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline ::sg::MailboxService_MailboxResponse* MailboxService::mutable_resp() {
  set_has_resp();
  if (resp_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::MailboxService_MailboxResponse>(GetArenaNoVirtual());
    resp_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.MailboxService.resp)
  return resp_;
}
inline void MailboxService::set_allocated_resp(::sg::MailboxService_MailboxResponse* resp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete resp_;
  }
  if (resp) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(resp);
    if (message_arena != submessage_arena) {
      resp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, resp, submessage_arena);
    }
    set_has_resp();
  } else {
    clear_has_resp();
  }
  resp_ = resp;
  // @@protoc_insertion_point(field_set_allocated:sg.MailboxService.resp)
}

// -------------------------------------------------------------------

// NewMailNotify

// optional .sg.MailDataList mail_list = 1;
inline bool NewMailNotify::has_mail_list() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewMailNotify::set_has_mail_list() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewMailNotify::clear_has_mail_list() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewMailNotify::clear_mail_list() {
  if (mail_list_ != NULL) mail_list_->Clear();
  clear_has_mail_list();
}
inline const ::sg::MailDataList& NewMailNotify::_internal_mail_list() const {
  return *mail_list_;
}
inline const ::sg::MailDataList& NewMailNotify::mail_list() const {
  const ::sg::MailDataList* p = mail_list_;
  // @@protoc_insertion_point(field_get:sg.NewMailNotify.mail_list)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::MailDataList*>(
      &::sg::_MailDataList_default_instance_);
}
inline ::sg::MailDataList* NewMailNotify::release_mail_list() {
  // @@protoc_insertion_point(field_release:sg.NewMailNotify.mail_list)
  clear_has_mail_list();
  ::sg::MailDataList* temp = mail_list_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  mail_list_ = NULL;
  return temp;
}
inline ::sg::MailDataList* NewMailNotify::unsafe_arena_release_mail_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.NewMailNotify.mail_list)
  clear_has_mail_list();
  ::sg::MailDataList* temp = mail_list_;
  mail_list_ = NULL;
  return temp;
}
inline ::sg::MailDataList* NewMailNotify::mutable_mail_list() {
  set_has_mail_list();
  if (mail_list_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::MailDataList>(GetArenaNoVirtual());
    mail_list_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.NewMailNotify.mail_list)
  return mail_list_;
}
inline void NewMailNotify::set_allocated_mail_list(::sg::MailDataList* mail_list) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete mail_list_;
  }
  if (mail_list) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(mail_list);
    if (message_arena != submessage_arena) {
      mail_list = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, mail_list, submessage_arena);
    }
    set_has_mail_list();
  } else {
    clear_has_mail_list();
  }
  mail_list_ = mail_list;
  // @@protoc_insertion_point(field_set_allocated:sg.NewMailNotify.mail_list)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace sg

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::sg::ItemAny_ITEM_TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::ItemAny_ITEM_TYPE>() {
  return ::sg::ItemAny_ITEM_TYPE_descriptor();
}
template <> struct is_proto_enum< ::sg::MailData_MAIL_TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::MailData_MAIL_TYPE>() {
  return ::sg::MailData_MAIL_TYPE_descriptor();
}
template <> struct is_proto_enum< ::sg::MailData_MAIL_STATE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::MailData_MAIL_STATE>() {
  return ::sg::MailData_MAIL_STATE_descriptor();
}
template <> struct is_proto_enum< ::sg::MailboxService_MAILBOX_COMMAND> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::MailboxService_MAILBOX_COMMAND>() {
  return ::sg::MailboxService_MAILBOX_COMMAND_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_Mail_2eproto
