// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: UserHarbour.proto

#ifndef PROTOBUF_INCLUDED_UserHarbour_2eproto
#define PROTOBUF_INCLUDED_UserHarbour_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "BaseStruct.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_UserHarbour_2eproto 

namespace protobuf_UserHarbour_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[23];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_UserHarbour_2eproto
namespace sg {
class FoodStyle;
class FoodStyleDefaultTypeInternal;
extern FoodStyleDefaultTypeInternal _FoodStyle_default_instance_;
class FoodStyleList;
class FoodStyleListDefaultTypeInternal;
extern FoodStyleListDefaultTypeInternal _FoodStyleList_default_instance_;
class HarborInfo;
class HarborInfoDefaultTypeInternal;
extern HarborInfoDefaultTypeInternal _HarborInfo_default_instance_;
class HarborNpc;
class HarborNpcDefaultTypeInternal;
extern HarborNpcDefaultTypeInternal _HarborNpc_default_instance_;
class HarborNpcInfo;
class HarborNpcInfoDefaultTypeInternal;
extern HarborNpcInfoDefaultTypeInternal _HarborNpcInfo_default_instance_;
class HarborNpcInfoList;
class HarborNpcInfoListDefaultTypeInternal;
extern HarborNpcInfoListDefaultTypeInternal _HarborNpcInfoList_default_instance_;
class HarborNpcList;
class HarborNpcListDefaultTypeInternal;
extern HarborNpcListDefaultTypeInternal _HarborNpcList_default_instance_;
class HarborNpcStateNotify;
class HarborNpcStateNotifyDefaultTypeInternal;
extern HarborNpcStateNotifyDefaultTypeInternal _HarborNpcStateNotify_default_instance_;
class HarborNpc_resident_task;
class HarborNpc_resident_taskDefaultTypeInternal;
extern HarborNpc_resident_taskDefaultTypeInternal _HarborNpc_resident_task_default_instance_;
class HarborPopulation;
class HarborPopulationDefaultTypeInternal;
extern HarborPopulationDefaultTypeInternal _HarborPopulation_default_instance_;
class HarborPopulationList;
class HarborPopulationListDefaultTypeInternal;
extern HarborPopulationListDefaultTypeInternal _HarborPopulationList_default_instance_;
class HarborStateNotify;
class HarborStateNotifyDefaultTypeInternal;
extern HarborStateNotifyDefaultTypeInternal _HarborStateNotify_default_instance_;
class SeatFoodOrder;
class SeatFoodOrderDefaultTypeInternal;
extern SeatFoodOrderDefaultTypeInternal _SeatFoodOrder_default_instance_;
class SeatFoodOrderList;
class SeatFoodOrderListDefaultTypeInternal;
extern SeatFoodOrderListDefaultTypeInternal _SeatFoodOrderList_default_instance_;
class SeatFoodOrderStateNotify;
class SeatFoodOrderStateNotifyDefaultTypeInternal;
extern SeatFoodOrderStateNotifyDefaultTypeInternal _SeatFoodOrderStateNotify_default_instance_;
class SeatMenu;
class SeatMenuDefaultTypeInternal;
extern SeatMenuDefaultTypeInternal _SeatMenu_default_instance_;
class SeatMenuFood;
class SeatMenuFoodDefaultTypeInternal;
extern SeatMenuFoodDefaultTypeInternal _SeatMenuFood_default_instance_;
class UserFoodOrderService;
class UserFoodOrderServiceDefaultTypeInternal;
extern UserFoodOrderServiceDefaultTypeInternal _UserFoodOrderService_default_instance_;
class UserFoodOrderService_FoodOrderRequest;
class UserFoodOrderService_FoodOrderRequestDefaultTypeInternal;
extern UserFoodOrderService_FoodOrderRequestDefaultTypeInternal _UserFoodOrderService_FoodOrderRequest_default_instance_;
class UserFoodOrderService_FoodOrderResponse;
class UserFoodOrderService_FoodOrderResponseDefaultTypeInternal;
extern UserFoodOrderService_FoodOrderResponseDefaultTypeInternal _UserFoodOrderService_FoodOrderResponse_default_instance_;
class UserHarborNpcService;
class UserHarborNpcServiceDefaultTypeInternal;
extern UserHarborNpcServiceDefaultTypeInternal _UserHarborNpcService_default_instance_;
class UserHarborNpcService_HarborNpcRequest;
class UserHarborNpcService_HarborNpcRequestDefaultTypeInternal;
extern UserHarborNpcService_HarborNpcRequestDefaultTypeInternal _UserHarborNpcService_HarborNpcRequest_default_instance_;
class UserHarborNpcService_HarborNpcResponse;
class UserHarborNpcService_HarborNpcResponseDefaultTypeInternal;
extern UserHarborNpcService_HarborNpcResponseDefaultTypeInternal _UserHarborNpcService_HarborNpcResponse_default_instance_;
}  // namespace sg
namespace google {
namespace protobuf {
template<> ::sg::FoodStyle* Arena::CreateMaybeMessage<::sg::FoodStyle>(Arena*);
template<> ::sg::FoodStyleList* Arena::CreateMaybeMessage<::sg::FoodStyleList>(Arena*);
template<> ::sg::HarborInfo* Arena::CreateMaybeMessage<::sg::HarborInfo>(Arena*);
template<> ::sg::HarborNpc* Arena::CreateMaybeMessage<::sg::HarborNpc>(Arena*);
template<> ::sg::HarborNpcInfo* Arena::CreateMaybeMessage<::sg::HarborNpcInfo>(Arena*);
template<> ::sg::HarborNpcInfoList* Arena::CreateMaybeMessage<::sg::HarborNpcInfoList>(Arena*);
template<> ::sg::HarborNpcList* Arena::CreateMaybeMessage<::sg::HarborNpcList>(Arena*);
template<> ::sg::HarborNpcStateNotify* Arena::CreateMaybeMessage<::sg::HarborNpcStateNotify>(Arena*);
template<> ::sg::HarborNpc_resident_task* Arena::CreateMaybeMessage<::sg::HarborNpc_resident_task>(Arena*);
template<> ::sg::HarborPopulation* Arena::CreateMaybeMessage<::sg::HarborPopulation>(Arena*);
template<> ::sg::HarborPopulationList* Arena::CreateMaybeMessage<::sg::HarborPopulationList>(Arena*);
template<> ::sg::HarborStateNotify* Arena::CreateMaybeMessage<::sg::HarborStateNotify>(Arena*);
template<> ::sg::SeatFoodOrder* Arena::CreateMaybeMessage<::sg::SeatFoodOrder>(Arena*);
template<> ::sg::SeatFoodOrderList* Arena::CreateMaybeMessage<::sg::SeatFoodOrderList>(Arena*);
template<> ::sg::SeatFoodOrderStateNotify* Arena::CreateMaybeMessage<::sg::SeatFoodOrderStateNotify>(Arena*);
template<> ::sg::SeatMenu* Arena::CreateMaybeMessage<::sg::SeatMenu>(Arena*);
template<> ::sg::SeatMenuFood* Arena::CreateMaybeMessage<::sg::SeatMenuFood>(Arena*);
template<> ::sg::UserFoodOrderService* Arena::CreateMaybeMessage<::sg::UserFoodOrderService>(Arena*);
template<> ::sg::UserFoodOrderService_FoodOrderRequest* Arena::CreateMaybeMessage<::sg::UserFoodOrderService_FoodOrderRequest>(Arena*);
template<> ::sg::UserFoodOrderService_FoodOrderResponse* Arena::CreateMaybeMessage<::sg::UserFoodOrderService_FoodOrderResponse>(Arena*);
template<> ::sg::UserHarborNpcService* Arena::CreateMaybeMessage<::sg::UserHarborNpcService>(Arena*);
template<> ::sg::UserHarborNpcService_HarborNpcRequest* Arena::CreateMaybeMessage<::sg::UserHarborNpcService_HarborNpcRequest>(Arena*);
template<> ::sg::UserHarborNpcService_HarborNpcResponse* Arena::CreateMaybeMessage<::sg::UserHarborNpcService_HarborNpcResponse>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace sg {

enum HarborNpc_NPC_STATE {
  HarborNpc_NPC_STATE_TO_DELETE = -1,
  HarborNpc_NPC_STATE_IDLE = 0,
  HarborNpc_NPC_STATE_GO_ABOARD = 1,
  HarborNpc_NPC_STATE_IN_QUEUEING = 2,
  HarborNpc_NPC_STATE_TAKE_SEAT = 3,
  HarborNpc_NPC_STATE_ORDER_SUCCESS = 4,
  HarborNpc_NPC_STATE_EATING_FOOD = 5,
  HarborNpc_NPC_STATE_DISMISS = 6,
  HarborNpc_NPC_STATE_WORKING = 7
};
bool HarborNpc_NPC_STATE_IsValid(int value);
const HarborNpc_NPC_STATE HarborNpc_NPC_STATE_NPC_STATE_MIN = HarborNpc_NPC_STATE_TO_DELETE;
const HarborNpc_NPC_STATE HarborNpc_NPC_STATE_NPC_STATE_MAX = HarborNpc_NPC_STATE_WORKING;
const int HarborNpc_NPC_STATE_NPC_STATE_ARRAYSIZE = HarborNpc_NPC_STATE_NPC_STATE_MAX + 1;

const ::google::protobuf::EnumDescriptor* HarborNpc_NPC_STATE_descriptor();
inline const ::std::string& HarborNpc_NPC_STATE_Name(HarborNpc_NPC_STATE value) {
  return ::google::protobuf::internal::NameOfEnum(
    HarborNpc_NPC_STATE_descriptor(), value);
}
inline bool HarborNpc_NPC_STATE_Parse(
    const ::std::string& name, HarborNpc_NPC_STATE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HarborNpc_NPC_STATE>(
    HarborNpc_NPC_STATE_descriptor(), name, value);
}
enum UserHarborNpcService_NPC_COMMAND {
  UserHarborNpcService_NPC_COMMAND_QUERY = 1,
  UserHarborNpcService_NPC_COMMAND_OPEN = 2,
  UserHarborNpcService_NPC_COMMAND_CLOSE = 3,
  UserHarborNpcService_NPC_COMMAND_START_QUEUEING = 4,
  UserHarborNpcService_NPC_COMMAND_COMPLETE_TASK = 5,
  UserHarborNpcService_NPC_COMMAND_QUERY_POPULATION = 11,
  UserHarborNpcService_NPC_COMMAND_QUERY_HARBOR_NPC_INFO = 12
};
bool UserHarborNpcService_NPC_COMMAND_IsValid(int value);
const UserHarborNpcService_NPC_COMMAND UserHarborNpcService_NPC_COMMAND_NPC_COMMAND_MIN = UserHarborNpcService_NPC_COMMAND_QUERY;
const UserHarborNpcService_NPC_COMMAND UserHarborNpcService_NPC_COMMAND_NPC_COMMAND_MAX = UserHarborNpcService_NPC_COMMAND_QUERY_HARBOR_NPC_INFO;
const int UserHarborNpcService_NPC_COMMAND_NPC_COMMAND_ARRAYSIZE = UserHarborNpcService_NPC_COMMAND_NPC_COMMAND_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserHarborNpcService_NPC_COMMAND_descriptor();
inline const ::std::string& UserHarborNpcService_NPC_COMMAND_Name(UserHarborNpcService_NPC_COMMAND value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserHarborNpcService_NPC_COMMAND_descriptor(), value);
}
inline bool UserHarborNpcService_NPC_COMMAND_Parse(
    const ::std::string& name, UserHarborNpcService_NPC_COMMAND* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserHarborNpcService_NPC_COMMAND>(
    UserHarborNpcService_NPC_COMMAND_descriptor(), name, value);
}
enum FoodStyle_FOOD_ATTR_ID {
  FoodStyle_FOOD_ATTR_ID_COLOR = 1,
  FoodStyle_FOOD_ATTR_ID_SMELL = 2,
  FoodStyle_FOOD_ATTR_ID_TASTE = 3,
  FoodStyle_FOOD_ATTR_ID_BELLYFUL = 4,
  FoodStyle_FOOD_ATTR_ID_DETOXIFCATION = 5,
  FoodStyle_FOOD_ATTR_ID_SOBER = 6,
  FoodStyle_FOOD_ATTR_ID_EXORCISM = 7,
  FoodStyle_FOOD_ATTR_ID_POISON = 8,
  FoodStyle_FOOD_ATTR_ID_ALCOHOL = 9,
  FoodStyle_FOOD_ATTR_ID_EVIL = 10,
  FoodStyle_FOOD_ATTR_ID_SOUR = 11,
  FoodStyle_FOOD_ATTR_ID_SWEET = 12,
  FoodStyle_FOOD_ATTR_ID_BITTER = 13,
  FoodStyle_FOOD_ATTR_ID_HOT = 14,
  FoodStyle_FOOD_ATTR_ID_SALTY = 15
};
bool FoodStyle_FOOD_ATTR_ID_IsValid(int value);
const FoodStyle_FOOD_ATTR_ID FoodStyle_FOOD_ATTR_ID_FOOD_ATTR_ID_MIN = FoodStyle_FOOD_ATTR_ID_COLOR;
const FoodStyle_FOOD_ATTR_ID FoodStyle_FOOD_ATTR_ID_FOOD_ATTR_ID_MAX = FoodStyle_FOOD_ATTR_ID_SALTY;
const int FoodStyle_FOOD_ATTR_ID_FOOD_ATTR_ID_ARRAYSIZE = FoodStyle_FOOD_ATTR_ID_FOOD_ATTR_ID_MAX + 1;

const ::google::protobuf::EnumDescriptor* FoodStyle_FOOD_ATTR_ID_descriptor();
inline const ::std::string& FoodStyle_FOOD_ATTR_ID_Name(FoodStyle_FOOD_ATTR_ID value) {
  return ::google::protobuf::internal::NameOfEnum(
    FoodStyle_FOOD_ATTR_ID_descriptor(), value);
}
inline bool FoodStyle_FOOD_ATTR_ID_Parse(
    const ::std::string& name, FoodStyle_FOOD_ATTR_ID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FoodStyle_FOOD_ATTR_ID>(
    FoodStyle_FOOD_ATTR_ID_descriptor(), name, value);
}
enum UserFoodOrderService_ORDER_COMMAND {
  UserFoodOrderService_ORDER_COMMAND_QUERY = 1,
  UserFoodOrderService_ORDER_COMMAND_ACCEPT = 2,
  UserFoodOrderService_ORDER_COMMAND_REJECT = 3,
  UserFoodOrderService_ORDER_COMMAND_ACCEPT_REWARD = 4
};
bool UserFoodOrderService_ORDER_COMMAND_IsValid(int value);
const UserFoodOrderService_ORDER_COMMAND UserFoodOrderService_ORDER_COMMAND_ORDER_COMMAND_MIN = UserFoodOrderService_ORDER_COMMAND_QUERY;
const UserFoodOrderService_ORDER_COMMAND UserFoodOrderService_ORDER_COMMAND_ORDER_COMMAND_MAX = UserFoodOrderService_ORDER_COMMAND_ACCEPT_REWARD;
const int UserFoodOrderService_ORDER_COMMAND_ORDER_COMMAND_ARRAYSIZE = UserFoodOrderService_ORDER_COMMAND_ORDER_COMMAND_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserFoodOrderService_ORDER_COMMAND_descriptor();
inline const ::std::string& UserFoodOrderService_ORDER_COMMAND_Name(UserFoodOrderService_ORDER_COMMAND value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserFoodOrderService_ORDER_COMMAND_descriptor(), value);
}
inline bool UserFoodOrderService_ORDER_COMMAND_Parse(
    const ::std::string& name, UserFoodOrderService_ORDER_COMMAND* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserFoodOrderService_ORDER_COMMAND>(
    UserFoodOrderService_ORDER_COMMAND_descriptor(), name, value);
}
enum HARBOR_STATE {
  HARBOR_STATE_IDLE = 0,
  HARBOR_STATE_OPEN = 1,
  HARBOR_STATE_CLOSE = 2
};
bool HARBOR_STATE_IsValid(int value);
const HARBOR_STATE HARBOR_STATE_MIN = HARBOR_STATE_IDLE;
const HARBOR_STATE HARBOR_STATE_MAX = HARBOR_STATE_CLOSE;
const int HARBOR_STATE_ARRAYSIZE = HARBOR_STATE_MAX + 1;

const ::google::protobuf::EnumDescriptor* HARBOR_STATE_descriptor();
inline const ::std::string& HARBOR_STATE_Name(HARBOR_STATE value) {
  return ::google::protobuf::internal::NameOfEnum(
    HARBOR_STATE_descriptor(), value);
}
inline bool HARBOR_STATE_Parse(
    const ::std::string& name, HARBOR_STATE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HARBOR_STATE>(
    HARBOR_STATE_descriptor(), name, value);
}
enum HARBOR_NPC_TYPE {
  HARBOR_NPC_TYPE_UNKNOWN = 0,
  HARBOR_NPC_TYPE_RESIDENT = 1,
  HARBOR_NPC_TYPE_PASSENGER = 2
};
bool HARBOR_NPC_TYPE_IsValid(int value);
const HARBOR_NPC_TYPE HARBOR_NPC_TYPE_MIN = HARBOR_NPC_TYPE_UNKNOWN;
const HARBOR_NPC_TYPE HARBOR_NPC_TYPE_MAX = HARBOR_NPC_TYPE_PASSENGER;
const int HARBOR_NPC_TYPE_ARRAYSIZE = HARBOR_NPC_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* HARBOR_NPC_TYPE_descriptor();
inline const ::std::string& HARBOR_NPC_TYPE_Name(HARBOR_NPC_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    HARBOR_NPC_TYPE_descriptor(), value);
}
inline bool HARBOR_NPC_TYPE_Parse(
    const ::std::string& name, HARBOR_NPC_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HARBOR_NPC_TYPE>(
    HARBOR_NPC_TYPE_descriptor(), name, value);
}
enum RESIDENT_TYPE {
  RESIDENT_TYPE_BEGGAR = 1,
  RESIDENT_TYPE_SHOP = 2
};
bool RESIDENT_TYPE_IsValid(int value);
const RESIDENT_TYPE RESIDENT_TYPE_MIN = RESIDENT_TYPE_BEGGAR;
const RESIDENT_TYPE RESIDENT_TYPE_MAX = RESIDENT_TYPE_SHOP;
const int RESIDENT_TYPE_ARRAYSIZE = RESIDENT_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* RESIDENT_TYPE_descriptor();
inline const ::std::string& RESIDENT_TYPE_Name(RESIDENT_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    RESIDENT_TYPE_descriptor(), value);
}
inline bool RESIDENT_TYPE_Parse(
    const ::std::string& name, RESIDENT_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RESIDENT_TYPE>(
    RESIDENT_TYPE_descriptor(), name, value);
}
enum CUSTOMER_OCCUPATION {
  CUSTOMER_OCCUPATION_COMMON = 0,
  CUSTOMER_OCCUPATION_EATER = 1,
  CUSTOMER_OCCUPATION_VENDOR = 2,
  CUSTOMER_OCCUPATION_DRINKER = 3
};
bool CUSTOMER_OCCUPATION_IsValid(int value);
const CUSTOMER_OCCUPATION CUSTOMER_OCCUPATION_MIN = CUSTOMER_OCCUPATION_COMMON;
const CUSTOMER_OCCUPATION CUSTOMER_OCCUPATION_MAX = CUSTOMER_OCCUPATION_DRINKER;
const int CUSTOMER_OCCUPATION_ARRAYSIZE = CUSTOMER_OCCUPATION_MAX + 1;

const ::google::protobuf::EnumDescriptor* CUSTOMER_OCCUPATION_descriptor();
inline const ::std::string& CUSTOMER_OCCUPATION_Name(CUSTOMER_OCCUPATION value) {
  return ::google::protobuf::internal::NameOfEnum(
    CUSTOMER_OCCUPATION_descriptor(), value);
}
inline bool CUSTOMER_OCCUPATION_Parse(
    const ::std::string& name, CUSTOMER_OCCUPATION* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CUSTOMER_OCCUPATION>(
    CUSTOMER_OCCUPATION_descriptor(), name, value);
}
enum FOOD_RECIPE_TYPE {
  FOOD_RECIPE_TYPE_STAPLE = 1,
  FOOD_RECIPE_TYPE_WINE = 2
};
bool FOOD_RECIPE_TYPE_IsValid(int value);
const FOOD_RECIPE_TYPE FOOD_RECIPE_TYPE_MIN = FOOD_RECIPE_TYPE_STAPLE;
const FOOD_RECIPE_TYPE FOOD_RECIPE_TYPE_MAX = FOOD_RECIPE_TYPE_WINE;
const int FOOD_RECIPE_TYPE_ARRAYSIZE = FOOD_RECIPE_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* FOOD_RECIPE_TYPE_descriptor();
inline const ::std::string& FOOD_RECIPE_TYPE_Name(FOOD_RECIPE_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    FOOD_RECIPE_TYPE_descriptor(), value);
}
inline bool FOOD_RECIPE_TYPE_Parse(
    const ::std::string& name, FOOD_RECIPE_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FOOD_RECIPE_TYPE>(
    FOOD_RECIPE_TYPE_descriptor(), name, value);
}
enum FOOD_ORDER_TYPE {
  FOOD_ORDER_TYPE_DISABLE = 0,
  FOOD_ORDER_TYPE_RECIPE = 1,
  FOOD_ORDER_TYPE_DIY = 2
};
bool FOOD_ORDER_TYPE_IsValid(int value);
const FOOD_ORDER_TYPE FOOD_ORDER_TYPE_MIN = FOOD_ORDER_TYPE_DISABLE;
const FOOD_ORDER_TYPE FOOD_ORDER_TYPE_MAX = FOOD_ORDER_TYPE_DIY;
const int FOOD_ORDER_TYPE_ARRAYSIZE = FOOD_ORDER_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* FOOD_ORDER_TYPE_descriptor();
inline const ::std::string& FOOD_ORDER_TYPE_Name(FOOD_ORDER_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    FOOD_ORDER_TYPE_descriptor(), value);
}
inline bool FOOD_ORDER_TYPE_Parse(
    const ::std::string& name, FOOD_ORDER_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FOOD_ORDER_TYPE>(
    FOOD_ORDER_TYPE_descriptor(), name, value);
}
enum FOOD_ORDER_STATE {
  FOOD_ORDER_STATE_TO_DELETE = -1,
  FOOD_ORDER_STATE_IDLE = 0,
  FOOD_ORDER_STATE_ORDERING = 1,
  FOOD_ORDER_STATE_COOKING = 2,
  FOOD_ORDER_STATE_EATING = 3,
  FOOD_ORDER_STATE_EATING_OVER = 4,
  FOOD_ORDER_STATE_PAY = 5,
  FOOD_ORDER_STATE_REJECT = 6,
  FOOD_ORDER_STATE_SUSPEND = 7
};
bool FOOD_ORDER_STATE_IsValid(int value);
const FOOD_ORDER_STATE FOOD_ORDER_STATE_MIN = FOOD_ORDER_STATE_TO_DELETE;
const FOOD_ORDER_STATE FOOD_ORDER_STATE_MAX = FOOD_ORDER_STATE_SUSPEND;
const int FOOD_ORDER_STATE_ARRAYSIZE = FOOD_ORDER_STATE_MAX + 1;

const ::google::protobuf::EnumDescriptor* FOOD_ORDER_STATE_descriptor();
inline const ::std::string& FOOD_ORDER_STATE_Name(FOOD_ORDER_STATE value) {
  return ::google::protobuf::internal::NameOfEnum(
    FOOD_ORDER_STATE_descriptor(), value);
}
inline bool FOOD_ORDER_STATE_Parse(
    const ::std::string& name, FOOD_ORDER_STATE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FOOD_ORDER_STATE>(
    FOOD_ORDER_STATE_descriptor(), name, value);
}
// ===================================================================

class HarborInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.HarborInfo) */ {
 public:
  HarborInfo();
  virtual ~HarborInfo();

  HarborInfo(const HarborInfo& from);

  inline HarborInfo& operator=(const HarborInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HarborInfo(HarborInfo&& from) noexcept
    : HarborInfo() {
    *this = ::std::move(from);
  }

  inline HarborInfo& operator=(HarborInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const HarborInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HarborInfo* internal_default_instance() {
    return reinterpret_cast<const HarborInfo*>(
               &_HarborInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void UnsafeArenaSwap(HarborInfo* other);
  void Swap(HarborInfo* other);
  friend void swap(HarborInfo& a, HarborInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HarborInfo* New() const final {
    return CreateMaybeMessage<HarborInfo>(NULL);
  }

  HarborInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HarborInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HarborInfo& from);
  void MergeFrom(const HarborInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HarborInfo* other);
  protected:
  explicit HarborInfo(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .sg.HARBOR_STATE state = 1;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 1;
  ::sg::HARBOR_STATE state() const;
  void set_state(::sg::HARBOR_STATE value);

  // optional int32 boom = 2;
  bool has_boom() const;
  void clear_boom();
  static const int kBoomFieldNumber = 2;
  ::google::protobuf::int32 boom() const;
  void set_boom(::google::protobuf::int32 value);

  // optional sfixed64 growtime = 3;
  bool has_growtime() const;
  void clear_growtime();
  static const int kGrowtimeFieldNumber = 3;
  ::google::protobuf::int64 growtime() const;
  void set_growtime(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:sg.HarborInfo)
 private:
  void set_has_state();
  void clear_has_state();
  void set_has_boom();
  void clear_has_boom();
  void set_has_growtime();
  void clear_has_growtime();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int state_;
  ::google::protobuf::int32 boom_;
  ::google::protobuf::int64 growtime_;
  friend struct ::protobuf_UserHarbour_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HarborNpc_resident_task : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.HarborNpc.resident_task) */ {
 public:
  HarborNpc_resident_task();
  virtual ~HarborNpc_resident_task();

  HarborNpc_resident_task(const HarborNpc_resident_task& from);

  inline HarborNpc_resident_task& operator=(const HarborNpc_resident_task& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HarborNpc_resident_task(HarborNpc_resident_task&& from) noexcept
    : HarborNpc_resident_task() {
    *this = ::std::move(from);
  }

  inline HarborNpc_resident_task& operator=(HarborNpc_resident_task&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const HarborNpc_resident_task& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HarborNpc_resident_task* internal_default_instance() {
    return reinterpret_cast<const HarborNpc_resident_task*>(
               &_HarborNpc_resident_task_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void UnsafeArenaSwap(HarborNpc_resident_task* other);
  void Swap(HarborNpc_resident_task* other);
  friend void swap(HarborNpc_resident_task& a, HarborNpc_resident_task& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HarborNpc_resident_task* New() const final {
    return CreateMaybeMessage<HarborNpc_resident_task>(NULL);
  }

  HarborNpc_resident_task* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HarborNpc_resident_task>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HarborNpc_resident_task& from);
  void MergeFrom(const HarborNpc_resident_task& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HarborNpc_resident_task* other);
  protected:
  explicit HarborNpc_resident_task(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // optional int32 need_idx = 2;
  bool has_need_idx() const;
  void clear_need_idx();
  static const int kNeedIdxFieldNumber = 2;
  ::google::protobuf::int32 need_idx() const;
  void set_need_idx(::google::protobuf::int32 value);

  // optional int32 reward_idx = 3;
  bool has_reward_idx() const;
  void clear_reward_idx();
  static const int kRewardIdxFieldNumber = 3;
  ::google::protobuf::int32 reward_idx() const;
  void set_reward_idx(::google::protobuf::int32 value);

  // optional bool reward_accept = 4;
  bool has_reward_accept() const;
  void clear_reward_accept();
  static const int kRewardAcceptFieldNumber = 4;
  bool reward_accept() const;
  void set_reward_accept(bool value);

  // @@protoc_insertion_point(class_scope:sg.HarborNpc.resident_task)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_need_idx();
  void clear_has_need_idx();
  void set_has_reward_idx();
  void clear_has_reward_idx();
  void set_has_reward_accept();
  void clear_has_reward_accept();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 need_idx_;
  ::google::protobuf::int32 reward_idx_;
  bool reward_accept_;
  friend struct ::protobuf_UserHarbour_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HarborNpc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.HarborNpc) */ {
 public:
  HarborNpc();
  virtual ~HarborNpc();

  HarborNpc(const HarborNpc& from);

  inline HarborNpc& operator=(const HarborNpc& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HarborNpc(HarborNpc&& from) noexcept
    : HarborNpc() {
    *this = ::std::move(from);
  }

  inline HarborNpc& operator=(HarborNpc&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const HarborNpc& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HarborNpc* internal_default_instance() {
    return reinterpret_cast<const HarborNpc*>(
               &_HarborNpc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void UnsafeArenaSwap(HarborNpc* other);
  void Swap(HarborNpc* other);
  friend void swap(HarborNpc& a, HarborNpc& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HarborNpc* New() const final {
    return CreateMaybeMessage<HarborNpc>(NULL);
  }

  HarborNpc* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HarborNpc>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HarborNpc& from);
  void MergeFrom(const HarborNpc& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HarborNpc* other);
  protected:
  explicit HarborNpc(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef HarborNpc_resident_task resident_task;

  typedef HarborNpc_NPC_STATE NPC_STATE;
  static const NPC_STATE TO_DELETE =
    HarborNpc_NPC_STATE_TO_DELETE;
  static const NPC_STATE IDLE =
    HarborNpc_NPC_STATE_IDLE;
  static const NPC_STATE GO_ABOARD =
    HarborNpc_NPC_STATE_GO_ABOARD;
  static const NPC_STATE IN_QUEUEING =
    HarborNpc_NPC_STATE_IN_QUEUEING;
  static const NPC_STATE TAKE_SEAT =
    HarborNpc_NPC_STATE_TAKE_SEAT;
  static const NPC_STATE ORDER_SUCCESS =
    HarborNpc_NPC_STATE_ORDER_SUCCESS;
  static const NPC_STATE EATING_FOOD =
    HarborNpc_NPC_STATE_EATING_FOOD;
  static const NPC_STATE DISMISS =
    HarborNpc_NPC_STATE_DISMISS;
  static const NPC_STATE WORKING =
    HarborNpc_NPC_STATE_WORKING;
  static inline bool NPC_STATE_IsValid(int value) {
    return HarborNpc_NPC_STATE_IsValid(value);
  }
  static const NPC_STATE NPC_STATE_MIN =
    HarborNpc_NPC_STATE_NPC_STATE_MIN;
  static const NPC_STATE NPC_STATE_MAX =
    HarborNpc_NPC_STATE_NPC_STATE_MAX;
  static const int NPC_STATE_ARRAYSIZE =
    HarborNpc_NPC_STATE_NPC_STATE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  NPC_STATE_descriptor() {
    return HarborNpc_NPC_STATE_descriptor();
  }
  static inline const ::std::string& NPC_STATE_Name(NPC_STATE value) {
    return HarborNpc_NPC_STATE_Name(value);
  }
  static inline bool NPC_STATE_Parse(const ::std::string& name,
      NPC_STATE* value) {
    return HarborNpc_NPC_STATE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .sg.HarborNpc.resident_task task_menu1 = 31;
  bool has_task_menu1() const;
  void clear_task_menu1();
  static const int kTaskMenu1FieldNumber = 31;
  private:
  const ::sg::HarborNpc_resident_task& _internal_task_menu1() const;
  public:
  const ::sg::HarborNpc_resident_task& task_menu1() const;
  ::sg::HarborNpc_resident_task* release_task_menu1();
  ::sg::HarborNpc_resident_task* mutable_task_menu1();
  void set_allocated_task_menu1(::sg::HarborNpc_resident_task* task_menu1);
  void unsafe_arena_set_allocated_task_menu1(
      ::sg::HarborNpc_resident_task* task_menu1);
  ::sg::HarborNpc_resident_task* unsafe_arena_release_task_menu1();

  // optional .sg.HarborNpc.resident_task task_menu2 = 32;
  bool has_task_menu2() const;
  void clear_task_menu2();
  static const int kTaskMenu2FieldNumber = 32;
  private:
  const ::sg::HarborNpc_resident_task& _internal_task_menu2() const;
  public:
  const ::sg::HarborNpc_resident_task& task_menu2() const;
  ::sg::HarborNpc_resident_task* release_task_menu2();
  ::sg::HarborNpc_resident_task* mutable_task_menu2();
  void set_allocated_task_menu2(::sg::HarborNpc_resident_task* task_menu2);
  void unsafe_arena_set_allocated_task_menu2(
      ::sg::HarborNpc_resident_task* task_menu2);
  ::sg::HarborNpc_resident_task* unsafe_arena_release_task_menu2();

  // optional .sg.HarborNpc.resident_task task_menu3 = 33;
  bool has_task_menu3() const;
  void clear_task_menu3();
  static const int kTaskMenu3FieldNumber = 33;
  private:
  const ::sg::HarborNpc_resident_task& _internal_task_menu3() const;
  public:
  const ::sg::HarborNpc_resident_task& task_menu3() const;
  ::sg::HarborNpc_resident_task* release_task_menu3();
  ::sg::HarborNpc_resident_task* mutable_task_menu3();
  void set_allocated_task_menu3(::sg::HarborNpc_resident_task* task_menu3);
  void unsafe_arena_set_allocated_task_menu3(
      ::sg::HarborNpc_resident_task* task_menu3);
  ::sg::HarborNpc_resident_task* unsafe_arena_release_task_menu3();

  // required int32 npcid = 1;
  bool has_npcid() const;
  void clear_npcid();
  static const int kNpcidFieldNumber = 1;
  ::google::protobuf::int32 npcid() const;
  void set_npcid(::google::protobuf::int32 value);

  // optional .sg.HARBOR_NPC_TYPE npc_type = 2;
  bool has_npc_type() const;
  void clear_npc_type();
  static const int kNpcTypeFieldNumber = 2;
  ::sg::HARBOR_NPC_TYPE npc_type() const;
  void set_npc_type(::sg::HARBOR_NPC_TYPE value);

  // optional uint64 cfgid = 3;
  bool has_cfgid() const;
  void clear_cfgid();
  static const int kCfgidFieldNumber = 3;
  ::google::protobuf::uint64 cfgid() const;
  void set_cfgid(::google::protobuf::uint64 value);

  // optional int32 seconds = 5;
  bool has_seconds() const;
  void clear_seconds();
  static const int kSecondsFieldNumber = 5;
  ::google::protobuf::int32 seconds() const;
  void set_seconds(::google::protobuf::int32 value);

  // optional int32 wealth_grade = 11;
  bool has_wealth_grade() const;
  void clear_wealth_grade();
  static const int kWealthGradeFieldNumber = 11;
  ::google::protobuf::int32 wealth_grade() const;
  void set_wealth_grade(::google::protobuf::int32 value);

  // optional int32 gold = 12;
  bool has_gold() const;
  void clear_gold();
  static const int kGoldFieldNumber = 12;
  ::google::protobuf::int32 gold() const;
  void set_gold(::google::protobuf::int32 value);

  // optional int32 satisfaction = 13;
  bool has_satisfaction() const;
  void clear_satisfaction();
  static const int kSatisfactionFieldNumber = 13;
  ::google::protobuf::int32 satisfaction() const;
  void set_satisfaction(::google::protobuf::int32 value);

  // optional int32 seatid = 14;
  bool has_seatid() const;
  void clear_seatid();
  static const int kSeatidFieldNumber = 14;
  ::google::protobuf::int32 seatid() const;
  void set_seatid(::google::protobuf::int32 value);

  // optional int32 occupation_val = 21;
  bool has_occupation_val() const;
  void clear_occupation_val();
  static const int kOccupationValFieldNumber = 21;
  ::google::protobuf::int32 occupation_val() const;
  void set_occupation_val(::google::protobuf::int32 value);

  // optional int32 satisfaction_accepted = 25;
  bool has_satisfaction_accepted() const;
  void clear_satisfaction_accepted();
  static const int kSatisfactionAcceptedFieldNumber = 25;
  ::google::protobuf::int32 satisfaction_accepted() const;
  void set_satisfaction_accepted(::google::protobuf::int32 value);

  // optional sfixed64 occupation_event_starttime = 22;
  bool has_occupation_event_starttime() const;
  void clear_occupation_event_starttime();
  static const int kOccupationEventStarttimeFieldNumber = 22;
  ::google::protobuf::int64 occupation_event_starttime() const;
  void set_occupation_event_starttime(::google::protobuf::int64 value);

  // optional int32 question_status = 23;
  bool has_question_status() const;
  void clear_question_status();
  static const int kQuestionStatusFieldNumber = 23;
  ::google::protobuf::int32 question_status() const;
  void set_question_status(::google::protobuf::int32 value);

  // optional int32 special_cond_bonus = 24;
  bool has_special_cond_bonus() const;
  void clear_special_cond_bonus();
  static const int kSpecialCondBonusFieldNumber = 24;
  ::google::protobuf::int32 special_cond_bonus() const;
  void set_special_cond_bonus(::google::protobuf::int32 value);

  // optional sfixed64 optime = 41;
  bool has_optime() const;
  void clear_optime();
  static const int kOptimeFieldNumber = 41;
  ::google::protobuf::int64 optime() const;
  void set_optime(::google::protobuf::int64 value);

  // optional .sg.HarborNpc.NPC_STATE state = 4;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 4;
  ::sg::HarborNpc_NPC_STATE state() const;
  void set_state(::sg::HarborNpc_NPC_STATE value);

  // @@protoc_insertion_point(class_scope:sg.HarborNpc)
 private:
  void set_has_npcid();
  void clear_has_npcid();
  void set_has_npc_type();
  void clear_has_npc_type();
  void set_has_cfgid();
  void clear_has_cfgid();
  void set_has_state();
  void clear_has_state();
  void set_has_seconds();
  void clear_has_seconds();
  void set_has_wealth_grade();
  void clear_has_wealth_grade();
  void set_has_gold();
  void clear_has_gold();
  void set_has_satisfaction();
  void clear_has_satisfaction();
  void set_has_seatid();
  void clear_has_seatid();
  void set_has_occupation_val();
  void clear_has_occupation_val();
  void set_has_occupation_event_starttime();
  void clear_has_occupation_event_starttime();
  void set_has_question_status();
  void clear_has_question_status();
  void set_has_special_cond_bonus();
  void clear_has_special_cond_bonus();
  void set_has_satisfaction_accepted();
  void clear_has_satisfaction_accepted();
  void set_has_task_menu1();
  void clear_has_task_menu1();
  void set_has_task_menu2();
  void clear_has_task_menu2();
  void set_has_task_menu3();
  void clear_has_task_menu3();
  void set_has_optime();
  void clear_has_optime();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::sg::HarborNpc_resident_task* task_menu1_;
  ::sg::HarborNpc_resident_task* task_menu2_;
  ::sg::HarborNpc_resident_task* task_menu3_;
  ::google::protobuf::int32 npcid_;
  int npc_type_;
  ::google::protobuf::uint64 cfgid_;
  ::google::protobuf::int32 seconds_;
  ::google::protobuf::int32 wealth_grade_;
  ::google::protobuf::int32 gold_;
  ::google::protobuf::int32 satisfaction_;
  ::google::protobuf::int32 seatid_;
  ::google::protobuf::int32 occupation_val_;
  ::google::protobuf::int32 satisfaction_accepted_;
  ::google::protobuf::int64 occupation_event_starttime_;
  ::google::protobuf::int32 question_status_;
  ::google::protobuf::int32 special_cond_bonus_;
  ::google::protobuf::int64 optime_;
  int state_;
  friend struct ::protobuf_UserHarbour_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HarborNpcList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.HarborNpcList) */ {
 public:
  HarborNpcList();
  virtual ~HarborNpcList();

  HarborNpcList(const HarborNpcList& from);

  inline HarborNpcList& operator=(const HarborNpcList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HarborNpcList(HarborNpcList&& from) noexcept
    : HarborNpcList() {
    *this = ::std::move(from);
  }

  inline HarborNpcList& operator=(HarborNpcList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const HarborNpcList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HarborNpcList* internal_default_instance() {
    return reinterpret_cast<const HarborNpcList*>(
               &_HarborNpcList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void UnsafeArenaSwap(HarborNpcList* other);
  void Swap(HarborNpcList* other);
  friend void swap(HarborNpcList& a, HarborNpcList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HarborNpcList* New() const final {
    return CreateMaybeMessage<HarborNpcList>(NULL);
  }

  HarborNpcList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HarborNpcList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HarborNpcList& from);
  void MergeFrom(const HarborNpcList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HarborNpcList* other);
  protected:
  explicit HarborNpcList(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sg.HarborNpc list = 1;
  int list_size() const;
  void clear_list();
  static const int kListFieldNumber = 1;
  ::sg::HarborNpc* mutable_list(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::HarborNpc >*
      mutable_list();
  const ::sg::HarborNpc& list(int index) const;
  ::sg::HarborNpc* add_list();
  const ::google::protobuf::RepeatedPtrField< ::sg::HarborNpc >&
      list() const;

  // @@protoc_insertion_point(class_scope:sg.HarborNpcList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::HarborNpc > list_;
  friend struct ::protobuf_UserHarbour_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HarborPopulation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.HarborPopulation) */ {
 public:
  HarborPopulation();
  virtual ~HarborPopulation();

  HarborPopulation(const HarborPopulation& from);

  inline HarborPopulation& operator=(const HarborPopulation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HarborPopulation(HarborPopulation&& from) noexcept
    : HarborPopulation() {
    *this = ::std::move(from);
  }

  inline HarborPopulation& operator=(HarborPopulation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const HarborPopulation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HarborPopulation* internal_default_instance() {
    return reinterpret_cast<const HarborPopulation*>(
               &_HarborPopulation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void UnsafeArenaSwap(HarborPopulation* other);
  void Swap(HarborPopulation* other);
  friend void swap(HarborPopulation& a, HarborPopulation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HarborPopulation* New() const final {
    return CreateMaybeMessage<HarborPopulation>(NULL);
  }

  HarborPopulation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HarborPopulation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HarborPopulation& from);
  void MergeFrom(const HarborPopulation& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HarborPopulation* other);
  protected:
  explicit HarborPopulation(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 harborid = 1;
  bool has_harborid() const;
  void clear_harborid();
  static const int kHarboridFieldNumber = 1;
  ::google::protobuf::int32 harborid() const;
  void set_harborid(::google::protobuf::int32 value);

  // required int32 population_num = 2;
  bool has_population_num() const;
  void clear_population_num();
  static const int kPopulationNumFieldNumber = 2;
  ::google::protobuf::int32 population_num() const;
  void set_population_num(::google::protobuf::int32 value);

  // required int32 population_num_max = 3;
  bool has_population_num_max() const;
  void clear_population_num_max();
  static const int kPopulationNumMaxFieldNumber = 3;
  ::google::protobuf::int32 population_num_max() const;
  void set_population_num_max(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.HarborPopulation)
 private:
  void set_has_harborid();
  void clear_has_harborid();
  void set_has_population_num();
  void clear_has_population_num();
  void set_has_population_num_max();
  void clear_has_population_num_max();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 harborid_;
  ::google::protobuf::int32 population_num_;
  ::google::protobuf::int32 population_num_max_;
  friend struct ::protobuf_UserHarbour_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HarborPopulationList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.HarborPopulationList) */ {
 public:
  HarborPopulationList();
  virtual ~HarborPopulationList();

  HarborPopulationList(const HarborPopulationList& from);

  inline HarborPopulationList& operator=(const HarborPopulationList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HarborPopulationList(HarborPopulationList&& from) noexcept
    : HarborPopulationList() {
    *this = ::std::move(from);
  }

  inline HarborPopulationList& operator=(HarborPopulationList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const HarborPopulationList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HarborPopulationList* internal_default_instance() {
    return reinterpret_cast<const HarborPopulationList*>(
               &_HarborPopulationList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void UnsafeArenaSwap(HarborPopulationList* other);
  void Swap(HarborPopulationList* other);
  friend void swap(HarborPopulationList& a, HarborPopulationList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HarborPopulationList* New() const final {
    return CreateMaybeMessage<HarborPopulationList>(NULL);
  }

  HarborPopulationList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HarborPopulationList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HarborPopulationList& from);
  void MergeFrom(const HarborPopulationList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HarborPopulationList* other);
  protected:
  explicit HarborPopulationList(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sg.HarborPopulation list = 1;
  int list_size() const;
  void clear_list();
  static const int kListFieldNumber = 1;
  ::sg::HarborPopulation* mutable_list(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::HarborPopulation >*
      mutable_list();
  const ::sg::HarborPopulation& list(int index) const;
  ::sg::HarborPopulation* add_list();
  const ::google::protobuf::RepeatedPtrField< ::sg::HarborPopulation >&
      list() const;

  // @@protoc_insertion_point(class_scope:sg.HarborPopulationList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::HarborPopulation > list_;
  friend struct ::protobuf_UserHarbour_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HarborNpcInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.HarborNpcInfo) */ {
 public:
  HarborNpcInfo();
  virtual ~HarborNpcInfo();

  HarborNpcInfo(const HarborNpcInfo& from);

  inline HarborNpcInfo& operator=(const HarborNpcInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HarborNpcInfo(HarborNpcInfo&& from) noexcept
    : HarborNpcInfo() {
    *this = ::std::move(from);
  }

  inline HarborNpcInfo& operator=(HarborNpcInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const HarborNpcInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HarborNpcInfo* internal_default_instance() {
    return reinterpret_cast<const HarborNpcInfo*>(
               &_HarborNpcInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void UnsafeArenaSwap(HarborNpcInfo* other);
  void Swap(HarborNpcInfo* other);
  friend void swap(HarborNpcInfo& a, HarborNpcInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HarborNpcInfo* New() const final {
    return CreateMaybeMessage<HarborNpcInfo>(NULL);
  }

  HarborNpcInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HarborNpcInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HarborNpcInfo& from);
  void MergeFrom(const HarborNpcInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HarborNpcInfo* other);
  protected:
  explicit HarborNpcInfo(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .sg.HarborNpcList npc_list = 2;
  bool has_npc_list() const;
  void clear_npc_list();
  static const int kNpcListFieldNumber = 2;
  private:
  const ::sg::HarborNpcList& _internal_npc_list() const;
  public:
  const ::sg::HarborNpcList& npc_list() const;
  ::sg::HarborNpcList* release_npc_list();
  ::sg::HarborNpcList* mutable_npc_list();
  void set_allocated_npc_list(::sg::HarborNpcList* npc_list);
  void unsafe_arena_set_allocated_npc_list(
      ::sg::HarborNpcList* npc_list);
  ::sg::HarborNpcList* unsafe_arena_release_npc_list();

  // optional .sg.HarborInfo harbor_info = 3;
  bool has_harbor_info() const;
  void clear_harbor_info();
  static const int kHarborInfoFieldNumber = 3;
  private:
  const ::sg::HarborInfo& _internal_harbor_info() const;
  public:
  const ::sg::HarborInfo& harbor_info() const;
  ::sg::HarborInfo* release_harbor_info();
  ::sg::HarborInfo* mutable_harbor_info();
  void set_allocated_harbor_info(::sg::HarborInfo* harbor_info);
  void unsafe_arena_set_allocated_harbor_info(
      ::sg::HarborInfo* harbor_info);
  ::sg::HarborInfo* unsafe_arena_release_harbor_info();

  // required int32 harborid = 1;
  bool has_harborid() const;
  void clear_harborid();
  static const int kHarboridFieldNumber = 1;
  ::google::protobuf::int32 harborid() const;
  void set_harborid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.HarborNpcInfo)
 private:
  void set_has_harborid();
  void clear_has_harborid();
  void set_has_npc_list();
  void clear_has_npc_list();
  void set_has_harbor_info();
  void clear_has_harbor_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::sg::HarborNpcList* npc_list_;
  ::sg::HarborInfo* harbor_info_;
  ::google::protobuf::int32 harborid_;
  friend struct ::protobuf_UserHarbour_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HarborNpcInfoList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.HarborNpcInfoList) */ {
 public:
  HarborNpcInfoList();
  virtual ~HarborNpcInfoList();

  HarborNpcInfoList(const HarborNpcInfoList& from);

  inline HarborNpcInfoList& operator=(const HarborNpcInfoList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HarborNpcInfoList(HarborNpcInfoList&& from) noexcept
    : HarborNpcInfoList() {
    *this = ::std::move(from);
  }

  inline HarborNpcInfoList& operator=(HarborNpcInfoList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const HarborNpcInfoList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HarborNpcInfoList* internal_default_instance() {
    return reinterpret_cast<const HarborNpcInfoList*>(
               &_HarborNpcInfoList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void UnsafeArenaSwap(HarborNpcInfoList* other);
  void Swap(HarborNpcInfoList* other);
  friend void swap(HarborNpcInfoList& a, HarborNpcInfoList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HarborNpcInfoList* New() const final {
    return CreateMaybeMessage<HarborNpcInfoList>(NULL);
  }

  HarborNpcInfoList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HarborNpcInfoList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HarborNpcInfoList& from);
  void MergeFrom(const HarborNpcInfoList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HarborNpcInfoList* other);
  protected:
  explicit HarborNpcInfoList(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sg.HarborNpcInfo list = 1;
  int list_size() const;
  void clear_list();
  static const int kListFieldNumber = 1;
  ::sg::HarborNpcInfo* mutable_list(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::HarborNpcInfo >*
      mutable_list();
  const ::sg::HarborNpcInfo& list(int index) const;
  ::sg::HarborNpcInfo* add_list();
  const ::google::protobuf::RepeatedPtrField< ::sg::HarborNpcInfo >&
      list() const;

  // @@protoc_insertion_point(class_scope:sg.HarborNpcInfoList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::HarborNpcInfo > list_;
  friend struct ::protobuf_UserHarbour_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserHarborNpcService_HarborNpcRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.UserHarborNpcService.HarborNpcRequest) */ {
 public:
  UserHarborNpcService_HarborNpcRequest();
  virtual ~UserHarborNpcService_HarborNpcRequest();

  UserHarborNpcService_HarborNpcRequest(const UserHarborNpcService_HarborNpcRequest& from);

  inline UserHarborNpcService_HarborNpcRequest& operator=(const UserHarborNpcService_HarborNpcRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserHarborNpcService_HarborNpcRequest(UserHarborNpcService_HarborNpcRequest&& from) noexcept
    : UserHarborNpcService_HarborNpcRequest() {
    *this = ::std::move(from);
  }

  inline UserHarborNpcService_HarborNpcRequest& operator=(UserHarborNpcService_HarborNpcRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserHarborNpcService_HarborNpcRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserHarborNpcService_HarborNpcRequest* internal_default_instance() {
    return reinterpret_cast<const UserHarborNpcService_HarborNpcRequest*>(
               &_UserHarborNpcService_HarborNpcRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void UnsafeArenaSwap(UserHarborNpcService_HarborNpcRequest* other);
  void Swap(UserHarborNpcService_HarborNpcRequest* other);
  friend void swap(UserHarborNpcService_HarborNpcRequest& a, UserHarborNpcService_HarborNpcRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserHarborNpcService_HarborNpcRequest* New() const final {
    return CreateMaybeMessage<UserHarborNpcService_HarborNpcRequest>(NULL);
  }

  UserHarborNpcService_HarborNpcRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserHarborNpcService_HarborNpcRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserHarborNpcService_HarborNpcRequest& from);
  void MergeFrom(const UserHarborNpcService_HarborNpcRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserHarborNpcService_HarborNpcRequest* other);
  protected:
  explicit UserHarborNpcService_HarborNpcRequest(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 start_queueing_list = 2;
  int start_queueing_list_size() const;
  void clear_start_queueing_list();
  static const int kStartQueueingListFieldNumber = 2;
  ::google::protobuf::int32 start_queueing_list(int index) const;
  void set_start_queueing_list(int index, ::google::protobuf::int32 value);
  void add_start_queueing_list(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      start_queueing_list() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_start_queueing_list();

  // optional int32 residentid = 3;
  bool has_residentid() const;
  void clear_residentid();
  static const int kResidentidFieldNumber = 3;
  ::google::protobuf::int32 residentid() const;
  void set_residentid(::google::protobuf::int32 value);

  // optional int32 select_task_menuid = 4;
  bool has_select_task_menuid() const;
  void clear_select_task_menuid();
  static const int kSelectTaskMenuidFieldNumber = 4;
  ::google::protobuf::int32 select_task_menuid() const;
  void set_select_task_menuid(::google::protobuf::int32 value);

  // optional int32 harborid = 5;
  bool has_harborid() const;
  void clear_harborid();
  static const int kHarboridFieldNumber = 5;
  ::google::protobuf::int32 harborid() const;
  void set_harborid(::google::protobuf::int32 value);

  // required .sg.UserHarborNpcService.NPC_COMMAND cmd = 1;
  bool has_cmd() const;
  void clear_cmd();
  static const int kCmdFieldNumber = 1;
  ::sg::UserHarborNpcService_NPC_COMMAND cmd() const;
  void set_cmd(::sg::UserHarborNpcService_NPC_COMMAND value);

  // @@protoc_insertion_point(class_scope:sg.UserHarborNpcService.HarborNpcRequest)
 private:
  void set_has_cmd();
  void clear_has_cmd();
  void set_has_residentid();
  void clear_has_residentid();
  void set_has_select_task_menuid();
  void clear_has_select_task_menuid();
  void set_has_harborid();
  void clear_has_harborid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > start_queueing_list_;
  ::google::protobuf::int32 residentid_;
  ::google::protobuf::int32 select_task_menuid_;
  ::google::protobuf::int32 harborid_;
  int cmd_;
  friend struct ::protobuf_UserHarbour_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserHarborNpcService_HarborNpcResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.UserHarborNpcService.HarborNpcResponse) */ {
 public:
  UserHarborNpcService_HarborNpcResponse();
  virtual ~UserHarborNpcService_HarborNpcResponse();

  UserHarborNpcService_HarborNpcResponse(const UserHarborNpcService_HarborNpcResponse& from);

  inline UserHarborNpcService_HarborNpcResponse& operator=(const UserHarborNpcService_HarborNpcResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserHarborNpcService_HarborNpcResponse(UserHarborNpcService_HarborNpcResponse&& from) noexcept
    : UserHarborNpcService_HarborNpcResponse() {
    *this = ::std::move(from);
  }

  inline UserHarborNpcService_HarborNpcResponse& operator=(UserHarborNpcService_HarborNpcResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserHarborNpcService_HarborNpcResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserHarborNpcService_HarborNpcResponse* internal_default_instance() {
    return reinterpret_cast<const UserHarborNpcService_HarborNpcResponse*>(
               &_UserHarborNpcService_HarborNpcResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void UnsafeArenaSwap(UserHarborNpcService_HarborNpcResponse* other);
  void Swap(UserHarborNpcService_HarborNpcResponse* other);
  friend void swap(UserHarborNpcService_HarborNpcResponse& a, UserHarborNpcService_HarborNpcResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserHarborNpcService_HarborNpcResponse* New() const final {
    return CreateMaybeMessage<UserHarborNpcService_HarborNpcResponse>(NULL);
  }

  UserHarborNpcService_HarborNpcResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserHarborNpcService_HarborNpcResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserHarborNpcService_HarborNpcResponse& from);
  void MergeFrom(const UserHarborNpcService_HarborNpcResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserHarborNpcService_HarborNpcResponse* other);
  protected:
  explicit UserHarborNpcService_HarborNpcResponse(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .sg.HarborNpcList npc_list = 2;
  bool has_npc_list() const;
  void clear_npc_list();
  static const int kNpcListFieldNumber = 2;
  private:
  const ::sg::HarborNpcList& _internal_npc_list() const;
  public:
  const ::sg::HarborNpcList& npc_list() const;
  ::sg::HarborNpcList* release_npc_list();
  ::sg::HarborNpcList* mutable_npc_list();
  void set_allocated_npc_list(::sg::HarborNpcList* npc_list);
  void unsafe_arena_set_allocated_npc_list(
      ::sg::HarborNpcList* npc_list);
  ::sg::HarborNpcList* unsafe_arena_release_npc_list();

  // optional .sg.HarborInfo harbor_info = 3;
  bool has_harbor_info() const;
  void clear_harbor_info();
  static const int kHarborInfoFieldNumber = 3;
  private:
  const ::sg::HarborInfo& _internal_harbor_info() const;
  public:
  const ::sg::HarborInfo& harbor_info() const;
  ::sg::HarborInfo* release_harbor_info();
  ::sg::HarborInfo* mutable_harbor_info();
  void set_allocated_harbor_info(::sg::HarborInfo* harbor_info);
  void unsafe_arena_set_allocated_harbor_info(
      ::sg::HarborInfo* harbor_info);
  ::sg::HarborInfo* unsafe_arena_release_harbor_info();

  // optional .sg.Reward resident_drop = 4;
  bool has_resident_drop() const;
  void clear_resident_drop();
  static const int kResidentDropFieldNumber = 4;
  private:
  const ::sg::Reward& _internal_resident_drop() const;
  public:
  const ::sg::Reward& resident_drop() const;
  ::sg::Reward* release_resident_drop();
  ::sg::Reward* mutable_resident_drop();
  void set_allocated_resident_drop(::sg::Reward* resident_drop);
  void unsafe_arena_set_allocated_resident_drop(
      ::sg::Reward* resident_drop);
  ::sg::Reward* unsafe_arena_release_resident_drop();

  // optional .sg.HarborPopulationList population_list = 11;
  bool has_population_list() const;
  void clear_population_list();
  static const int kPopulationListFieldNumber = 11;
  private:
  const ::sg::HarborPopulationList& _internal_population_list() const;
  public:
  const ::sg::HarborPopulationList& population_list() const;
  ::sg::HarborPopulationList* release_population_list();
  ::sg::HarborPopulationList* mutable_population_list();
  void set_allocated_population_list(::sg::HarborPopulationList* population_list);
  void unsafe_arena_set_allocated_population_list(
      ::sg::HarborPopulationList* population_list);
  ::sg::HarborPopulationList* unsafe_arena_release_population_list();

  // optional .sg.HarborNpcInfoList npc_info_list = 12;
  bool has_npc_info_list() const;
  void clear_npc_info_list();
  static const int kNpcInfoListFieldNumber = 12;
  private:
  const ::sg::HarborNpcInfoList& _internal_npc_info_list() const;
  public:
  const ::sg::HarborNpcInfoList& npc_info_list() const;
  ::sg::HarborNpcInfoList* release_npc_info_list();
  ::sg::HarborNpcInfoList* mutable_npc_info_list();
  void set_allocated_npc_info_list(::sg::HarborNpcInfoList* npc_info_list);
  void unsafe_arena_set_allocated_npc_info_list(
      ::sg::HarborNpcInfoList* npc_info_list);
  ::sg::HarborNpcInfoList* unsafe_arena_release_npc_info_list();

  // required int32 result = 1;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::google::protobuf::int32 result() const;
  void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.UserHarborNpcService.HarborNpcResponse)
 private:
  void set_has_result();
  void clear_has_result();
  void set_has_npc_list();
  void clear_has_npc_list();
  void set_has_harbor_info();
  void clear_has_harbor_info();
  void set_has_resident_drop();
  void clear_has_resident_drop();
  void set_has_population_list();
  void clear_has_population_list();
  void set_has_npc_info_list();
  void clear_has_npc_info_list();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::sg::HarborNpcList* npc_list_;
  ::sg::HarborInfo* harbor_info_;
  ::sg::Reward* resident_drop_;
  ::sg::HarborPopulationList* population_list_;
  ::sg::HarborNpcInfoList* npc_info_list_;
  ::google::protobuf::int32 result_;
  friend struct ::protobuf_UserHarbour_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserHarborNpcService : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.UserHarborNpcService) */ {
 public:
  UserHarborNpcService();
  virtual ~UserHarborNpcService();

  UserHarborNpcService(const UserHarborNpcService& from);

  inline UserHarborNpcService& operator=(const UserHarborNpcService& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserHarborNpcService(UserHarborNpcService&& from) noexcept
    : UserHarborNpcService() {
    *this = ::std::move(from);
  }

  inline UserHarborNpcService& operator=(UserHarborNpcService&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserHarborNpcService& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserHarborNpcService* internal_default_instance() {
    return reinterpret_cast<const UserHarborNpcService*>(
               &_UserHarborNpcService_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void UnsafeArenaSwap(UserHarborNpcService* other);
  void Swap(UserHarborNpcService* other);
  friend void swap(UserHarborNpcService& a, UserHarborNpcService& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserHarborNpcService* New() const final {
    return CreateMaybeMessage<UserHarborNpcService>(NULL);
  }

  UserHarborNpcService* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserHarborNpcService>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserHarborNpcService& from);
  void MergeFrom(const UserHarborNpcService& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserHarborNpcService* other);
  protected:
  explicit UserHarborNpcService(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UserHarborNpcService_HarborNpcRequest HarborNpcRequest;
  typedef UserHarborNpcService_HarborNpcResponse HarborNpcResponse;

  typedef UserHarborNpcService_NPC_COMMAND NPC_COMMAND;
  static const NPC_COMMAND QUERY =
    UserHarborNpcService_NPC_COMMAND_QUERY;
  static const NPC_COMMAND OPEN =
    UserHarborNpcService_NPC_COMMAND_OPEN;
  static const NPC_COMMAND CLOSE =
    UserHarborNpcService_NPC_COMMAND_CLOSE;
  static const NPC_COMMAND START_QUEUEING =
    UserHarborNpcService_NPC_COMMAND_START_QUEUEING;
  static const NPC_COMMAND COMPLETE_TASK =
    UserHarborNpcService_NPC_COMMAND_COMPLETE_TASK;
  static const NPC_COMMAND QUERY_POPULATION =
    UserHarborNpcService_NPC_COMMAND_QUERY_POPULATION;
  static const NPC_COMMAND QUERY_HARBOR_NPC_INFO =
    UserHarborNpcService_NPC_COMMAND_QUERY_HARBOR_NPC_INFO;
  static inline bool NPC_COMMAND_IsValid(int value) {
    return UserHarborNpcService_NPC_COMMAND_IsValid(value);
  }
  static const NPC_COMMAND NPC_COMMAND_MIN =
    UserHarborNpcService_NPC_COMMAND_NPC_COMMAND_MIN;
  static const NPC_COMMAND NPC_COMMAND_MAX =
    UserHarborNpcService_NPC_COMMAND_NPC_COMMAND_MAX;
  static const int NPC_COMMAND_ARRAYSIZE =
    UserHarborNpcService_NPC_COMMAND_NPC_COMMAND_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  NPC_COMMAND_descriptor() {
    return UserHarborNpcService_NPC_COMMAND_descriptor();
  }
  static inline const ::std::string& NPC_COMMAND_Name(NPC_COMMAND value) {
    return UserHarborNpcService_NPC_COMMAND_Name(value);
  }
  static inline bool NPC_COMMAND_Parse(const ::std::string& name,
      NPC_COMMAND* value) {
    return UserHarborNpcService_NPC_COMMAND_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .sg.UserHarborNpcService.HarborNpcRequest req = 1;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 1;
  private:
  const ::sg::UserHarborNpcService_HarborNpcRequest& _internal_req() const;
  public:
  const ::sg::UserHarborNpcService_HarborNpcRequest& req() const;
  ::sg::UserHarborNpcService_HarborNpcRequest* release_req();
  ::sg::UserHarborNpcService_HarborNpcRequest* mutable_req();
  void set_allocated_req(::sg::UserHarborNpcService_HarborNpcRequest* req);
  void unsafe_arena_set_allocated_req(
      ::sg::UserHarborNpcService_HarborNpcRequest* req);
  ::sg::UserHarborNpcService_HarborNpcRequest* unsafe_arena_release_req();

  // optional .sg.UserHarborNpcService.HarborNpcResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  private:
  const ::sg::UserHarborNpcService_HarborNpcResponse& _internal_resp() const;
  public:
  const ::sg::UserHarborNpcService_HarborNpcResponse& resp() const;
  ::sg::UserHarborNpcService_HarborNpcResponse* release_resp();
  ::sg::UserHarborNpcService_HarborNpcResponse* mutable_resp();
  void set_allocated_resp(::sg::UserHarborNpcService_HarborNpcResponse* resp);
  void unsafe_arena_set_allocated_resp(
      ::sg::UserHarborNpcService_HarborNpcResponse* resp);
  ::sg::UserHarborNpcService_HarborNpcResponse* unsafe_arena_release_resp();

  // @@protoc_insertion_point(class_scope:sg.UserHarborNpcService)
 private:
  void set_has_req();
  void clear_has_req();
  void set_has_resp();
  void clear_has_resp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::sg::UserHarborNpcService_HarborNpcRequest* req_;
  ::sg::UserHarborNpcService_HarborNpcResponse* resp_;
  friend struct ::protobuf_UserHarbour_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HarborStateNotify : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.HarborStateNotify) */ {
 public:
  HarborStateNotify();
  virtual ~HarborStateNotify();

  HarborStateNotify(const HarborStateNotify& from);

  inline HarborStateNotify& operator=(const HarborStateNotify& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HarborStateNotify(HarborStateNotify&& from) noexcept
    : HarborStateNotify() {
    *this = ::std::move(from);
  }

  inline HarborStateNotify& operator=(HarborStateNotify&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const HarborStateNotify& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HarborStateNotify* internal_default_instance() {
    return reinterpret_cast<const HarborStateNotify*>(
               &_HarborStateNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void UnsafeArenaSwap(HarborStateNotify* other);
  void Swap(HarborStateNotify* other);
  friend void swap(HarborStateNotify& a, HarborStateNotify& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HarborStateNotify* New() const final {
    return CreateMaybeMessage<HarborStateNotify>(NULL);
  }

  HarborStateNotify* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HarborStateNotify>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HarborStateNotify& from);
  void MergeFrom(const HarborStateNotify& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HarborStateNotify* other);
  protected:
  explicit HarborStateNotify(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .sg.HarborInfo harbor_info = 1;
  bool has_harbor_info() const;
  void clear_harbor_info();
  static const int kHarborInfoFieldNumber = 1;
  private:
  const ::sg::HarborInfo& _internal_harbor_info() const;
  public:
  const ::sg::HarborInfo& harbor_info() const;
  ::sg::HarborInfo* release_harbor_info();
  ::sg::HarborInfo* mutable_harbor_info();
  void set_allocated_harbor_info(::sg::HarborInfo* harbor_info);
  void unsafe_arena_set_allocated_harbor_info(
      ::sg::HarborInfo* harbor_info);
  ::sg::HarborInfo* unsafe_arena_release_harbor_info();

  // @@protoc_insertion_point(class_scope:sg.HarborStateNotify)
 private:
  void set_has_harbor_info();
  void clear_has_harbor_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::sg::HarborInfo* harbor_info_;
  friend struct ::protobuf_UserHarbour_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HarborNpcStateNotify : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.HarborNpcStateNotify) */ {
 public:
  HarborNpcStateNotify();
  virtual ~HarborNpcStateNotify();

  HarborNpcStateNotify(const HarborNpcStateNotify& from);

  inline HarborNpcStateNotify& operator=(const HarborNpcStateNotify& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HarborNpcStateNotify(HarborNpcStateNotify&& from) noexcept
    : HarborNpcStateNotify() {
    *this = ::std::move(from);
  }

  inline HarborNpcStateNotify& operator=(HarborNpcStateNotify&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const HarborNpcStateNotify& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HarborNpcStateNotify* internal_default_instance() {
    return reinterpret_cast<const HarborNpcStateNotify*>(
               &_HarborNpcStateNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void UnsafeArenaSwap(HarborNpcStateNotify* other);
  void Swap(HarborNpcStateNotify* other);
  friend void swap(HarborNpcStateNotify& a, HarborNpcStateNotify& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HarborNpcStateNotify* New() const final {
    return CreateMaybeMessage<HarborNpcStateNotify>(NULL);
  }

  HarborNpcStateNotify* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HarborNpcStateNotify>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HarborNpcStateNotify& from);
  void MergeFrom(const HarborNpcStateNotify& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HarborNpcStateNotify* other);
  protected:
  explicit HarborNpcStateNotify(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .sg.HarborNpcList npc_list = 1;
  bool has_npc_list() const;
  void clear_npc_list();
  static const int kNpcListFieldNumber = 1;
  private:
  const ::sg::HarborNpcList& _internal_npc_list() const;
  public:
  const ::sg::HarborNpcList& npc_list() const;
  ::sg::HarborNpcList* release_npc_list();
  ::sg::HarborNpcList* mutable_npc_list();
  void set_allocated_npc_list(::sg::HarborNpcList* npc_list);
  void unsafe_arena_set_allocated_npc_list(
      ::sg::HarborNpcList* npc_list);
  ::sg::HarborNpcList* unsafe_arena_release_npc_list();

  // required int32 harborid = 2;
  bool has_harborid() const;
  void clear_harborid();
  static const int kHarboridFieldNumber = 2;
  ::google::protobuf::int32 harborid() const;
  void set_harborid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.HarborNpcStateNotify)
 private:
  void set_has_npc_list();
  void clear_has_npc_list();
  void set_has_harborid();
  void clear_has_harborid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::sg::HarborNpcList* npc_list_;
  ::google::protobuf::int32 harborid_;
  friend struct ::protobuf_UserHarbour_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FoodStyle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.FoodStyle) */ {
 public:
  FoodStyle();
  virtual ~FoodStyle();

  FoodStyle(const FoodStyle& from);

  inline FoodStyle& operator=(const FoodStyle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FoodStyle(FoodStyle&& from) noexcept
    : FoodStyle() {
    *this = ::std::move(from);
  }

  inline FoodStyle& operator=(FoodStyle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const FoodStyle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FoodStyle* internal_default_instance() {
    return reinterpret_cast<const FoodStyle*>(
               &_FoodStyle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void UnsafeArenaSwap(FoodStyle* other);
  void Swap(FoodStyle* other);
  friend void swap(FoodStyle& a, FoodStyle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FoodStyle* New() const final {
    return CreateMaybeMessage<FoodStyle>(NULL);
  }

  FoodStyle* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FoodStyle>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FoodStyle& from);
  void MergeFrom(const FoodStyle& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FoodStyle* other);
  protected:
  explicit FoodStyle(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef FoodStyle_FOOD_ATTR_ID FOOD_ATTR_ID;
  static const FOOD_ATTR_ID COLOR =
    FoodStyle_FOOD_ATTR_ID_COLOR;
  static const FOOD_ATTR_ID SMELL =
    FoodStyle_FOOD_ATTR_ID_SMELL;
  static const FOOD_ATTR_ID TASTE =
    FoodStyle_FOOD_ATTR_ID_TASTE;
  static const FOOD_ATTR_ID BELLYFUL =
    FoodStyle_FOOD_ATTR_ID_BELLYFUL;
  static const FOOD_ATTR_ID DETOXIFCATION =
    FoodStyle_FOOD_ATTR_ID_DETOXIFCATION;
  static const FOOD_ATTR_ID SOBER =
    FoodStyle_FOOD_ATTR_ID_SOBER;
  static const FOOD_ATTR_ID EXORCISM =
    FoodStyle_FOOD_ATTR_ID_EXORCISM;
  static const FOOD_ATTR_ID POISON =
    FoodStyle_FOOD_ATTR_ID_POISON;
  static const FOOD_ATTR_ID ALCOHOL =
    FoodStyle_FOOD_ATTR_ID_ALCOHOL;
  static const FOOD_ATTR_ID EVIL =
    FoodStyle_FOOD_ATTR_ID_EVIL;
  static const FOOD_ATTR_ID SOUR =
    FoodStyle_FOOD_ATTR_ID_SOUR;
  static const FOOD_ATTR_ID SWEET =
    FoodStyle_FOOD_ATTR_ID_SWEET;
  static const FOOD_ATTR_ID BITTER =
    FoodStyle_FOOD_ATTR_ID_BITTER;
  static const FOOD_ATTR_ID HOT =
    FoodStyle_FOOD_ATTR_ID_HOT;
  static const FOOD_ATTR_ID SALTY =
    FoodStyle_FOOD_ATTR_ID_SALTY;
  static inline bool FOOD_ATTR_ID_IsValid(int value) {
    return FoodStyle_FOOD_ATTR_ID_IsValid(value);
  }
  static const FOOD_ATTR_ID FOOD_ATTR_ID_MIN =
    FoodStyle_FOOD_ATTR_ID_FOOD_ATTR_ID_MIN;
  static const FOOD_ATTR_ID FOOD_ATTR_ID_MAX =
    FoodStyle_FOOD_ATTR_ID_FOOD_ATTR_ID_MAX;
  static const int FOOD_ATTR_ID_ARRAYSIZE =
    FoodStyle_FOOD_ATTR_ID_FOOD_ATTR_ID_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FOOD_ATTR_ID_descriptor() {
    return FoodStyle_FOOD_ATTR_ID_descriptor();
  }
  static inline const ::std::string& FOOD_ATTR_ID_Name(FOOD_ATTR_ID value) {
    return FoodStyle_FOOD_ATTR_ID_Name(value);
  }
  static inline bool FOOD_ATTR_ID_Parse(const ::std::string& name,
      FOOD_ATTR_ID* value) {
    return FoodStyle_FOOD_ATTR_ID_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int32 minval = 2;
  bool has_minval() const;
  void clear_minval();
  static const int kMinvalFieldNumber = 2;
  ::google::protobuf::int32 minval() const;
  void set_minval(::google::protobuf::int32 value);

  // required int32 maxval = 3;
  bool has_maxval() const;
  void clear_maxval();
  static const int kMaxvalFieldNumber = 3;
  ::google::protobuf::int32 maxval() const;
  void set_maxval(::google::protobuf::int32 value);

  // required .sg.FoodStyle.FOOD_ATTR_ID attrid = 1;
  bool has_attrid() const;
  void clear_attrid();
  static const int kAttridFieldNumber = 1;
  ::sg::FoodStyle_FOOD_ATTR_ID attrid() const;
  void set_attrid(::sg::FoodStyle_FOOD_ATTR_ID value);

  // @@protoc_insertion_point(class_scope:sg.FoodStyle)
 private:
  void set_has_attrid();
  void clear_has_attrid();
  void set_has_minval();
  void clear_has_minval();
  void set_has_maxval();
  void clear_has_maxval();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 minval_;
  ::google::protobuf::int32 maxval_;
  int attrid_;
  friend struct ::protobuf_UserHarbour_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FoodStyleList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.FoodStyleList) */ {
 public:
  FoodStyleList();
  virtual ~FoodStyleList();

  FoodStyleList(const FoodStyleList& from);

  inline FoodStyleList& operator=(const FoodStyleList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FoodStyleList(FoodStyleList&& from) noexcept
    : FoodStyleList() {
    *this = ::std::move(from);
  }

  inline FoodStyleList& operator=(FoodStyleList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const FoodStyleList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FoodStyleList* internal_default_instance() {
    return reinterpret_cast<const FoodStyleList*>(
               &_FoodStyleList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void UnsafeArenaSwap(FoodStyleList* other);
  void Swap(FoodStyleList* other);
  friend void swap(FoodStyleList& a, FoodStyleList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FoodStyleList* New() const final {
    return CreateMaybeMessage<FoodStyleList>(NULL);
  }

  FoodStyleList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FoodStyleList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FoodStyleList& from);
  void MergeFrom(const FoodStyleList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FoodStyleList* other);
  protected:
  explicit FoodStyleList(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sg.FoodStyle list = 1;
  int list_size() const;
  void clear_list();
  static const int kListFieldNumber = 1;
  ::sg::FoodStyle* mutable_list(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::FoodStyle >*
      mutable_list();
  const ::sg::FoodStyle& list(int index) const;
  ::sg::FoodStyle* add_list();
  const ::google::protobuf::RepeatedPtrField< ::sg::FoodStyle >&
      list() const;

  // @@protoc_insertion_point(class_scope:sg.FoodStyleList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::FoodStyle > list_;
  friend struct ::protobuf_UserHarbour_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SeatFoodOrder : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.SeatFoodOrder) */ {
 public:
  SeatFoodOrder();
  virtual ~SeatFoodOrder();

  SeatFoodOrder(const SeatFoodOrder& from);

  inline SeatFoodOrder& operator=(const SeatFoodOrder& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SeatFoodOrder(SeatFoodOrder&& from) noexcept
    : SeatFoodOrder() {
    *this = ::std::move(from);
  }

  inline SeatFoodOrder& operator=(SeatFoodOrder&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const SeatFoodOrder& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SeatFoodOrder* internal_default_instance() {
    return reinterpret_cast<const SeatFoodOrder*>(
               &_SeatFoodOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void UnsafeArenaSwap(SeatFoodOrder* other);
  void Swap(SeatFoodOrder* other);
  friend void swap(SeatFoodOrder& a, SeatFoodOrder& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SeatFoodOrder* New() const final {
    return CreateMaybeMessage<SeatFoodOrder>(NULL);
  }

  SeatFoodOrder* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SeatFoodOrder>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SeatFoodOrder& from);
  void MergeFrom(const SeatFoodOrder& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SeatFoodOrder* other);
  protected:
  explicit SeatFoodOrder(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 seatid = 1;
  bool has_seatid() const;
  void clear_seatid();
  static const int kSeatidFieldNumber = 1;
  ::google::protobuf::int32 seatid() const;
  void set_seatid(::google::protobuf::int32 value);

  // required int32 posid = 2;
  bool has_posid() const;
  void clear_posid();
  static const int kPosidFieldNumber = 2;
  ::google::protobuf::int32 posid() const;
  void set_posid(::google::protobuf::int32 value);

  // required int32 orderid = 3;
  bool has_orderid() const;
  void clear_orderid();
  static const int kOrderidFieldNumber = 3;
  ::google::protobuf::int32 orderid() const;
  void set_orderid(::google::protobuf::int32 value);

  // required .sg.FOOD_ORDER_TYPE order_type = 4;
  bool has_order_type() const;
  void clear_order_type();
  static const int kOrderTypeFieldNumber = 4;
  ::sg::FOOD_ORDER_TYPE order_type() const;
  void set_order_type(::sg::FOOD_ORDER_TYPE value);

  // required int32 npcid = 6;
  bool has_npcid() const;
  void clear_npcid();
  static const int kNpcidFieldNumber = 6;
  ::google::protobuf::int32 npcid() const;
  void set_npcid(::google::protobuf::int32 value);

  // optional int32 foodfilterid = 11;
  bool has_foodfilterid() const;
  void clear_foodfilterid();
  static const int kFoodfilteridFieldNumber = 11;
  ::google::protobuf::int32 foodfilterid() const;
  void set_foodfilterid(::google::protobuf::int32 value);

  // optional int32 recipeid = 12;
  bool has_recipeid() const;
  void clear_recipeid();
  static const int kRecipeidFieldNumber = 12;
  ::google::protobuf::int32 recipeid() const;
  void set_recipeid(::google::protobuf::int32 value);

  // optional int32 itemid = 13;
  bool has_itemid() const;
  void clear_itemid();
  static const int kItemidFieldNumber = 13;
  ::google::protobuf::int32 itemid() const;
  void set_itemid(::google::protobuf::int32 value);

  // optional int32 tip_diamond = 25;
  bool has_tip_diamond() const;
  void clear_tip_diamond();
  static const int kTipDiamondFieldNumber = 25;
  ::google::protobuf::int32 tip_diamond() const;
  void set_tip_diamond(::google::protobuf::int32 value);

  // optional int32 star = 21;
  bool has_star() const;
  void clear_star();
  static const int kStarFieldNumber = 21;
  ::google::protobuf::int32 star() const;
  void set_star(::google::protobuf::int32 value);

  // optional int32 gather_gold = 22;
  bool has_gather_gold() const;
  void clear_gather_gold();
  static const int kGatherGoldFieldNumber = 22;
  ::google::protobuf::int32 gather_gold() const;
  void set_gather_gold(::google::protobuf::int32 value);

  // optional int32 gather_satisfaction = 23;
  bool has_gather_satisfaction() const;
  void clear_gather_satisfaction();
  static const int kGatherSatisfactionFieldNumber = 23;
  ::google::protobuf::int32 gather_satisfaction() const;
  void set_gather_satisfaction(::google::protobuf::int32 value);

  // optional int32 tip_gold = 24;
  bool has_tip_gold() const;
  void clear_tip_gold();
  static const int kTipGoldFieldNumber = 24;
  ::google::protobuf::int32 tip_gold() const;
  void set_tip_gold(::google::protobuf::int32 value);

  // required .sg.FOOD_ORDER_STATE order_state = 5;
  bool has_order_state() const;
  void clear_order_state();
  static const int kOrderStateFieldNumber = 5;
  ::sg::FOOD_ORDER_STATE order_state() const;
  void set_order_state(::sg::FOOD_ORDER_STATE value);

  // @@protoc_insertion_point(class_scope:sg.SeatFoodOrder)
 private:
  void set_has_seatid();
  void clear_has_seatid();
  void set_has_posid();
  void clear_has_posid();
  void set_has_orderid();
  void clear_has_orderid();
  void set_has_order_type();
  void clear_has_order_type();
  void set_has_order_state();
  void clear_has_order_state();
  void set_has_npcid();
  void clear_has_npcid();
  void set_has_foodfilterid();
  void clear_has_foodfilterid();
  void set_has_recipeid();
  void clear_has_recipeid();
  void set_has_itemid();
  void clear_has_itemid();
  void set_has_star();
  void clear_has_star();
  void set_has_gather_gold();
  void clear_has_gather_gold();
  void set_has_gather_satisfaction();
  void clear_has_gather_satisfaction();
  void set_has_tip_gold();
  void clear_has_tip_gold();
  void set_has_tip_diamond();
  void clear_has_tip_diamond();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 seatid_;
  ::google::protobuf::int32 posid_;
  ::google::protobuf::int32 orderid_;
  int order_type_;
  ::google::protobuf::int32 npcid_;
  ::google::protobuf::int32 foodfilterid_;
  ::google::protobuf::int32 recipeid_;
  ::google::protobuf::int32 itemid_;
  ::google::protobuf::int32 tip_diamond_;
  ::google::protobuf::int32 star_;
  ::google::protobuf::int32 gather_gold_;
  ::google::protobuf::int32 gather_satisfaction_;
  ::google::protobuf::int32 tip_gold_;
  int order_state_;
  friend struct ::protobuf_UserHarbour_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SeatFoodOrderList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.SeatFoodOrderList) */ {
 public:
  SeatFoodOrderList();
  virtual ~SeatFoodOrderList();

  SeatFoodOrderList(const SeatFoodOrderList& from);

  inline SeatFoodOrderList& operator=(const SeatFoodOrderList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SeatFoodOrderList(SeatFoodOrderList&& from) noexcept
    : SeatFoodOrderList() {
    *this = ::std::move(from);
  }

  inline SeatFoodOrderList& operator=(SeatFoodOrderList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const SeatFoodOrderList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SeatFoodOrderList* internal_default_instance() {
    return reinterpret_cast<const SeatFoodOrderList*>(
               &_SeatFoodOrderList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void UnsafeArenaSwap(SeatFoodOrderList* other);
  void Swap(SeatFoodOrderList* other);
  friend void swap(SeatFoodOrderList& a, SeatFoodOrderList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SeatFoodOrderList* New() const final {
    return CreateMaybeMessage<SeatFoodOrderList>(NULL);
  }

  SeatFoodOrderList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SeatFoodOrderList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SeatFoodOrderList& from);
  void MergeFrom(const SeatFoodOrderList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SeatFoodOrderList* other);
  protected:
  explicit SeatFoodOrderList(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sg.SeatFoodOrder list = 1;
  int list_size() const;
  void clear_list();
  static const int kListFieldNumber = 1;
  ::sg::SeatFoodOrder* mutable_list(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::SeatFoodOrder >*
      mutable_list();
  const ::sg::SeatFoodOrder& list(int index) const;
  ::sg::SeatFoodOrder* add_list();
  const ::google::protobuf::RepeatedPtrField< ::sg::SeatFoodOrder >&
      list() const;

  // @@protoc_insertion_point(class_scope:sg.SeatFoodOrderList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::SeatFoodOrder > list_;
  friend struct ::protobuf_UserHarbour_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SeatMenuFood : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.SeatMenuFood) */ {
 public:
  SeatMenuFood();
  virtual ~SeatMenuFood();

  SeatMenuFood(const SeatMenuFood& from);

  inline SeatMenuFood& operator=(const SeatMenuFood& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SeatMenuFood(SeatMenuFood&& from) noexcept
    : SeatMenuFood() {
    *this = ::std::move(from);
  }

  inline SeatMenuFood& operator=(SeatMenuFood&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const SeatMenuFood& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SeatMenuFood* internal_default_instance() {
    return reinterpret_cast<const SeatMenuFood*>(
               &_SeatMenuFood_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void UnsafeArenaSwap(SeatMenuFood* other);
  void Swap(SeatMenuFood* other);
  friend void swap(SeatMenuFood& a, SeatMenuFood& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SeatMenuFood* New() const final {
    return CreateMaybeMessage<SeatMenuFood>(NULL);
  }

  SeatMenuFood* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SeatMenuFood>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SeatMenuFood& from);
  void MergeFrom(const SeatMenuFood& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SeatMenuFood* other);
  protected:
  explicit SeatMenuFood(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 posid = 1;
  bool has_posid() const;
  void clear_posid();
  static const int kPosidFieldNumber = 1;
  ::google::protobuf::int32 posid() const;
  void set_posid(::google::protobuf::int32 value);

  // optional int32 itemid = 2;
  bool has_itemid() const;
  void clear_itemid();
  static const int kItemidFieldNumber = 2;
  ::google::protobuf::int32 itemid() const;
  void set_itemid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.SeatMenuFood)
 private:
  void set_has_posid();
  void clear_has_posid();
  void set_has_itemid();
  void clear_has_itemid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 posid_;
  ::google::protobuf::int32 itemid_;
  friend struct ::protobuf_UserHarbour_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SeatMenu : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.SeatMenu) */ {
 public:
  SeatMenu();
  virtual ~SeatMenu();

  SeatMenu(const SeatMenu& from);

  inline SeatMenu& operator=(const SeatMenu& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SeatMenu(SeatMenu&& from) noexcept
    : SeatMenu() {
    *this = ::std::move(from);
  }

  inline SeatMenu& operator=(SeatMenu&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const SeatMenu& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SeatMenu* internal_default_instance() {
    return reinterpret_cast<const SeatMenu*>(
               &_SeatMenu_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void UnsafeArenaSwap(SeatMenu* other);
  void Swap(SeatMenu* other);
  friend void swap(SeatMenu& a, SeatMenu& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SeatMenu* New() const final {
    return CreateMaybeMessage<SeatMenu>(NULL);
  }

  SeatMenu* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SeatMenu>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SeatMenu& from);
  void MergeFrom(const SeatMenu& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SeatMenu* other);
  protected:
  explicit SeatMenu(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sg.SeatMenuFood menu_food_list = 2;
  int menu_food_list_size() const;
  void clear_menu_food_list();
  static const int kMenuFoodListFieldNumber = 2;
  ::sg::SeatMenuFood* mutable_menu_food_list(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::SeatMenuFood >*
      mutable_menu_food_list();
  const ::sg::SeatMenuFood& menu_food_list(int index) const;
  ::sg::SeatMenuFood* add_menu_food_list();
  const ::google::protobuf::RepeatedPtrField< ::sg::SeatMenuFood >&
      menu_food_list() const;

  // required int32 seatid = 1;
  bool has_seatid() const;
  void clear_seatid();
  static const int kSeatidFieldNumber = 1;
  ::google::protobuf::int32 seatid() const;
  void set_seatid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.SeatMenu)
 private:
  void set_has_seatid();
  void clear_has_seatid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::SeatMenuFood > menu_food_list_;
  ::google::protobuf::int32 seatid_;
  friend struct ::protobuf_UserHarbour_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserFoodOrderService_FoodOrderRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.UserFoodOrderService.FoodOrderRequest) */ {
 public:
  UserFoodOrderService_FoodOrderRequest();
  virtual ~UserFoodOrderService_FoodOrderRequest();

  UserFoodOrderService_FoodOrderRequest(const UserFoodOrderService_FoodOrderRequest& from);

  inline UserFoodOrderService_FoodOrderRequest& operator=(const UserFoodOrderService_FoodOrderRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserFoodOrderService_FoodOrderRequest(UserFoodOrderService_FoodOrderRequest&& from) noexcept
    : UserFoodOrderService_FoodOrderRequest() {
    *this = ::std::move(from);
  }

  inline UserFoodOrderService_FoodOrderRequest& operator=(UserFoodOrderService_FoodOrderRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserFoodOrderService_FoodOrderRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserFoodOrderService_FoodOrderRequest* internal_default_instance() {
    return reinterpret_cast<const UserFoodOrderService_FoodOrderRequest*>(
               &_UserFoodOrderService_FoodOrderRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void UnsafeArenaSwap(UserFoodOrderService_FoodOrderRequest* other);
  void Swap(UserFoodOrderService_FoodOrderRequest* other);
  friend void swap(UserFoodOrderService_FoodOrderRequest& a, UserFoodOrderService_FoodOrderRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserFoodOrderService_FoodOrderRequest* New() const final {
    return CreateMaybeMessage<UserFoodOrderService_FoodOrderRequest>(NULL);
  }

  UserFoodOrderService_FoodOrderRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserFoodOrderService_FoodOrderRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserFoodOrderService_FoodOrderRequest& from);
  void MergeFrom(const UserFoodOrderService_FoodOrderRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserFoodOrderService_FoodOrderRequest* other);
  protected:
  explicit UserFoodOrderService_FoodOrderRequest(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .sg.SeatMenu menu = 2;
  bool has_menu() const;
  void clear_menu();
  static const int kMenuFieldNumber = 2;
  private:
  const ::sg::SeatMenu& _internal_menu() const;
  public:
  const ::sg::SeatMenu& menu() const;
  ::sg::SeatMenu* release_menu();
  ::sg::SeatMenu* mutable_menu();
  void set_allocated_menu(::sg::SeatMenu* menu);
  void unsafe_arena_set_allocated_menu(
      ::sg::SeatMenu* menu);
  ::sg::SeatMenu* unsafe_arena_release_menu();

  // required .sg.UserFoodOrderService.ORDER_COMMAND cmd = 1;
  bool has_cmd() const;
  void clear_cmd();
  static const int kCmdFieldNumber = 1;
  ::sg::UserFoodOrderService_ORDER_COMMAND cmd() const;
  void set_cmd(::sg::UserFoodOrderService_ORDER_COMMAND value);

  // @@protoc_insertion_point(class_scope:sg.UserFoodOrderService.FoodOrderRequest)
 private:
  void set_has_cmd();
  void clear_has_cmd();
  void set_has_menu();
  void clear_has_menu();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::sg::SeatMenu* menu_;
  int cmd_;
  friend struct ::protobuf_UserHarbour_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserFoodOrderService_FoodOrderResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.UserFoodOrderService.FoodOrderResponse) */ {
 public:
  UserFoodOrderService_FoodOrderResponse();
  virtual ~UserFoodOrderService_FoodOrderResponse();

  UserFoodOrderService_FoodOrderResponse(const UserFoodOrderService_FoodOrderResponse& from);

  inline UserFoodOrderService_FoodOrderResponse& operator=(const UserFoodOrderService_FoodOrderResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserFoodOrderService_FoodOrderResponse(UserFoodOrderService_FoodOrderResponse&& from) noexcept
    : UserFoodOrderService_FoodOrderResponse() {
    *this = ::std::move(from);
  }

  inline UserFoodOrderService_FoodOrderResponse& operator=(UserFoodOrderService_FoodOrderResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserFoodOrderService_FoodOrderResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserFoodOrderService_FoodOrderResponse* internal_default_instance() {
    return reinterpret_cast<const UserFoodOrderService_FoodOrderResponse*>(
               &_UserFoodOrderService_FoodOrderResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void UnsafeArenaSwap(UserFoodOrderService_FoodOrderResponse* other);
  void Swap(UserFoodOrderService_FoodOrderResponse* other);
  friend void swap(UserFoodOrderService_FoodOrderResponse& a, UserFoodOrderService_FoodOrderResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserFoodOrderService_FoodOrderResponse* New() const final {
    return CreateMaybeMessage<UserFoodOrderService_FoodOrderResponse>(NULL);
  }

  UserFoodOrderService_FoodOrderResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserFoodOrderService_FoodOrderResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserFoodOrderService_FoodOrderResponse& from);
  void MergeFrom(const UserFoodOrderService_FoodOrderResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserFoodOrderService_FoodOrderResponse* other);
  protected:
  explicit UserFoodOrderService_FoodOrderResponse(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .sg.SeatFoodOrderList order_list = 2;
  bool has_order_list() const;
  void clear_order_list();
  static const int kOrderListFieldNumber = 2;
  private:
  const ::sg::SeatFoodOrderList& _internal_order_list() const;
  public:
  const ::sg::SeatFoodOrderList& order_list() const;
  ::sg::SeatFoodOrderList* release_order_list();
  ::sg::SeatFoodOrderList* mutable_order_list();
  void set_allocated_order_list(::sg::SeatFoodOrderList* order_list);
  void unsafe_arena_set_allocated_order_list(
      ::sg::SeatFoodOrderList* order_list);
  ::sg::SeatFoodOrderList* unsafe_arena_release_order_list();

  // optional .sg.Reward out_drop = 3;
  bool has_out_drop() const;
  void clear_out_drop();
  static const int kOutDropFieldNumber = 3;
  private:
  const ::sg::Reward& _internal_out_drop() const;
  public:
  const ::sg::Reward& out_drop() const;
  ::sg::Reward* release_out_drop();
  ::sg::Reward* mutable_out_drop();
  void set_allocated_out_drop(::sg::Reward* out_drop);
  void unsafe_arena_set_allocated_out_drop(
      ::sg::Reward* out_drop);
  ::sg::Reward* unsafe_arena_release_out_drop();

  // required int32 result = 1;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::google::protobuf::int32 result() const;
  void set_result(::google::protobuf::int32 value);

  // optional int32 star = 4;
  bool has_star() const;
  void clear_star();
  static const int kStarFieldNumber = 4;
  ::google::protobuf::int32 star() const;
  void set_star(::google::protobuf::int32 value);

  // optional int32 diy_recipeid = 11;
  bool has_diy_recipeid() const;
  void clear_diy_recipeid();
  static const int kDiyRecipeidFieldNumber = 11;
  ::google::protobuf::int32 diy_recipeid() const;
  void set_diy_recipeid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.UserFoodOrderService.FoodOrderResponse)
 private:
  void set_has_result();
  void clear_has_result();
  void set_has_order_list();
  void clear_has_order_list();
  void set_has_out_drop();
  void clear_has_out_drop();
  void set_has_star();
  void clear_has_star();
  void set_has_diy_recipeid();
  void clear_has_diy_recipeid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::sg::SeatFoodOrderList* order_list_;
  ::sg::Reward* out_drop_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 star_;
  ::google::protobuf::int32 diy_recipeid_;
  friend struct ::protobuf_UserHarbour_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserFoodOrderService : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.UserFoodOrderService) */ {
 public:
  UserFoodOrderService();
  virtual ~UserFoodOrderService();

  UserFoodOrderService(const UserFoodOrderService& from);

  inline UserFoodOrderService& operator=(const UserFoodOrderService& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserFoodOrderService(UserFoodOrderService&& from) noexcept
    : UserFoodOrderService() {
    *this = ::std::move(from);
  }

  inline UserFoodOrderService& operator=(UserFoodOrderService&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserFoodOrderService& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserFoodOrderService* internal_default_instance() {
    return reinterpret_cast<const UserFoodOrderService*>(
               &_UserFoodOrderService_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void UnsafeArenaSwap(UserFoodOrderService* other);
  void Swap(UserFoodOrderService* other);
  friend void swap(UserFoodOrderService& a, UserFoodOrderService& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserFoodOrderService* New() const final {
    return CreateMaybeMessage<UserFoodOrderService>(NULL);
  }

  UserFoodOrderService* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserFoodOrderService>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserFoodOrderService& from);
  void MergeFrom(const UserFoodOrderService& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserFoodOrderService* other);
  protected:
  explicit UserFoodOrderService(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UserFoodOrderService_FoodOrderRequest FoodOrderRequest;
  typedef UserFoodOrderService_FoodOrderResponse FoodOrderResponse;

  typedef UserFoodOrderService_ORDER_COMMAND ORDER_COMMAND;
  static const ORDER_COMMAND QUERY =
    UserFoodOrderService_ORDER_COMMAND_QUERY;
  static const ORDER_COMMAND ACCEPT =
    UserFoodOrderService_ORDER_COMMAND_ACCEPT;
  static const ORDER_COMMAND REJECT =
    UserFoodOrderService_ORDER_COMMAND_REJECT;
  static const ORDER_COMMAND ACCEPT_REWARD =
    UserFoodOrderService_ORDER_COMMAND_ACCEPT_REWARD;
  static inline bool ORDER_COMMAND_IsValid(int value) {
    return UserFoodOrderService_ORDER_COMMAND_IsValid(value);
  }
  static const ORDER_COMMAND ORDER_COMMAND_MIN =
    UserFoodOrderService_ORDER_COMMAND_ORDER_COMMAND_MIN;
  static const ORDER_COMMAND ORDER_COMMAND_MAX =
    UserFoodOrderService_ORDER_COMMAND_ORDER_COMMAND_MAX;
  static const int ORDER_COMMAND_ARRAYSIZE =
    UserFoodOrderService_ORDER_COMMAND_ORDER_COMMAND_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ORDER_COMMAND_descriptor() {
    return UserFoodOrderService_ORDER_COMMAND_descriptor();
  }
  static inline const ::std::string& ORDER_COMMAND_Name(ORDER_COMMAND value) {
    return UserFoodOrderService_ORDER_COMMAND_Name(value);
  }
  static inline bool ORDER_COMMAND_Parse(const ::std::string& name,
      ORDER_COMMAND* value) {
    return UserFoodOrderService_ORDER_COMMAND_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .sg.UserFoodOrderService.FoodOrderRequest req = 1;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 1;
  private:
  const ::sg::UserFoodOrderService_FoodOrderRequest& _internal_req() const;
  public:
  const ::sg::UserFoodOrderService_FoodOrderRequest& req() const;
  ::sg::UserFoodOrderService_FoodOrderRequest* release_req();
  ::sg::UserFoodOrderService_FoodOrderRequest* mutable_req();
  void set_allocated_req(::sg::UserFoodOrderService_FoodOrderRequest* req);
  void unsafe_arena_set_allocated_req(
      ::sg::UserFoodOrderService_FoodOrderRequest* req);
  ::sg::UserFoodOrderService_FoodOrderRequest* unsafe_arena_release_req();

  // optional .sg.UserFoodOrderService.FoodOrderResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  private:
  const ::sg::UserFoodOrderService_FoodOrderResponse& _internal_resp() const;
  public:
  const ::sg::UserFoodOrderService_FoodOrderResponse& resp() const;
  ::sg::UserFoodOrderService_FoodOrderResponse* release_resp();
  ::sg::UserFoodOrderService_FoodOrderResponse* mutable_resp();
  void set_allocated_resp(::sg::UserFoodOrderService_FoodOrderResponse* resp);
  void unsafe_arena_set_allocated_resp(
      ::sg::UserFoodOrderService_FoodOrderResponse* resp);
  ::sg::UserFoodOrderService_FoodOrderResponse* unsafe_arena_release_resp();

  // @@protoc_insertion_point(class_scope:sg.UserFoodOrderService)
 private:
  void set_has_req();
  void clear_has_req();
  void set_has_resp();
  void clear_has_resp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::sg::UserFoodOrderService_FoodOrderRequest* req_;
  ::sg::UserFoodOrderService_FoodOrderResponse* resp_;
  friend struct ::protobuf_UserHarbour_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SeatFoodOrderStateNotify : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.SeatFoodOrderStateNotify) */ {
 public:
  SeatFoodOrderStateNotify();
  virtual ~SeatFoodOrderStateNotify();

  SeatFoodOrderStateNotify(const SeatFoodOrderStateNotify& from);

  inline SeatFoodOrderStateNotify& operator=(const SeatFoodOrderStateNotify& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SeatFoodOrderStateNotify(SeatFoodOrderStateNotify&& from) noexcept
    : SeatFoodOrderStateNotify() {
    *this = ::std::move(from);
  }

  inline SeatFoodOrderStateNotify& operator=(SeatFoodOrderStateNotify&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const SeatFoodOrderStateNotify& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SeatFoodOrderStateNotify* internal_default_instance() {
    return reinterpret_cast<const SeatFoodOrderStateNotify*>(
               &_SeatFoodOrderStateNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void UnsafeArenaSwap(SeatFoodOrderStateNotify* other);
  void Swap(SeatFoodOrderStateNotify* other);
  friend void swap(SeatFoodOrderStateNotify& a, SeatFoodOrderStateNotify& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SeatFoodOrderStateNotify* New() const final {
    return CreateMaybeMessage<SeatFoodOrderStateNotify>(NULL);
  }

  SeatFoodOrderStateNotify* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SeatFoodOrderStateNotify>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SeatFoodOrderStateNotify& from);
  void MergeFrom(const SeatFoodOrderStateNotify& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SeatFoodOrderStateNotify* other);
  protected:
  explicit SeatFoodOrderStateNotify(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .sg.SeatFoodOrderList order_list = 1;
  bool has_order_list() const;
  void clear_order_list();
  static const int kOrderListFieldNumber = 1;
  private:
  const ::sg::SeatFoodOrderList& _internal_order_list() const;
  public:
  const ::sg::SeatFoodOrderList& order_list() const;
  ::sg::SeatFoodOrderList* release_order_list();
  ::sg::SeatFoodOrderList* mutable_order_list();
  void set_allocated_order_list(::sg::SeatFoodOrderList* order_list);
  void unsafe_arena_set_allocated_order_list(
      ::sg::SeatFoodOrderList* order_list);
  ::sg::SeatFoodOrderList* unsafe_arena_release_order_list();

  // @@protoc_insertion_point(class_scope:sg.SeatFoodOrderStateNotify)
 private:
  void set_has_order_list();
  void clear_has_order_list();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::sg::SeatFoodOrderList* order_list_;
  friend struct ::protobuf_UserHarbour_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// HarborInfo

// optional .sg.HARBOR_STATE state = 1;
inline bool HarborInfo::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HarborInfo::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HarborInfo::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HarborInfo::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::sg::HARBOR_STATE HarborInfo::state() const {
  // @@protoc_insertion_point(field_get:sg.HarborInfo.state)
  return static_cast< ::sg::HARBOR_STATE >(state_);
}
inline void HarborInfo::set_state(::sg::HARBOR_STATE value) {
  assert(::sg::HARBOR_STATE_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:sg.HarborInfo.state)
}

// optional int32 boom = 2;
inline bool HarborInfo::has_boom() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HarborInfo::set_has_boom() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HarborInfo::clear_has_boom() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HarborInfo::clear_boom() {
  boom_ = 0;
  clear_has_boom();
}
inline ::google::protobuf::int32 HarborInfo::boom() const {
  // @@protoc_insertion_point(field_get:sg.HarborInfo.boom)
  return boom_;
}
inline void HarborInfo::set_boom(::google::protobuf::int32 value) {
  set_has_boom();
  boom_ = value;
  // @@protoc_insertion_point(field_set:sg.HarborInfo.boom)
}

// optional sfixed64 growtime = 3;
inline bool HarborInfo::has_growtime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HarborInfo::set_has_growtime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HarborInfo::clear_has_growtime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HarborInfo::clear_growtime() {
  growtime_ = GOOGLE_LONGLONG(0);
  clear_has_growtime();
}
inline ::google::protobuf::int64 HarborInfo::growtime() const {
  // @@protoc_insertion_point(field_get:sg.HarborInfo.growtime)
  return growtime_;
}
inline void HarborInfo::set_growtime(::google::protobuf::int64 value) {
  set_has_growtime();
  growtime_ = value;
  // @@protoc_insertion_point(field_set:sg.HarborInfo.growtime)
}

// -------------------------------------------------------------------

// HarborNpc_resident_task

// required int32 id = 1;
inline bool HarborNpc_resident_task::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HarborNpc_resident_task::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HarborNpc_resident_task::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HarborNpc_resident_task::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 HarborNpc_resident_task::id() const {
  // @@protoc_insertion_point(field_get:sg.HarborNpc.resident_task.id)
  return id_;
}
inline void HarborNpc_resident_task::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:sg.HarborNpc.resident_task.id)
}

// optional int32 need_idx = 2;
inline bool HarborNpc_resident_task::has_need_idx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HarborNpc_resident_task::set_has_need_idx() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HarborNpc_resident_task::clear_has_need_idx() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HarborNpc_resident_task::clear_need_idx() {
  need_idx_ = 0;
  clear_has_need_idx();
}
inline ::google::protobuf::int32 HarborNpc_resident_task::need_idx() const {
  // @@protoc_insertion_point(field_get:sg.HarborNpc.resident_task.need_idx)
  return need_idx_;
}
inline void HarborNpc_resident_task::set_need_idx(::google::protobuf::int32 value) {
  set_has_need_idx();
  need_idx_ = value;
  // @@protoc_insertion_point(field_set:sg.HarborNpc.resident_task.need_idx)
}

// optional int32 reward_idx = 3;
inline bool HarborNpc_resident_task::has_reward_idx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HarborNpc_resident_task::set_has_reward_idx() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HarborNpc_resident_task::clear_has_reward_idx() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HarborNpc_resident_task::clear_reward_idx() {
  reward_idx_ = 0;
  clear_has_reward_idx();
}
inline ::google::protobuf::int32 HarborNpc_resident_task::reward_idx() const {
  // @@protoc_insertion_point(field_get:sg.HarborNpc.resident_task.reward_idx)
  return reward_idx_;
}
inline void HarborNpc_resident_task::set_reward_idx(::google::protobuf::int32 value) {
  set_has_reward_idx();
  reward_idx_ = value;
  // @@protoc_insertion_point(field_set:sg.HarborNpc.resident_task.reward_idx)
}

// optional bool reward_accept = 4;
inline bool HarborNpc_resident_task::has_reward_accept() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HarborNpc_resident_task::set_has_reward_accept() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HarborNpc_resident_task::clear_has_reward_accept() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HarborNpc_resident_task::clear_reward_accept() {
  reward_accept_ = false;
  clear_has_reward_accept();
}
inline bool HarborNpc_resident_task::reward_accept() const {
  // @@protoc_insertion_point(field_get:sg.HarborNpc.resident_task.reward_accept)
  return reward_accept_;
}
inline void HarborNpc_resident_task::set_reward_accept(bool value) {
  set_has_reward_accept();
  reward_accept_ = value;
  // @@protoc_insertion_point(field_set:sg.HarborNpc.resident_task.reward_accept)
}

// -------------------------------------------------------------------

// HarborNpc

// required int32 npcid = 1;
inline bool HarborNpc::has_npcid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HarborNpc::set_has_npcid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HarborNpc::clear_has_npcid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HarborNpc::clear_npcid() {
  npcid_ = 0;
  clear_has_npcid();
}
inline ::google::protobuf::int32 HarborNpc::npcid() const {
  // @@protoc_insertion_point(field_get:sg.HarborNpc.npcid)
  return npcid_;
}
inline void HarborNpc::set_npcid(::google::protobuf::int32 value) {
  set_has_npcid();
  npcid_ = value;
  // @@protoc_insertion_point(field_set:sg.HarborNpc.npcid)
}

// optional .sg.HARBOR_NPC_TYPE npc_type = 2;
inline bool HarborNpc::has_npc_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HarborNpc::set_has_npc_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HarborNpc::clear_has_npc_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HarborNpc::clear_npc_type() {
  npc_type_ = 0;
  clear_has_npc_type();
}
inline ::sg::HARBOR_NPC_TYPE HarborNpc::npc_type() const {
  // @@protoc_insertion_point(field_get:sg.HarborNpc.npc_type)
  return static_cast< ::sg::HARBOR_NPC_TYPE >(npc_type_);
}
inline void HarborNpc::set_npc_type(::sg::HARBOR_NPC_TYPE value) {
  assert(::sg::HARBOR_NPC_TYPE_IsValid(value));
  set_has_npc_type();
  npc_type_ = value;
  // @@protoc_insertion_point(field_set:sg.HarborNpc.npc_type)
}

// optional uint64 cfgid = 3;
inline bool HarborNpc::has_cfgid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HarborNpc::set_has_cfgid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HarborNpc::clear_has_cfgid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HarborNpc::clear_cfgid() {
  cfgid_ = GOOGLE_ULONGLONG(0);
  clear_has_cfgid();
}
inline ::google::protobuf::uint64 HarborNpc::cfgid() const {
  // @@protoc_insertion_point(field_get:sg.HarborNpc.cfgid)
  return cfgid_;
}
inline void HarborNpc::set_cfgid(::google::protobuf::uint64 value) {
  set_has_cfgid();
  cfgid_ = value;
  // @@protoc_insertion_point(field_set:sg.HarborNpc.cfgid)
}

// optional .sg.HarborNpc.NPC_STATE state = 4;
inline bool HarborNpc::has_state() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void HarborNpc::set_has_state() {
  _has_bits_[0] |= 0x00020000u;
}
inline void HarborNpc::clear_has_state() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void HarborNpc::clear_state() {
  state_ = -1;
  clear_has_state();
}
inline ::sg::HarborNpc_NPC_STATE HarborNpc::state() const {
  // @@protoc_insertion_point(field_get:sg.HarborNpc.state)
  return static_cast< ::sg::HarborNpc_NPC_STATE >(state_);
}
inline void HarborNpc::set_state(::sg::HarborNpc_NPC_STATE value) {
  assert(::sg::HarborNpc_NPC_STATE_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:sg.HarborNpc.state)
}

// optional int32 seconds = 5;
inline bool HarborNpc::has_seconds() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void HarborNpc::set_has_seconds() {
  _has_bits_[0] |= 0x00000040u;
}
inline void HarborNpc::clear_has_seconds() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void HarborNpc::clear_seconds() {
  seconds_ = 0;
  clear_has_seconds();
}
inline ::google::protobuf::int32 HarborNpc::seconds() const {
  // @@protoc_insertion_point(field_get:sg.HarborNpc.seconds)
  return seconds_;
}
inline void HarborNpc::set_seconds(::google::protobuf::int32 value) {
  set_has_seconds();
  seconds_ = value;
  // @@protoc_insertion_point(field_set:sg.HarborNpc.seconds)
}

// optional int32 wealth_grade = 11;
inline bool HarborNpc::has_wealth_grade() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void HarborNpc::set_has_wealth_grade() {
  _has_bits_[0] |= 0x00000080u;
}
inline void HarborNpc::clear_has_wealth_grade() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void HarborNpc::clear_wealth_grade() {
  wealth_grade_ = 0;
  clear_has_wealth_grade();
}
inline ::google::protobuf::int32 HarborNpc::wealth_grade() const {
  // @@protoc_insertion_point(field_get:sg.HarborNpc.wealth_grade)
  return wealth_grade_;
}
inline void HarborNpc::set_wealth_grade(::google::protobuf::int32 value) {
  set_has_wealth_grade();
  wealth_grade_ = value;
  // @@protoc_insertion_point(field_set:sg.HarborNpc.wealth_grade)
}

// optional int32 gold = 12;
inline bool HarborNpc::has_gold() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void HarborNpc::set_has_gold() {
  _has_bits_[0] |= 0x00000100u;
}
inline void HarborNpc::clear_has_gold() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void HarborNpc::clear_gold() {
  gold_ = 0;
  clear_has_gold();
}
inline ::google::protobuf::int32 HarborNpc::gold() const {
  // @@protoc_insertion_point(field_get:sg.HarborNpc.gold)
  return gold_;
}
inline void HarborNpc::set_gold(::google::protobuf::int32 value) {
  set_has_gold();
  gold_ = value;
  // @@protoc_insertion_point(field_set:sg.HarborNpc.gold)
}

// optional int32 satisfaction = 13;
inline bool HarborNpc::has_satisfaction() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void HarborNpc::set_has_satisfaction() {
  _has_bits_[0] |= 0x00000200u;
}
inline void HarborNpc::clear_has_satisfaction() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void HarborNpc::clear_satisfaction() {
  satisfaction_ = 0;
  clear_has_satisfaction();
}
inline ::google::protobuf::int32 HarborNpc::satisfaction() const {
  // @@protoc_insertion_point(field_get:sg.HarborNpc.satisfaction)
  return satisfaction_;
}
inline void HarborNpc::set_satisfaction(::google::protobuf::int32 value) {
  set_has_satisfaction();
  satisfaction_ = value;
  // @@protoc_insertion_point(field_set:sg.HarborNpc.satisfaction)
}

// optional int32 seatid = 14;
inline bool HarborNpc::has_seatid() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void HarborNpc::set_has_seatid() {
  _has_bits_[0] |= 0x00000400u;
}
inline void HarborNpc::clear_has_seatid() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void HarborNpc::clear_seatid() {
  seatid_ = 0;
  clear_has_seatid();
}
inline ::google::protobuf::int32 HarborNpc::seatid() const {
  // @@protoc_insertion_point(field_get:sg.HarborNpc.seatid)
  return seatid_;
}
inline void HarborNpc::set_seatid(::google::protobuf::int32 value) {
  set_has_seatid();
  seatid_ = value;
  // @@protoc_insertion_point(field_set:sg.HarborNpc.seatid)
}

// optional int32 occupation_val = 21;
inline bool HarborNpc::has_occupation_val() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void HarborNpc::set_has_occupation_val() {
  _has_bits_[0] |= 0x00000800u;
}
inline void HarborNpc::clear_has_occupation_val() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void HarborNpc::clear_occupation_val() {
  occupation_val_ = 0;
  clear_has_occupation_val();
}
inline ::google::protobuf::int32 HarborNpc::occupation_val() const {
  // @@protoc_insertion_point(field_get:sg.HarborNpc.occupation_val)
  return occupation_val_;
}
inline void HarborNpc::set_occupation_val(::google::protobuf::int32 value) {
  set_has_occupation_val();
  occupation_val_ = value;
  // @@protoc_insertion_point(field_set:sg.HarborNpc.occupation_val)
}

// optional sfixed64 occupation_event_starttime = 22;
inline bool HarborNpc::has_occupation_event_starttime() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void HarborNpc::set_has_occupation_event_starttime() {
  _has_bits_[0] |= 0x00002000u;
}
inline void HarborNpc::clear_has_occupation_event_starttime() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void HarborNpc::clear_occupation_event_starttime() {
  occupation_event_starttime_ = GOOGLE_LONGLONG(0);
  clear_has_occupation_event_starttime();
}
inline ::google::protobuf::int64 HarborNpc::occupation_event_starttime() const {
  // @@protoc_insertion_point(field_get:sg.HarborNpc.occupation_event_starttime)
  return occupation_event_starttime_;
}
inline void HarborNpc::set_occupation_event_starttime(::google::protobuf::int64 value) {
  set_has_occupation_event_starttime();
  occupation_event_starttime_ = value;
  // @@protoc_insertion_point(field_set:sg.HarborNpc.occupation_event_starttime)
}

// optional int32 question_status = 23;
inline bool HarborNpc::has_question_status() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void HarborNpc::set_has_question_status() {
  _has_bits_[0] |= 0x00004000u;
}
inline void HarborNpc::clear_has_question_status() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void HarborNpc::clear_question_status() {
  question_status_ = 0;
  clear_has_question_status();
}
inline ::google::protobuf::int32 HarborNpc::question_status() const {
  // @@protoc_insertion_point(field_get:sg.HarborNpc.question_status)
  return question_status_;
}
inline void HarborNpc::set_question_status(::google::protobuf::int32 value) {
  set_has_question_status();
  question_status_ = value;
  // @@protoc_insertion_point(field_set:sg.HarborNpc.question_status)
}

// optional int32 special_cond_bonus = 24;
inline bool HarborNpc::has_special_cond_bonus() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void HarborNpc::set_has_special_cond_bonus() {
  _has_bits_[0] |= 0x00008000u;
}
inline void HarborNpc::clear_has_special_cond_bonus() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void HarborNpc::clear_special_cond_bonus() {
  special_cond_bonus_ = 0;
  clear_has_special_cond_bonus();
}
inline ::google::protobuf::int32 HarborNpc::special_cond_bonus() const {
  // @@protoc_insertion_point(field_get:sg.HarborNpc.special_cond_bonus)
  return special_cond_bonus_;
}
inline void HarborNpc::set_special_cond_bonus(::google::protobuf::int32 value) {
  set_has_special_cond_bonus();
  special_cond_bonus_ = value;
  // @@protoc_insertion_point(field_set:sg.HarborNpc.special_cond_bonus)
}

// optional int32 satisfaction_accepted = 25;
inline bool HarborNpc::has_satisfaction_accepted() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void HarborNpc::set_has_satisfaction_accepted() {
  _has_bits_[0] |= 0x00001000u;
}
inline void HarborNpc::clear_has_satisfaction_accepted() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void HarborNpc::clear_satisfaction_accepted() {
  satisfaction_accepted_ = 0;
  clear_has_satisfaction_accepted();
}
inline ::google::protobuf::int32 HarborNpc::satisfaction_accepted() const {
  // @@protoc_insertion_point(field_get:sg.HarborNpc.satisfaction_accepted)
  return satisfaction_accepted_;
}
inline void HarborNpc::set_satisfaction_accepted(::google::protobuf::int32 value) {
  set_has_satisfaction_accepted();
  satisfaction_accepted_ = value;
  // @@protoc_insertion_point(field_set:sg.HarborNpc.satisfaction_accepted)
}

// optional .sg.HarborNpc.resident_task task_menu1 = 31;
inline bool HarborNpc::has_task_menu1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HarborNpc::set_has_task_menu1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HarborNpc::clear_has_task_menu1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HarborNpc::clear_task_menu1() {
  if (task_menu1_ != NULL) task_menu1_->Clear();
  clear_has_task_menu1();
}
inline const ::sg::HarborNpc_resident_task& HarborNpc::_internal_task_menu1() const {
  return *task_menu1_;
}
inline const ::sg::HarborNpc_resident_task& HarborNpc::task_menu1() const {
  const ::sg::HarborNpc_resident_task* p = task_menu1_;
  // @@protoc_insertion_point(field_get:sg.HarborNpc.task_menu1)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::HarborNpc_resident_task*>(
      &::sg::_HarborNpc_resident_task_default_instance_);
}
inline ::sg::HarborNpc_resident_task* HarborNpc::release_task_menu1() {
  // @@protoc_insertion_point(field_release:sg.HarborNpc.task_menu1)
  clear_has_task_menu1();
  ::sg::HarborNpc_resident_task* temp = task_menu1_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  task_menu1_ = NULL;
  return temp;
}
inline ::sg::HarborNpc_resident_task* HarborNpc::unsafe_arena_release_task_menu1() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.HarborNpc.task_menu1)
  clear_has_task_menu1();
  ::sg::HarborNpc_resident_task* temp = task_menu1_;
  task_menu1_ = NULL;
  return temp;
}
inline ::sg::HarborNpc_resident_task* HarborNpc::mutable_task_menu1() {
  set_has_task_menu1();
  if (task_menu1_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::HarborNpc_resident_task>(GetArenaNoVirtual());
    task_menu1_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.HarborNpc.task_menu1)
  return task_menu1_;
}
inline void HarborNpc::set_allocated_task_menu1(::sg::HarborNpc_resident_task* task_menu1) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete task_menu1_;
  }
  if (task_menu1) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(task_menu1);
    if (message_arena != submessage_arena) {
      task_menu1 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, task_menu1, submessage_arena);
    }
    set_has_task_menu1();
  } else {
    clear_has_task_menu1();
  }
  task_menu1_ = task_menu1;
  // @@protoc_insertion_point(field_set_allocated:sg.HarborNpc.task_menu1)
}

// optional .sg.HarborNpc.resident_task task_menu2 = 32;
inline bool HarborNpc::has_task_menu2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HarborNpc::set_has_task_menu2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HarborNpc::clear_has_task_menu2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HarborNpc::clear_task_menu2() {
  if (task_menu2_ != NULL) task_menu2_->Clear();
  clear_has_task_menu2();
}
inline const ::sg::HarborNpc_resident_task& HarborNpc::_internal_task_menu2() const {
  return *task_menu2_;
}
inline const ::sg::HarborNpc_resident_task& HarborNpc::task_menu2() const {
  const ::sg::HarborNpc_resident_task* p = task_menu2_;
  // @@protoc_insertion_point(field_get:sg.HarborNpc.task_menu2)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::HarborNpc_resident_task*>(
      &::sg::_HarborNpc_resident_task_default_instance_);
}
inline ::sg::HarborNpc_resident_task* HarborNpc::release_task_menu2() {
  // @@protoc_insertion_point(field_release:sg.HarborNpc.task_menu2)
  clear_has_task_menu2();
  ::sg::HarborNpc_resident_task* temp = task_menu2_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  task_menu2_ = NULL;
  return temp;
}
inline ::sg::HarborNpc_resident_task* HarborNpc::unsafe_arena_release_task_menu2() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.HarborNpc.task_menu2)
  clear_has_task_menu2();
  ::sg::HarborNpc_resident_task* temp = task_menu2_;
  task_menu2_ = NULL;
  return temp;
}
inline ::sg::HarborNpc_resident_task* HarborNpc::mutable_task_menu2() {
  set_has_task_menu2();
  if (task_menu2_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::HarborNpc_resident_task>(GetArenaNoVirtual());
    task_menu2_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.HarborNpc.task_menu2)
  return task_menu2_;
}
inline void HarborNpc::set_allocated_task_menu2(::sg::HarborNpc_resident_task* task_menu2) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete task_menu2_;
  }
  if (task_menu2) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(task_menu2);
    if (message_arena != submessage_arena) {
      task_menu2 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, task_menu2, submessage_arena);
    }
    set_has_task_menu2();
  } else {
    clear_has_task_menu2();
  }
  task_menu2_ = task_menu2;
  // @@protoc_insertion_point(field_set_allocated:sg.HarborNpc.task_menu2)
}

// optional .sg.HarborNpc.resident_task task_menu3 = 33;
inline bool HarborNpc::has_task_menu3() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HarborNpc::set_has_task_menu3() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HarborNpc::clear_has_task_menu3() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HarborNpc::clear_task_menu3() {
  if (task_menu3_ != NULL) task_menu3_->Clear();
  clear_has_task_menu3();
}
inline const ::sg::HarborNpc_resident_task& HarborNpc::_internal_task_menu3() const {
  return *task_menu3_;
}
inline const ::sg::HarborNpc_resident_task& HarborNpc::task_menu3() const {
  const ::sg::HarborNpc_resident_task* p = task_menu3_;
  // @@protoc_insertion_point(field_get:sg.HarborNpc.task_menu3)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::HarborNpc_resident_task*>(
      &::sg::_HarborNpc_resident_task_default_instance_);
}
inline ::sg::HarborNpc_resident_task* HarborNpc::release_task_menu3() {
  // @@protoc_insertion_point(field_release:sg.HarborNpc.task_menu3)
  clear_has_task_menu3();
  ::sg::HarborNpc_resident_task* temp = task_menu3_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  task_menu3_ = NULL;
  return temp;
}
inline ::sg::HarborNpc_resident_task* HarborNpc::unsafe_arena_release_task_menu3() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.HarborNpc.task_menu3)
  clear_has_task_menu3();
  ::sg::HarborNpc_resident_task* temp = task_menu3_;
  task_menu3_ = NULL;
  return temp;
}
inline ::sg::HarborNpc_resident_task* HarborNpc::mutable_task_menu3() {
  set_has_task_menu3();
  if (task_menu3_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::HarborNpc_resident_task>(GetArenaNoVirtual());
    task_menu3_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.HarborNpc.task_menu3)
  return task_menu3_;
}
inline void HarborNpc::set_allocated_task_menu3(::sg::HarborNpc_resident_task* task_menu3) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete task_menu3_;
  }
  if (task_menu3) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(task_menu3);
    if (message_arena != submessage_arena) {
      task_menu3 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, task_menu3, submessage_arena);
    }
    set_has_task_menu3();
  } else {
    clear_has_task_menu3();
  }
  task_menu3_ = task_menu3;
  // @@protoc_insertion_point(field_set_allocated:sg.HarborNpc.task_menu3)
}

// optional sfixed64 optime = 41;
inline bool HarborNpc::has_optime() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void HarborNpc::set_has_optime() {
  _has_bits_[0] |= 0x00010000u;
}
inline void HarborNpc::clear_has_optime() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void HarborNpc::clear_optime() {
  optime_ = GOOGLE_LONGLONG(0);
  clear_has_optime();
}
inline ::google::protobuf::int64 HarborNpc::optime() const {
  // @@protoc_insertion_point(field_get:sg.HarborNpc.optime)
  return optime_;
}
inline void HarborNpc::set_optime(::google::protobuf::int64 value) {
  set_has_optime();
  optime_ = value;
  // @@protoc_insertion_point(field_set:sg.HarborNpc.optime)
}

// -------------------------------------------------------------------

// HarborNpcList

// repeated .sg.HarborNpc list = 1;
inline int HarborNpcList::list_size() const {
  return list_.size();
}
inline void HarborNpcList::clear_list() {
  list_.Clear();
}
inline ::sg::HarborNpc* HarborNpcList::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:sg.HarborNpcList.list)
  return list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::HarborNpc >*
HarborNpcList::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:sg.HarborNpcList.list)
  return &list_;
}
inline const ::sg::HarborNpc& HarborNpcList::list(int index) const {
  // @@protoc_insertion_point(field_get:sg.HarborNpcList.list)
  return list_.Get(index);
}
inline ::sg::HarborNpc* HarborNpcList::add_list() {
  // @@protoc_insertion_point(field_add:sg.HarborNpcList.list)
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::HarborNpc >&
HarborNpcList::list() const {
  // @@protoc_insertion_point(field_list:sg.HarborNpcList.list)
  return list_;
}

// -------------------------------------------------------------------

// HarborPopulation

// required int32 harborid = 1;
inline bool HarborPopulation::has_harborid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HarborPopulation::set_has_harborid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HarborPopulation::clear_has_harborid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HarborPopulation::clear_harborid() {
  harborid_ = 0;
  clear_has_harborid();
}
inline ::google::protobuf::int32 HarborPopulation::harborid() const {
  // @@protoc_insertion_point(field_get:sg.HarborPopulation.harborid)
  return harborid_;
}
inline void HarborPopulation::set_harborid(::google::protobuf::int32 value) {
  set_has_harborid();
  harborid_ = value;
  // @@protoc_insertion_point(field_set:sg.HarborPopulation.harborid)
}

// required int32 population_num = 2;
inline bool HarborPopulation::has_population_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HarborPopulation::set_has_population_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HarborPopulation::clear_has_population_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HarborPopulation::clear_population_num() {
  population_num_ = 0;
  clear_has_population_num();
}
inline ::google::protobuf::int32 HarborPopulation::population_num() const {
  // @@protoc_insertion_point(field_get:sg.HarborPopulation.population_num)
  return population_num_;
}
inline void HarborPopulation::set_population_num(::google::protobuf::int32 value) {
  set_has_population_num();
  population_num_ = value;
  // @@protoc_insertion_point(field_set:sg.HarborPopulation.population_num)
}

// required int32 population_num_max = 3;
inline bool HarborPopulation::has_population_num_max() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HarborPopulation::set_has_population_num_max() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HarborPopulation::clear_has_population_num_max() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HarborPopulation::clear_population_num_max() {
  population_num_max_ = 0;
  clear_has_population_num_max();
}
inline ::google::protobuf::int32 HarborPopulation::population_num_max() const {
  // @@protoc_insertion_point(field_get:sg.HarborPopulation.population_num_max)
  return population_num_max_;
}
inline void HarborPopulation::set_population_num_max(::google::protobuf::int32 value) {
  set_has_population_num_max();
  population_num_max_ = value;
  // @@protoc_insertion_point(field_set:sg.HarborPopulation.population_num_max)
}

// -------------------------------------------------------------------

// HarborPopulationList

// repeated .sg.HarborPopulation list = 1;
inline int HarborPopulationList::list_size() const {
  return list_.size();
}
inline void HarborPopulationList::clear_list() {
  list_.Clear();
}
inline ::sg::HarborPopulation* HarborPopulationList::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:sg.HarborPopulationList.list)
  return list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::HarborPopulation >*
HarborPopulationList::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:sg.HarborPopulationList.list)
  return &list_;
}
inline const ::sg::HarborPopulation& HarborPopulationList::list(int index) const {
  // @@protoc_insertion_point(field_get:sg.HarborPopulationList.list)
  return list_.Get(index);
}
inline ::sg::HarborPopulation* HarborPopulationList::add_list() {
  // @@protoc_insertion_point(field_add:sg.HarborPopulationList.list)
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::HarborPopulation >&
HarborPopulationList::list() const {
  // @@protoc_insertion_point(field_list:sg.HarborPopulationList.list)
  return list_;
}

// -------------------------------------------------------------------

// HarborNpcInfo

// required int32 harborid = 1;
inline bool HarborNpcInfo::has_harborid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HarborNpcInfo::set_has_harborid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HarborNpcInfo::clear_has_harborid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HarborNpcInfo::clear_harborid() {
  harborid_ = 0;
  clear_has_harborid();
}
inline ::google::protobuf::int32 HarborNpcInfo::harborid() const {
  // @@protoc_insertion_point(field_get:sg.HarborNpcInfo.harborid)
  return harborid_;
}
inline void HarborNpcInfo::set_harborid(::google::protobuf::int32 value) {
  set_has_harborid();
  harborid_ = value;
  // @@protoc_insertion_point(field_set:sg.HarborNpcInfo.harborid)
}

// optional .sg.HarborNpcList npc_list = 2;
inline bool HarborNpcInfo::has_npc_list() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HarborNpcInfo::set_has_npc_list() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HarborNpcInfo::clear_has_npc_list() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HarborNpcInfo::clear_npc_list() {
  if (npc_list_ != NULL) npc_list_->Clear();
  clear_has_npc_list();
}
inline const ::sg::HarborNpcList& HarborNpcInfo::_internal_npc_list() const {
  return *npc_list_;
}
inline const ::sg::HarborNpcList& HarborNpcInfo::npc_list() const {
  const ::sg::HarborNpcList* p = npc_list_;
  // @@protoc_insertion_point(field_get:sg.HarborNpcInfo.npc_list)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::HarborNpcList*>(
      &::sg::_HarborNpcList_default_instance_);
}
inline ::sg::HarborNpcList* HarborNpcInfo::release_npc_list() {
  // @@protoc_insertion_point(field_release:sg.HarborNpcInfo.npc_list)
  clear_has_npc_list();
  ::sg::HarborNpcList* temp = npc_list_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  npc_list_ = NULL;
  return temp;
}
inline ::sg::HarborNpcList* HarborNpcInfo::unsafe_arena_release_npc_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.HarborNpcInfo.npc_list)
  clear_has_npc_list();
  ::sg::HarborNpcList* temp = npc_list_;
  npc_list_ = NULL;
  return temp;
}
inline ::sg::HarborNpcList* HarborNpcInfo::mutable_npc_list() {
  set_has_npc_list();
  if (npc_list_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::HarborNpcList>(GetArenaNoVirtual());
    npc_list_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.HarborNpcInfo.npc_list)
  return npc_list_;
}
inline void HarborNpcInfo::set_allocated_npc_list(::sg::HarborNpcList* npc_list) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete npc_list_;
  }
  if (npc_list) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(npc_list);
    if (message_arena != submessage_arena) {
      npc_list = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, npc_list, submessage_arena);
    }
    set_has_npc_list();
  } else {
    clear_has_npc_list();
  }
  npc_list_ = npc_list;
  // @@protoc_insertion_point(field_set_allocated:sg.HarborNpcInfo.npc_list)
}

// optional .sg.HarborInfo harbor_info = 3;
inline bool HarborNpcInfo::has_harbor_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HarborNpcInfo::set_has_harbor_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HarborNpcInfo::clear_has_harbor_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HarborNpcInfo::clear_harbor_info() {
  if (harbor_info_ != NULL) harbor_info_->Clear();
  clear_has_harbor_info();
}
inline const ::sg::HarborInfo& HarborNpcInfo::_internal_harbor_info() const {
  return *harbor_info_;
}
inline const ::sg::HarborInfo& HarborNpcInfo::harbor_info() const {
  const ::sg::HarborInfo* p = harbor_info_;
  // @@protoc_insertion_point(field_get:sg.HarborNpcInfo.harbor_info)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::HarborInfo*>(
      &::sg::_HarborInfo_default_instance_);
}
inline ::sg::HarborInfo* HarborNpcInfo::release_harbor_info() {
  // @@protoc_insertion_point(field_release:sg.HarborNpcInfo.harbor_info)
  clear_has_harbor_info();
  ::sg::HarborInfo* temp = harbor_info_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  harbor_info_ = NULL;
  return temp;
}
inline ::sg::HarborInfo* HarborNpcInfo::unsafe_arena_release_harbor_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.HarborNpcInfo.harbor_info)
  clear_has_harbor_info();
  ::sg::HarborInfo* temp = harbor_info_;
  harbor_info_ = NULL;
  return temp;
}
inline ::sg::HarborInfo* HarborNpcInfo::mutable_harbor_info() {
  set_has_harbor_info();
  if (harbor_info_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::HarborInfo>(GetArenaNoVirtual());
    harbor_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.HarborNpcInfo.harbor_info)
  return harbor_info_;
}
inline void HarborNpcInfo::set_allocated_harbor_info(::sg::HarborInfo* harbor_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete harbor_info_;
  }
  if (harbor_info) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(harbor_info);
    if (message_arena != submessage_arena) {
      harbor_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, harbor_info, submessage_arena);
    }
    set_has_harbor_info();
  } else {
    clear_has_harbor_info();
  }
  harbor_info_ = harbor_info;
  // @@protoc_insertion_point(field_set_allocated:sg.HarborNpcInfo.harbor_info)
}

// -------------------------------------------------------------------

// HarborNpcInfoList

// repeated .sg.HarborNpcInfo list = 1;
inline int HarborNpcInfoList::list_size() const {
  return list_.size();
}
inline void HarborNpcInfoList::clear_list() {
  list_.Clear();
}
inline ::sg::HarborNpcInfo* HarborNpcInfoList::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:sg.HarborNpcInfoList.list)
  return list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::HarborNpcInfo >*
HarborNpcInfoList::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:sg.HarborNpcInfoList.list)
  return &list_;
}
inline const ::sg::HarborNpcInfo& HarborNpcInfoList::list(int index) const {
  // @@protoc_insertion_point(field_get:sg.HarborNpcInfoList.list)
  return list_.Get(index);
}
inline ::sg::HarborNpcInfo* HarborNpcInfoList::add_list() {
  // @@protoc_insertion_point(field_add:sg.HarborNpcInfoList.list)
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::HarborNpcInfo >&
HarborNpcInfoList::list() const {
  // @@protoc_insertion_point(field_list:sg.HarborNpcInfoList.list)
  return list_;
}

// -------------------------------------------------------------------

// UserHarborNpcService_HarborNpcRequest

// required .sg.UserHarborNpcService.NPC_COMMAND cmd = 1;
inline bool UserHarborNpcService_HarborNpcRequest::has_cmd() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserHarborNpcService_HarborNpcRequest::set_has_cmd() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserHarborNpcService_HarborNpcRequest::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserHarborNpcService_HarborNpcRequest::clear_cmd() {
  cmd_ = 1;
  clear_has_cmd();
}
inline ::sg::UserHarborNpcService_NPC_COMMAND UserHarborNpcService_HarborNpcRequest::cmd() const {
  // @@protoc_insertion_point(field_get:sg.UserHarborNpcService.HarborNpcRequest.cmd)
  return static_cast< ::sg::UserHarborNpcService_NPC_COMMAND >(cmd_);
}
inline void UserHarborNpcService_HarborNpcRequest::set_cmd(::sg::UserHarborNpcService_NPC_COMMAND value) {
  assert(::sg::UserHarborNpcService_NPC_COMMAND_IsValid(value));
  set_has_cmd();
  cmd_ = value;
  // @@protoc_insertion_point(field_set:sg.UserHarborNpcService.HarborNpcRequest.cmd)
}

// repeated int32 start_queueing_list = 2;
inline int UserHarborNpcService_HarborNpcRequest::start_queueing_list_size() const {
  return start_queueing_list_.size();
}
inline void UserHarborNpcService_HarborNpcRequest::clear_start_queueing_list() {
  start_queueing_list_.Clear();
}
inline ::google::protobuf::int32 UserHarborNpcService_HarborNpcRequest::start_queueing_list(int index) const {
  // @@protoc_insertion_point(field_get:sg.UserHarborNpcService.HarborNpcRequest.start_queueing_list)
  return start_queueing_list_.Get(index);
}
inline void UserHarborNpcService_HarborNpcRequest::set_start_queueing_list(int index, ::google::protobuf::int32 value) {
  start_queueing_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:sg.UserHarborNpcService.HarborNpcRequest.start_queueing_list)
}
inline void UserHarborNpcService_HarborNpcRequest::add_start_queueing_list(::google::protobuf::int32 value) {
  start_queueing_list_.Add(value);
  // @@protoc_insertion_point(field_add:sg.UserHarborNpcService.HarborNpcRequest.start_queueing_list)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
UserHarborNpcService_HarborNpcRequest::start_queueing_list() const {
  // @@protoc_insertion_point(field_list:sg.UserHarborNpcService.HarborNpcRequest.start_queueing_list)
  return start_queueing_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
UserHarborNpcService_HarborNpcRequest::mutable_start_queueing_list() {
  // @@protoc_insertion_point(field_mutable_list:sg.UserHarborNpcService.HarborNpcRequest.start_queueing_list)
  return &start_queueing_list_;
}

// optional int32 residentid = 3;
inline bool UserHarborNpcService_HarborNpcRequest::has_residentid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserHarborNpcService_HarborNpcRequest::set_has_residentid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserHarborNpcService_HarborNpcRequest::clear_has_residentid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserHarborNpcService_HarborNpcRequest::clear_residentid() {
  residentid_ = 0;
  clear_has_residentid();
}
inline ::google::protobuf::int32 UserHarborNpcService_HarborNpcRequest::residentid() const {
  // @@protoc_insertion_point(field_get:sg.UserHarborNpcService.HarborNpcRequest.residentid)
  return residentid_;
}
inline void UserHarborNpcService_HarborNpcRequest::set_residentid(::google::protobuf::int32 value) {
  set_has_residentid();
  residentid_ = value;
  // @@protoc_insertion_point(field_set:sg.UserHarborNpcService.HarborNpcRequest.residentid)
}

// optional int32 select_task_menuid = 4;
inline bool UserHarborNpcService_HarborNpcRequest::has_select_task_menuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserHarborNpcService_HarborNpcRequest::set_has_select_task_menuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserHarborNpcService_HarborNpcRequest::clear_has_select_task_menuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserHarborNpcService_HarborNpcRequest::clear_select_task_menuid() {
  select_task_menuid_ = 0;
  clear_has_select_task_menuid();
}
inline ::google::protobuf::int32 UserHarborNpcService_HarborNpcRequest::select_task_menuid() const {
  // @@protoc_insertion_point(field_get:sg.UserHarborNpcService.HarborNpcRequest.select_task_menuid)
  return select_task_menuid_;
}
inline void UserHarborNpcService_HarborNpcRequest::set_select_task_menuid(::google::protobuf::int32 value) {
  set_has_select_task_menuid();
  select_task_menuid_ = value;
  // @@protoc_insertion_point(field_set:sg.UserHarborNpcService.HarborNpcRequest.select_task_menuid)
}

// optional int32 harborid = 5;
inline bool UserHarborNpcService_HarborNpcRequest::has_harborid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserHarborNpcService_HarborNpcRequest::set_has_harborid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserHarborNpcService_HarborNpcRequest::clear_has_harborid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserHarborNpcService_HarborNpcRequest::clear_harborid() {
  harborid_ = 0;
  clear_has_harborid();
}
inline ::google::protobuf::int32 UserHarborNpcService_HarborNpcRequest::harborid() const {
  // @@protoc_insertion_point(field_get:sg.UserHarborNpcService.HarborNpcRequest.harborid)
  return harborid_;
}
inline void UserHarborNpcService_HarborNpcRequest::set_harborid(::google::protobuf::int32 value) {
  set_has_harborid();
  harborid_ = value;
  // @@protoc_insertion_point(field_set:sg.UserHarborNpcService.HarborNpcRequest.harborid)
}

// -------------------------------------------------------------------

// UserHarborNpcService_HarborNpcResponse

// required int32 result = 1;
inline bool UserHarborNpcService_HarborNpcResponse::has_result() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserHarborNpcService_HarborNpcResponse::set_has_result() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserHarborNpcService_HarborNpcResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserHarborNpcService_HarborNpcResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 UserHarborNpcService_HarborNpcResponse::result() const {
  // @@protoc_insertion_point(field_get:sg.UserHarborNpcService.HarborNpcResponse.result)
  return result_;
}
inline void UserHarborNpcService_HarborNpcResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:sg.UserHarborNpcService.HarborNpcResponse.result)
}

// optional .sg.HarborNpcList npc_list = 2;
inline bool UserHarborNpcService_HarborNpcResponse::has_npc_list() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserHarborNpcService_HarborNpcResponse::set_has_npc_list() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserHarborNpcService_HarborNpcResponse::clear_has_npc_list() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserHarborNpcService_HarborNpcResponse::clear_npc_list() {
  if (npc_list_ != NULL) npc_list_->Clear();
  clear_has_npc_list();
}
inline const ::sg::HarborNpcList& UserHarborNpcService_HarborNpcResponse::_internal_npc_list() const {
  return *npc_list_;
}
inline const ::sg::HarborNpcList& UserHarborNpcService_HarborNpcResponse::npc_list() const {
  const ::sg::HarborNpcList* p = npc_list_;
  // @@protoc_insertion_point(field_get:sg.UserHarborNpcService.HarborNpcResponse.npc_list)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::HarborNpcList*>(
      &::sg::_HarborNpcList_default_instance_);
}
inline ::sg::HarborNpcList* UserHarborNpcService_HarborNpcResponse::release_npc_list() {
  // @@protoc_insertion_point(field_release:sg.UserHarborNpcService.HarborNpcResponse.npc_list)
  clear_has_npc_list();
  ::sg::HarborNpcList* temp = npc_list_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  npc_list_ = NULL;
  return temp;
}
inline ::sg::HarborNpcList* UserHarborNpcService_HarborNpcResponse::unsafe_arena_release_npc_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.UserHarborNpcService.HarborNpcResponse.npc_list)
  clear_has_npc_list();
  ::sg::HarborNpcList* temp = npc_list_;
  npc_list_ = NULL;
  return temp;
}
inline ::sg::HarborNpcList* UserHarborNpcService_HarborNpcResponse::mutable_npc_list() {
  set_has_npc_list();
  if (npc_list_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::HarborNpcList>(GetArenaNoVirtual());
    npc_list_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.UserHarborNpcService.HarborNpcResponse.npc_list)
  return npc_list_;
}
inline void UserHarborNpcService_HarborNpcResponse::set_allocated_npc_list(::sg::HarborNpcList* npc_list) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete npc_list_;
  }
  if (npc_list) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(npc_list);
    if (message_arena != submessage_arena) {
      npc_list = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, npc_list, submessage_arena);
    }
    set_has_npc_list();
  } else {
    clear_has_npc_list();
  }
  npc_list_ = npc_list;
  // @@protoc_insertion_point(field_set_allocated:sg.UserHarborNpcService.HarborNpcResponse.npc_list)
}

// optional .sg.HarborInfo harbor_info = 3;
inline bool UserHarborNpcService_HarborNpcResponse::has_harbor_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserHarborNpcService_HarborNpcResponse::set_has_harbor_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserHarborNpcService_HarborNpcResponse::clear_has_harbor_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserHarborNpcService_HarborNpcResponse::clear_harbor_info() {
  if (harbor_info_ != NULL) harbor_info_->Clear();
  clear_has_harbor_info();
}
inline const ::sg::HarborInfo& UserHarborNpcService_HarborNpcResponse::_internal_harbor_info() const {
  return *harbor_info_;
}
inline const ::sg::HarborInfo& UserHarborNpcService_HarborNpcResponse::harbor_info() const {
  const ::sg::HarborInfo* p = harbor_info_;
  // @@protoc_insertion_point(field_get:sg.UserHarborNpcService.HarborNpcResponse.harbor_info)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::HarborInfo*>(
      &::sg::_HarborInfo_default_instance_);
}
inline ::sg::HarborInfo* UserHarborNpcService_HarborNpcResponse::release_harbor_info() {
  // @@protoc_insertion_point(field_release:sg.UserHarborNpcService.HarborNpcResponse.harbor_info)
  clear_has_harbor_info();
  ::sg::HarborInfo* temp = harbor_info_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  harbor_info_ = NULL;
  return temp;
}
inline ::sg::HarborInfo* UserHarborNpcService_HarborNpcResponse::unsafe_arena_release_harbor_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.UserHarborNpcService.HarborNpcResponse.harbor_info)
  clear_has_harbor_info();
  ::sg::HarborInfo* temp = harbor_info_;
  harbor_info_ = NULL;
  return temp;
}
inline ::sg::HarborInfo* UserHarborNpcService_HarborNpcResponse::mutable_harbor_info() {
  set_has_harbor_info();
  if (harbor_info_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::HarborInfo>(GetArenaNoVirtual());
    harbor_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.UserHarborNpcService.HarborNpcResponse.harbor_info)
  return harbor_info_;
}
inline void UserHarborNpcService_HarborNpcResponse::set_allocated_harbor_info(::sg::HarborInfo* harbor_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete harbor_info_;
  }
  if (harbor_info) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(harbor_info);
    if (message_arena != submessage_arena) {
      harbor_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, harbor_info, submessage_arena);
    }
    set_has_harbor_info();
  } else {
    clear_has_harbor_info();
  }
  harbor_info_ = harbor_info;
  // @@protoc_insertion_point(field_set_allocated:sg.UserHarborNpcService.HarborNpcResponse.harbor_info)
}

// optional .sg.Reward resident_drop = 4;
inline bool UserHarborNpcService_HarborNpcResponse::has_resident_drop() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserHarborNpcService_HarborNpcResponse::set_has_resident_drop() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserHarborNpcService_HarborNpcResponse::clear_has_resident_drop() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::sg::Reward& UserHarborNpcService_HarborNpcResponse::_internal_resident_drop() const {
  return *resident_drop_;
}
inline const ::sg::Reward& UserHarborNpcService_HarborNpcResponse::resident_drop() const {
  const ::sg::Reward* p = resident_drop_;
  // @@protoc_insertion_point(field_get:sg.UserHarborNpcService.HarborNpcResponse.resident_drop)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::Reward*>(
      &::sg::_Reward_default_instance_);
}
inline ::sg::Reward* UserHarborNpcService_HarborNpcResponse::release_resident_drop() {
  // @@protoc_insertion_point(field_release:sg.UserHarborNpcService.HarborNpcResponse.resident_drop)
  clear_has_resident_drop();
  ::sg::Reward* temp = resident_drop_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  resident_drop_ = NULL;
  return temp;
}
inline ::sg::Reward* UserHarborNpcService_HarborNpcResponse::unsafe_arena_release_resident_drop() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.UserHarborNpcService.HarborNpcResponse.resident_drop)
  clear_has_resident_drop();
  ::sg::Reward* temp = resident_drop_;
  resident_drop_ = NULL;
  return temp;
}
inline ::sg::Reward* UserHarborNpcService_HarborNpcResponse::mutable_resident_drop() {
  set_has_resident_drop();
  if (resident_drop_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::Reward>(GetArenaNoVirtual());
    resident_drop_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.UserHarborNpcService.HarborNpcResponse.resident_drop)
  return resident_drop_;
}
inline void UserHarborNpcService_HarborNpcResponse::set_allocated_resident_drop(::sg::Reward* resident_drop) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(resident_drop_);
  }
  if (resident_drop) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(resident_drop)->GetArena();
    if (message_arena != submessage_arena) {
      resident_drop = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, resident_drop, submessage_arena);
    }
    set_has_resident_drop();
  } else {
    clear_has_resident_drop();
  }
  resident_drop_ = resident_drop;
  // @@protoc_insertion_point(field_set_allocated:sg.UserHarborNpcService.HarborNpcResponse.resident_drop)
}

// optional .sg.HarborPopulationList population_list = 11;
inline bool UserHarborNpcService_HarborNpcResponse::has_population_list() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserHarborNpcService_HarborNpcResponse::set_has_population_list() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserHarborNpcService_HarborNpcResponse::clear_has_population_list() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserHarborNpcService_HarborNpcResponse::clear_population_list() {
  if (population_list_ != NULL) population_list_->Clear();
  clear_has_population_list();
}
inline const ::sg::HarborPopulationList& UserHarborNpcService_HarborNpcResponse::_internal_population_list() const {
  return *population_list_;
}
inline const ::sg::HarborPopulationList& UserHarborNpcService_HarborNpcResponse::population_list() const {
  const ::sg::HarborPopulationList* p = population_list_;
  // @@protoc_insertion_point(field_get:sg.UserHarborNpcService.HarborNpcResponse.population_list)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::HarborPopulationList*>(
      &::sg::_HarborPopulationList_default_instance_);
}
inline ::sg::HarborPopulationList* UserHarborNpcService_HarborNpcResponse::release_population_list() {
  // @@protoc_insertion_point(field_release:sg.UserHarborNpcService.HarborNpcResponse.population_list)
  clear_has_population_list();
  ::sg::HarborPopulationList* temp = population_list_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  population_list_ = NULL;
  return temp;
}
inline ::sg::HarborPopulationList* UserHarborNpcService_HarborNpcResponse::unsafe_arena_release_population_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.UserHarborNpcService.HarborNpcResponse.population_list)
  clear_has_population_list();
  ::sg::HarborPopulationList* temp = population_list_;
  population_list_ = NULL;
  return temp;
}
inline ::sg::HarborPopulationList* UserHarborNpcService_HarborNpcResponse::mutable_population_list() {
  set_has_population_list();
  if (population_list_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::HarborPopulationList>(GetArenaNoVirtual());
    population_list_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.UserHarborNpcService.HarborNpcResponse.population_list)
  return population_list_;
}
inline void UserHarborNpcService_HarborNpcResponse::set_allocated_population_list(::sg::HarborPopulationList* population_list) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete population_list_;
  }
  if (population_list) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(population_list);
    if (message_arena != submessage_arena) {
      population_list = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, population_list, submessage_arena);
    }
    set_has_population_list();
  } else {
    clear_has_population_list();
  }
  population_list_ = population_list;
  // @@protoc_insertion_point(field_set_allocated:sg.UserHarborNpcService.HarborNpcResponse.population_list)
}

// optional .sg.HarborNpcInfoList npc_info_list = 12;
inline bool UserHarborNpcService_HarborNpcResponse::has_npc_info_list() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserHarborNpcService_HarborNpcResponse::set_has_npc_info_list() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserHarborNpcService_HarborNpcResponse::clear_has_npc_info_list() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserHarborNpcService_HarborNpcResponse::clear_npc_info_list() {
  if (npc_info_list_ != NULL) npc_info_list_->Clear();
  clear_has_npc_info_list();
}
inline const ::sg::HarborNpcInfoList& UserHarborNpcService_HarborNpcResponse::_internal_npc_info_list() const {
  return *npc_info_list_;
}
inline const ::sg::HarborNpcInfoList& UserHarborNpcService_HarborNpcResponse::npc_info_list() const {
  const ::sg::HarborNpcInfoList* p = npc_info_list_;
  // @@protoc_insertion_point(field_get:sg.UserHarborNpcService.HarborNpcResponse.npc_info_list)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::HarborNpcInfoList*>(
      &::sg::_HarborNpcInfoList_default_instance_);
}
inline ::sg::HarborNpcInfoList* UserHarborNpcService_HarborNpcResponse::release_npc_info_list() {
  // @@protoc_insertion_point(field_release:sg.UserHarborNpcService.HarborNpcResponse.npc_info_list)
  clear_has_npc_info_list();
  ::sg::HarborNpcInfoList* temp = npc_info_list_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  npc_info_list_ = NULL;
  return temp;
}
inline ::sg::HarborNpcInfoList* UserHarborNpcService_HarborNpcResponse::unsafe_arena_release_npc_info_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.UserHarborNpcService.HarborNpcResponse.npc_info_list)
  clear_has_npc_info_list();
  ::sg::HarborNpcInfoList* temp = npc_info_list_;
  npc_info_list_ = NULL;
  return temp;
}
inline ::sg::HarborNpcInfoList* UserHarborNpcService_HarborNpcResponse::mutable_npc_info_list() {
  set_has_npc_info_list();
  if (npc_info_list_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::HarborNpcInfoList>(GetArenaNoVirtual());
    npc_info_list_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.UserHarborNpcService.HarborNpcResponse.npc_info_list)
  return npc_info_list_;
}
inline void UserHarborNpcService_HarborNpcResponse::set_allocated_npc_info_list(::sg::HarborNpcInfoList* npc_info_list) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete npc_info_list_;
  }
  if (npc_info_list) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(npc_info_list);
    if (message_arena != submessage_arena) {
      npc_info_list = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, npc_info_list, submessage_arena);
    }
    set_has_npc_info_list();
  } else {
    clear_has_npc_info_list();
  }
  npc_info_list_ = npc_info_list;
  // @@protoc_insertion_point(field_set_allocated:sg.UserHarborNpcService.HarborNpcResponse.npc_info_list)
}

// -------------------------------------------------------------------

// UserHarborNpcService

// optional .sg.UserHarborNpcService.HarborNpcRequest req = 1;
inline bool UserHarborNpcService::has_req() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserHarborNpcService::set_has_req() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserHarborNpcService::clear_has_req() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserHarborNpcService::clear_req() {
  if (req_ != NULL) req_->Clear();
  clear_has_req();
}
inline const ::sg::UserHarborNpcService_HarborNpcRequest& UserHarborNpcService::_internal_req() const {
  return *req_;
}
inline const ::sg::UserHarborNpcService_HarborNpcRequest& UserHarborNpcService::req() const {
  const ::sg::UserHarborNpcService_HarborNpcRequest* p = req_;
  // @@protoc_insertion_point(field_get:sg.UserHarborNpcService.req)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::UserHarborNpcService_HarborNpcRequest*>(
      &::sg::_UserHarborNpcService_HarborNpcRequest_default_instance_);
}
inline ::sg::UserHarborNpcService_HarborNpcRequest* UserHarborNpcService::release_req() {
  // @@protoc_insertion_point(field_release:sg.UserHarborNpcService.req)
  clear_has_req();
  ::sg::UserHarborNpcService_HarborNpcRequest* temp = req_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  req_ = NULL;
  return temp;
}
inline ::sg::UserHarborNpcService_HarborNpcRequest* UserHarborNpcService::unsafe_arena_release_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.UserHarborNpcService.req)
  clear_has_req();
  ::sg::UserHarborNpcService_HarborNpcRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline ::sg::UserHarborNpcService_HarborNpcRequest* UserHarborNpcService::mutable_req() {
  set_has_req();
  if (req_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::UserHarborNpcService_HarborNpcRequest>(GetArenaNoVirtual());
    req_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.UserHarborNpcService.req)
  return req_;
}
inline void UserHarborNpcService::set_allocated_req(::sg::UserHarborNpcService_HarborNpcRequest* req) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete req_;
  }
  if (req) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(req);
    if (message_arena != submessage_arena) {
      req = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, req, submessage_arena);
    }
    set_has_req();
  } else {
    clear_has_req();
  }
  req_ = req;
  // @@protoc_insertion_point(field_set_allocated:sg.UserHarborNpcService.req)
}

// optional .sg.UserHarborNpcService.HarborNpcResponse resp = 2;
inline bool UserHarborNpcService::has_resp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserHarborNpcService::set_has_resp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserHarborNpcService::clear_has_resp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserHarborNpcService::clear_resp() {
  if (resp_ != NULL) resp_->Clear();
  clear_has_resp();
}
inline const ::sg::UserHarborNpcService_HarborNpcResponse& UserHarborNpcService::_internal_resp() const {
  return *resp_;
}
inline const ::sg::UserHarborNpcService_HarborNpcResponse& UserHarborNpcService::resp() const {
  const ::sg::UserHarborNpcService_HarborNpcResponse* p = resp_;
  // @@protoc_insertion_point(field_get:sg.UserHarborNpcService.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::UserHarborNpcService_HarborNpcResponse*>(
      &::sg::_UserHarborNpcService_HarborNpcResponse_default_instance_);
}
inline ::sg::UserHarborNpcService_HarborNpcResponse* UserHarborNpcService::release_resp() {
  // @@protoc_insertion_point(field_release:sg.UserHarborNpcService.resp)
  clear_has_resp();
  ::sg::UserHarborNpcService_HarborNpcResponse* temp = resp_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  resp_ = NULL;
  return temp;
}
inline ::sg::UserHarborNpcService_HarborNpcResponse* UserHarborNpcService::unsafe_arena_release_resp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.UserHarborNpcService.resp)
  clear_has_resp();
  ::sg::UserHarborNpcService_HarborNpcResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline ::sg::UserHarborNpcService_HarborNpcResponse* UserHarborNpcService::mutable_resp() {
  set_has_resp();
  if (resp_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::UserHarborNpcService_HarborNpcResponse>(GetArenaNoVirtual());
    resp_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.UserHarborNpcService.resp)
  return resp_;
}
inline void UserHarborNpcService::set_allocated_resp(::sg::UserHarborNpcService_HarborNpcResponse* resp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete resp_;
  }
  if (resp) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(resp);
    if (message_arena != submessage_arena) {
      resp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, resp, submessage_arena);
    }
    set_has_resp();
  } else {
    clear_has_resp();
  }
  resp_ = resp;
  // @@protoc_insertion_point(field_set_allocated:sg.UserHarborNpcService.resp)
}

// -------------------------------------------------------------------

// HarborStateNotify

// required .sg.HarborInfo harbor_info = 1;
inline bool HarborStateNotify::has_harbor_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HarborStateNotify::set_has_harbor_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HarborStateNotify::clear_has_harbor_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HarborStateNotify::clear_harbor_info() {
  if (harbor_info_ != NULL) harbor_info_->Clear();
  clear_has_harbor_info();
}
inline const ::sg::HarborInfo& HarborStateNotify::_internal_harbor_info() const {
  return *harbor_info_;
}
inline const ::sg::HarborInfo& HarborStateNotify::harbor_info() const {
  const ::sg::HarborInfo* p = harbor_info_;
  // @@protoc_insertion_point(field_get:sg.HarborStateNotify.harbor_info)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::HarborInfo*>(
      &::sg::_HarborInfo_default_instance_);
}
inline ::sg::HarborInfo* HarborStateNotify::release_harbor_info() {
  // @@protoc_insertion_point(field_release:sg.HarborStateNotify.harbor_info)
  clear_has_harbor_info();
  ::sg::HarborInfo* temp = harbor_info_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  harbor_info_ = NULL;
  return temp;
}
inline ::sg::HarborInfo* HarborStateNotify::unsafe_arena_release_harbor_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.HarborStateNotify.harbor_info)
  clear_has_harbor_info();
  ::sg::HarborInfo* temp = harbor_info_;
  harbor_info_ = NULL;
  return temp;
}
inline ::sg::HarborInfo* HarborStateNotify::mutable_harbor_info() {
  set_has_harbor_info();
  if (harbor_info_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::HarborInfo>(GetArenaNoVirtual());
    harbor_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.HarborStateNotify.harbor_info)
  return harbor_info_;
}
inline void HarborStateNotify::set_allocated_harbor_info(::sg::HarborInfo* harbor_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete harbor_info_;
  }
  if (harbor_info) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(harbor_info);
    if (message_arena != submessage_arena) {
      harbor_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, harbor_info, submessage_arena);
    }
    set_has_harbor_info();
  } else {
    clear_has_harbor_info();
  }
  harbor_info_ = harbor_info;
  // @@protoc_insertion_point(field_set_allocated:sg.HarborStateNotify.harbor_info)
}

// -------------------------------------------------------------------

// HarborNpcStateNotify

// required .sg.HarborNpcList npc_list = 1;
inline bool HarborNpcStateNotify::has_npc_list() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HarborNpcStateNotify::set_has_npc_list() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HarborNpcStateNotify::clear_has_npc_list() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HarborNpcStateNotify::clear_npc_list() {
  if (npc_list_ != NULL) npc_list_->Clear();
  clear_has_npc_list();
}
inline const ::sg::HarborNpcList& HarborNpcStateNotify::_internal_npc_list() const {
  return *npc_list_;
}
inline const ::sg::HarborNpcList& HarborNpcStateNotify::npc_list() const {
  const ::sg::HarborNpcList* p = npc_list_;
  // @@protoc_insertion_point(field_get:sg.HarborNpcStateNotify.npc_list)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::HarborNpcList*>(
      &::sg::_HarborNpcList_default_instance_);
}
inline ::sg::HarborNpcList* HarborNpcStateNotify::release_npc_list() {
  // @@protoc_insertion_point(field_release:sg.HarborNpcStateNotify.npc_list)
  clear_has_npc_list();
  ::sg::HarborNpcList* temp = npc_list_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  npc_list_ = NULL;
  return temp;
}
inline ::sg::HarborNpcList* HarborNpcStateNotify::unsafe_arena_release_npc_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.HarborNpcStateNotify.npc_list)
  clear_has_npc_list();
  ::sg::HarborNpcList* temp = npc_list_;
  npc_list_ = NULL;
  return temp;
}
inline ::sg::HarborNpcList* HarborNpcStateNotify::mutable_npc_list() {
  set_has_npc_list();
  if (npc_list_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::HarborNpcList>(GetArenaNoVirtual());
    npc_list_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.HarborNpcStateNotify.npc_list)
  return npc_list_;
}
inline void HarborNpcStateNotify::set_allocated_npc_list(::sg::HarborNpcList* npc_list) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete npc_list_;
  }
  if (npc_list) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(npc_list);
    if (message_arena != submessage_arena) {
      npc_list = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, npc_list, submessage_arena);
    }
    set_has_npc_list();
  } else {
    clear_has_npc_list();
  }
  npc_list_ = npc_list;
  // @@protoc_insertion_point(field_set_allocated:sg.HarborNpcStateNotify.npc_list)
}

// required int32 harborid = 2;
inline bool HarborNpcStateNotify::has_harborid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HarborNpcStateNotify::set_has_harborid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HarborNpcStateNotify::clear_has_harborid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HarborNpcStateNotify::clear_harborid() {
  harborid_ = 0;
  clear_has_harborid();
}
inline ::google::protobuf::int32 HarborNpcStateNotify::harborid() const {
  // @@protoc_insertion_point(field_get:sg.HarborNpcStateNotify.harborid)
  return harborid_;
}
inline void HarborNpcStateNotify::set_harborid(::google::protobuf::int32 value) {
  set_has_harborid();
  harborid_ = value;
  // @@protoc_insertion_point(field_set:sg.HarborNpcStateNotify.harborid)
}

// -------------------------------------------------------------------

// FoodStyle

// required .sg.FoodStyle.FOOD_ATTR_ID attrid = 1;
inline bool FoodStyle::has_attrid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FoodStyle::set_has_attrid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FoodStyle::clear_has_attrid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FoodStyle::clear_attrid() {
  attrid_ = 1;
  clear_has_attrid();
}
inline ::sg::FoodStyle_FOOD_ATTR_ID FoodStyle::attrid() const {
  // @@protoc_insertion_point(field_get:sg.FoodStyle.attrid)
  return static_cast< ::sg::FoodStyle_FOOD_ATTR_ID >(attrid_);
}
inline void FoodStyle::set_attrid(::sg::FoodStyle_FOOD_ATTR_ID value) {
  assert(::sg::FoodStyle_FOOD_ATTR_ID_IsValid(value));
  set_has_attrid();
  attrid_ = value;
  // @@protoc_insertion_point(field_set:sg.FoodStyle.attrid)
}

// required int32 minval = 2;
inline bool FoodStyle::has_minval() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FoodStyle::set_has_minval() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FoodStyle::clear_has_minval() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FoodStyle::clear_minval() {
  minval_ = 0;
  clear_has_minval();
}
inline ::google::protobuf::int32 FoodStyle::minval() const {
  // @@protoc_insertion_point(field_get:sg.FoodStyle.minval)
  return minval_;
}
inline void FoodStyle::set_minval(::google::protobuf::int32 value) {
  set_has_minval();
  minval_ = value;
  // @@protoc_insertion_point(field_set:sg.FoodStyle.minval)
}

// required int32 maxval = 3;
inline bool FoodStyle::has_maxval() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FoodStyle::set_has_maxval() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FoodStyle::clear_has_maxval() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FoodStyle::clear_maxval() {
  maxval_ = 0;
  clear_has_maxval();
}
inline ::google::protobuf::int32 FoodStyle::maxval() const {
  // @@protoc_insertion_point(field_get:sg.FoodStyle.maxval)
  return maxval_;
}
inline void FoodStyle::set_maxval(::google::protobuf::int32 value) {
  set_has_maxval();
  maxval_ = value;
  // @@protoc_insertion_point(field_set:sg.FoodStyle.maxval)
}

// -------------------------------------------------------------------

// FoodStyleList

// repeated .sg.FoodStyle list = 1;
inline int FoodStyleList::list_size() const {
  return list_.size();
}
inline void FoodStyleList::clear_list() {
  list_.Clear();
}
inline ::sg::FoodStyle* FoodStyleList::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:sg.FoodStyleList.list)
  return list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::FoodStyle >*
FoodStyleList::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:sg.FoodStyleList.list)
  return &list_;
}
inline const ::sg::FoodStyle& FoodStyleList::list(int index) const {
  // @@protoc_insertion_point(field_get:sg.FoodStyleList.list)
  return list_.Get(index);
}
inline ::sg::FoodStyle* FoodStyleList::add_list() {
  // @@protoc_insertion_point(field_add:sg.FoodStyleList.list)
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::FoodStyle >&
FoodStyleList::list() const {
  // @@protoc_insertion_point(field_list:sg.FoodStyleList.list)
  return list_;
}

// -------------------------------------------------------------------

// SeatFoodOrder

// required int32 seatid = 1;
inline bool SeatFoodOrder::has_seatid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SeatFoodOrder::set_has_seatid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SeatFoodOrder::clear_has_seatid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SeatFoodOrder::clear_seatid() {
  seatid_ = 0;
  clear_has_seatid();
}
inline ::google::protobuf::int32 SeatFoodOrder::seatid() const {
  // @@protoc_insertion_point(field_get:sg.SeatFoodOrder.seatid)
  return seatid_;
}
inline void SeatFoodOrder::set_seatid(::google::protobuf::int32 value) {
  set_has_seatid();
  seatid_ = value;
  // @@protoc_insertion_point(field_set:sg.SeatFoodOrder.seatid)
}

// required int32 posid = 2;
inline bool SeatFoodOrder::has_posid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SeatFoodOrder::set_has_posid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SeatFoodOrder::clear_has_posid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SeatFoodOrder::clear_posid() {
  posid_ = 0;
  clear_has_posid();
}
inline ::google::protobuf::int32 SeatFoodOrder::posid() const {
  // @@protoc_insertion_point(field_get:sg.SeatFoodOrder.posid)
  return posid_;
}
inline void SeatFoodOrder::set_posid(::google::protobuf::int32 value) {
  set_has_posid();
  posid_ = value;
  // @@protoc_insertion_point(field_set:sg.SeatFoodOrder.posid)
}

// required int32 orderid = 3;
inline bool SeatFoodOrder::has_orderid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SeatFoodOrder::set_has_orderid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SeatFoodOrder::clear_has_orderid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SeatFoodOrder::clear_orderid() {
  orderid_ = 0;
  clear_has_orderid();
}
inline ::google::protobuf::int32 SeatFoodOrder::orderid() const {
  // @@protoc_insertion_point(field_get:sg.SeatFoodOrder.orderid)
  return orderid_;
}
inline void SeatFoodOrder::set_orderid(::google::protobuf::int32 value) {
  set_has_orderid();
  orderid_ = value;
  // @@protoc_insertion_point(field_set:sg.SeatFoodOrder.orderid)
}

// required .sg.FOOD_ORDER_TYPE order_type = 4;
inline bool SeatFoodOrder::has_order_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SeatFoodOrder::set_has_order_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SeatFoodOrder::clear_has_order_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SeatFoodOrder::clear_order_type() {
  order_type_ = 0;
  clear_has_order_type();
}
inline ::sg::FOOD_ORDER_TYPE SeatFoodOrder::order_type() const {
  // @@protoc_insertion_point(field_get:sg.SeatFoodOrder.order_type)
  return static_cast< ::sg::FOOD_ORDER_TYPE >(order_type_);
}
inline void SeatFoodOrder::set_order_type(::sg::FOOD_ORDER_TYPE value) {
  assert(::sg::FOOD_ORDER_TYPE_IsValid(value));
  set_has_order_type();
  order_type_ = value;
  // @@protoc_insertion_point(field_set:sg.SeatFoodOrder.order_type)
}

// required .sg.FOOD_ORDER_STATE order_state = 5;
inline bool SeatFoodOrder::has_order_state() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SeatFoodOrder::set_has_order_state() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SeatFoodOrder::clear_has_order_state() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SeatFoodOrder::clear_order_state() {
  order_state_ = -1;
  clear_has_order_state();
}
inline ::sg::FOOD_ORDER_STATE SeatFoodOrder::order_state() const {
  // @@protoc_insertion_point(field_get:sg.SeatFoodOrder.order_state)
  return static_cast< ::sg::FOOD_ORDER_STATE >(order_state_);
}
inline void SeatFoodOrder::set_order_state(::sg::FOOD_ORDER_STATE value) {
  assert(::sg::FOOD_ORDER_STATE_IsValid(value));
  set_has_order_state();
  order_state_ = value;
  // @@protoc_insertion_point(field_set:sg.SeatFoodOrder.order_state)
}

// required int32 npcid = 6;
inline bool SeatFoodOrder::has_npcid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SeatFoodOrder::set_has_npcid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SeatFoodOrder::clear_has_npcid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SeatFoodOrder::clear_npcid() {
  npcid_ = 0;
  clear_has_npcid();
}
inline ::google::protobuf::int32 SeatFoodOrder::npcid() const {
  // @@protoc_insertion_point(field_get:sg.SeatFoodOrder.npcid)
  return npcid_;
}
inline void SeatFoodOrder::set_npcid(::google::protobuf::int32 value) {
  set_has_npcid();
  npcid_ = value;
  // @@protoc_insertion_point(field_set:sg.SeatFoodOrder.npcid)
}

// optional int32 foodfilterid = 11;
inline bool SeatFoodOrder::has_foodfilterid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SeatFoodOrder::set_has_foodfilterid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SeatFoodOrder::clear_has_foodfilterid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SeatFoodOrder::clear_foodfilterid() {
  foodfilterid_ = 0;
  clear_has_foodfilterid();
}
inline ::google::protobuf::int32 SeatFoodOrder::foodfilterid() const {
  // @@protoc_insertion_point(field_get:sg.SeatFoodOrder.foodfilterid)
  return foodfilterid_;
}
inline void SeatFoodOrder::set_foodfilterid(::google::protobuf::int32 value) {
  set_has_foodfilterid();
  foodfilterid_ = value;
  // @@protoc_insertion_point(field_set:sg.SeatFoodOrder.foodfilterid)
}

// optional int32 recipeid = 12;
inline bool SeatFoodOrder::has_recipeid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SeatFoodOrder::set_has_recipeid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SeatFoodOrder::clear_has_recipeid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SeatFoodOrder::clear_recipeid() {
  recipeid_ = 0;
  clear_has_recipeid();
}
inline ::google::protobuf::int32 SeatFoodOrder::recipeid() const {
  // @@protoc_insertion_point(field_get:sg.SeatFoodOrder.recipeid)
  return recipeid_;
}
inline void SeatFoodOrder::set_recipeid(::google::protobuf::int32 value) {
  set_has_recipeid();
  recipeid_ = value;
  // @@protoc_insertion_point(field_set:sg.SeatFoodOrder.recipeid)
}

// optional int32 itemid = 13;
inline bool SeatFoodOrder::has_itemid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SeatFoodOrder::set_has_itemid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SeatFoodOrder::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SeatFoodOrder::clear_itemid() {
  itemid_ = 0;
  clear_has_itemid();
}
inline ::google::protobuf::int32 SeatFoodOrder::itemid() const {
  // @@protoc_insertion_point(field_get:sg.SeatFoodOrder.itemid)
  return itemid_;
}
inline void SeatFoodOrder::set_itemid(::google::protobuf::int32 value) {
  set_has_itemid();
  itemid_ = value;
  // @@protoc_insertion_point(field_set:sg.SeatFoodOrder.itemid)
}

// optional int32 star = 21;
inline bool SeatFoodOrder::has_star() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SeatFoodOrder::set_has_star() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SeatFoodOrder::clear_has_star() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SeatFoodOrder::clear_star() {
  star_ = 0;
  clear_has_star();
}
inline ::google::protobuf::int32 SeatFoodOrder::star() const {
  // @@protoc_insertion_point(field_get:sg.SeatFoodOrder.star)
  return star_;
}
inline void SeatFoodOrder::set_star(::google::protobuf::int32 value) {
  set_has_star();
  star_ = value;
  // @@protoc_insertion_point(field_set:sg.SeatFoodOrder.star)
}

// optional int32 gather_gold = 22;
inline bool SeatFoodOrder::has_gather_gold() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SeatFoodOrder::set_has_gather_gold() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SeatFoodOrder::clear_has_gather_gold() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SeatFoodOrder::clear_gather_gold() {
  gather_gold_ = 0;
  clear_has_gather_gold();
}
inline ::google::protobuf::int32 SeatFoodOrder::gather_gold() const {
  // @@protoc_insertion_point(field_get:sg.SeatFoodOrder.gather_gold)
  return gather_gold_;
}
inline void SeatFoodOrder::set_gather_gold(::google::protobuf::int32 value) {
  set_has_gather_gold();
  gather_gold_ = value;
  // @@protoc_insertion_point(field_set:sg.SeatFoodOrder.gather_gold)
}

// optional int32 gather_satisfaction = 23;
inline bool SeatFoodOrder::has_gather_satisfaction() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SeatFoodOrder::set_has_gather_satisfaction() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SeatFoodOrder::clear_has_gather_satisfaction() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SeatFoodOrder::clear_gather_satisfaction() {
  gather_satisfaction_ = 0;
  clear_has_gather_satisfaction();
}
inline ::google::protobuf::int32 SeatFoodOrder::gather_satisfaction() const {
  // @@protoc_insertion_point(field_get:sg.SeatFoodOrder.gather_satisfaction)
  return gather_satisfaction_;
}
inline void SeatFoodOrder::set_gather_satisfaction(::google::protobuf::int32 value) {
  set_has_gather_satisfaction();
  gather_satisfaction_ = value;
  // @@protoc_insertion_point(field_set:sg.SeatFoodOrder.gather_satisfaction)
}

// optional int32 tip_gold = 24;
inline bool SeatFoodOrder::has_tip_gold() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SeatFoodOrder::set_has_tip_gold() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SeatFoodOrder::clear_has_tip_gold() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SeatFoodOrder::clear_tip_gold() {
  tip_gold_ = 0;
  clear_has_tip_gold();
}
inline ::google::protobuf::int32 SeatFoodOrder::tip_gold() const {
  // @@protoc_insertion_point(field_get:sg.SeatFoodOrder.tip_gold)
  return tip_gold_;
}
inline void SeatFoodOrder::set_tip_gold(::google::protobuf::int32 value) {
  set_has_tip_gold();
  tip_gold_ = value;
  // @@protoc_insertion_point(field_set:sg.SeatFoodOrder.tip_gold)
}

// optional int32 tip_diamond = 25;
inline bool SeatFoodOrder::has_tip_diamond() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SeatFoodOrder::set_has_tip_diamond() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SeatFoodOrder::clear_has_tip_diamond() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SeatFoodOrder::clear_tip_diamond() {
  tip_diamond_ = 0;
  clear_has_tip_diamond();
}
inline ::google::protobuf::int32 SeatFoodOrder::tip_diamond() const {
  // @@protoc_insertion_point(field_get:sg.SeatFoodOrder.tip_diamond)
  return tip_diamond_;
}
inline void SeatFoodOrder::set_tip_diamond(::google::protobuf::int32 value) {
  set_has_tip_diamond();
  tip_diamond_ = value;
  // @@protoc_insertion_point(field_set:sg.SeatFoodOrder.tip_diamond)
}

// -------------------------------------------------------------------

// SeatFoodOrderList

// repeated .sg.SeatFoodOrder list = 1;
inline int SeatFoodOrderList::list_size() const {
  return list_.size();
}
inline void SeatFoodOrderList::clear_list() {
  list_.Clear();
}
inline ::sg::SeatFoodOrder* SeatFoodOrderList::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:sg.SeatFoodOrderList.list)
  return list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::SeatFoodOrder >*
SeatFoodOrderList::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:sg.SeatFoodOrderList.list)
  return &list_;
}
inline const ::sg::SeatFoodOrder& SeatFoodOrderList::list(int index) const {
  // @@protoc_insertion_point(field_get:sg.SeatFoodOrderList.list)
  return list_.Get(index);
}
inline ::sg::SeatFoodOrder* SeatFoodOrderList::add_list() {
  // @@protoc_insertion_point(field_add:sg.SeatFoodOrderList.list)
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::SeatFoodOrder >&
SeatFoodOrderList::list() const {
  // @@protoc_insertion_point(field_list:sg.SeatFoodOrderList.list)
  return list_;
}

// -------------------------------------------------------------------

// SeatMenuFood

// required int32 posid = 1;
inline bool SeatMenuFood::has_posid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SeatMenuFood::set_has_posid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SeatMenuFood::clear_has_posid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SeatMenuFood::clear_posid() {
  posid_ = 0;
  clear_has_posid();
}
inline ::google::protobuf::int32 SeatMenuFood::posid() const {
  // @@protoc_insertion_point(field_get:sg.SeatMenuFood.posid)
  return posid_;
}
inline void SeatMenuFood::set_posid(::google::protobuf::int32 value) {
  set_has_posid();
  posid_ = value;
  // @@protoc_insertion_point(field_set:sg.SeatMenuFood.posid)
}

// optional int32 itemid = 2;
inline bool SeatMenuFood::has_itemid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SeatMenuFood::set_has_itemid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SeatMenuFood::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SeatMenuFood::clear_itemid() {
  itemid_ = 0;
  clear_has_itemid();
}
inline ::google::protobuf::int32 SeatMenuFood::itemid() const {
  // @@protoc_insertion_point(field_get:sg.SeatMenuFood.itemid)
  return itemid_;
}
inline void SeatMenuFood::set_itemid(::google::protobuf::int32 value) {
  set_has_itemid();
  itemid_ = value;
  // @@protoc_insertion_point(field_set:sg.SeatMenuFood.itemid)
}

// -------------------------------------------------------------------

// SeatMenu

// required int32 seatid = 1;
inline bool SeatMenu::has_seatid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SeatMenu::set_has_seatid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SeatMenu::clear_has_seatid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SeatMenu::clear_seatid() {
  seatid_ = 0;
  clear_has_seatid();
}
inline ::google::protobuf::int32 SeatMenu::seatid() const {
  // @@protoc_insertion_point(field_get:sg.SeatMenu.seatid)
  return seatid_;
}
inline void SeatMenu::set_seatid(::google::protobuf::int32 value) {
  set_has_seatid();
  seatid_ = value;
  // @@protoc_insertion_point(field_set:sg.SeatMenu.seatid)
}

// repeated .sg.SeatMenuFood menu_food_list = 2;
inline int SeatMenu::menu_food_list_size() const {
  return menu_food_list_.size();
}
inline void SeatMenu::clear_menu_food_list() {
  menu_food_list_.Clear();
}
inline ::sg::SeatMenuFood* SeatMenu::mutable_menu_food_list(int index) {
  // @@protoc_insertion_point(field_mutable:sg.SeatMenu.menu_food_list)
  return menu_food_list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::SeatMenuFood >*
SeatMenu::mutable_menu_food_list() {
  // @@protoc_insertion_point(field_mutable_list:sg.SeatMenu.menu_food_list)
  return &menu_food_list_;
}
inline const ::sg::SeatMenuFood& SeatMenu::menu_food_list(int index) const {
  // @@protoc_insertion_point(field_get:sg.SeatMenu.menu_food_list)
  return menu_food_list_.Get(index);
}
inline ::sg::SeatMenuFood* SeatMenu::add_menu_food_list() {
  // @@protoc_insertion_point(field_add:sg.SeatMenu.menu_food_list)
  return menu_food_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::SeatMenuFood >&
SeatMenu::menu_food_list() const {
  // @@protoc_insertion_point(field_list:sg.SeatMenu.menu_food_list)
  return menu_food_list_;
}

// -------------------------------------------------------------------

// UserFoodOrderService_FoodOrderRequest

// required .sg.UserFoodOrderService.ORDER_COMMAND cmd = 1;
inline bool UserFoodOrderService_FoodOrderRequest::has_cmd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserFoodOrderService_FoodOrderRequest::set_has_cmd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserFoodOrderService_FoodOrderRequest::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserFoodOrderService_FoodOrderRequest::clear_cmd() {
  cmd_ = 1;
  clear_has_cmd();
}
inline ::sg::UserFoodOrderService_ORDER_COMMAND UserFoodOrderService_FoodOrderRequest::cmd() const {
  // @@protoc_insertion_point(field_get:sg.UserFoodOrderService.FoodOrderRequest.cmd)
  return static_cast< ::sg::UserFoodOrderService_ORDER_COMMAND >(cmd_);
}
inline void UserFoodOrderService_FoodOrderRequest::set_cmd(::sg::UserFoodOrderService_ORDER_COMMAND value) {
  assert(::sg::UserFoodOrderService_ORDER_COMMAND_IsValid(value));
  set_has_cmd();
  cmd_ = value;
  // @@protoc_insertion_point(field_set:sg.UserFoodOrderService.FoodOrderRequest.cmd)
}

// optional .sg.SeatMenu menu = 2;
inline bool UserFoodOrderService_FoodOrderRequest::has_menu() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserFoodOrderService_FoodOrderRequest::set_has_menu() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserFoodOrderService_FoodOrderRequest::clear_has_menu() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserFoodOrderService_FoodOrderRequest::clear_menu() {
  if (menu_ != NULL) menu_->Clear();
  clear_has_menu();
}
inline const ::sg::SeatMenu& UserFoodOrderService_FoodOrderRequest::_internal_menu() const {
  return *menu_;
}
inline const ::sg::SeatMenu& UserFoodOrderService_FoodOrderRequest::menu() const {
  const ::sg::SeatMenu* p = menu_;
  // @@protoc_insertion_point(field_get:sg.UserFoodOrderService.FoodOrderRequest.menu)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::SeatMenu*>(
      &::sg::_SeatMenu_default_instance_);
}
inline ::sg::SeatMenu* UserFoodOrderService_FoodOrderRequest::release_menu() {
  // @@protoc_insertion_point(field_release:sg.UserFoodOrderService.FoodOrderRequest.menu)
  clear_has_menu();
  ::sg::SeatMenu* temp = menu_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  menu_ = NULL;
  return temp;
}
inline ::sg::SeatMenu* UserFoodOrderService_FoodOrderRequest::unsafe_arena_release_menu() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.UserFoodOrderService.FoodOrderRequest.menu)
  clear_has_menu();
  ::sg::SeatMenu* temp = menu_;
  menu_ = NULL;
  return temp;
}
inline ::sg::SeatMenu* UserFoodOrderService_FoodOrderRequest::mutable_menu() {
  set_has_menu();
  if (menu_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::SeatMenu>(GetArenaNoVirtual());
    menu_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.UserFoodOrderService.FoodOrderRequest.menu)
  return menu_;
}
inline void UserFoodOrderService_FoodOrderRequest::set_allocated_menu(::sg::SeatMenu* menu) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete menu_;
  }
  if (menu) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(menu);
    if (message_arena != submessage_arena) {
      menu = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, menu, submessage_arena);
    }
    set_has_menu();
  } else {
    clear_has_menu();
  }
  menu_ = menu;
  // @@protoc_insertion_point(field_set_allocated:sg.UserFoodOrderService.FoodOrderRequest.menu)
}

// -------------------------------------------------------------------

// UserFoodOrderService_FoodOrderResponse

// required int32 result = 1;
inline bool UserFoodOrderService_FoodOrderResponse::has_result() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserFoodOrderService_FoodOrderResponse::set_has_result() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserFoodOrderService_FoodOrderResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserFoodOrderService_FoodOrderResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 UserFoodOrderService_FoodOrderResponse::result() const {
  // @@protoc_insertion_point(field_get:sg.UserFoodOrderService.FoodOrderResponse.result)
  return result_;
}
inline void UserFoodOrderService_FoodOrderResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:sg.UserFoodOrderService.FoodOrderResponse.result)
}

// optional .sg.SeatFoodOrderList order_list = 2;
inline bool UserFoodOrderService_FoodOrderResponse::has_order_list() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserFoodOrderService_FoodOrderResponse::set_has_order_list() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserFoodOrderService_FoodOrderResponse::clear_has_order_list() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserFoodOrderService_FoodOrderResponse::clear_order_list() {
  if (order_list_ != NULL) order_list_->Clear();
  clear_has_order_list();
}
inline const ::sg::SeatFoodOrderList& UserFoodOrderService_FoodOrderResponse::_internal_order_list() const {
  return *order_list_;
}
inline const ::sg::SeatFoodOrderList& UserFoodOrderService_FoodOrderResponse::order_list() const {
  const ::sg::SeatFoodOrderList* p = order_list_;
  // @@protoc_insertion_point(field_get:sg.UserFoodOrderService.FoodOrderResponse.order_list)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::SeatFoodOrderList*>(
      &::sg::_SeatFoodOrderList_default_instance_);
}
inline ::sg::SeatFoodOrderList* UserFoodOrderService_FoodOrderResponse::release_order_list() {
  // @@protoc_insertion_point(field_release:sg.UserFoodOrderService.FoodOrderResponse.order_list)
  clear_has_order_list();
  ::sg::SeatFoodOrderList* temp = order_list_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  order_list_ = NULL;
  return temp;
}
inline ::sg::SeatFoodOrderList* UserFoodOrderService_FoodOrderResponse::unsafe_arena_release_order_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.UserFoodOrderService.FoodOrderResponse.order_list)
  clear_has_order_list();
  ::sg::SeatFoodOrderList* temp = order_list_;
  order_list_ = NULL;
  return temp;
}
inline ::sg::SeatFoodOrderList* UserFoodOrderService_FoodOrderResponse::mutable_order_list() {
  set_has_order_list();
  if (order_list_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::SeatFoodOrderList>(GetArenaNoVirtual());
    order_list_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.UserFoodOrderService.FoodOrderResponse.order_list)
  return order_list_;
}
inline void UserFoodOrderService_FoodOrderResponse::set_allocated_order_list(::sg::SeatFoodOrderList* order_list) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete order_list_;
  }
  if (order_list) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(order_list);
    if (message_arena != submessage_arena) {
      order_list = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, order_list, submessage_arena);
    }
    set_has_order_list();
  } else {
    clear_has_order_list();
  }
  order_list_ = order_list;
  // @@protoc_insertion_point(field_set_allocated:sg.UserFoodOrderService.FoodOrderResponse.order_list)
}

// optional .sg.Reward out_drop = 3;
inline bool UserFoodOrderService_FoodOrderResponse::has_out_drop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserFoodOrderService_FoodOrderResponse::set_has_out_drop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserFoodOrderService_FoodOrderResponse::clear_has_out_drop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::sg::Reward& UserFoodOrderService_FoodOrderResponse::_internal_out_drop() const {
  return *out_drop_;
}
inline const ::sg::Reward& UserFoodOrderService_FoodOrderResponse::out_drop() const {
  const ::sg::Reward* p = out_drop_;
  // @@protoc_insertion_point(field_get:sg.UserFoodOrderService.FoodOrderResponse.out_drop)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::Reward*>(
      &::sg::_Reward_default_instance_);
}
inline ::sg::Reward* UserFoodOrderService_FoodOrderResponse::release_out_drop() {
  // @@protoc_insertion_point(field_release:sg.UserFoodOrderService.FoodOrderResponse.out_drop)
  clear_has_out_drop();
  ::sg::Reward* temp = out_drop_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  out_drop_ = NULL;
  return temp;
}
inline ::sg::Reward* UserFoodOrderService_FoodOrderResponse::unsafe_arena_release_out_drop() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.UserFoodOrderService.FoodOrderResponse.out_drop)
  clear_has_out_drop();
  ::sg::Reward* temp = out_drop_;
  out_drop_ = NULL;
  return temp;
}
inline ::sg::Reward* UserFoodOrderService_FoodOrderResponse::mutable_out_drop() {
  set_has_out_drop();
  if (out_drop_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::Reward>(GetArenaNoVirtual());
    out_drop_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.UserFoodOrderService.FoodOrderResponse.out_drop)
  return out_drop_;
}
inline void UserFoodOrderService_FoodOrderResponse::set_allocated_out_drop(::sg::Reward* out_drop) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(out_drop_);
  }
  if (out_drop) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(out_drop)->GetArena();
    if (message_arena != submessage_arena) {
      out_drop = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, out_drop, submessage_arena);
    }
    set_has_out_drop();
  } else {
    clear_has_out_drop();
  }
  out_drop_ = out_drop;
  // @@protoc_insertion_point(field_set_allocated:sg.UserFoodOrderService.FoodOrderResponse.out_drop)
}

// optional int32 star = 4;
inline bool UserFoodOrderService_FoodOrderResponse::has_star() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserFoodOrderService_FoodOrderResponse::set_has_star() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserFoodOrderService_FoodOrderResponse::clear_has_star() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserFoodOrderService_FoodOrderResponse::clear_star() {
  star_ = 0;
  clear_has_star();
}
inline ::google::protobuf::int32 UserFoodOrderService_FoodOrderResponse::star() const {
  // @@protoc_insertion_point(field_get:sg.UserFoodOrderService.FoodOrderResponse.star)
  return star_;
}
inline void UserFoodOrderService_FoodOrderResponse::set_star(::google::protobuf::int32 value) {
  set_has_star();
  star_ = value;
  // @@protoc_insertion_point(field_set:sg.UserFoodOrderService.FoodOrderResponse.star)
}

// optional int32 diy_recipeid = 11;
inline bool UserFoodOrderService_FoodOrderResponse::has_diy_recipeid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserFoodOrderService_FoodOrderResponse::set_has_diy_recipeid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserFoodOrderService_FoodOrderResponse::clear_has_diy_recipeid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserFoodOrderService_FoodOrderResponse::clear_diy_recipeid() {
  diy_recipeid_ = 0;
  clear_has_diy_recipeid();
}
inline ::google::protobuf::int32 UserFoodOrderService_FoodOrderResponse::diy_recipeid() const {
  // @@protoc_insertion_point(field_get:sg.UserFoodOrderService.FoodOrderResponse.diy_recipeid)
  return diy_recipeid_;
}
inline void UserFoodOrderService_FoodOrderResponse::set_diy_recipeid(::google::protobuf::int32 value) {
  set_has_diy_recipeid();
  diy_recipeid_ = value;
  // @@protoc_insertion_point(field_set:sg.UserFoodOrderService.FoodOrderResponse.diy_recipeid)
}

// -------------------------------------------------------------------

// UserFoodOrderService

// optional .sg.UserFoodOrderService.FoodOrderRequest req = 1;
inline bool UserFoodOrderService::has_req() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserFoodOrderService::set_has_req() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserFoodOrderService::clear_has_req() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserFoodOrderService::clear_req() {
  if (req_ != NULL) req_->Clear();
  clear_has_req();
}
inline const ::sg::UserFoodOrderService_FoodOrderRequest& UserFoodOrderService::_internal_req() const {
  return *req_;
}
inline const ::sg::UserFoodOrderService_FoodOrderRequest& UserFoodOrderService::req() const {
  const ::sg::UserFoodOrderService_FoodOrderRequest* p = req_;
  // @@protoc_insertion_point(field_get:sg.UserFoodOrderService.req)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::UserFoodOrderService_FoodOrderRequest*>(
      &::sg::_UserFoodOrderService_FoodOrderRequest_default_instance_);
}
inline ::sg::UserFoodOrderService_FoodOrderRequest* UserFoodOrderService::release_req() {
  // @@protoc_insertion_point(field_release:sg.UserFoodOrderService.req)
  clear_has_req();
  ::sg::UserFoodOrderService_FoodOrderRequest* temp = req_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  req_ = NULL;
  return temp;
}
inline ::sg::UserFoodOrderService_FoodOrderRequest* UserFoodOrderService::unsafe_arena_release_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.UserFoodOrderService.req)
  clear_has_req();
  ::sg::UserFoodOrderService_FoodOrderRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline ::sg::UserFoodOrderService_FoodOrderRequest* UserFoodOrderService::mutable_req() {
  set_has_req();
  if (req_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::UserFoodOrderService_FoodOrderRequest>(GetArenaNoVirtual());
    req_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.UserFoodOrderService.req)
  return req_;
}
inline void UserFoodOrderService::set_allocated_req(::sg::UserFoodOrderService_FoodOrderRequest* req) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete req_;
  }
  if (req) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(req);
    if (message_arena != submessage_arena) {
      req = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, req, submessage_arena);
    }
    set_has_req();
  } else {
    clear_has_req();
  }
  req_ = req;
  // @@protoc_insertion_point(field_set_allocated:sg.UserFoodOrderService.req)
}

// optional .sg.UserFoodOrderService.FoodOrderResponse resp = 2;
inline bool UserFoodOrderService::has_resp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserFoodOrderService::set_has_resp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserFoodOrderService::clear_has_resp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserFoodOrderService::clear_resp() {
  if (resp_ != NULL) resp_->Clear();
  clear_has_resp();
}
inline const ::sg::UserFoodOrderService_FoodOrderResponse& UserFoodOrderService::_internal_resp() const {
  return *resp_;
}
inline const ::sg::UserFoodOrderService_FoodOrderResponse& UserFoodOrderService::resp() const {
  const ::sg::UserFoodOrderService_FoodOrderResponse* p = resp_;
  // @@protoc_insertion_point(field_get:sg.UserFoodOrderService.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::UserFoodOrderService_FoodOrderResponse*>(
      &::sg::_UserFoodOrderService_FoodOrderResponse_default_instance_);
}
inline ::sg::UserFoodOrderService_FoodOrderResponse* UserFoodOrderService::release_resp() {
  // @@protoc_insertion_point(field_release:sg.UserFoodOrderService.resp)
  clear_has_resp();
  ::sg::UserFoodOrderService_FoodOrderResponse* temp = resp_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  resp_ = NULL;
  return temp;
}
inline ::sg::UserFoodOrderService_FoodOrderResponse* UserFoodOrderService::unsafe_arena_release_resp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.UserFoodOrderService.resp)
  clear_has_resp();
  ::sg::UserFoodOrderService_FoodOrderResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline ::sg::UserFoodOrderService_FoodOrderResponse* UserFoodOrderService::mutable_resp() {
  set_has_resp();
  if (resp_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::UserFoodOrderService_FoodOrderResponse>(GetArenaNoVirtual());
    resp_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.UserFoodOrderService.resp)
  return resp_;
}
inline void UserFoodOrderService::set_allocated_resp(::sg::UserFoodOrderService_FoodOrderResponse* resp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete resp_;
  }
  if (resp) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(resp);
    if (message_arena != submessage_arena) {
      resp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, resp, submessage_arena);
    }
    set_has_resp();
  } else {
    clear_has_resp();
  }
  resp_ = resp;
  // @@protoc_insertion_point(field_set_allocated:sg.UserFoodOrderService.resp)
}

// -------------------------------------------------------------------

// SeatFoodOrderStateNotify

// required .sg.SeatFoodOrderList order_list = 1;
inline bool SeatFoodOrderStateNotify::has_order_list() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SeatFoodOrderStateNotify::set_has_order_list() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SeatFoodOrderStateNotify::clear_has_order_list() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SeatFoodOrderStateNotify::clear_order_list() {
  if (order_list_ != NULL) order_list_->Clear();
  clear_has_order_list();
}
inline const ::sg::SeatFoodOrderList& SeatFoodOrderStateNotify::_internal_order_list() const {
  return *order_list_;
}
inline const ::sg::SeatFoodOrderList& SeatFoodOrderStateNotify::order_list() const {
  const ::sg::SeatFoodOrderList* p = order_list_;
  // @@protoc_insertion_point(field_get:sg.SeatFoodOrderStateNotify.order_list)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::SeatFoodOrderList*>(
      &::sg::_SeatFoodOrderList_default_instance_);
}
inline ::sg::SeatFoodOrderList* SeatFoodOrderStateNotify::release_order_list() {
  // @@protoc_insertion_point(field_release:sg.SeatFoodOrderStateNotify.order_list)
  clear_has_order_list();
  ::sg::SeatFoodOrderList* temp = order_list_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  order_list_ = NULL;
  return temp;
}
inline ::sg::SeatFoodOrderList* SeatFoodOrderStateNotify::unsafe_arena_release_order_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.SeatFoodOrderStateNotify.order_list)
  clear_has_order_list();
  ::sg::SeatFoodOrderList* temp = order_list_;
  order_list_ = NULL;
  return temp;
}
inline ::sg::SeatFoodOrderList* SeatFoodOrderStateNotify::mutable_order_list() {
  set_has_order_list();
  if (order_list_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::SeatFoodOrderList>(GetArenaNoVirtual());
    order_list_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.SeatFoodOrderStateNotify.order_list)
  return order_list_;
}
inline void SeatFoodOrderStateNotify::set_allocated_order_list(::sg::SeatFoodOrderList* order_list) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete order_list_;
  }
  if (order_list) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(order_list);
    if (message_arena != submessage_arena) {
      order_list = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, order_list, submessage_arena);
    }
    set_has_order_list();
  } else {
    clear_has_order_list();
  }
  order_list_ = order_list;
  // @@protoc_insertion_point(field_set_allocated:sg.SeatFoodOrderStateNotify.order_list)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace sg

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::sg::HarborNpc_NPC_STATE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::HarborNpc_NPC_STATE>() {
  return ::sg::HarborNpc_NPC_STATE_descriptor();
}
template <> struct is_proto_enum< ::sg::UserHarborNpcService_NPC_COMMAND> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::UserHarborNpcService_NPC_COMMAND>() {
  return ::sg::UserHarborNpcService_NPC_COMMAND_descriptor();
}
template <> struct is_proto_enum< ::sg::FoodStyle_FOOD_ATTR_ID> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::FoodStyle_FOOD_ATTR_ID>() {
  return ::sg::FoodStyle_FOOD_ATTR_ID_descriptor();
}
template <> struct is_proto_enum< ::sg::UserFoodOrderService_ORDER_COMMAND> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::UserFoodOrderService_ORDER_COMMAND>() {
  return ::sg::UserFoodOrderService_ORDER_COMMAND_descriptor();
}
template <> struct is_proto_enum< ::sg::HARBOR_STATE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::HARBOR_STATE>() {
  return ::sg::HARBOR_STATE_descriptor();
}
template <> struct is_proto_enum< ::sg::HARBOR_NPC_TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::HARBOR_NPC_TYPE>() {
  return ::sg::HARBOR_NPC_TYPE_descriptor();
}
template <> struct is_proto_enum< ::sg::RESIDENT_TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::RESIDENT_TYPE>() {
  return ::sg::RESIDENT_TYPE_descriptor();
}
template <> struct is_proto_enum< ::sg::CUSTOMER_OCCUPATION> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::CUSTOMER_OCCUPATION>() {
  return ::sg::CUSTOMER_OCCUPATION_descriptor();
}
template <> struct is_proto_enum< ::sg::FOOD_RECIPE_TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::FOOD_RECIPE_TYPE>() {
  return ::sg::FOOD_RECIPE_TYPE_descriptor();
}
template <> struct is_proto_enum< ::sg::FOOD_ORDER_TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::FOOD_ORDER_TYPE>() {
  return ::sg::FOOD_ORDER_TYPE_descriptor();
}
template <> struct is_proto_enum< ::sg::FOOD_ORDER_STATE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::FOOD_ORDER_STATE>() {
  return ::sg::FOOD_ORDER_STATE_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_UserHarbour_2eproto
