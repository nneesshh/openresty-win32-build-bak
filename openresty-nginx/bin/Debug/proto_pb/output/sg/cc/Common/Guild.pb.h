// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Guild.proto

#ifndef PROTOBUF_INCLUDED_Guild_2eproto
#define PROTOBUF_INCLUDED_Guild_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "BaseStruct.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_Guild_2eproto 

namespace protobuf_Guild_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[18];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_Guild_2eproto
namespace sg {
class DonateItem;
class DonateItemDefaultTypeInternal;
extern DonateItemDefaultTypeInternal _DonateItem_default_instance_;
class DonateItemList;
class DonateItemListDefaultTypeInternal;
extern DonateItemListDefaultTypeInternal _DonateItemList_default_instance_;
class GameGuildTrackNotify;
class GameGuildTrackNotifyDefaultTypeInternal;
extern GameGuildTrackNotifyDefaultTypeInternal _GameGuildTrackNotify_default_instance_;
class GuildBuilding;
class GuildBuildingDefaultTypeInternal;
extern GuildBuildingDefaultTypeInternal _GuildBuilding_default_instance_;
class GuildBuildingList;
class GuildBuildingListDefaultTypeInternal;
extern GuildBuildingListDefaultTypeInternal _GuildBuildingList_default_instance_;
class GuildData;
class GuildDataDefaultTypeInternal;
extern GuildDataDefaultTypeInternal _GuildData_default_instance_;
class GuildDataList;
class GuildDataListDefaultTypeInternal;
extern GuildDataListDefaultTypeInternal _GuildDataList_default_instance_;
class GuildService;
class GuildServiceDefaultTypeInternal;
extern GuildServiceDefaultTypeInternal _GuildService_default_instance_;
class GuildService_GuildRequest;
class GuildService_GuildRequestDefaultTypeInternal;
extern GuildService_GuildRequestDefaultTypeInternal _GuildService_GuildRequest_default_instance_;
class GuildService_GuildResponse;
class GuildService_GuildResponseDefaultTypeInternal;
extern GuildService_GuildResponseDefaultTypeInternal _GuildService_GuildResponse_default_instance_;
class GuildSignin;
class GuildSigninDefaultTypeInternal;
extern GuildSigninDefaultTypeInternal _GuildSignin_default_instance_;
class GuildSigninList;
class GuildSigninListDefaultTypeInternal;
extern GuildSigninListDefaultTypeInternal _GuildSigninList_default_instance_;
class GuildStoreItem;
class GuildStoreItemDefaultTypeInternal;
extern GuildStoreItemDefaultTypeInternal _GuildStoreItem_default_instance_;
class GuildStoreItemList;
class GuildStoreItemListDefaultTypeInternal;
extern GuildStoreItemListDefaultTypeInternal _GuildStoreItemList_default_instance_;
class GuildTrack;
class GuildTrackDefaultTypeInternal;
extern GuildTrackDefaultTypeInternal _GuildTrack_default_instance_;
class GuildTrackList;
class GuildTrackListDefaultTypeInternal;
extern GuildTrackListDefaultTypeInternal _GuildTrackList_default_instance_;
class GuildUserData;
class GuildUserDataDefaultTypeInternal;
extern GuildUserDataDefaultTypeInternal _GuildUserData_default_instance_;
class GuildUserDataList;
class GuildUserDataListDefaultTypeInternal;
extern GuildUserDataListDefaultTypeInternal _GuildUserDataList_default_instance_;
}  // namespace sg
namespace google {
namespace protobuf {
template<> ::sg::DonateItem* Arena::CreateMaybeMessage<::sg::DonateItem>(Arena*);
template<> ::sg::DonateItemList* Arena::CreateMaybeMessage<::sg::DonateItemList>(Arena*);
template<> ::sg::GameGuildTrackNotify* Arena::CreateMaybeMessage<::sg::GameGuildTrackNotify>(Arena*);
template<> ::sg::GuildBuilding* Arena::CreateMaybeMessage<::sg::GuildBuilding>(Arena*);
template<> ::sg::GuildBuildingList* Arena::CreateMaybeMessage<::sg::GuildBuildingList>(Arena*);
template<> ::sg::GuildData* Arena::CreateMaybeMessage<::sg::GuildData>(Arena*);
template<> ::sg::GuildDataList* Arena::CreateMaybeMessage<::sg::GuildDataList>(Arena*);
template<> ::sg::GuildService* Arena::CreateMaybeMessage<::sg::GuildService>(Arena*);
template<> ::sg::GuildService_GuildRequest* Arena::CreateMaybeMessage<::sg::GuildService_GuildRequest>(Arena*);
template<> ::sg::GuildService_GuildResponse* Arena::CreateMaybeMessage<::sg::GuildService_GuildResponse>(Arena*);
template<> ::sg::GuildSignin* Arena::CreateMaybeMessage<::sg::GuildSignin>(Arena*);
template<> ::sg::GuildSigninList* Arena::CreateMaybeMessage<::sg::GuildSigninList>(Arena*);
template<> ::sg::GuildStoreItem* Arena::CreateMaybeMessage<::sg::GuildStoreItem>(Arena*);
template<> ::sg::GuildStoreItemList* Arena::CreateMaybeMessage<::sg::GuildStoreItemList>(Arena*);
template<> ::sg::GuildTrack* Arena::CreateMaybeMessage<::sg::GuildTrack>(Arena*);
template<> ::sg::GuildTrackList* Arena::CreateMaybeMessage<::sg::GuildTrackList>(Arena*);
template<> ::sg::GuildUserData* Arena::CreateMaybeMessage<::sg::GuildUserData>(Arena*);
template<> ::sg::GuildUserDataList* Arena::CreateMaybeMessage<::sg::GuildUserDataList>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace sg {

enum GuildBuilding_BUILDING_TYPE {
  GuildBuilding_BUILDING_TYPE_TECH = 1,
  GuildBuilding_BUILDING_TYPE_SQUARE = 2,
  GuildBuilding_BUILDING_TYPE_SHOP = 3
};
bool GuildBuilding_BUILDING_TYPE_IsValid(int value);
const GuildBuilding_BUILDING_TYPE GuildBuilding_BUILDING_TYPE_BUILDING_TYPE_MIN = GuildBuilding_BUILDING_TYPE_TECH;
const GuildBuilding_BUILDING_TYPE GuildBuilding_BUILDING_TYPE_BUILDING_TYPE_MAX = GuildBuilding_BUILDING_TYPE_SHOP;
const int GuildBuilding_BUILDING_TYPE_BUILDING_TYPE_ARRAYSIZE = GuildBuilding_BUILDING_TYPE_BUILDING_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* GuildBuilding_BUILDING_TYPE_descriptor();
inline const ::std::string& GuildBuilding_BUILDING_TYPE_Name(GuildBuilding_BUILDING_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    GuildBuilding_BUILDING_TYPE_descriptor(), value);
}
inline bool GuildBuilding_BUILDING_TYPE_Parse(
    const ::std::string& name, GuildBuilding_BUILDING_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GuildBuilding_BUILDING_TYPE>(
    GuildBuilding_BUILDING_TYPE_descriptor(), name, value);
}
enum GuildBuilding_BUILDING_STATE {
  GuildBuilding_BUILDING_STATE_IDLE = 0,
  GuildBuilding_BUILDING_STATE_BUSY = 1,
  GuildBuilding_BUILDING_STATE_READY = 2
};
bool GuildBuilding_BUILDING_STATE_IsValid(int value);
const GuildBuilding_BUILDING_STATE GuildBuilding_BUILDING_STATE_BUILDING_STATE_MIN = GuildBuilding_BUILDING_STATE_IDLE;
const GuildBuilding_BUILDING_STATE GuildBuilding_BUILDING_STATE_BUILDING_STATE_MAX = GuildBuilding_BUILDING_STATE_READY;
const int GuildBuilding_BUILDING_STATE_BUILDING_STATE_ARRAYSIZE = GuildBuilding_BUILDING_STATE_BUILDING_STATE_MAX + 1;

const ::google::protobuf::EnumDescriptor* GuildBuilding_BUILDING_STATE_descriptor();
inline const ::std::string& GuildBuilding_BUILDING_STATE_Name(GuildBuilding_BUILDING_STATE value) {
  return ::google::protobuf::internal::NameOfEnum(
    GuildBuilding_BUILDING_STATE_descriptor(), value);
}
inline bool GuildBuilding_BUILDING_STATE_Parse(
    const ::std::string& name, GuildBuilding_BUILDING_STATE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GuildBuilding_BUILDING_STATE>(
    GuildBuilding_BUILDING_STATE_descriptor(), name, value);
}
enum GuildSignin_STATE {
  GuildSignin_STATE_NOT_SIGNIN = 0,
  GuildSignin_STATE_SIGNIN = 1,
  GuildSignin_STATE_ACCEPT = 2
};
bool GuildSignin_STATE_IsValid(int value);
const GuildSignin_STATE GuildSignin_STATE_STATE_MIN = GuildSignin_STATE_NOT_SIGNIN;
const GuildSignin_STATE GuildSignin_STATE_STATE_MAX = GuildSignin_STATE_ACCEPT;
const int GuildSignin_STATE_STATE_ARRAYSIZE = GuildSignin_STATE_STATE_MAX + 1;

const ::google::protobuf::EnumDescriptor* GuildSignin_STATE_descriptor();
inline const ::std::string& GuildSignin_STATE_Name(GuildSignin_STATE value) {
  return ::google::protobuf::internal::NameOfEnum(
    GuildSignin_STATE_descriptor(), value);
}
inline bool GuildSignin_STATE_Parse(
    const ::std::string& name, GuildSignin_STATE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GuildSignin_STATE>(
    GuildSignin_STATE_descriptor(), name, value);
}
enum GuildTrack_TRACK_ACTION_TYPE {
  GuildTrack_TRACK_ACTION_TYPE_JOIN = 1,
  GuildTrack_TRACK_ACTION_TYPE_QUIT = 2,
  GuildTrack_TRACK_ACTION_TYPE_DONATE = 3,
  GuildTrack_TRACK_ACTION_TYPE_ACCEPT = 11,
  GuildTrack_TRACK_ACTION_TYPE_REJECT = 12,
  GuildTrack_TRACK_ACTION_TYPE_KICK = 13,
  GuildTrack_TRACK_ACTION_TYPE_APPOINT = 14,
  GuildTrack_TRACK_ACTION_TYPE_SELECT_NEW_LEADER = 15,
  GuildTrack_TRACK_ACTION_TYPE_BUILDING_UPGRADE_START = 21,
  GuildTrack_TRACK_ACTION_TYPE_BUILDING_UPGRADE_OVER = 22
};
bool GuildTrack_TRACK_ACTION_TYPE_IsValid(int value);
const GuildTrack_TRACK_ACTION_TYPE GuildTrack_TRACK_ACTION_TYPE_TRACK_ACTION_TYPE_MIN = GuildTrack_TRACK_ACTION_TYPE_JOIN;
const GuildTrack_TRACK_ACTION_TYPE GuildTrack_TRACK_ACTION_TYPE_TRACK_ACTION_TYPE_MAX = GuildTrack_TRACK_ACTION_TYPE_BUILDING_UPGRADE_OVER;
const int GuildTrack_TRACK_ACTION_TYPE_TRACK_ACTION_TYPE_ARRAYSIZE = GuildTrack_TRACK_ACTION_TYPE_TRACK_ACTION_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* GuildTrack_TRACK_ACTION_TYPE_descriptor();
inline const ::std::string& GuildTrack_TRACK_ACTION_TYPE_Name(GuildTrack_TRACK_ACTION_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    GuildTrack_TRACK_ACTION_TYPE_descriptor(), value);
}
inline bool GuildTrack_TRACK_ACTION_TYPE_Parse(
    const ::std::string& name, GuildTrack_TRACK_ACTION_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GuildTrack_TRACK_ACTION_TYPE>(
    GuildTrack_TRACK_ACTION_TYPE_descriptor(), name, value);
}
enum GuildService_GUILD_COMMAND {
  GuildService_GUILD_COMMAND_CREATE = 1,
  GuildService_GUILD_COMMAND_UPGRADE = 2,
  GuildService_GUILD_COMMAND_MODIFY = 3,
  GuildService_GUILD_COMMAND_DISBAND = 4,
  GuildService_GUILD_COMMAND_REFRESH_CANDIDATES = 5,
  GuildService_GUILD_COMMAND_JOIN = 11,
  GuildService_GUILD_COMMAND_QUIT = 12,
  GuildService_GUILD_COMMAND_DONATE = 13,
  GuildService_GUILD_COMMAND_MANAGE_ACCEPT = 21,
  GuildService_GUILD_COMMAND_MANAGE_REJECT = 22,
  GuildService_GUILD_COMMAND_MANAGE_KICK = 23,
  GuildService_GUILD_COMMAND_MANAGE_APPOINT = 24,
  GuildService_GUILD_COMMAND_QUERY_ALL = 31,
  GuildService_GUILD_COMMAND_QUERY_ONE = 32,
  GuildService_GUILD_COMMAND_QUERY_TRACK = 33,
  GuildService_GUILD_COMMAND_QUERY_SIGNIN = 41,
  GuildService_GUILD_COMMAND_ACCEPT_SIGNIN = 42,
  GuildService_GUILD_COMMAND_QUERY_STORE = 51,
  GuildService_GUILD_COMMAND_QUERY_BUILDING = 61,
  GuildService_GUILD_COMMAND_BUILD_ONCE = 62
};
bool GuildService_GUILD_COMMAND_IsValid(int value);
const GuildService_GUILD_COMMAND GuildService_GUILD_COMMAND_GUILD_COMMAND_MIN = GuildService_GUILD_COMMAND_CREATE;
const GuildService_GUILD_COMMAND GuildService_GUILD_COMMAND_GUILD_COMMAND_MAX = GuildService_GUILD_COMMAND_BUILD_ONCE;
const int GuildService_GUILD_COMMAND_GUILD_COMMAND_ARRAYSIZE = GuildService_GUILD_COMMAND_GUILD_COMMAND_MAX + 1;

const ::google::protobuf::EnumDescriptor* GuildService_GUILD_COMMAND_descriptor();
inline const ::std::string& GuildService_GUILD_COMMAND_Name(GuildService_GUILD_COMMAND value) {
  return ::google::protobuf::internal::NameOfEnum(
    GuildService_GUILD_COMMAND_descriptor(), value);
}
inline bool GuildService_GUILD_COMMAND_Parse(
    const ::std::string& name, GuildService_GUILD_COMMAND* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GuildService_GUILD_COMMAND>(
    GuildService_GUILD_COMMAND_descriptor(), name, value);
}
enum GUILD_STATE {
  GUILD_PREPARE = 1,
  GUILD_READY = 2,
  GUILD_DISBANDED = 3
};
bool GUILD_STATE_IsValid(int value);
const GUILD_STATE GUILD_STATE_MIN = GUILD_PREPARE;
const GUILD_STATE GUILD_STATE_MAX = GUILD_DISBANDED;
const int GUILD_STATE_ARRAYSIZE = GUILD_STATE_MAX + 1;

const ::google::protobuf::EnumDescriptor* GUILD_STATE_descriptor();
inline const ::std::string& GUILD_STATE_Name(GUILD_STATE value) {
  return ::google::protobuf::internal::NameOfEnum(
    GUILD_STATE_descriptor(), value);
}
inline bool GUILD_STATE_Parse(
    const ::std::string& name, GUILD_STATE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GUILD_STATE>(
    GUILD_STATE_descriptor(), name, value);
}
enum GUILD_ACCEPT_TYPE {
  GUILD_ACCEPT_TYPE_DISABLE = 0,
  GUILD_ACCEPT_TYPE_AUTO_ACCEPT = 1,
  GUILD_ACCEPT_TYPE_MANUAL = 2
};
bool GUILD_ACCEPT_TYPE_IsValid(int value);
const GUILD_ACCEPT_TYPE GUILD_ACCEPT_TYPE_MIN = GUILD_ACCEPT_TYPE_DISABLE;
const GUILD_ACCEPT_TYPE GUILD_ACCEPT_TYPE_MAX = GUILD_ACCEPT_TYPE_MANUAL;
const int GUILD_ACCEPT_TYPE_ARRAYSIZE = GUILD_ACCEPT_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* GUILD_ACCEPT_TYPE_descriptor();
inline const ::std::string& GUILD_ACCEPT_TYPE_Name(GUILD_ACCEPT_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    GUILD_ACCEPT_TYPE_descriptor(), value);
}
inline bool GUILD_ACCEPT_TYPE_Parse(
    const ::std::string& name, GUILD_ACCEPT_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GUILD_ACCEPT_TYPE>(
    GUILD_ACCEPT_TYPE_descriptor(), name, value);
}
enum GUILD_USER_TITLE {
  GUILD_USER_TITLE_NONE = 0,
  GUILD_USER_TITLE_APPRENTICE = 1,
  GUILD_USER_TITLE_ELITE = 2,
  GUILD_USER_TITLE_EXPERT = 3,
  GUILD_USER_TITLE_MASTER = 4,
  GUILD_USER_TITLE_GRAND_MASTER = 5,
  GUILD_USER_TITLE_VICE_LEADER = 11,
  GUILD_USER_TITLE_LEADER = 12
};
bool GUILD_USER_TITLE_IsValid(int value);
const GUILD_USER_TITLE GUILD_USER_TITLE_MIN = GUILD_USER_TITLE_NONE;
const GUILD_USER_TITLE GUILD_USER_TITLE_MAX = GUILD_USER_TITLE_LEADER;
const int GUILD_USER_TITLE_ARRAYSIZE = GUILD_USER_TITLE_MAX + 1;

const ::google::protobuf::EnumDescriptor* GUILD_USER_TITLE_descriptor();
inline const ::std::string& GUILD_USER_TITLE_Name(GUILD_USER_TITLE value) {
  return ::google::protobuf::internal::NameOfEnum(
    GUILD_USER_TITLE_descriptor(), value);
}
inline bool GUILD_USER_TITLE_Parse(
    const ::std::string& name, GUILD_USER_TITLE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GUILD_USER_TITLE>(
    GUILD_USER_TITLE_descriptor(), name, value);
}
enum GUILD_USER_STATE {
  GUILD_USER_STATE_TO_DELETE = -1,
  GUILD_USER_STATE_FREEMAN = 0,
  GUILD_USER_STATE_JOINNING = 1,
  GUILD_USER_STATE_OK = 2
};
bool GUILD_USER_STATE_IsValid(int value);
const GUILD_USER_STATE GUILD_USER_STATE_MIN = GUILD_USER_STATE_TO_DELETE;
const GUILD_USER_STATE GUILD_USER_STATE_MAX = GUILD_USER_STATE_OK;
const int GUILD_USER_STATE_ARRAYSIZE = GUILD_USER_STATE_MAX + 1;

const ::google::protobuf::EnumDescriptor* GUILD_USER_STATE_descriptor();
inline const ::std::string& GUILD_USER_STATE_Name(GUILD_USER_STATE value) {
  return ::google::protobuf::internal::NameOfEnum(
    GUILD_USER_STATE_descriptor(), value);
}
inline bool GUILD_USER_STATE_Parse(
    const ::std::string& name, GUILD_USER_STATE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GUILD_USER_STATE>(
    GUILD_USER_STATE_descriptor(), name, value);
}
enum GUILD_SIGNIN_TYPE {
  GUILD_SIGNIN_TYPE_GOLD = 1,
  GUILD_SIGNIN_TYPE_DIAMOND = 2,
  GUILD_SIGNIN_TYPE_LUXURY = 3
};
bool GUILD_SIGNIN_TYPE_IsValid(int value);
const GUILD_SIGNIN_TYPE GUILD_SIGNIN_TYPE_MIN = GUILD_SIGNIN_TYPE_GOLD;
const GUILD_SIGNIN_TYPE GUILD_SIGNIN_TYPE_MAX = GUILD_SIGNIN_TYPE_LUXURY;
const int GUILD_SIGNIN_TYPE_ARRAYSIZE = GUILD_SIGNIN_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* GUILD_SIGNIN_TYPE_descriptor();
inline const ::std::string& GUILD_SIGNIN_TYPE_Name(GUILD_SIGNIN_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    GUILD_SIGNIN_TYPE_descriptor(), value);
}
inline bool GUILD_SIGNIN_TYPE_Parse(
    const ::std::string& name, GUILD_SIGNIN_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GUILD_SIGNIN_TYPE>(
    GUILD_SIGNIN_TYPE_descriptor(), name, value);
}
// ===================================================================

class GuildStoreItem : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.GuildStoreItem) */ {
 public:
  GuildStoreItem();
  virtual ~GuildStoreItem();

  GuildStoreItem(const GuildStoreItem& from);

  inline GuildStoreItem& operator=(const GuildStoreItem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GuildStoreItem(GuildStoreItem&& from) noexcept
    : GuildStoreItem() {
    *this = ::std::move(from);
  }

  inline GuildStoreItem& operator=(GuildStoreItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const GuildStoreItem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GuildStoreItem* internal_default_instance() {
    return reinterpret_cast<const GuildStoreItem*>(
               &_GuildStoreItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void UnsafeArenaSwap(GuildStoreItem* other);
  void Swap(GuildStoreItem* other);
  friend void swap(GuildStoreItem& a, GuildStoreItem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GuildStoreItem* New() const final {
    return CreateMaybeMessage<GuildStoreItem>(NULL);
  }

  GuildStoreItem* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GuildStoreItem>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GuildStoreItem& from);
  void MergeFrom(const GuildStoreItem& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GuildStoreItem* other);
  protected:
  explicit GuildStoreItem(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 item_typeid = 1;
  bool has_item_typeid() const;
  void clear_item_typeid();
  static const int kItemTypeidFieldNumber = 1;
  ::google::protobuf::uint64 item_typeid() const;
  void set_item_typeid(::google::protobuf::uint64 value);

  // required int32 item_num = 2;
  bool has_item_num() const;
  void clear_item_num();
  static const int kItemNumFieldNumber = 2;
  ::google::protobuf::int32 item_num() const;
  void set_item_num(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.GuildStoreItem)
 private:
  void set_has_item_typeid();
  void clear_has_item_typeid();
  void set_has_item_num();
  void clear_has_item_num();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 item_typeid_;
  ::google::protobuf::int32 item_num_;
  friend struct ::protobuf_Guild_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GuildStoreItemList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.GuildStoreItemList) */ {
 public:
  GuildStoreItemList();
  virtual ~GuildStoreItemList();

  GuildStoreItemList(const GuildStoreItemList& from);

  inline GuildStoreItemList& operator=(const GuildStoreItemList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GuildStoreItemList(GuildStoreItemList&& from) noexcept
    : GuildStoreItemList() {
    *this = ::std::move(from);
  }

  inline GuildStoreItemList& operator=(GuildStoreItemList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const GuildStoreItemList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GuildStoreItemList* internal_default_instance() {
    return reinterpret_cast<const GuildStoreItemList*>(
               &_GuildStoreItemList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void UnsafeArenaSwap(GuildStoreItemList* other);
  void Swap(GuildStoreItemList* other);
  friend void swap(GuildStoreItemList& a, GuildStoreItemList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GuildStoreItemList* New() const final {
    return CreateMaybeMessage<GuildStoreItemList>(NULL);
  }

  GuildStoreItemList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GuildStoreItemList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GuildStoreItemList& from);
  void MergeFrom(const GuildStoreItemList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GuildStoreItemList* other);
  protected:
  explicit GuildStoreItemList(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sg.GuildStoreItem list = 1;
  int list_size() const;
  void clear_list();
  static const int kListFieldNumber = 1;
  ::sg::GuildStoreItem* mutable_list(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::GuildStoreItem >*
      mutable_list();
  const ::sg::GuildStoreItem& list(int index) const;
  ::sg::GuildStoreItem* add_list();
  const ::google::protobuf::RepeatedPtrField< ::sg::GuildStoreItem >&
      list() const;

  // @@protoc_insertion_point(class_scope:sg.GuildStoreItemList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::GuildStoreItem > list_;
  friend struct ::protobuf_Guild_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GuildBuilding : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.GuildBuilding) */ {
 public:
  GuildBuilding();
  virtual ~GuildBuilding();

  GuildBuilding(const GuildBuilding& from);

  inline GuildBuilding& operator=(const GuildBuilding& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GuildBuilding(GuildBuilding&& from) noexcept
    : GuildBuilding() {
    *this = ::std::move(from);
  }

  inline GuildBuilding& operator=(GuildBuilding&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const GuildBuilding& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GuildBuilding* internal_default_instance() {
    return reinterpret_cast<const GuildBuilding*>(
               &_GuildBuilding_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void UnsafeArenaSwap(GuildBuilding* other);
  void Swap(GuildBuilding* other);
  friend void swap(GuildBuilding& a, GuildBuilding& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GuildBuilding* New() const final {
    return CreateMaybeMessage<GuildBuilding>(NULL);
  }

  GuildBuilding* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GuildBuilding>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GuildBuilding& from);
  void MergeFrom(const GuildBuilding& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GuildBuilding* other);
  protected:
  explicit GuildBuilding(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GuildBuilding_BUILDING_TYPE BUILDING_TYPE;
  static const BUILDING_TYPE TECH =
    GuildBuilding_BUILDING_TYPE_TECH;
  static const BUILDING_TYPE SQUARE =
    GuildBuilding_BUILDING_TYPE_SQUARE;
  static const BUILDING_TYPE SHOP =
    GuildBuilding_BUILDING_TYPE_SHOP;
  static inline bool BUILDING_TYPE_IsValid(int value) {
    return GuildBuilding_BUILDING_TYPE_IsValid(value);
  }
  static const BUILDING_TYPE BUILDING_TYPE_MIN =
    GuildBuilding_BUILDING_TYPE_BUILDING_TYPE_MIN;
  static const BUILDING_TYPE BUILDING_TYPE_MAX =
    GuildBuilding_BUILDING_TYPE_BUILDING_TYPE_MAX;
  static const int BUILDING_TYPE_ARRAYSIZE =
    GuildBuilding_BUILDING_TYPE_BUILDING_TYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  BUILDING_TYPE_descriptor() {
    return GuildBuilding_BUILDING_TYPE_descriptor();
  }
  static inline const ::std::string& BUILDING_TYPE_Name(BUILDING_TYPE value) {
    return GuildBuilding_BUILDING_TYPE_Name(value);
  }
  static inline bool BUILDING_TYPE_Parse(const ::std::string& name,
      BUILDING_TYPE* value) {
    return GuildBuilding_BUILDING_TYPE_Parse(name, value);
  }

  typedef GuildBuilding_BUILDING_STATE BUILDING_STATE;
  static const BUILDING_STATE IDLE =
    GuildBuilding_BUILDING_STATE_IDLE;
  static const BUILDING_STATE BUSY =
    GuildBuilding_BUILDING_STATE_BUSY;
  static const BUILDING_STATE READY =
    GuildBuilding_BUILDING_STATE_READY;
  static inline bool BUILDING_STATE_IsValid(int value) {
    return GuildBuilding_BUILDING_STATE_IsValid(value);
  }
  static const BUILDING_STATE BUILDING_STATE_MIN =
    GuildBuilding_BUILDING_STATE_BUILDING_STATE_MIN;
  static const BUILDING_STATE BUILDING_STATE_MAX =
    GuildBuilding_BUILDING_STATE_BUILDING_STATE_MAX;
  static const int BUILDING_STATE_ARRAYSIZE =
    GuildBuilding_BUILDING_STATE_BUILDING_STATE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  BUILDING_STATE_descriptor() {
    return GuildBuilding_BUILDING_STATE_descriptor();
  }
  static inline const ::std::string& BUILDING_STATE_Name(BUILDING_STATE value) {
    return GuildBuilding_BUILDING_STATE_Name(value);
  }
  static inline bool BUILDING_STATE_Parse(const ::std::string& name,
      BUILDING_STATE* value) {
    return GuildBuilding_BUILDING_STATE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int32 building_type = 1;
  bool has_building_type() const;
  void clear_building_type();
  static const int kBuildingTypeFieldNumber = 1;
  ::google::protobuf::int32 building_type() const;
  void set_building_type(::google::protobuf::int32 value);

  // required int32 level = 2;
  bool has_level() const;
  void clear_level();
  static const int kLevelFieldNumber = 2;
  ::google::protobuf::int32 level() const;
  void set_level(::google::protobuf::int32 value);

  // required .sg.GuildBuilding.BUILDING_STATE state = 3;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 3;
  ::sg::GuildBuilding_BUILDING_STATE state() const;
  void set_state(::sg::GuildBuilding_BUILDING_STATE value);

  // required int32 seconds = 4;
  bool has_seconds() const;
  void clear_seconds();
  static const int kSecondsFieldNumber = 4;
  ::google::protobuf::int32 seconds() const;
  void set_seconds(::google::protobuf::int32 value);

  // required sfixed64 starttime = 5;
  bool has_starttime() const;
  void clear_starttime();
  static const int kStarttimeFieldNumber = 5;
  ::google::protobuf::int64 starttime() const;
  void set_starttime(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:sg.GuildBuilding)
 private:
  void set_has_building_type();
  void clear_has_building_type();
  void set_has_level();
  void clear_has_level();
  void set_has_state();
  void clear_has_state();
  void set_has_seconds();
  void clear_has_seconds();
  void set_has_starttime();
  void clear_has_starttime();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 building_type_;
  ::google::protobuf::int32 level_;
  int state_;
  ::google::protobuf::int32 seconds_;
  ::google::protobuf::int64 starttime_;
  friend struct ::protobuf_Guild_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GuildBuildingList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.GuildBuildingList) */ {
 public:
  GuildBuildingList();
  virtual ~GuildBuildingList();

  GuildBuildingList(const GuildBuildingList& from);

  inline GuildBuildingList& operator=(const GuildBuildingList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GuildBuildingList(GuildBuildingList&& from) noexcept
    : GuildBuildingList() {
    *this = ::std::move(from);
  }

  inline GuildBuildingList& operator=(GuildBuildingList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const GuildBuildingList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GuildBuildingList* internal_default_instance() {
    return reinterpret_cast<const GuildBuildingList*>(
               &_GuildBuildingList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void UnsafeArenaSwap(GuildBuildingList* other);
  void Swap(GuildBuildingList* other);
  friend void swap(GuildBuildingList& a, GuildBuildingList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GuildBuildingList* New() const final {
    return CreateMaybeMessage<GuildBuildingList>(NULL);
  }

  GuildBuildingList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GuildBuildingList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GuildBuildingList& from);
  void MergeFrom(const GuildBuildingList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GuildBuildingList* other);
  protected:
  explicit GuildBuildingList(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sg.GuildBuilding list = 1;
  int list_size() const;
  void clear_list();
  static const int kListFieldNumber = 1;
  ::sg::GuildBuilding* mutable_list(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::GuildBuilding >*
      mutable_list();
  const ::sg::GuildBuilding& list(int index) const;
  ::sg::GuildBuilding* add_list();
  const ::google::protobuf::RepeatedPtrField< ::sg::GuildBuilding >&
      list() const;

  // @@protoc_insertion_point(class_scope:sg.GuildBuildingList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::GuildBuilding > list_;
  friend struct ::protobuf_Guild_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GuildUserData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.GuildUserData) */ {
 public:
  GuildUserData();
  virtual ~GuildUserData();

  GuildUserData(const GuildUserData& from);

  inline GuildUserData& operator=(const GuildUserData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GuildUserData(GuildUserData&& from) noexcept
    : GuildUserData() {
    *this = ::std::move(from);
  }

  inline GuildUserData& operator=(GuildUserData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const GuildUserData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GuildUserData* internal_default_instance() {
    return reinterpret_cast<const GuildUserData*>(
               &_GuildUserData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void UnsafeArenaSwap(GuildUserData* other);
  void Swap(GuildUserData* other);
  friend void swap(GuildUserData& a, GuildUserData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GuildUserData* New() const final {
    return CreateMaybeMessage<GuildUserData>(NULL);
  }

  GuildUserData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GuildUserData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GuildUserData& from);
  void MergeFrom(const GuildUserData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GuildUserData* other);
  protected:
  explicit GuildUserData(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes role_nick = 2;
  bool has_role_nick() const;
  void clear_role_nick();
  static const int kRoleNickFieldNumber = 2;
  const ::std::string& role_nick() const;
  void set_role_nick(const ::std::string& value);
  #if LANG_CXX11
  void set_role_nick(::std::string&& value);
  #endif
  void set_role_nick(const char* value);
  void set_role_nick(const void* value, size_t size);
  ::std::string* mutable_role_nick();
  ::std::string* release_role_nick();
  void set_allocated_role_nick(::std::string* role_nick);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_role_nick();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_role_nick(
      ::std::string* role_nick);

  // required uint64 uuid = 1;
  bool has_uuid() const;
  void clear_uuid();
  static const int kUuidFieldNumber = 1;
  ::google::protobuf::uint64 uuid() const;
  void set_uuid(::google::protobuf::uint64 value);

  // required int32 role_level = 3;
  bool has_role_level() const;
  void clear_role_level();
  static const int kRoleLevelFieldNumber = 3;
  ::google::protobuf::int32 role_level() const;
  void set_role_level(::google::protobuf::int32 value);

  // required int32 role_exp = 4;
  bool has_role_exp() const;
  void clear_role_exp();
  static const int kRoleExpFieldNumber = 4;
  ::google::protobuf::int32 role_exp() const;
  void set_role_exp(::google::protobuf::int32 value);

  // required int32 role_rank = 5;
  bool has_role_rank() const;
  void clear_role_rank();
  static const int kRoleRankFieldNumber = 5;
  ::google::protobuf::int32 role_rank() const;
  void set_role_rank(::google::protobuf::int32 value);

  // required int32 role_portrait = 6;
  bool has_role_portrait() const;
  void clear_role_portrait();
  static const int kRolePortraitFieldNumber = 6;
  ::google::protobuf::int32 role_portrait() const;
  void set_role_portrait(::google::protobuf::int32 value);

  // required int32 role_portrait_frame = 7;
  bool has_role_portrait_frame() const;
  void clear_role_portrait_frame();
  static const int kRolePortraitFrameFieldNumber = 7;
  ::google::protobuf::int32 role_portrait_frame() const;
  void set_role_portrait_frame(::google::protobuf::int32 value);

  // required int32 role_force = 8;
  bool has_role_force() const;
  void clear_role_force();
  static const int kRoleForceFieldNumber = 8;
  ::google::protobuf::int32 role_force() const;
  void set_role_force(::google::protobuf::int32 value);

  // required sfixed64 optime = 11;
  bool has_optime() const;
  void clear_optime();
  static const int kOptimeFieldNumber = 11;
  ::google::protobuf::int64 optime() const;
  void set_optime(::google::protobuf::int64 value);

  // required bool is_online = 12;
  bool has_is_online() const;
  void clear_is_online();
  static const int kIsOnlineFieldNumber = 12;
  bool is_online() const;
  void set_is_online(bool value);

  // required .sg.GUILD_USER_TITLE title = 21;
  bool has_title() const;
  void clear_title();
  static const int kTitleFieldNumber = 21;
  ::sg::GUILD_USER_TITLE title() const;
  void set_title(::sg::GUILD_USER_TITLE value);

  // required int32 donation = 22;
  bool has_donation() const;
  void clear_donation();
  static const int kDonationFieldNumber = 22;
  ::google::protobuf::int32 donation() const;
  void set_donation(::google::protobuf::int32 value);

  // optional int32 donation_today = 23;
  bool has_donation_today() const;
  void clear_donation_today();
  static const int kDonationTodayFieldNumber = 23;
  ::google::protobuf::int32 donation_today() const;
  void set_donation_today(::google::protobuf::int32 value);

  // required .sg.GUILD_USER_STATE state = 9;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 9;
  ::sg::GUILD_USER_STATE state() const;
  void set_state(::sg::GUILD_USER_STATE value);

  // @@protoc_insertion_point(class_scope:sg.GuildUserData)
 private:
  void set_has_uuid();
  void clear_has_uuid();
  void set_has_role_nick();
  void clear_has_role_nick();
  void set_has_role_level();
  void clear_has_role_level();
  void set_has_role_exp();
  void clear_has_role_exp();
  void set_has_role_rank();
  void clear_has_role_rank();
  void set_has_role_portrait();
  void clear_has_role_portrait();
  void set_has_role_portrait_frame();
  void clear_has_role_portrait_frame();
  void set_has_role_force();
  void clear_has_role_force();
  void set_has_state();
  void clear_has_state();
  void set_has_optime();
  void clear_has_optime();
  void set_has_is_online();
  void clear_has_is_online();
  void set_has_title();
  void clear_has_title();
  void set_has_donation();
  void clear_has_donation();
  void set_has_donation_today();
  void clear_has_donation_today();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr role_nick_;
  ::google::protobuf::uint64 uuid_;
  ::google::protobuf::int32 role_level_;
  ::google::protobuf::int32 role_exp_;
  ::google::protobuf::int32 role_rank_;
  ::google::protobuf::int32 role_portrait_;
  ::google::protobuf::int32 role_portrait_frame_;
  ::google::protobuf::int32 role_force_;
  ::google::protobuf::int64 optime_;
  bool is_online_;
  int title_;
  ::google::protobuf::int32 donation_;
  ::google::protobuf::int32 donation_today_;
  int state_;
  friend struct ::protobuf_Guild_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GuildUserDataList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.GuildUserDataList) */ {
 public:
  GuildUserDataList();
  virtual ~GuildUserDataList();

  GuildUserDataList(const GuildUserDataList& from);

  inline GuildUserDataList& operator=(const GuildUserDataList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GuildUserDataList(GuildUserDataList&& from) noexcept
    : GuildUserDataList() {
    *this = ::std::move(from);
  }

  inline GuildUserDataList& operator=(GuildUserDataList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const GuildUserDataList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GuildUserDataList* internal_default_instance() {
    return reinterpret_cast<const GuildUserDataList*>(
               &_GuildUserDataList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void UnsafeArenaSwap(GuildUserDataList* other);
  void Swap(GuildUserDataList* other);
  friend void swap(GuildUserDataList& a, GuildUserDataList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GuildUserDataList* New() const final {
    return CreateMaybeMessage<GuildUserDataList>(NULL);
  }

  GuildUserDataList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GuildUserDataList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GuildUserDataList& from);
  void MergeFrom(const GuildUserDataList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GuildUserDataList* other);
  protected:
  explicit GuildUserDataList(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sg.GuildUserData list = 1;
  int list_size() const;
  void clear_list();
  static const int kListFieldNumber = 1;
  ::sg::GuildUserData* mutable_list(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::GuildUserData >*
      mutable_list();
  const ::sg::GuildUserData& list(int index) const;
  ::sg::GuildUserData* add_list();
  const ::google::protobuf::RepeatedPtrField< ::sg::GuildUserData >&
      list() const;

  // @@protoc_insertion_point(class_scope:sg.GuildUserDataList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::GuildUserData > list_;
  friend struct ::protobuf_Guild_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GuildData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.GuildData) */ {
 public:
  GuildData();
  virtual ~GuildData();

  GuildData(const GuildData& from);

  inline GuildData& operator=(const GuildData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GuildData(GuildData&& from) noexcept
    : GuildData() {
    *this = ::std::move(from);
  }

  inline GuildData& operator=(GuildData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const GuildData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GuildData* internal_default_instance() {
    return reinterpret_cast<const GuildData*>(
               &_GuildData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void UnsafeArenaSwap(GuildData* other);
  void Swap(GuildData* other);
  friend void swap(GuildData& a, GuildData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GuildData* New() const final {
    return CreateMaybeMessage<GuildData>(NULL);
  }

  GuildData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GuildData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GuildData& from);
  void MergeFrom(const GuildData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GuildData* other);
  protected:
  explicit GuildData(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const void* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_name();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      ::std::string* name);

  // required bytes announcement = 6;
  bool has_announcement() const;
  void clear_announcement();
  static const int kAnnouncementFieldNumber = 6;
  const ::std::string& announcement() const;
  void set_announcement(const ::std::string& value);
  #if LANG_CXX11
  void set_announcement(::std::string&& value);
  #endif
  void set_announcement(const char* value);
  void set_announcement(const void* value, size_t size);
  ::std::string* mutable_announcement();
  ::std::string* release_announcement();
  void set_allocated_announcement(::std::string* announcement);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_announcement();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_announcement(
      ::std::string* announcement);

  // required bytes badge = 8;
  bool has_badge() const;
  void clear_badge();
  static const int kBadgeFieldNumber = 8;
  const ::std::string& badge() const;
  void set_badge(const ::std::string& value);
  #if LANG_CXX11
  void set_badge(::std::string&& value);
  #endif
  void set_badge(const char* value);
  void set_badge(const void* value, size_t size);
  ::std::string* mutable_badge();
  ::std::string* release_badge();
  void set_allocated_badge(::std::string* badge);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_badge();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_badge(
      ::std::string* badge);

  // optional .sg.GuildUserDataList member_list = 21;
  bool has_member_list() const;
  void clear_member_list();
  static const int kMemberListFieldNumber = 21;
  private:
  const ::sg::GuildUserDataList& _internal_member_list() const;
  public:
  const ::sg::GuildUserDataList& member_list() const;
  ::sg::GuildUserDataList* release_member_list();
  ::sg::GuildUserDataList* mutable_member_list();
  void set_allocated_member_list(::sg::GuildUserDataList* member_list);
  void unsafe_arena_set_allocated_member_list(
      ::sg::GuildUserDataList* member_list);
  ::sg::GuildUserDataList* unsafe_arena_release_member_list();

  // optional .sg.GuildUserDataList join_list = 22;
  bool has_join_list() const;
  void clear_join_list();
  static const int kJoinListFieldNumber = 22;
  private:
  const ::sg::GuildUserDataList& _internal_join_list() const;
  public:
  const ::sg::GuildUserDataList& join_list() const;
  ::sg::GuildUserDataList* release_join_list();
  ::sg::GuildUserDataList* mutable_join_list();
  void set_allocated_join_list(::sg::GuildUserDataList* join_list);
  void unsafe_arena_set_allocated_join_list(
      ::sg::GuildUserDataList* join_list);
  ::sg::GuildUserDataList* unsafe_arena_release_join_list();

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // required int32 level = 3;
  bool has_level() const;
  void clear_level();
  static const int kLevelFieldNumber = 3;
  ::google::protobuf::int32 level() const;
  void set_level(::google::protobuf::int32 value);

  // required uint64 fund = 5;
  bool has_fund() const;
  void clear_fund();
  static const int kFundFieldNumber = 5;
  ::google::protobuf::uint64 fund() const;
  void set_fund(::google::protobuf::uint64 value);

  // required int32 population = 4;
  bool has_population() const;
  void clear_population();
  static const int kPopulationFieldNumber = 4;
  ::google::protobuf::int32 population() const;
  void set_population(::google::protobuf::int32 value);

  // optional .sg.GUILD_ACCEPT_TYPE accept_type = 11;
  bool has_accept_type() const;
  void clear_accept_type();
  static const int kAcceptTypeFieldNumber = 11;
  ::sg::GUILD_ACCEPT_TYPE accept_type() const;
  void set_accept_type(::sg::GUILD_ACCEPT_TYPE value);

  // optional int32 join_level = 12;
  bool has_join_level() const;
  void clear_join_level();
  static const int kJoinLevelFieldNumber = 12;
  ::google::protobuf::int32 join_level() const;
  void set_join_level(::google::protobuf::int32 value);

  // optional int32 join_force = 13;
  bool has_join_force() const;
  void clear_join_force();
  static const int kJoinForceFieldNumber = 13;
  ::google::protobuf::int32 join_force() const;
  void set_join_force(::google::protobuf::int32 value);

  // optional bool shopping = 14;
  bool has_shopping() const;
  void clear_shopping();
  static const int kShoppingFieldNumber = 14;
  bool shopping() const;
  void set_shopping(bool value);

  // optional bool chat = 15;
  bool has_chat() const;
  void clear_chat();
  static const int kChatFieldNumber = 15;
  bool chat() const;
  void set_chat(bool value);

  // required .sg.GUILD_STATE state = 7;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 7;
  ::sg::GUILD_STATE state() const;
  void set_state(::sg::GUILD_STATE value);

  // @@protoc_insertion_point(class_scope:sg.GuildData)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_name();
  void clear_has_name();
  void set_has_level();
  void clear_has_level();
  void set_has_population();
  void clear_has_population();
  void set_has_fund();
  void clear_has_fund();
  void set_has_announcement();
  void clear_has_announcement();
  void set_has_state();
  void clear_has_state();
  void set_has_badge();
  void clear_has_badge();
  void set_has_accept_type();
  void clear_has_accept_type();
  void set_has_join_level();
  void clear_has_join_level();
  void set_has_join_force();
  void clear_has_join_force();
  void set_has_shopping();
  void clear_has_shopping();
  void set_has_chat();
  void clear_has_chat();
  void set_has_member_list();
  void clear_has_member_list();
  void set_has_join_list();
  void clear_has_join_list();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr announcement_;
  ::google::protobuf::internal::ArenaStringPtr badge_;
  ::sg::GuildUserDataList* member_list_;
  ::sg::GuildUserDataList* join_list_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::uint64 fund_;
  ::google::protobuf::int32 population_;
  int accept_type_;
  ::google::protobuf::int32 join_level_;
  ::google::protobuf::int32 join_force_;
  bool shopping_;
  bool chat_;
  int state_;
  friend struct ::protobuf_Guild_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GuildDataList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.GuildDataList) */ {
 public:
  GuildDataList();
  virtual ~GuildDataList();

  GuildDataList(const GuildDataList& from);

  inline GuildDataList& operator=(const GuildDataList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GuildDataList(GuildDataList&& from) noexcept
    : GuildDataList() {
    *this = ::std::move(from);
  }

  inline GuildDataList& operator=(GuildDataList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const GuildDataList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GuildDataList* internal_default_instance() {
    return reinterpret_cast<const GuildDataList*>(
               &_GuildDataList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void UnsafeArenaSwap(GuildDataList* other);
  void Swap(GuildDataList* other);
  friend void swap(GuildDataList& a, GuildDataList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GuildDataList* New() const final {
    return CreateMaybeMessage<GuildDataList>(NULL);
  }

  GuildDataList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GuildDataList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GuildDataList& from);
  void MergeFrom(const GuildDataList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GuildDataList* other);
  protected:
  explicit GuildDataList(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sg.GuildData list = 1;
  int list_size() const;
  void clear_list();
  static const int kListFieldNumber = 1;
  ::sg::GuildData* mutable_list(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::GuildData >*
      mutable_list();
  const ::sg::GuildData& list(int index) const;
  ::sg::GuildData* add_list();
  const ::google::protobuf::RepeatedPtrField< ::sg::GuildData >&
      list() const;

  // @@protoc_insertion_point(class_scope:sg.GuildDataList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::GuildData > list_;
  friend struct ::protobuf_Guild_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GuildSignin : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.GuildSignin) */ {
 public:
  GuildSignin();
  virtual ~GuildSignin();

  GuildSignin(const GuildSignin& from);

  inline GuildSignin& operator=(const GuildSignin& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GuildSignin(GuildSignin&& from) noexcept
    : GuildSignin() {
    *this = ::std::move(from);
  }

  inline GuildSignin& operator=(GuildSignin&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const GuildSignin& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GuildSignin* internal_default_instance() {
    return reinterpret_cast<const GuildSignin*>(
               &_GuildSignin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void UnsafeArenaSwap(GuildSignin* other);
  void Swap(GuildSignin* other);
  friend void swap(GuildSignin& a, GuildSignin& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GuildSignin* New() const final {
    return CreateMaybeMessage<GuildSignin>(NULL);
  }

  GuildSignin* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GuildSignin>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GuildSignin& from);
  void MergeFrom(const GuildSignin& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GuildSignin* other);
  protected:
  explicit GuildSignin(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GuildSignin_STATE STATE;
  static const STATE NOT_SIGNIN =
    GuildSignin_STATE_NOT_SIGNIN;
  static const STATE SIGNIN =
    GuildSignin_STATE_SIGNIN;
  static const STATE ACCEPT =
    GuildSignin_STATE_ACCEPT;
  static inline bool STATE_IsValid(int value) {
    return GuildSignin_STATE_IsValid(value);
  }
  static const STATE STATE_MIN =
    GuildSignin_STATE_STATE_MIN;
  static const STATE STATE_MAX =
    GuildSignin_STATE_STATE_MAX;
  static const int STATE_ARRAYSIZE =
    GuildSignin_STATE_STATE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  STATE_descriptor() {
    return GuildSignin_STATE_descriptor();
  }
  static inline const ::std::string& STATE_Name(STATE value) {
    return GuildSignin_STATE_Name(value);
  }
  static inline bool STATE_Parse(const ::std::string& name,
      STATE* value) {
    return GuildSignin_STATE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional bytes drop_str = 3;
  bool has_drop_str() const;
  void clear_drop_str();
  static const int kDropStrFieldNumber = 3;
  const ::std::string& drop_str() const;
  void set_drop_str(const ::std::string& value);
  #if LANG_CXX11
  void set_drop_str(::std::string&& value);
  #endif
  void set_drop_str(const char* value);
  void set_drop_str(const void* value, size_t size);
  ::std::string* mutable_drop_str();
  ::std::string* release_drop_str();
  void set_allocated_drop_str(::std::string* drop_str);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_drop_str();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_drop_str(
      ::std::string* drop_str);

  // required int32 type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // required .sg.GuildSignin.STATE state = 2;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 2;
  ::sg::GuildSignin_STATE state() const;
  void set_state(::sg::GuildSignin_STATE value);

  // @@protoc_insertion_point(class_scope:sg.GuildSignin)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_state();
  void clear_has_state();
  void set_has_drop_str();
  void clear_has_drop_str();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr drop_str_;
  ::google::protobuf::int32 type_;
  int state_;
  friend struct ::protobuf_Guild_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GuildSigninList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.GuildSigninList) */ {
 public:
  GuildSigninList();
  virtual ~GuildSigninList();

  GuildSigninList(const GuildSigninList& from);

  inline GuildSigninList& operator=(const GuildSigninList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GuildSigninList(GuildSigninList&& from) noexcept
    : GuildSigninList() {
    *this = ::std::move(from);
  }

  inline GuildSigninList& operator=(GuildSigninList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const GuildSigninList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GuildSigninList* internal_default_instance() {
    return reinterpret_cast<const GuildSigninList*>(
               &_GuildSigninList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void UnsafeArenaSwap(GuildSigninList* other);
  void Swap(GuildSigninList* other);
  friend void swap(GuildSigninList& a, GuildSigninList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GuildSigninList* New() const final {
    return CreateMaybeMessage<GuildSigninList>(NULL);
  }

  GuildSigninList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GuildSigninList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GuildSigninList& from);
  void MergeFrom(const GuildSigninList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GuildSigninList* other);
  protected:
  explicit GuildSigninList(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sg.GuildSignin list = 1;
  int list_size() const;
  void clear_list();
  static const int kListFieldNumber = 1;
  ::sg::GuildSignin* mutable_list(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::GuildSignin >*
      mutable_list();
  const ::sg::GuildSignin& list(int index) const;
  ::sg::GuildSignin* add_list();
  const ::google::protobuf::RepeatedPtrField< ::sg::GuildSignin >&
      list() const;

  // @@protoc_insertion_point(class_scope:sg.GuildSigninList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::GuildSignin > list_;
  friend struct ::protobuf_Guild_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GuildTrack : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.GuildTrack) */ {
 public:
  GuildTrack();
  virtual ~GuildTrack();

  GuildTrack(const GuildTrack& from);

  inline GuildTrack& operator=(const GuildTrack& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GuildTrack(GuildTrack&& from) noexcept
    : GuildTrack() {
    *this = ::std::move(from);
  }

  inline GuildTrack& operator=(GuildTrack&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const GuildTrack& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GuildTrack* internal_default_instance() {
    return reinterpret_cast<const GuildTrack*>(
               &_GuildTrack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void UnsafeArenaSwap(GuildTrack* other);
  void Swap(GuildTrack* other);
  friend void swap(GuildTrack& a, GuildTrack& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GuildTrack* New() const final {
    return CreateMaybeMessage<GuildTrack>(NULL);
  }

  GuildTrack* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GuildTrack>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GuildTrack& from);
  void MergeFrom(const GuildTrack& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GuildTrack* other);
  protected:
  explicit GuildTrack(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GuildTrack_TRACK_ACTION_TYPE TRACK_ACTION_TYPE;
  static const TRACK_ACTION_TYPE JOIN =
    GuildTrack_TRACK_ACTION_TYPE_JOIN;
  static const TRACK_ACTION_TYPE QUIT =
    GuildTrack_TRACK_ACTION_TYPE_QUIT;
  static const TRACK_ACTION_TYPE DONATE =
    GuildTrack_TRACK_ACTION_TYPE_DONATE;
  static const TRACK_ACTION_TYPE ACCEPT =
    GuildTrack_TRACK_ACTION_TYPE_ACCEPT;
  static const TRACK_ACTION_TYPE REJECT =
    GuildTrack_TRACK_ACTION_TYPE_REJECT;
  static const TRACK_ACTION_TYPE KICK =
    GuildTrack_TRACK_ACTION_TYPE_KICK;
  static const TRACK_ACTION_TYPE APPOINT =
    GuildTrack_TRACK_ACTION_TYPE_APPOINT;
  static const TRACK_ACTION_TYPE SELECT_NEW_LEADER =
    GuildTrack_TRACK_ACTION_TYPE_SELECT_NEW_LEADER;
  static const TRACK_ACTION_TYPE BUILDING_UPGRADE_START =
    GuildTrack_TRACK_ACTION_TYPE_BUILDING_UPGRADE_START;
  static const TRACK_ACTION_TYPE BUILDING_UPGRADE_OVER =
    GuildTrack_TRACK_ACTION_TYPE_BUILDING_UPGRADE_OVER;
  static inline bool TRACK_ACTION_TYPE_IsValid(int value) {
    return GuildTrack_TRACK_ACTION_TYPE_IsValid(value);
  }
  static const TRACK_ACTION_TYPE TRACK_ACTION_TYPE_MIN =
    GuildTrack_TRACK_ACTION_TYPE_TRACK_ACTION_TYPE_MIN;
  static const TRACK_ACTION_TYPE TRACK_ACTION_TYPE_MAX =
    GuildTrack_TRACK_ACTION_TYPE_TRACK_ACTION_TYPE_MAX;
  static const int TRACK_ACTION_TYPE_ARRAYSIZE =
    GuildTrack_TRACK_ACTION_TYPE_TRACK_ACTION_TYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TRACK_ACTION_TYPE_descriptor() {
    return GuildTrack_TRACK_ACTION_TYPE_descriptor();
  }
  static inline const ::std::string& TRACK_ACTION_TYPE_Name(TRACK_ACTION_TYPE value) {
    return GuildTrack_TRACK_ACTION_TYPE_Name(value);
  }
  static inline bool TRACK_ACTION_TYPE_Parse(const ::std::string& name,
      TRACK_ACTION_TYPE* value) {
    return GuildTrack_TRACK_ACTION_TYPE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required bytes nick = 2;
  bool has_nick() const;
  void clear_nick();
  static const int kNickFieldNumber = 2;
  const ::std::string& nick() const;
  void set_nick(const ::std::string& value);
  #if LANG_CXX11
  void set_nick(::std::string&& value);
  #endif
  void set_nick(const char* value);
  void set_nick(const void* value, size_t size);
  ::std::string* mutable_nick();
  ::std::string* release_nick();
  void set_allocated_nick(::std::string* nick);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_nick();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_nick(
      ::std::string* nick);

  // optional bytes name = 12;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 12;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const void* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_name();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      ::std::string* name);

  // optional bytes announcement = 13;
  bool has_announcement() const;
  void clear_announcement();
  static const int kAnnouncementFieldNumber = 13;
  const ::std::string& announcement() const;
  void set_announcement(const ::std::string& value);
  #if LANG_CXX11
  void set_announcement(::std::string&& value);
  #endif
  void set_announcement(const char* value);
  void set_announcement(const void* value, size_t size);
  ::std::string* mutable_announcement();
  ::std::string* release_announcement();
  void set_allocated_announcement(::std::string* announcement);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_announcement();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_announcement(
      ::std::string* announcement);

  // optional bytes target_nick = 15;
  bool has_target_nick() const;
  void clear_target_nick();
  static const int kTargetNickFieldNumber = 15;
  const ::std::string& target_nick() const;
  void set_target_nick(const ::std::string& value);
  #if LANG_CXX11
  void set_target_nick(::std::string&& value);
  #endif
  void set_target_nick(const char* value);
  void set_target_nick(const void* value, size_t size);
  ::std::string* mutable_target_nick();
  ::std::string* release_target_nick();
  void set_allocated_target_nick(::std::string* target_nick);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_target_nick();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_target_nick(
      ::std::string* target_nick);

  // required uint64 uuid = 1;
  bool has_uuid() const;
  void clear_uuid();
  static const int kUuidFieldNumber = 1;
  ::google::protobuf::uint64 uuid() const;
  void set_uuid(::google::protobuf::uint64 value);

  // required int32 action_type = 3;
  bool has_action_type() const;
  void clear_action_type();
  static const int kActionTypeFieldNumber = 3;
  ::google::protobuf::int32 action_type() const;
  void set_action_type(::google::protobuf::int32 value);

  // optional int32 guildid = 11;
  bool has_guildid() const;
  void clear_guildid();
  static const int kGuildidFieldNumber = 11;
  ::google::protobuf::int32 guildid() const;
  void set_guildid(::google::protobuf::int32 value);

  // optional uint64 target_uuid = 14;
  bool has_target_uuid() const;
  void clear_target_uuid();
  static const int kTargetUuidFieldNumber = 14;
  ::google::protobuf::uint64 target_uuid() const;
  void set_target_uuid(::google::protobuf::uint64 value);

  // optional int32 target_title = 16;
  bool has_target_title() const;
  void clear_target_title();
  static const int kTargetTitleFieldNumber = 16;
  ::google::protobuf::int32 target_title() const;
  void set_target_title(::google::protobuf::int32 value);

  // optional int32 donation = 17;
  bool has_donation() const;
  void clear_donation();
  static const int kDonationFieldNumber = 17;
  ::google::protobuf::int32 donation() const;
  void set_donation(::google::protobuf::int32 value);

  // optional int32 building_type = 18;
  bool has_building_type() const;
  void clear_building_type();
  static const int kBuildingTypeFieldNumber = 18;
  ::google::protobuf::int32 building_type() const;
  void set_building_type(::google::protobuf::int32 value);

  // optional int32 building_level = 19;
  bool has_building_level() const;
  void clear_building_level();
  static const int kBuildingLevelFieldNumber = 19;
  ::google::protobuf::int32 building_level() const;
  void set_building_level(::google::protobuf::int32 value);

  // optional sfixed64 optime = 21;
  bool has_optime() const;
  void clear_optime();
  static const int kOptimeFieldNumber = 21;
  ::google::protobuf::int64 optime() const;
  void set_optime(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:sg.GuildTrack)
 private:
  void set_has_uuid();
  void clear_has_uuid();
  void set_has_nick();
  void clear_has_nick();
  void set_has_action_type();
  void clear_has_action_type();
  void set_has_guildid();
  void clear_has_guildid();
  void set_has_name();
  void clear_has_name();
  void set_has_announcement();
  void clear_has_announcement();
  void set_has_target_uuid();
  void clear_has_target_uuid();
  void set_has_target_nick();
  void clear_has_target_nick();
  void set_has_target_title();
  void clear_has_target_title();
  void set_has_donation();
  void clear_has_donation();
  void set_has_building_type();
  void clear_has_building_type();
  void set_has_building_level();
  void clear_has_building_level();
  void set_has_optime();
  void clear_has_optime();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr nick_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr announcement_;
  ::google::protobuf::internal::ArenaStringPtr target_nick_;
  ::google::protobuf::uint64 uuid_;
  ::google::protobuf::int32 action_type_;
  ::google::protobuf::int32 guildid_;
  ::google::protobuf::uint64 target_uuid_;
  ::google::protobuf::int32 target_title_;
  ::google::protobuf::int32 donation_;
  ::google::protobuf::int32 building_type_;
  ::google::protobuf::int32 building_level_;
  ::google::protobuf::int64 optime_;
  friend struct ::protobuf_Guild_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GuildTrackList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.GuildTrackList) */ {
 public:
  GuildTrackList();
  virtual ~GuildTrackList();

  GuildTrackList(const GuildTrackList& from);

  inline GuildTrackList& operator=(const GuildTrackList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GuildTrackList(GuildTrackList&& from) noexcept
    : GuildTrackList() {
    *this = ::std::move(from);
  }

  inline GuildTrackList& operator=(GuildTrackList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const GuildTrackList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GuildTrackList* internal_default_instance() {
    return reinterpret_cast<const GuildTrackList*>(
               &_GuildTrackList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void UnsafeArenaSwap(GuildTrackList* other);
  void Swap(GuildTrackList* other);
  friend void swap(GuildTrackList& a, GuildTrackList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GuildTrackList* New() const final {
    return CreateMaybeMessage<GuildTrackList>(NULL);
  }

  GuildTrackList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GuildTrackList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GuildTrackList& from);
  void MergeFrom(const GuildTrackList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GuildTrackList* other);
  protected:
  explicit GuildTrackList(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sg.GuildTrack list = 1;
  int list_size() const;
  void clear_list();
  static const int kListFieldNumber = 1;
  ::sg::GuildTrack* mutable_list(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::GuildTrack >*
      mutable_list();
  const ::sg::GuildTrack& list(int index) const;
  ::sg::GuildTrack* add_list();
  const ::google::protobuf::RepeatedPtrField< ::sg::GuildTrack >&
      list() const;

  // @@protoc_insertion_point(class_scope:sg.GuildTrackList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::GuildTrack > list_;
  friend struct ::protobuf_Guild_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DonateItem : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.DonateItem) */ {
 public:
  DonateItem();
  virtual ~DonateItem();

  DonateItem(const DonateItem& from);

  inline DonateItem& operator=(const DonateItem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DonateItem(DonateItem&& from) noexcept
    : DonateItem() {
    *this = ::std::move(from);
  }

  inline DonateItem& operator=(DonateItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const DonateItem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DonateItem* internal_default_instance() {
    return reinterpret_cast<const DonateItem*>(
               &_DonateItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void UnsafeArenaSwap(DonateItem* other);
  void Swap(DonateItem* other);
  friend void swap(DonateItem& a, DonateItem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DonateItem* New() const final {
    return CreateMaybeMessage<DonateItem>(NULL);
  }

  DonateItem* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DonateItem>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DonateItem& from);
  void MergeFrom(const DonateItem& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DonateItem* other);
  protected:
  explicit DonateItem(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // required int32 num = 2;
  bool has_num() const;
  void clear_num();
  static const int kNumFieldNumber = 2;
  ::google::protobuf::int32 num() const;
  void set_num(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.DonateItem)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_num();
  void clear_has_num();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 num_;
  friend struct ::protobuf_Guild_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DonateItemList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.DonateItemList) */ {
 public:
  DonateItemList();
  virtual ~DonateItemList();

  DonateItemList(const DonateItemList& from);

  inline DonateItemList& operator=(const DonateItemList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DonateItemList(DonateItemList&& from) noexcept
    : DonateItemList() {
    *this = ::std::move(from);
  }

  inline DonateItemList& operator=(DonateItemList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const DonateItemList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DonateItemList* internal_default_instance() {
    return reinterpret_cast<const DonateItemList*>(
               &_DonateItemList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void UnsafeArenaSwap(DonateItemList* other);
  void Swap(DonateItemList* other);
  friend void swap(DonateItemList& a, DonateItemList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DonateItemList* New() const final {
    return CreateMaybeMessage<DonateItemList>(NULL);
  }

  DonateItemList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DonateItemList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DonateItemList& from);
  void MergeFrom(const DonateItemList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DonateItemList* other);
  protected:
  explicit DonateItemList(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sg.DonateItem list = 1;
  int list_size() const;
  void clear_list();
  static const int kListFieldNumber = 1;
  ::sg::DonateItem* mutable_list(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::DonateItem >*
      mutable_list();
  const ::sg::DonateItem& list(int index) const;
  ::sg::DonateItem* add_list();
  const ::google::protobuf::RepeatedPtrField< ::sg::DonateItem >&
      list() const;

  // @@protoc_insertion_point(class_scope:sg.DonateItemList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::DonateItem > list_;
  friend struct ::protobuf_Guild_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GuildService_GuildRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.GuildService.GuildRequest) */ {
 public:
  GuildService_GuildRequest();
  virtual ~GuildService_GuildRequest();

  GuildService_GuildRequest(const GuildService_GuildRequest& from);

  inline GuildService_GuildRequest& operator=(const GuildService_GuildRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GuildService_GuildRequest(GuildService_GuildRequest&& from) noexcept
    : GuildService_GuildRequest() {
    *this = ::std::move(from);
  }

  inline GuildService_GuildRequest& operator=(GuildService_GuildRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const GuildService_GuildRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GuildService_GuildRequest* internal_default_instance() {
    return reinterpret_cast<const GuildService_GuildRequest*>(
               &_GuildService_GuildRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void UnsafeArenaSwap(GuildService_GuildRequest* other);
  void Swap(GuildService_GuildRequest* other);
  friend void swap(GuildService_GuildRequest& a, GuildService_GuildRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GuildService_GuildRequest* New() const final {
    return CreateMaybeMessage<GuildService_GuildRequest>(NULL);
  }

  GuildService_GuildRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GuildService_GuildRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GuildService_GuildRequest& from);
  void MergeFrom(const GuildService_GuildRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GuildService_GuildRequest* other);
  protected:
  explicit GuildService_GuildRequest(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes name = 3;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const void* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_name();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      ::std::string* name);

  // optional bytes announcement = 4;
  bool has_announcement() const;
  void clear_announcement();
  static const int kAnnouncementFieldNumber = 4;
  const ::std::string& announcement() const;
  void set_announcement(const ::std::string& value);
  #if LANG_CXX11
  void set_announcement(::std::string&& value);
  #endif
  void set_announcement(const char* value);
  void set_announcement(const void* value, size_t size);
  ::std::string* mutable_announcement();
  ::std::string* release_announcement();
  void set_allocated_announcement(::std::string* announcement);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_announcement();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_announcement(
      ::std::string* announcement);

  // optional bytes badge = 8;
  bool has_badge() const;
  void clear_badge();
  static const int kBadgeFieldNumber = 8;
  const ::std::string& badge() const;
  void set_badge(const ::std::string& value);
  #if LANG_CXX11
  void set_badge(::std::string&& value);
  #endif
  void set_badge(const char* value);
  void set_badge(const void* value, size_t size);
  ::std::string* mutable_badge();
  ::std::string* release_badge();
  void set_allocated_badge(::std::string* badge);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_badge();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_badge(
      ::std::string* badge);

  // optional .sg.DonateItemList donate_list = 7;
  bool has_donate_list() const;
  void clear_donate_list();
  static const int kDonateListFieldNumber = 7;
  private:
  const ::sg::DonateItemList& _internal_donate_list() const;
  public:
  const ::sg::DonateItemList& donate_list() const;
  ::sg::DonateItemList* release_donate_list();
  ::sg::DonateItemList* mutable_donate_list();
  void set_allocated_donate_list(::sg::DonateItemList* donate_list);
  void unsafe_arena_set_allocated_donate_list(
      ::sg::DonateItemList* donate_list);
  ::sg::DonateItemList* unsafe_arena_release_donate_list();

  // optional int32 guildid = 2;
  bool has_guildid() const;
  void clear_guildid();
  static const int kGuildidFieldNumber = 2;
  ::google::protobuf::int32 guildid() const;
  void set_guildid(::google::protobuf::int32 value);

  // optional int32 user_title = 6;
  bool has_user_title() const;
  void clear_user_title();
  static const int kUserTitleFieldNumber = 6;
  ::google::protobuf::int32 user_title() const;
  void set_user_title(::google::protobuf::int32 value);

  // optional uint64 user_uuid = 5;
  bool has_user_uuid() const;
  void clear_user_uuid();
  static const int kUserUuidFieldNumber = 5;
  ::google::protobuf::uint64 user_uuid() const;
  void set_user_uuid(::google::protobuf::uint64 value);

  // optional .sg.GUILD_ACCEPT_TYPE accept_type = 11;
  bool has_accept_type() const;
  void clear_accept_type();
  static const int kAcceptTypeFieldNumber = 11;
  ::sg::GUILD_ACCEPT_TYPE accept_type() const;
  void set_accept_type(::sg::GUILD_ACCEPT_TYPE value);

  // optional int32 join_level = 12;
  bool has_join_level() const;
  void clear_join_level();
  static const int kJoinLevelFieldNumber = 12;
  ::google::protobuf::int32 join_level() const;
  void set_join_level(::google::protobuf::int32 value);

  // optional int32 building_type = 31;
  bool has_building_type() const;
  void clear_building_type();
  static const int kBuildingTypeFieldNumber = 31;
  ::google::protobuf::int32 building_type() const;
  void set_building_type(::google::protobuf::int32 value);

  // optional int32 join_force = 13;
  bool has_join_force() const;
  void clear_join_force();
  static const int kJoinForceFieldNumber = 13;
  ::google::protobuf::int32 join_force() const;
  void set_join_force(::google::protobuf::int32 value);

  // optional int32 signin_type = 21;
  bool has_signin_type() const;
  void clear_signin_type();
  static const int kSigninTypeFieldNumber = 21;
  ::google::protobuf::int32 signin_type() const;
  void set_signin_type(::google::protobuf::int32 value);

  // required .sg.GuildService.GUILD_COMMAND cmd = 1;
  bool has_cmd() const;
  void clear_cmd();
  static const int kCmdFieldNumber = 1;
  ::sg::GuildService_GUILD_COMMAND cmd() const;
  void set_cmd(::sg::GuildService_GUILD_COMMAND value);

  // @@protoc_insertion_point(class_scope:sg.GuildService.GuildRequest)
 private:
  void set_has_cmd();
  void clear_has_cmd();
  void set_has_guildid();
  void clear_has_guildid();
  void set_has_name();
  void clear_has_name();
  void set_has_announcement();
  void clear_has_announcement();
  void set_has_user_uuid();
  void clear_has_user_uuid();
  void set_has_user_title();
  void clear_has_user_title();
  void set_has_donate_list();
  void clear_has_donate_list();
  void set_has_badge();
  void clear_has_badge();
  void set_has_accept_type();
  void clear_has_accept_type();
  void set_has_join_level();
  void clear_has_join_level();
  void set_has_join_force();
  void clear_has_join_force();
  void set_has_signin_type();
  void clear_has_signin_type();
  void set_has_building_type();
  void clear_has_building_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr announcement_;
  ::google::protobuf::internal::ArenaStringPtr badge_;
  ::sg::DonateItemList* donate_list_;
  ::google::protobuf::int32 guildid_;
  ::google::protobuf::int32 user_title_;
  ::google::protobuf::uint64 user_uuid_;
  int accept_type_;
  ::google::protobuf::int32 join_level_;
  ::google::protobuf::int32 building_type_;
  ::google::protobuf::int32 join_force_;
  ::google::protobuf::int32 signin_type_;
  int cmd_;
  friend struct ::protobuf_Guild_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GuildService_GuildResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.GuildService.GuildResponse) */ {
 public:
  GuildService_GuildResponse();
  virtual ~GuildService_GuildResponse();

  GuildService_GuildResponse(const GuildService_GuildResponse& from);

  inline GuildService_GuildResponse& operator=(const GuildService_GuildResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GuildService_GuildResponse(GuildService_GuildResponse&& from) noexcept
    : GuildService_GuildResponse() {
    *this = ::std::move(from);
  }

  inline GuildService_GuildResponse& operator=(GuildService_GuildResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const GuildService_GuildResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GuildService_GuildResponse* internal_default_instance() {
    return reinterpret_cast<const GuildService_GuildResponse*>(
               &_GuildService_GuildResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void UnsafeArenaSwap(GuildService_GuildResponse* other);
  void Swap(GuildService_GuildResponse* other);
  friend void swap(GuildService_GuildResponse& a, GuildService_GuildResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GuildService_GuildResponse* New() const final {
    return CreateMaybeMessage<GuildService_GuildResponse>(NULL);
  }

  GuildService_GuildResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GuildService_GuildResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GuildService_GuildResponse& from);
  void MergeFrom(const GuildService_GuildResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GuildService_GuildResponse* other);
  protected:
  explicit GuildService_GuildResponse(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 self_joinning_list = 4;
  int self_joinning_list_size() const;
  void clear_self_joinning_list();
  static const int kSelfJoinningListFieldNumber = 4;
  ::google::protobuf::int32 self_joinning_list(int index) const;
  void set_self_joinning_list(int index, ::google::protobuf::int32 value);
  void add_self_joinning_list(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      self_joinning_list() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_self_joinning_list();

  // optional .sg.GuildDataList guild_list = 2;
  bool has_guild_list() const;
  void clear_guild_list();
  static const int kGuildListFieldNumber = 2;
  private:
  const ::sg::GuildDataList& _internal_guild_list() const;
  public:
  const ::sg::GuildDataList& guild_list() const;
  ::sg::GuildDataList* release_guild_list();
  ::sg::GuildDataList* mutable_guild_list();
  void set_allocated_guild_list(::sg::GuildDataList* guild_list);
  void unsafe_arena_set_allocated_guild_list(
      ::sg::GuildDataList* guild_list);
  ::sg::GuildDataList* unsafe_arena_release_guild_list();

  // optional .sg.GuildTrackList track_list = 3;
  bool has_track_list() const;
  void clear_track_list();
  static const int kTrackListFieldNumber = 3;
  private:
  const ::sg::GuildTrackList& _internal_track_list() const;
  public:
  const ::sg::GuildTrackList& track_list() const;
  ::sg::GuildTrackList* release_track_list();
  ::sg::GuildTrackList* mutable_track_list();
  void set_allocated_track_list(::sg::GuildTrackList* track_list);
  void unsafe_arena_set_allocated_track_list(
      ::sg::GuildTrackList* track_list);
  ::sg::GuildTrackList* unsafe_arena_release_track_list();

  // optional .sg.GuildSigninList signin_list = 11;
  bool has_signin_list() const;
  void clear_signin_list();
  static const int kSigninListFieldNumber = 11;
  private:
  const ::sg::GuildSigninList& _internal_signin_list() const;
  public:
  const ::sg::GuildSigninList& signin_list() const;
  ::sg::GuildSigninList* release_signin_list();
  ::sg::GuildSigninList* mutable_signin_list();
  void set_allocated_signin_list(::sg::GuildSigninList* signin_list);
  void unsafe_arena_set_allocated_signin_list(
      ::sg::GuildSigninList* signin_list);
  ::sg::GuildSigninList* unsafe_arena_release_signin_list();

  // optional .sg.Reward signin_drop = 12;
  bool has_signin_drop() const;
  void clear_signin_drop();
  static const int kSigninDropFieldNumber = 12;
  private:
  const ::sg::Reward& _internal_signin_drop() const;
  public:
  const ::sg::Reward& signin_drop() const;
  ::sg::Reward* release_signin_drop();
  ::sg::Reward* mutable_signin_drop();
  void set_allocated_signin_drop(::sg::Reward* signin_drop);
  void unsafe_arena_set_allocated_signin_drop(
      ::sg::Reward* signin_drop);
  ::sg::Reward* unsafe_arena_release_signin_drop();

  // optional .sg.GuildStoreItemList store_item_list = 15;
  bool has_store_item_list() const;
  void clear_store_item_list();
  static const int kStoreItemListFieldNumber = 15;
  private:
  const ::sg::GuildStoreItemList& _internal_store_item_list() const;
  public:
  const ::sg::GuildStoreItemList& store_item_list() const;
  ::sg::GuildStoreItemList* release_store_item_list();
  ::sg::GuildStoreItemList* mutable_store_item_list();
  void set_allocated_store_item_list(::sg::GuildStoreItemList* store_item_list);
  void unsafe_arena_set_allocated_store_item_list(
      ::sg::GuildStoreItemList* store_item_list);
  ::sg::GuildStoreItemList* unsafe_arena_release_store_item_list();

  // optional .sg.Reward donate_drop = 16;
  bool has_donate_drop() const;
  void clear_donate_drop();
  static const int kDonateDropFieldNumber = 16;
  private:
  const ::sg::Reward& _internal_donate_drop() const;
  public:
  const ::sg::Reward& donate_drop() const;
  ::sg::Reward* release_donate_drop();
  ::sg::Reward* mutable_donate_drop();
  void set_allocated_donate_drop(::sg::Reward* donate_drop);
  void unsafe_arena_set_allocated_donate_drop(
      ::sg::Reward* donate_drop);
  ::sg::Reward* unsafe_arena_release_donate_drop();

  // optional .sg.GuildBuildingList building_list = 17;
  bool has_building_list() const;
  void clear_building_list();
  static const int kBuildingListFieldNumber = 17;
  private:
  const ::sg::GuildBuildingList& _internal_building_list() const;
  public:
  const ::sg::GuildBuildingList& building_list() const;
  ::sg::GuildBuildingList* release_building_list();
  ::sg::GuildBuildingList* mutable_building_list();
  void set_allocated_building_list(::sg::GuildBuildingList* building_list);
  void unsafe_arena_set_allocated_building_list(
      ::sg::GuildBuildingList* building_list);
  ::sg::GuildBuildingList* unsafe_arena_release_building_list();

  // required int32 result = 1;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::google::protobuf::int32 result() const;
  void set_result(::google::protobuf::int32 value);

  // optional int32 quit_join_cd = 14;
  bool has_quit_join_cd() const;
  void clear_quit_join_cd();
  static const int kQuitJoinCdFieldNumber = 14;
  ::google::protobuf::int32 quit_join_cd() const;
  void set_quit_join_cd(::google::protobuf::int32 value);

  // optional sfixed64 last_quit_optime = 13;
  bool has_last_quit_optime() const;
  void clear_last_quit_optime();
  static const int kLastQuitOptimeFieldNumber = 13;
  ::google::protobuf::int64 last_quit_optime() const;
  void set_last_quit_optime(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:sg.GuildService.GuildResponse)
 private:
  void set_has_result();
  void clear_has_result();
  void set_has_guild_list();
  void clear_has_guild_list();
  void set_has_track_list();
  void clear_has_track_list();
  void set_has_signin_list();
  void clear_has_signin_list();
  void set_has_signin_drop();
  void clear_has_signin_drop();
  void set_has_last_quit_optime();
  void clear_has_last_quit_optime();
  void set_has_quit_join_cd();
  void clear_has_quit_join_cd();
  void set_has_store_item_list();
  void clear_has_store_item_list();
  void set_has_donate_drop();
  void clear_has_donate_drop();
  void set_has_building_list();
  void clear_has_building_list();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > self_joinning_list_;
  ::sg::GuildDataList* guild_list_;
  ::sg::GuildTrackList* track_list_;
  ::sg::GuildSigninList* signin_list_;
  ::sg::Reward* signin_drop_;
  ::sg::GuildStoreItemList* store_item_list_;
  ::sg::Reward* donate_drop_;
  ::sg::GuildBuildingList* building_list_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 quit_join_cd_;
  ::google::protobuf::int64 last_quit_optime_;
  friend struct ::protobuf_Guild_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GuildService : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.GuildService) */ {
 public:
  GuildService();
  virtual ~GuildService();

  GuildService(const GuildService& from);

  inline GuildService& operator=(const GuildService& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GuildService(GuildService&& from) noexcept
    : GuildService() {
    *this = ::std::move(from);
  }

  inline GuildService& operator=(GuildService&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const GuildService& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GuildService* internal_default_instance() {
    return reinterpret_cast<const GuildService*>(
               &_GuildService_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void UnsafeArenaSwap(GuildService* other);
  void Swap(GuildService* other);
  friend void swap(GuildService& a, GuildService& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GuildService* New() const final {
    return CreateMaybeMessage<GuildService>(NULL);
  }

  GuildService* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GuildService>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GuildService& from);
  void MergeFrom(const GuildService& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GuildService* other);
  protected:
  explicit GuildService(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GuildService_GuildRequest GuildRequest;
  typedef GuildService_GuildResponse GuildResponse;

  typedef GuildService_GUILD_COMMAND GUILD_COMMAND;
  static const GUILD_COMMAND CREATE =
    GuildService_GUILD_COMMAND_CREATE;
  static const GUILD_COMMAND UPGRADE =
    GuildService_GUILD_COMMAND_UPGRADE;
  static const GUILD_COMMAND MODIFY =
    GuildService_GUILD_COMMAND_MODIFY;
  static const GUILD_COMMAND DISBAND =
    GuildService_GUILD_COMMAND_DISBAND;
  static const GUILD_COMMAND REFRESH_CANDIDATES =
    GuildService_GUILD_COMMAND_REFRESH_CANDIDATES;
  static const GUILD_COMMAND JOIN =
    GuildService_GUILD_COMMAND_JOIN;
  static const GUILD_COMMAND QUIT =
    GuildService_GUILD_COMMAND_QUIT;
  static const GUILD_COMMAND DONATE =
    GuildService_GUILD_COMMAND_DONATE;
  static const GUILD_COMMAND MANAGE_ACCEPT =
    GuildService_GUILD_COMMAND_MANAGE_ACCEPT;
  static const GUILD_COMMAND MANAGE_REJECT =
    GuildService_GUILD_COMMAND_MANAGE_REJECT;
  static const GUILD_COMMAND MANAGE_KICK =
    GuildService_GUILD_COMMAND_MANAGE_KICK;
  static const GUILD_COMMAND MANAGE_APPOINT =
    GuildService_GUILD_COMMAND_MANAGE_APPOINT;
  static const GUILD_COMMAND QUERY_ALL =
    GuildService_GUILD_COMMAND_QUERY_ALL;
  static const GUILD_COMMAND QUERY_ONE =
    GuildService_GUILD_COMMAND_QUERY_ONE;
  static const GUILD_COMMAND QUERY_TRACK =
    GuildService_GUILD_COMMAND_QUERY_TRACK;
  static const GUILD_COMMAND QUERY_SIGNIN =
    GuildService_GUILD_COMMAND_QUERY_SIGNIN;
  static const GUILD_COMMAND ACCEPT_SIGNIN =
    GuildService_GUILD_COMMAND_ACCEPT_SIGNIN;
  static const GUILD_COMMAND QUERY_STORE =
    GuildService_GUILD_COMMAND_QUERY_STORE;
  static const GUILD_COMMAND QUERY_BUILDING =
    GuildService_GUILD_COMMAND_QUERY_BUILDING;
  static const GUILD_COMMAND BUILD_ONCE =
    GuildService_GUILD_COMMAND_BUILD_ONCE;
  static inline bool GUILD_COMMAND_IsValid(int value) {
    return GuildService_GUILD_COMMAND_IsValid(value);
  }
  static const GUILD_COMMAND GUILD_COMMAND_MIN =
    GuildService_GUILD_COMMAND_GUILD_COMMAND_MIN;
  static const GUILD_COMMAND GUILD_COMMAND_MAX =
    GuildService_GUILD_COMMAND_GUILD_COMMAND_MAX;
  static const int GUILD_COMMAND_ARRAYSIZE =
    GuildService_GUILD_COMMAND_GUILD_COMMAND_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  GUILD_COMMAND_descriptor() {
    return GuildService_GUILD_COMMAND_descriptor();
  }
  static inline const ::std::string& GUILD_COMMAND_Name(GUILD_COMMAND value) {
    return GuildService_GUILD_COMMAND_Name(value);
  }
  static inline bool GUILD_COMMAND_Parse(const ::std::string& name,
      GUILD_COMMAND* value) {
    return GuildService_GUILD_COMMAND_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .sg.GuildService.GuildRequest req = 1;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 1;
  private:
  const ::sg::GuildService_GuildRequest& _internal_req() const;
  public:
  const ::sg::GuildService_GuildRequest& req() const;
  ::sg::GuildService_GuildRequest* release_req();
  ::sg::GuildService_GuildRequest* mutable_req();
  void set_allocated_req(::sg::GuildService_GuildRequest* req);
  void unsafe_arena_set_allocated_req(
      ::sg::GuildService_GuildRequest* req);
  ::sg::GuildService_GuildRequest* unsafe_arena_release_req();

  // optional .sg.GuildService.GuildResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  private:
  const ::sg::GuildService_GuildResponse& _internal_resp() const;
  public:
  const ::sg::GuildService_GuildResponse& resp() const;
  ::sg::GuildService_GuildResponse* release_resp();
  ::sg::GuildService_GuildResponse* mutable_resp();
  void set_allocated_resp(::sg::GuildService_GuildResponse* resp);
  void unsafe_arena_set_allocated_resp(
      ::sg::GuildService_GuildResponse* resp);
  ::sg::GuildService_GuildResponse* unsafe_arena_release_resp();

  // @@protoc_insertion_point(class_scope:sg.GuildService)
 private:
  void set_has_req();
  void clear_has_req();
  void set_has_resp();
  void clear_has_resp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::sg::GuildService_GuildRequest* req_;
  ::sg::GuildService_GuildResponse* resp_;
  friend struct ::protobuf_Guild_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GameGuildTrackNotify : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.GameGuildTrackNotify) */ {
 public:
  GameGuildTrackNotify();
  virtual ~GameGuildTrackNotify();

  GameGuildTrackNotify(const GameGuildTrackNotify& from);

  inline GameGuildTrackNotify& operator=(const GameGuildTrackNotify& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameGuildTrackNotify(GameGuildTrackNotify&& from) noexcept
    : GameGuildTrackNotify() {
    *this = ::std::move(from);
  }

  inline GameGuildTrackNotify& operator=(GameGuildTrackNotify&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const GameGuildTrackNotify& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameGuildTrackNotify* internal_default_instance() {
    return reinterpret_cast<const GameGuildTrackNotify*>(
               &_GameGuildTrackNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void UnsafeArenaSwap(GameGuildTrackNotify* other);
  void Swap(GameGuildTrackNotify* other);
  friend void swap(GameGuildTrackNotify& a, GameGuildTrackNotify& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameGuildTrackNotify* New() const final {
    return CreateMaybeMessage<GameGuildTrackNotify>(NULL);
  }

  GameGuildTrackNotify* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameGuildTrackNotify>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GameGuildTrackNotify& from);
  void MergeFrom(const GameGuildTrackNotify& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameGuildTrackNotify* other);
  protected:
  explicit GameGuildTrackNotify(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .sg.GuildTrack track = 1;
  bool has_track() const;
  void clear_track();
  static const int kTrackFieldNumber = 1;
  private:
  const ::sg::GuildTrack& _internal_track() const;
  public:
  const ::sg::GuildTrack& track() const;
  ::sg::GuildTrack* release_track();
  ::sg::GuildTrack* mutable_track();
  void set_allocated_track(::sg::GuildTrack* track);
  void unsafe_arena_set_allocated_track(
      ::sg::GuildTrack* track);
  ::sg::GuildTrack* unsafe_arena_release_track();

  // optional .sg.GuildData guild = 2;
  bool has_guild() const;
  void clear_guild();
  static const int kGuildFieldNumber = 2;
  private:
  const ::sg::GuildData& _internal_guild() const;
  public:
  const ::sg::GuildData& guild() const;
  ::sg::GuildData* release_guild();
  ::sg::GuildData* mutable_guild();
  void set_allocated_guild(::sg::GuildData* guild);
  void unsafe_arena_set_allocated_guild(
      ::sg::GuildData* guild);
  ::sg::GuildData* unsafe_arena_release_guild();

  // @@protoc_insertion_point(class_scope:sg.GameGuildTrackNotify)
 private:
  void set_has_track();
  void clear_has_track();
  void set_has_guild();
  void clear_has_guild();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::sg::GuildTrack* track_;
  ::sg::GuildData* guild_;
  friend struct ::protobuf_Guild_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GuildStoreItem

// required uint64 item_typeid = 1;
inline bool GuildStoreItem::has_item_typeid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GuildStoreItem::set_has_item_typeid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GuildStoreItem::clear_has_item_typeid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GuildStoreItem::clear_item_typeid() {
  item_typeid_ = GOOGLE_ULONGLONG(0);
  clear_has_item_typeid();
}
inline ::google::protobuf::uint64 GuildStoreItem::item_typeid() const {
  // @@protoc_insertion_point(field_get:sg.GuildStoreItem.item_typeid)
  return item_typeid_;
}
inline void GuildStoreItem::set_item_typeid(::google::protobuf::uint64 value) {
  set_has_item_typeid();
  item_typeid_ = value;
  // @@protoc_insertion_point(field_set:sg.GuildStoreItem.item_typeid)
}

// required int32 item_num = 2;
inline bool GuildStoreItem::has_item_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GuildStoreItem::set_has_item_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GuildStoreItem::clear_has_item_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GuildStoreItem::clear_item_num() {
  item_num_ = 0;
  clear_has_item_num();
}
inline ::google::protobuf::int32 GuildStoreItem::item_num() const {
  // @@protoc_insertion_point(field_get:sg.GuildStoreItem.item_num)
  return item_num_;
}
inline void GuildStoreItem::set_item_num(::google::protobuf::int32 value) {
  set_has_item_num();
  item_num_ = value;
  // @@protoc_insertion_point(field_set:sg.GuildStoreItem.item_num)
}

// -------------------------------------------------------------------

// GuildStoreItemList

// repeated .sg.GuildStoreItem list = 1;
inline int GuildStoreItemList::list_size() const {
  return list_.size();
}
inline void GuildStoreItemList::clear_list() {
  list_.Clear();
}
inline ::sg::GuildStoreItem* GuildStoreItemList::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:sg.GuildStoreItemList.list)
  return list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::GuildStoreItem >*
GuildStoreItemList::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:sg.GuildStoreItemList.list)
  return &list_;
}
inline const ::sg::GuildStoreItem& GuildStoreItemList::list(int index) const {
  // @@protoc_insertion_point(field_get:sg.GuildStoreItemList.list)
  return list_.Get(index);
}
inline ::sg::GuildStoreItem* GuildStoreItemList::add_list() {
  // @@protoc_insertion_point(field_add:sg.GuildStoreItemList.list)
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::GuildStoreItem >&
GuildStoreItemList::list() const {
  // @@protoc_insertion_point(field_list:sg.GuildStoreItemList.list)
  return list_;
}

// -------------------------------------------------------------------

// GuildBuilding

// required int32 building_type = 1;
inline bool GuildBuilding::has_building_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GuildBuilding::set_has_building_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GuildBuilding::clear_has_building_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GuildBuilding::clear_building_type() {
  building_type_ = 0;
  clear_has_building_type();
}
inline ::google::protobuf::int32 GuildBuilding::building_type() const {
  // @@protoc_insertion_point(field_get:sg.GuildBuilding.building_type)
  return building_type_;
}
inline void GuildBuilding::set_building_type(::google::protobuf::int32 value) {
  set_has_building_type();
  building_type_ = value;
  // @@protoc_insertion_point(field_set:sg.GuildBuilding.building_type)
}

// required int32 level = 2;
inline bool GuildBuilding::has_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GuildBuilding::set_has_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GuildBuilding::clear_has_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GuildBuilding::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 GuildBuilding::level() const {
  // @@protoc_insertion_point(field_get:sg.GuildBuilding.level)
  return level_;
}
inline void GuildBuilding::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:sg.GuildBuilding.level)
}

// required .sg.GuildBuilding.BUILDING_STATE state = 3;
inline bool GuildBuilding::has_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GuildBuilding::set_has_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GuildBuilding::clear_has_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GuildBuilding::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::sg::GuildBuilding_BUILDING_STATE GuildBuilding::state() const {
  // @@protoc_insertion_point(field_get:sg.GuildBuilding.state)
  return static_cast< ::sg::GuildBuilding_BUILDING_STATE >(state_);
}
inline void GuildBuilding::set_state(::sg::GuildBuilding_BUILDING_STATE value) {
  assert(::sg::GuildBuilding_BUILDING_STATE_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:sg.GuildBuilding.state)
}

// required int32 seconds = 4;
inline bool GuildBuilding::has_seconds() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GuildBuilding::set_has_seconds() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GuildBuilding::clear_has_seconds() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GuildBuilding::clear_seconds() {
  seconds_ = 0;
  clear_has_seconds();
}
inline ::google::protobuf::int32 GuildBuilding::seconds() const {
  // @@protoc_insertion_point(field_get:sg.GuildBuilding.seconds)
  return seconds_;
}
inline void GuildBuilding::set_seconds(::google::protobuf::int32 value) {
  set_has_seconds();
  seconds_ = value;
  // @@protoc_insertion_point(field_set:sg.GuildBuilding.seconds)
}

// required sfixed64 starttime = 5;
inline bool GuildBuilding::has_starttime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GuildBuilding::set_has_starttime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GuildBuilding::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GuildBuilding::clear_starttime() {
  starttime_ = GOOGLE_LONGLONG(0);
  clear_has_starttime();
}
inline ::google::protobuf::int64 GuildBuilding::starttime() const {
  // @@protoc_insertion_point(field_get:sg.GuildBuilding.starttime)
  return starttime_;
}
inline void GuildBuilding::set_starttime(::google::protobuf::int64 value) {
  set_has_starttime();
  starttime_ = value;
  // @@protoc_insertion_point(field_set:sg.GuildBuilding.starttime)
}

// -------------------------------------------------------------------

// GuildBuildingList

// repeated .sg.GuildBuilding list = 1;
inline int GuildBuildingList::list_size() const {
  return list_.size();
}
inline void GuildBuildingList::clear_list() {
  list_.Clear();
}
inline ::sg::GuildBuilding* GuildBuildingList::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:sg.GuildBuildingList.list)
  return list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::GuildBuilding >*
GuildBuildingList::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:sg.GuildBuildingList.list)
  return &list_;
}
inline const ::sg::GuildBuilding& GuildBuildingList::list(int index) const {
  // @@protoc_insertion_point(field_get:sg.GuildBuildingList.list)
  return list_.Get(index);
}
inline ::sg::GuildBuilding* GuildBuildingList::add_list() {
  // @@protoc_insertion_point(field_add:sg.GuildBuildingList.list)
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::GuildBuilding >&
GuildBuildingList::list() const {
  // @@protoc_insertion_point(field_list:sg.GuildBuildingList.list)
  return list_;
}

// -------------------------------------------------------------------

// GuildUserData

// required uint64 uuid = 1;
inline bool GuildUserData::has_uuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GuildUserData::set_has_uuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GuildUserData::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GuildUserData::clear_uuid() {
  uuid_ = GOOGLE_ULONGLONG(0);
  clear_has_uuid();
}
inline ::google::protobuf::uint64 GuildUserData::uuid() const {
  // @@protoc_insertion_point(field_get:sg.GuildUserData.uuid)
  return uuid_;
}
inline void GuildUserData::set_uuid(::google::protobuf::uint64 value) {
  set_has_uuid();
  uuid_ = value;
  // @@protoc_insertion_point(field_set:sg.GuildUserData.uuid)
}

// required bytes role_nick = 2;
inline bool GuildUserData::has_role_nick() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GuildUserData::set_has_role_nick() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GuildUserData::clear_has_role_nick() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GuildUserData::clear_role_nick() {
  role_nick_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_role_nick();
}
inline const ::std::string& GuildUserData::role_nick() const {
  // @@protoc_insertion_point(field_get:sg.GuildUserData.role_nick)
  return role_nick_.Get();
}
inline void GuildUserData::set_role_nick(const ::std::string& value) {
  set_has_role_nick();
  role_nick_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:sg.GuildUserData.role_nick)
}
#if LANG_CXX11
inline void GuildUserData::set_role_nick(::std::string&& value) {
  set_has_role_nick();
  role_nick_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:sg.GuildUserData.role_nick)
}
#endif
inline void GuildUserData::set_role_nick(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_role_nick();
  role_nick_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:sg.GuildUserData.role_nick)
}
inline void GuildUserData::set_role_nick(const void* value,
    size_t size) {
  set_has_role_nick();
  role_nick_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:sg.GuildUserData.role_nick)
}
inline ::std::string* GuildUserData::mutable_role_nick() {
  set_has_role_nick();
  // @@protoc_insertion_point(field_mutable:sg.GuildUserData.role_nick)
  return role_nick_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* GuildUserData::release_role_nick() {
  // @@protoc_insertion_point(field_release:sg.GuildUserData.role_nick)
  if (!has_role_nick()) {
    return NULL;
  }
  clear_has_role_nick();
  return role_nick_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void GuildUserData::set_allocated_role_nick(::std::string* role_nick) {
  if (role_nick != NULL) {
    set_has_role_nick();
  } else {
    clear_has_role_nick();
  }
  role_nick_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), role_nick,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:sg.GuildUserData.role_nick)
}
inline ::std::string* GuildUserData::unsafe_arena_release_role_nick() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.GuildUserData.role_nick)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_role_nick();
  return role_nick_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void GuildUserData::unsafe_arena_set_allocated_role_nick(
    ::std::string* role_nick) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (role_nick != NULL) {
    set_has_role_nick();
  } else {
    clear_has_role_nick();
  }
  role_nick_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      role_nick, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sg.GuildUserData.role_nick)
}

// required int32 role_level = 3;
inline bool GuildUserData::has_role_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GuildUserData::set_has_role_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GuildUserData::clear_has_role_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GuildUserData::clear_role_level() {
  role_level_ = 0;
  clear_has_role_level();
}
inline ::google::protobuf::int32 GuildUserData::role_level() const {
  // @@protoc_insertion_point(field_get:sg.GuildUserData.role_level)
  return role_level_;
}
inline void GuildUserData::set_role_level(::google::protobuf::int32 value) {
  set_has_role_level();
  role_level_ = value;
  // @@protoc_insertion_point(field_set:sg.GuildUserData.role_level)
}

// required int32 role_exp = 4;
inline bool GuildUserData::has_role_exp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GuildUserData::set_has_role_exp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GuildUserData::clear_has_role_exp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GuildUserData::clear_role_exp() {
  role_exp_ = 0;
  clear_has_role_exp();
}
inline ::google::protobuf::int32 GuildUserData::role_exp() const {
  // @@protoc_insertion_point(field_get:sg.GuildUserData.role_exp)
  return role_exp_;
}
inline void GuildUserData::set_role_exp(::google::protobuf::int32 value) {
  set_has_role_exp();
  role_exp_ = value;
  // @@protoc_insertion_point(field_set:sg.GuildUserData.role_exp)
}

// required int32 role_rank = 5;
inline bool GuildUserData::has_role_rank() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GuildUserData::set_has_role_rank() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GuildUserData::clear_has_role_rank() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GuildUserData::clear_role_rank() {
  role_rank_ = 0;
  clear_has_role_rank();
}
inline ::google::protobuf::int32 GuildUserData::role_rank() const {
  // @@protoc_insertion_point(field_get:sg.GuildUserData.role_rank)
  return role_rank_;
}
inline void GuildUserData::set_role_rank(::google::protobuf::int32 value) {
  set_has_role_rank();
  role_rank_ = value;
  // @@protoc_insertion_point(field_set:sg.GuildUserData.role_rank)
}

// required int32 role_portrait = 6;
inline bool GuildUserData::has_role_portrait() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GuildUserData::set_has_role_portrait() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GuildUserData::clear_has_role_portrait() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GuildUserData::clear_role_portrait() {
  role_portrait_ = 0;
  clear_has_role_portrait();
}
inline ::google::protobuf::int32 GuildUserData::role_portrait() const {
  // @@protoc_insertion_point(field_get:sg.GuildUserData.role_portrait)
  return role_portrait_;
}
inline void GuildUserData::set_role_portrait(::google::protobuf::int32 value) {
  set_has_role_portrait();
  role_portrait_ = value;
  // @@protoc_insertion_point(field_set:sg.GuildUserData.role_portrait)
}

// required int32 role_portrait_frame = 7;
inline bool GuildUserData::has_role_portrait_frame() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GuildUserData::set_has_role_portrait_frame() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GuildUserData::clear_has_role_portrait_frame() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GuildUserData::clear_role_portrait_frame() {
  role_portrait_frame_ = 0;
  clear_has_role_portrait_frame();
}
inline ::google::protobuf::int32 GuildUserData::role_portrait_frame() const {
  // @@protoc_insertion_point(field_get:sg.GuildUserData.role_portrait_frame)
  return role_portrait_frame_;
}
inline void GuildUserData::set_role_portrait_frame(::google::protobuf::int32 value) {
  set_has_role_portrait_frame();
  role_portrait_frame_ = value;
  // @@protoc_insertion_point(field_set:sg.GuildUserData.role_portrait_frame)
}

// required int32 role_force = 8;
inline bool GuildUserData::has_role_force() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GuildUserData::set_has_role_force() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GuildUserData::clear_has_role_force() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GuildUserData::clear_role_force() {
  role_force_ = 0;
  clear_has_role_force();
}
inline ::google::protobuf::int32 GuildUserData::role_force() const {
  // @@protoc_insertion_point(field_get:sg.GuildUserData.role_force)
  return role_force_;
}
inline void GuildUserData::set_role_force(::google::protobuf::int32 value) {
  set_has_role_force();
  role_force_ = value;
  // @@protoc_insertion_point(field_set:sg.GuildUserData.role_force)
}

// required .sg.GUILD_USER_STATE state = 9;
inline bool GuildUserData::has_state() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void GuildUserData::set_has_state() {
  _has_bits_[0] |= 0x00002000u;
}
inline void GuildUserData::clear_has_state() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void GuildUserData::clear_state() {
  state_ = -1;
  clear_has_state();
}
inline ::sg::GUILD_USER_STATE GuildUserData::state() const {
  // @@protoc_insertion_point(field_get:sg.GuildUserData.state)
  return static_cast< ::sg::GUILD_USER_STATE >(state_);
}
inline void GuildUserData::set_state(::sg::GUILD_USER_STATE value) {
  assert(::sg::GUILD_USER_STATE_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:sg.GuildUserData.state)
}

// required sfixed64 optime = 11;
inline bool GuildUserData::has_optime() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GuildUserData::set_has_optime() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GuildUserData::clear_has_optime() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GuildUserData::clear_optime() {
  optime_ = GOOGLE_LONGLONG(0);
  clear_has_optime();
}
inline ::google::protobuf::int64 GuildUserData::optime() const {
  // @@protoc_insertion_point(field_get:sg.GuildUserData.optime)
  return optime_;
}
inline void GuildUserData::set_optime(::google::protobuf::int64 value) {
  set_has_optime();
  optime_ = value;
  // @@protoc_insertion_point(field_set:sg.GuildUserData.optime)
}

// required bool is_online = 12;
inline bool GuildUserData::has_is_online() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GuildUserData::set_has_is_online() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GuildUserData::clear_has_is_online() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GuildUserData::clear_is_online() {
  is_online_ = false;
  clear_has_is_online();
}
inline bool GuildUserData::is_online() const {
  // @@protoc_insertion_point(field_get:sg.GuildUserData.is_online)
  return is_online_;
}
inline void GuildUserData::set_is_online(bool value) {
  set_has_is_online();
  is_online_ = value;
  // @@protoc_insertion_point(field_set:sg.GuildUserData.is_online)
}

// required .sg.GUILD_USER_TITLE title = 21;
inline bool GuildUserData::has_title() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GuildUserData::set_has_title() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GuildUserData::clear_has_title() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GuildUserData::clear_title() {
  title_ = 0;
  clear_has_title();
}
inline ::sg::GUILD_USER_TITLE GuildUserData::title() const {
  // @@protoc_insertion_point(field_get:sg.GuildUserData.title)
  return static_cast< ::sg::GUILD_USER_TITLE >(title_);
}
inline void GuildUserData::set_title(::sg::GUILD_USER_TITLE value) {
  assert(::sg::GUILD_USER_TITLE_IsValid(value));
  set_has_title();
  title_ = value;
  // @@protoc_insertion_point(field_set:sg.GuildUserData.title)
}

// required int32 donation = 22;
inline bool GuildUserData::has_donation() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GuildUserData::set_has_donation() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GuildUserData::clear_has_donation() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GuildUserData::clear_donation() {
  donation_ = 0;
  clear_has_donation();
}
inline ::google::protobuf::int32 GuildUserData::donation() const {
  // @@protoc_insertion_point(field_get:sg.GuildUserData.donation)
  return donation_;
}
inline void GuildUserData::set_donation(::google::protobuf::int32 value) {
  set_has_donation();
  donation_ = value;
  // @@protoc_insertion_point(field_set:sg.GuildUserData.donation)
}

// optional int32 donation_today = 23;
inline bool GuildUserData::has_donation_today() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void GuildUserData::set_has_donation_today() {
  _has_bits_[0] |= 0x00001000u;
}
inline void GuildUserData::clear_has_donation_today() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void GuildUserData::clear_donation_today() {
  donation_today_ = 0;
  clear_has_donation_today();
}
inline ::google::protobuf::int32 GuildUserData::donation_today() const {
  // @@protoc_insertion_point(field_get:sg.GuildUserData.donation_today)
  return donation_today_;
}
inline void GuildUserData::set_donation_today(::google::protobuf::int32 value) {
  set_has_donation_today();
  donation_today_ = value;
  // @@protoc_insertion_point(field_set:sg.GuildUserData.donation_today)
}

// -------------------------------------------------------------------

// GuildUserDataList

// repeated .sg.GuildUserData list = 1;
inline int GuildUserDataList::list_size() const {
  return list_.size();
}
inline void GuildUserDataList::clear_list() {
  list_.Clear();
}
inline ::sg::GuildUserData* GuildUserDataList::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:sg.GuildUserDataList.list)
  return list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::GuildUserData >*
GuildUserDataList::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:sg.GuildUserDataList.list)
  return &list_;
}
inline const ::sg::GuildUserData& GuildUserDataList::list(int index) const {
  // @@protoc_insertion_point(field_get:sg.GuildUserDataList.list)
  return list_.Get(index);
}
inline ::sg::GuildUserData* GuildUserDataList::add_list() {
  // @@protoc_insertion_point(field_add:sg.GuildUserDataList.list)
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::GuildUserData >&
GuildUserDataList::list() const {
  // @@protoc_insertion_point(field_list:sg.GuildUserDataList.list)
  return list_;
}

// -------------------------------------------------------------------

// GuildData

// required int32 id = 1;
inline bool GuildData::has_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GuildData::set_has_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GuildData::clear_has_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GuildData::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 GuildData::id() const {
  // @@protoc_insertion_point(field_get:sg.GuildData.id)
  return id_;
}
inline void GuildData::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:sg.GuildData.id)
}

// required bytes name = 2;
inline bool GuildData::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GuildData::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GuildData::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GuildData::clear_name() {
  name_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_name();
}
inline const ::std::string& GuildData::name() const {
  // @@protoc_insertion_point(field_get:sg.GuildData.name)
  return name_.Get();
}
inline void GuildData::set_name(const ::std::string& value) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:sg.GuildData.name)
}
#if LANG_CXX11
inline void GuildData::set_name(::std::string&& value) {
  set_has_name();
  name_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:sg.GuildData.name)
}
#endif
inline void GuildData::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:sg.GuildData.name)
}
inline void GuildData::set_name(const void* value,
    size_t size) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:sg.GuildData.name)
}
inline ::std::string* GuildData::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:sg.GuildData.name)
  return name_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* GuildData::release_name() {
  // @@protoc_insertion_point(field_release:sg.GuildData.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void GuildData::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:sg.GuildData.name)
}
inline ::std::string* GuildData::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.GuildData.name)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_name();
  return name_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void GuildData::unsafe_arena_set_allocated_name(
    ::std::string* name) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      name, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sg.GuildData.name)
}

// required int32 level = 3;
inline bool GuildData::has_level() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GuildData::set_has_level() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GuildData::clear_has_level() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GuildData::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 GuildData::level() const {
  // @@protoc_insertion_point(field_get:sg.GuildData.level)
  return level_;
}
inline void GuildData::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:sg.GuildData.level)
}

// required int32 population = 4;
inline bool GuildData::has_population() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GuildData::set_has_population() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GuildData::clear_has_population() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GuildData::clear_population() {
  population_ = 0;
  clear_has_population();
}
inline ::google::protobuf::int32 GuildData::population() const {
  // @@protoc_insertion_point(field_get:sg.GuildData.population)
  return population_;
}
inline void GuildData::set_population(::google::protobuf::int32 value) {
  set_has_population();
  population_ = value;
  // @@protoc_insertion_point(field_set:sg.GuildData.population)
}

// required uint64 fund = 5;
inline bool GuildData::has_fund() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GuildData::set_has_fund() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GuildData::clear_has_fund() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GuildData::clear_fund() {
  fund_ = GOOGLE_ULONGLONG(0);
  clear_has_fund();
}
inline ::google::protobuf::uint64 GuildData::fund() const {
  // @@protoc_insertion_point(field_get:sg.GuildData.fund)
  return fund_;
}
inline void GuildData::set_fund(::google::protobuf::uint64 value) {
  set_has_fund();
  fund_ = value;
  // @@protoc_insertion_point(field_set:sg.GuildData.fund)
}

// required bytes announcement = 6;
inline bool GuildData::has_announcement() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GuildData::set_has_announcement() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GuildData::clear_has_announcement() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GuildData::clear_announcement() {
  announcement_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_announcement();
}
inline const ::std::string& GuildData::announcement() const {
  // @@protoc_insertion_point(field_get:sg.GuildData.announcement)
  return announcement_.Get();
}
inline void GuildData::set_announcement(const ::std::string& value) {
  set_has_announcement();
  announcement_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:sg.GuildData.announcement)
}
#if LANG_CXX11
inline void GuildData::set_announcement(::std::string&& value) {
  set_has_announcement();
  announcement_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:sg.GuildData.announcement)
}
#endif
inline void GuildData::set_announcement(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_announcement();
  announcement_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:sg.GuildData.announcement)
}
inline void GuildData::set_announcement(const void* value,
    size_t size) {
  set_has_announcement();
  announcement_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:sg.GuildData.announcement)
}
inline ::std::string* GuildData::mutable_announcement() {
  set_has_announcement();
  // @@protoc_insertion_point(field_mutable:sg.GuildData.announcement)
  return announcement_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* GuildData::release_announcement() {
  // @@protoc_insertion_point(field_release:sg.GuildData.announcement)
  if (!has_announcement()) {
    return NULL;
  }
  clear_has_announcement();
  return announcement_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void GuildData::set_allocated_announcement(::std::string* announcement) {
  if (announcement != NULL) {
    set_has_announcement();
  } else {
    clear_has_announcement();
  }
  announcement_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), announcement,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:sg.GuildData.announcement)
}
inline ::std::string* GuildData::unsafe_arena_release_announcement() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.GuildData.announcement)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_announcement();
  return announcement_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void GuildData::unsafe_arena_set_allocated_announcement(
    ::std::string* announcement) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (announcement != NULL) {
    set_has_announcement();
  } else {
    clear_has_announcement();
  }
  announcement_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      announcement, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sg.GuildData.announcement)
}

// required .sg.GUILD_STATE state = 7;
inline bool GuildData::has_state() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void GuildData::set_has_state() {
  _has_bits_[0] |= 0x00004000u;
}
inline void GuildData::clear_has_state() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void GuildData::clear_state() {
  state_ = 1;
  clear_has_state();
}
inline ::sg::GUILD_STATE GuildData::state() const {
  // @@protoc_insertion_point(field_get:sg.GuildData.state)
  return static_cast< ::sg::GUILD_STATE >(state_);
}
inline void GuildData::set_state(::sg::GUILD_STATE value) {
  assert(::sg::GUILD_STATE_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:sg.GuildData.state)
}

// required bytes badge = 8;
inline bool GuildData::has_badge() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GuildData::set_has_badge() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GuildData::clear_has_badge() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GuildData::clear_badge() {
  badge_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_badge();
}
inline const ::std::string& GuildData::badge() const {
  // @@protoc_insertion_point(field_get:sg.GuildData.badge)
  return badge_.Get();
}
inline void GuildData::set_badge(const ::std::string& value) {
  set_has_badge();
  badge_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:sg.GuildData.badge)
}
#if LANG_CXX11
inline void GuildData::set_badge(::std::string&& value) {
  set_has_badge();
  badge_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:sg.GuildData.badge)
}
#endif
inline void GuildData::set_badge(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_badge();
  badge_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:sg.GuildData.badge)
}
inline void GuildData::set_badge(const void* value,
    size_t size) {
  set_has_badge();
  badge_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:sg.GuildData.badge)
}
inline ::std::string* GuildData::mutable_badge() {
  set_has_badge();
  // @@protoc_insertion_point(field_mutable:sg.GuildData.badge)
  return badge_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* GuildData::release_badge() {
  // @@protoc_insertion_point(field_release:sg.GuildData.badge)
  if (!has_badge()) {
    return NULL;
  }
  clear_has_badge();
  return badge_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void GuildData::set_allocated_badge(::std::string* badge) {
  if (badge != NULL) {
    set_has_badge();
  } else {
    clear_has_badge();
  }
  badge_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), badge,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:sg.GuildData.badge)
}
inline ::std::string* GuildData::unsafe_arena_release_badge() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.GuildData.badge)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_badge();
  return badge_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void GuildData::unsafe_arena_set_allocated_badge(
    ::std::string* badge) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (badge != NULL) {
    set_has_badge();
  } else {
    clear_has_badge();
  }
  badge_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      badge, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sg.GuildData.badge)
}

// optional .sg.GUILD_ACCEPT_TYPE accept_type = 11;
inline bool GuildData::has_accept_type() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GuildData::set_has_accept_type() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GuildData::clear_has_accept_type() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GuildData::clear_accept_type() {
  accept_type_ = 0;
  clear_has_accept_type();
}
inline ::sg::GUILD_ACCEPT_TYPE GuildData::accept_type() const {
  // @@protoc_insertion_point(field_get:sg.GuildData.accept_type)
  return static_cast< ::sg::GUILD_ACCEPT_TYPE >(accept_type_);
}
inline void GuildData::set_accept_type(::sg::GUILD_ACCEPT_TYPE value) {
  assert(::sg::GUILD_ACCEPT_TYPE_IsValid(value));
  set_has_accept_type();
  accept_type_ = value;
  // @@protoc_insertion_point(field_set:sg.GuildData.accept_type)
}

// optional int32 join_level = 12;
inline bool GuildData::has_join_level() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GuildData::set_has_join_level() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GuildData::clear_has_join_level() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GuildData::clear_join_level() {
  join_level_ = 0;
  clear_has_join_level();
}
inline ::google::protobuf::int32 GuildData::join_level() const {
  // @@protoc_insertion_point(field_get:sg.GuildData.join_level)
  return join_level_;
}
inline void GuildData::set_join_level(::google::protobuf::int32 value) {
  set_has_join_level();
  join_level_ = value;
  // @@protoc_insertion_point(field_set:sg.GuildData.join_level)
}

// optional int32 join_force = 13;
inline bool GuildData::has_join_force() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GuildData::set_has_join_force() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GuildData::clear_has_join_force() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GuildData::clear_join_force() {
  join_force_ = 0;
  clear_has_join_force();
}
inline ::google::protobuf::int32 GuildData::join_force() const {
  // @@protoc_insertion_point(field_get:sg.GuildData.join_force)
  return join_force_;
}
inline void GuildData::set_join_force(::google::protobuf::int32 value) {
  set_has_join_force();
  join_force_ = value;
  // @@protoc_insertion_point(field_set:sg.GuildData.join_force)
}

// optional bool shopping = 14;
inline bool GuildData::has_shopping() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void GuildData::set_has_shopping() {
  _has_bits_[0] |= 0x00001000u;
}
inline void GuildData::clear_has_shopping() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void GuildData::clear_shopping() {
  shopping_ = false;
  clear_has_shopping();
}
inline bool GuildData::shopping() const {
  // @@protoc_insertion_point(field_get:sg.GuildData.shopping)
  return shopping_;
}
inline void GuildData::set_shopping(bool value) {
  set_has_shopping();
  shopping_ = value;
  // @@protoc_insertion_point(field_set:sg.GuildData.shopping)
}

// optional bool chat = 15;
inline bool GuildData::has_chat() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void GuildData::set_has_chat() {
  _has_bits_[0] |= 0x00002000u;
}
inline void GuildData::clear_has_chat() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void GuildData::clear_chat() {
  chat_ = false;
  clear_has_chat();
}
inline bool GuildData::chat() const {
  // @@protoc_insertion_point(field_get:sg.GuildData.chat)
  return chat_;
}
inline void GuildData::set_chat(bool value) {
  set_has_chat();
  chat_ = value;
  // @@protoc_insertion_point(field_set:sg.GuildData.chat)
}

// optional .sg.GuildUserDataList member_list = 21;
inline bool GuildData::has_member_list() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GuildData::set_has_member_list() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GuildData::clear_has_member_list() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GuildData::clear_member_list() {
  if (member_list_ != NULL) member_list_->Clear();
  clear_has_member_list();
}
inline const ::sg::GuildUserDataList& GuildData::_internal_member_list() const {
  return *member_list_;
}
inline const ::sg::GuildUserDataList& GuildData::member_list() const {
  const ::sg::GuildUserDataList* p = member_list_;
  // @@protoc_insertion_point(field_get:sg.GuildData.member_list)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::GuildUserDataList*>(
      &::sg::_GuildUserDataList_default_instance_);
}
inline ::sg::GuildUserDataList* GuildData::release_member_list() {
  // @@protoc_insertion_point(field_release:sg.GuildData.member_list)
  clear_has_member_list();
  ::sg::GuildUserDataList* temp = member_list_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  member_list_ = NULL;
  return temp;
}
inline ::sg::GuildUserDataList* GuildData::unsafe_arena_release_member_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.GuildData.member_list)
  clear_has_member_list();
  ::sg::GuildUserDataList* temp = member_list_;
  member_list_ = NULL;
  return temp;
}
inline ::sg::GuildUserDataList* GuildData::mutable_member_list() {
  set_has_member_list();
  if (member_list_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::GuildUserDataList>(GetArenaNoVirtual());
    member_list_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.GuildData.member_list)
  return member_list_;
}
inline void GuildData::set_allocated_member_list(::sg::GuildUserDataList* member_list) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete member_list_;
  }
  if (member_list) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(member_list);
    if (message_arena != submessage_arena) {
      member_list = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, member_list, submessage_arena);
    }
    set_has_member_list();
  } else {
    clear_has_member_list();
  }
  member_list_ = member_list;
  // @@protoc_insertion_point(field_set_allocated:sg.GuildData.member_list)
}

// optional .sg.GuildUserDataList join_list = 22;
inline bool GuildData::has_join_list() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GuildData::set_has_join_list() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GuildData::clear_has_join_list() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GuildData::clear_join_list() {
  if (join_list_ != NULL) join_list_->Clear();
  clear_has_join_list();
}
inline const ::sg::GuildUserDataList& GuildData::_internal_join_list() const {
  return *join_list_;
}
inline const ::sg::GuildUserDataList& GuildData::join_list() const {
  const ::sg::GuildUserDataList* p = join_list_;
  // @@protoc_insertion_point(field_get:sg.GuildData.join_list)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::GuildUserDataList*>(
      &::sg::_GuildUserDataList_default_instance_);
}
inline ::sg::GuildUserDataList* GuildData::release_join_list() {
  // @@protoc_insertion_point(field_release:sg.GuildData.join_list)
  clear_has_join_list();
  ::sg::GuildUserDataList* temp = join_list_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  join_list_ = NULL;
  return temp;
}
inline ::sg::GuildUserDataList* GuildData::unsafe_arena_release_join_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.GuildData.join_list)
  clear_has_join_list();
  ::sg::GuildUserDataList* temp = join_list_;
  join_list_ = NULL;
  return temp;
}
inline ::sg::GuildUserDataList* GuildData::mutable_join_list() {
  set_has_join_list();
  if (join_list_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::GuildUserDataList>(GetArenaNoVirtual());
    join_list_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.GuildData.join_list)
  return join_list_;
}
inline void GuildData::set_allocated_join_list(::sg::GuildUserDataList* join_list) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete join_list_;
  }
  if (join_list) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(join_list);
    if (message_arena != submessage_arena) {
      join_list = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, join_list, submessage_arena);
    }
    set_has_join_list();
  } else {
    clear_has_join_list();
  }
  join_list_ = join_list;
  // @@protoc_insertion_point(field_set_allocated:sg.GuildData.join_list)
}

// -------------------------------------------------------------------

// GuildDataList

// repeated .sg.GuildData list = 1;
inline int GuildDataList::list_size() const {
  return list_.size();
}
inline void GuildDataList::clear_list() {
  list_.Clear();
}
inline ::sg::GuildData* GuildDataList::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:sg.GuildDataList.list)
  return list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::GuildData >*
GuildDataList::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:sg.GuildDataList.list)
  return &list_;
}
inline const ::sg::GuildData& GuildDataList::list(int index) const {
  // @@protoc_insertion_point(field_get:sg.GuildDataList.list)
  return list_.Get(index);
}
inline ::sg::GuildData* GuildDataList::add_list() {
  // @@protoc_insertion_point(field_add:sg.GuildDataList.list)
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::GuildData >&
GuildDataList::list() const {
  // @@protoc_insertion_point(field_list:sg.GuildDataList.list)
  return list_;
}

// -------------------------------------------------------------------

// GuildSignin

// required int32 type = 1;
inline bool GuildSignin::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GuildSignin::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GuildSignin::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GuildSignin::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 GuildSignin::type() const {
  // @@protoc_insertion_point(field_get:sg.GuildSignin.type)
  return type_;
}
inline void GuildSignin::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:sg.GuildSignin.type)
}

// required .sg.GuildSignin.STATE state = 2;
inline bool GuildSignin::has_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GuildSignin::set_has_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GuildSignin::clear_has_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GuildSignin::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::sg::GuildSignin_STATE GuildSignin::state() const {
  // @@protoc_insertion_point(field_get:sg.GuildSignin.state)
  return static_cast< ::sg::GuildSignin_STATE >(state_);
}
inline void GuildSignin::set_state(::sg::GuildSignin_STATE value) {
  assert(::sg::GuildSignin_STATE_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:sg.GuildSignin.state)
}

// optional bytes drop_str = 3;
inline bool GuildSignin::has_drop_str() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GuildSignin::set_has_drop_str() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GuildSignin::clear_has_drop_str() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GuildSignin::clear_drop_str() {
  drop_str_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_drop_str();
}
inline const ::std::string& GuildSignin::drop_str() const {
  // @@protoc_insertion_point(field_get:sg.GuildSignin.drop_str)
  return drop_str_.Get();
}
inline void GuildSignin::set_drop_str(const ::std::string& value) {
  set_has_drop_str();
  drop_str_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:sg.GuildSignin.drop_str)
}
#if LANG_CXX11
inline void GuildSignin::set_drop_str(::std::string&& value) {
  set_has_drop_str();
  drop_str_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:sg.GuildSignin.drop_str)
}
#endif
inline void GuildSignin::set_drop_str(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_drop_str();
  drop_str_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:sg.GuildSignin.drop_str)
}
inline void GuildSignin::set_drop_str(const void* value,
    size_t size) {
  set_has_drop_str();
  drop_str_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:sg.GuildSignin.drop_str)
}
inline ::std::string* GuildSignin::mutable_drop_str() {
  set_has_drop_str();
  // @@protoc_insertion_point(field_mutable:sg.GuildSignin.drop_str)
  return drop_str_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* GuildSignin::release_drop_str() {
  // @@protoc_insertion_point(field_release:sg.GuildSignin.drop_str)
  if (!has_drop_str()) {
    return NULL;
  }
  clear_has_drop_str();
  return drop_str_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void GuildSignin::set_allocated_drop_str(::std::string* drop_str) {
  if (drop_str != NULL) {
    set_has_drop_str();
  } else {
    clear_has_drop_str();
  }
  drop_str_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), drop_str,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:sg.GuildSignin.drop_str)
}
inline ::std::string* GuildSignin::unsafe_arena_release_drop_str() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.GuildSignin.drop_str)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_drop_str();
  return drop_str_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void GuildSignin::unsafe_arena_set_allocated_drop_str(
    ::std::string* drop_str) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (drop_str != NULL) {
    set_has_drop_str();
  } else {
    clear_has_drop_str();
  }
  drop_str_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      drop_str, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sg.GuildSignin.drop_str)
}

// -------------------------------------------------------------------

// GuildSigninList

// repeated .sg.GuildSignin list = 1;
inline int GuildSigninList::list_size() const {
  return list_.size();
}
inline void GuildSigninList::clear_list() {
  list_.Clear();
}
inline ::sg::GuildSignin* GuildSigninList::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:sg.GuildSigninList.list)
  return list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::GuildSignin >*
GuildSigninList::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:sg.GuildSigninList.list)
  return &list_;
}
inline const ::sg::GuildSignin& GuildSigninList::list(int index) const {
  // @@protoc_insertion_point(field_get:sg.GuildSigninList.list)
  return list_.Get(index);
}
inline ::sg::GuildSignin* GuildSigninList::add_list() {
  // @@protoc_insertion_point(field_add:sg.GuildSigninList.list)
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::GuildSignin >&
GuildSigninList::list() const {
  // @@protoc_insertion_point(field_list:sg.GuildSigninList.list)
  return list_;
}

// -------------------------------------------------------------------

// GuildTrack

// required uint64 uuid = 1;
inline bool GuildTrack::has_uuid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GuildTrack::set_has_uuid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GuildTrack::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GuildTrack::clear_uuid() {
  uuid_ = GOOGLE_ULONGLONG(0);
  clear_has_uuid();
}
inline ::google::protobuf::uint64 GuildTrack::uuid() const {
  // @@protoc_insertion_point(field_get:sg.GuildTrack.uuid)
  return uuid_;
}
inline void GuildTrack::set_uuid(::google::protobuf::uint64 value) {
  set_has_uuid();
  uuid_ = value;
  // @@protoc_insertion_point(field_set:sg.GuildTrack.uuid)
}

// required bytes nick = 2;
inline bool GuildTrack::has_nick() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GuildTrack::set_has_nick() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GuildTrack::clear_has_nick() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GuildTrack::clear_nick() {
  nick_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_nick();
}
inline const ::std::string& GuildTrack::nick() const {
  // @@protoc_insertion_point(field_get:sg.GuildTrack.nick)
  return nick_.Get();
}
inline void GuildTrack::set_nick(const ::std::string& value) {
  set_has_nick();
  nick_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:sg.GuildTrack.nick)
}
#if LANG_CXX11
inline void GuildTrack::set_nick(::std::string&& value) {
  set_has_nick();
  nick_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:sg.GuildTrack.nick)
}
#endif
inline void GuildTrack::set_nick(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_nick();
  nick_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:sg.GuildTrack.nick)
}
inline void GuildTrack::set_nick(const void* value,
    size_t size) {
  set_has_nick();
  nick_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:sg.GuildTrack.nick)
}
inline ::std::string* GuildTrack::mutable_nick() {
  set_has_nick();
  // @@protoc_insertion_point(field_mutable:sg.GuildTrack.nick)
  return nick_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* GuildTrack::release_nick() {
  // @@protoc_insertion_point(field_release:sg.GuildTrack.nick)
  if (!has_nick()) {
    return NULL;
  }
  clear_has_nick();
  return nick_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void GuildTrack::set_allocated_nick(::std::string* nick) {
  if (nick != NULL) {
    set_has_nick();
  } else {
    clear_has_nick();
  }
  nick_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nick,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:sg.GuildTrack.nick)
}
inline ::std::string* GuildTrack::unsafe_arena_release_nick() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.GuildTrack.nick)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_nick();
  return nick_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void GuildTrack::unsafe_arena_set_allocated_nick(
    ::std::string* nick) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (nick != NULL) {
    set_has_nick();
  } else {
    clear_has_nick();
  }
  nick_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      nick, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sg.GuildTrack.nick)
}

// required int32 action_type = 3;
inline bool GuildTrack::has_action_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GuildTrack::set_has_action_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GuildTrack::clear_has_action_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GuildTrack::clear_action_type() {
  action_type_ = 0;
  clear_has_action_type();
}
inline ::google::protobuf::int32 GuildTrack::action_type() const {
  // @@protoc_insertion_point(field_get:sg.GuildTrack.action_type)
  return action_type_;
}
inline void GuildTrack::set_action_type(::google::protobuf::int32 value) {
  set_has_action_type();
  action_type_ = value;
  // @@protoc_insertion_point(field_set:sg.GuildTrack.action_type)
}

// optional int32 guildid = 11;
inline bool GuildTrack::has_guildid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GuildTrack::set_has_guildid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GuildTrack::clear_has_guildid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GuildTrack::clear_guildid() {
  guildid_ = 0;
  clear_has_guildid();
}
inline ::google::protobuf::int32 GuildTrack::guildid() const {
  // @@protoc_insertion_point(field_get:sg.GuildTrack.guildid)
  return guildid_;
}
inline void GuildTrack::set_guildid(::google::protobuf::int32 value) {
  set_has_guildid();
  guildid_ = value;
  // @@protoc_insertion_point(field_set:sg.GuildTrack.guildid)
}

// optional bytes name = 12;
inline bool GuildTrack::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GuildTrack::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GuildTrack::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GuildTrack::clear_name() {
  name_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_name();
}
inline const ::std::string& GuildTrack::name() const {
  // @@protoc_insertion_point(field_get:sg.GuildTrack.name)
  return name_.Get();
}
inline void GuildTrack::set_name(const ::std::string& value) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:sg.GuildTrack.name)
}
#if LANG_CXX11
inline void GuildTrack::set_name(::std::string&& value) {
  set_has_name();
  name_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:sg.GuildTrack.name)
}
#endif
inline void GuildTrack::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:sg.GuildTrack.name)
}
inline void GuildTrack::set_name(const void* value,
    size_t size) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:sg.GuildTrack.name)
}
inline ::std::string* GuildTrack::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:sg.GuildTrack.name)
  return name_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* GuildTrack::release_name() {
  // @@protoc_insertion_point(field_release:sg.GuildTrack.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void GuildTrack::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:sg.GuildTrack.name)
}
inline ::std::string* GuildTrack::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.GuildTrack.name)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_name();
  return name_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void GuildTrack::unsafe_arena_set_allocated_name(
    ::std::string* name) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      name, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sg.GuildTrack.name)
}

// optional bytes announcement = 13;
inline bool GuildTrack::has_announcement() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GuildTrack::set_has_announcement() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GuildTrack::clear_has_announcement() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GuildTrack::clear_announcement() {
  announcement_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_announcement();
}
inline const ::std::string& GuildTrack::announcement() const {
  // @@protoc_insertion_point(field_get:sg.GuildTrack.announcement)
  return announcement_.Get();
}
inline void GuildTrack::set_announcement(const ::std::string& value) {
  set_has_announcement();
  announcement_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:sg.GuildTrack.announcement)
}
#if LANG_CXX11
inline void GuildTrack::set_announcement(::std::string&& value) {
  set_has_announcement();
  announcement_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:sg.GuildTrack.announcement)
}
#endif
inline void GuildTrack::set_announcement(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_announcement();
  announcement_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:sg.GuildTrack.announcement)
}
inline void GuildTrack::set_announcement(const void* value,
    size_t size) {
  set_has_announcement();
  announcement_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:sg.GuildTrack.announcement)
}
inline ::std::string* GuildTrack::mutable_announcement() {
  set_has_announcement();
  // @@protoc_insertion_point(field_mutable:sg.GuildTrack.announcement)
  return announcement_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* GuildTrack::release_announcement() {
  // @@protoc_insertion_point(field_release:sg.GuildTrack.announcement)
  if (!has_announcement()) {
    return NULL;
  }
  clear_has_announcement();
  return announcement_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void GuildTrack::set_allocated_announcement(::std::string* announcement) {
  if (announcement != NULL) {
    set_has_announcement();
  } else {
    clear_has_announcement();
  }
  announcement_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), announcement,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:sg.GuildTrack.announcement)
}
inline ::std::string* GuildTrack::unsafe_arena_release_announcement() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.GuildTrack.announcement)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_announcement();
  return announcement_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void GuildTrack::unsafe_arena_set_allocated_announcement(
    ::std::string* announcement) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (announcement != NULL) {
    set_has_announcement();
  } else {
    clear_has_announcement();
  }
  announcement_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      announcement, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sg.GuildTrack.announcement)
}

// optional uint64 target_uuid = 14;
inline bool GuildTrack::has_target_uuid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GuildTrack::set_has_target_uuid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GuildTrack::clear_has_target_uuid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GuildTrack::clear_target_uuid() {
  target_uuid_ = GOOGLE_ULONGLONG(0);
  clear_has_target_uuid();
}
inline ::google::protobuf::uint64 GuildTrack::target_uuid() const {
  // @@protoc_insertion_point(field_get:sg.GuildTrack.target_uuid)
  return target_uuid_;
}
inline void GuildTrack::set_target_uuid(::google::protobuf::uint64 value) {
  set_has_target_uuid();
  target_uuid_ = value;
  // @@protoc_insertion_point(field_set:sg.GuildTrack.target_uuid)
}

// optional bytes target_nick = 15;
inline bool GuildTrack::has_target_nick() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GuildTrack::set_has_target_nick() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GuildTrack::clear_has_target_nick() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GuildTrack::clear_target_nick() {
  target_nick_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_target_nick();
}
inline const ::std::string& GuildTrack::target_nick() const {
  // @@protoc_insertion_point(field_get:sg.GuildTrack.target_nick)
  return target_nick_.Get();
}
inline void GuildTrack::set_target_nick(const ::std::string& value) {
  set_has_target_nick();
  target_nick_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:sg.GuildTrack.target_nick)
}
#if LANG_CXX11
inline void GuildTrack::set_target_nick(::std::string&& value) {
  set_has_target_nick();
  target_nick_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:sg.GuildTrack.target_nick)
}
#endif
inline void GuildTrack::set_target_nick(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_target_nick();
  target_nick_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:sg.GuildTrack.target_nick)
}
inline void GuildTrack::set_target_nick(const void* value,
    size_t size) {
  set_has_target_nick();
  target_nick_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:sg.GuildTrack.target_nick)
}
inline ::std::string* GuildTrack::mutable_target_nick() {
  set_has_target_nick();
  // @@protoc_insertion_point(field_mutable:sg.GuildTrack.target_nick)
  return target_nick_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* GuildTrack::release_target_nick() {
  // @@protoc_insertion_point(field_release:sg.GuildTrack.target_nick)
  if (!has_target_nick()) {
    return NULL;
  }
  clear_has_target_nick();
  return target_nick_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void GuildTrack::set_allocated_target_nick(::std::string* target_nick) {
  if (target_nick != NULL) {
    set_has_target_nick();
  } else {
    clear_has_target_nick();
  }
  target_nick_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), target_nick,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:sg.GuildTrack.target_nick)
}
inline ::std::string* GuildTrack::unsafe_arena_release_target_nick() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.GuildTrack.target_nick)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_target_nick();
  return target_nick_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void GuildTrack::unsafe_arena_set_allocated_target_nick(
    ::std::string* target_nick) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (target_nick != NULL) {
    set_has_target_nick();
  } else {
    clear_has_target_nick();
  }
  target_nick_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      target_nick, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sg.GuildTrack.target_nick)
}

// optional int32 target_title = 16;
inline bool GuildTrack::has_target_title() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GuildTrack::set_has_target_title() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GuildTrack::clear_has_target_title() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GuildTrack::clear_target_title() {
  target_title_ = 0;
  clear_has_target_title();
}
inline ::google::protobuf::int32 GuildTrack::target_title() const {
  // @@protoc_insertion_point(field_get:sg.GuildTrack.target_title)
  return target_title_;
}
inline void GuildTrack::set_target_title(::google::protobuf::int32 value) {
  set_has_target_title();
  target_title_ = value;
  // @@protoc_insertion_point(field_set:sg.GuildTrack.target_title)
}

// optional int32 donation = 17;
inline bool GuildTrack::has_donation() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GuildTrack::set_has_donation() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GuildTrack::clear_has_donation() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GuildTrack::clear_donation() {
  donation_ = 0;
  clear_has_donation();
}
inline ::google::protobuf::int32 GuildTrack::donation() const {
  // @@protoc_insertion_point(field_get:sg.GuildTrack.donation)
  return donation_;
}
inline void GuildTrack::set_donation(::google::protobuf::int32 value) {
  set_has_donation();
  donation_ = value;
  // @@protoc_insertion_point(field_set:sg.GuildTrack.donation)
}

// optional int32 building_type = 18;
inline bool GuildTrack::has_building_type() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GuildTrack::set_has_building_type() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GuildTrack::clear_has_building_type() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GuildTrack::clear_building_type() {
  building_type_ = 0;
  clear_has_building_type();
}
inline ::google::protobuf::int32 GuildTrack::building_type() const {
  // @@protoc_insertion_point(field_get:sg.GuildTrack.building_type)
  return building_type_;
}
inline void GuildTrack::set_building_type(::google::protobuf::int32 value) {
  set_has_building_type();
  building_type_ = value;
  // @@protoc_insertion_point(field_set:sg.GuildTrack.building_type)
}

// optional int32 building_level = 19;
inline bool GuildTrack::has_building_level() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GuildTrack::set_has_building_level() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GuildTrack::clear_has_building_level() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GuildTrack::clear_building_level() {
  building_level_ = 0;
  clear_has_building_level();
}
inline ::google::protobuf::int32 GuildTrack::building_level() const {
  // @@protoc_insertion_point(field_get:sg.GuildTrack.building_level)
  return building_level_;
}
inline void GuildTrack::set_building_level(::google::protobuf::int32 value) {
  set_has_building_level();
  building_level_ = value;
  // @@protoc_insertion_point(field_set:sg.GuildTrack.building_level)
}

// optional sfixed64 optime = 21;
inline bool GuildTrack::has_optime() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void GuildTrack::set_has_optime() {
  _has_bits_[0] |= 0x00001000u;
}
inline void GuildTrack::clear_has_optime() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void GuildTrack::clear_optime() {
  optime_ = GOOGLE_LONGLONG(0);
  clear_has_optime();
}
inline ::google::protobuf::int64 GuildTrack::optime() const {
  // @@protoc_insertion_point(field_get:sg.GuildTrack.optime)
  return optime_;
}
inline void GuildTrack::set_optime(::google::protobuf::int64 value) {
  set_has_optime();
  optime_ = value;
  // @@protoc_insertion_point(field_set:sg.GuildTrack.optime)
}

// -------------------------------------------------------------------

// GuildTrackList

// repeated .sg.GuildTrack list = 1;
inline int GuildTrackList::list_size() const {
  return list_.size();
}
inline void GuildTrackList::clear_list() {
  list_.Clear();
}
inline ::sg::GuildTrack* GuildTrackList::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:sg.GuildTrackList.list)
  return list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::GuildTrack >*
GuildTrackList::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:sg.GuildTrackList.list)
  return &list_;
}
inline const ::sg::GuildTrack& GuildTrackList::list(int index) const {
  // @@protoc_insertion_point(field_get:sg.GuildTrackList.list)
  return list_.Get(index);
}
inline ::sg::GuildTrack* GuildTrackList::add_list() {
  // @@protoc_insertion_point(field_add:sg.GuildTrackList.list)
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::GuildTrack >&
GuildTrackList::list() const {
  // @@protoc_insertion_point(field_list:sg.GuildTrackList.list)
  return list_;
}

// -------------------------------------------------------------------

// DonateItem

// required int32 id = 1;
inline bool DonateItem::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DonateItem::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DonateItem::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DonateItem::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 DonateItem::id() const {
  // @@protoc_insertion_point(field_get:sg.DonateItem.id)
  return id_;
}
inline void DonateItem::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:sg.DonateItem.id)
}

// required int32 num = 2;
inline bool DonateItem::has_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DonateItem::set_has_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DonateItem::clear_has_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DonateItem::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 DonateItem::num() const {
  // @@protoc_insertion_point(field_get:sg.DonateItem.num)
  return num_;
}
inline void DonateItem::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
  // @@protoc_insertion_point(field_set:sg.DonateItem.num)
}

// -------------------------------------------------------------------

// DonateItemList

// repeated .sg.DonateItem list = 1;
inline int DonateItemList::list_size() const {
  return list_.size();
}
inline void DonateItemList::clear_list() {
  list_.Clear();
}
inline ::sg::DonateItem* DonateItemList::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:sg.DonateItemList.list)
  return list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::DonateItem >*
DonateItemList::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:sg.DonateItemList.list)
  return &list_;
}
inline const ::sg::DonateItem& DonateItemList::list(int index) const {
  // @@protoc_insertion_point(field_get:sg.DonateItemList.list)
  return list_.Get(index);
}
inline ::sg::DonateItem* DonateItemList::add_list() {
  // @@protoc_insertion_point(field_add:sg.DonateItemList.list)
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::DonateItem >&
DonateItemList::list() const {
  // @@protoc_insertion_point(field_list:sg.DonateItemList.list)
  return list_;
}

// -------------------------------------------------------------------

// GuildService_GuildRequest

// required .sg.GuildService.GUILD_COMMAND cmd = 1;
inline bool GuildService_GuildRequest::has_cmd() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void GuildService_GuildRequest::set_has_cmd() {
  _has_bits_[0] |= 0x00001000u;
}
inline void GuildService_GuildRequest::clear_has_cmd() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void GuildService_GuildRequest::clear_cmd() {
  cmd_ = 1;
  clear_has_cmd();
}
inline ::sg::GuildService_GUILD_COMMAND GuildService_GuildRequest::cmd() const {
  // @@protoc_insertion_point(field_get:sg.GuildService.GuildRequest.cmd)
  return static_cast< ::sg::GuildService_GUILD_COMMAND >(cmd_);
}
inline void GuildService_GuildRequest::set_cmd(::sg::GuildService_GUILD_COMMAND value) {
  assert(::sg::GuildService_GUILD_COMMAND_IsValid(value));
  set_has_cmd();
  cmd_ = value;
  // @@protoc_insertion_point(field_set:sg.GuildService.GuildRequest.cmd)
}

// optional int32 guildid = 2;
inline bool GuildService_GuildRequest::has_guildid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GuildService_GuildRequest::set_has_guildid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GuildService_GuildRequest::clear_has_guildid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GuildService_GuildRequest::clear_guildid() {
  guildid_ = 0;
  clear_has_guildid();
}
inline ::google::protobuf::int32 GuildService_GuildRequest::guildid() const {
  // @@protoc_insertion_point(field_get:sg.GuildService.GuildRequest.guildid)
  return guildid_;
}
inline void GuildService_GuildRequest::set_guildid(::google::protobuf::int32 value) {
  set_has_guildid();
  guildid_ = value;
  // @@protoc_insertion_point(field_set:sg.GuildService.GuildRequest.guildid)
}

// optional bytes name = 3;
inline bool GuildService_GuildRequest::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GuildService_GuildRequest::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GuildService_GuildRequest::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GuildService_GuildRequest::clear_name() {
  name_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_name();
}
inline const ::std::string& GuildService_GuildRequest::name() const {
  // @@protoc_insertion_point(field_get:sg.GuildService.GuildRequest.name)
  return name_.Get();
}
inline void GuildService_GuildRequest::set_name(const ::std::string& value) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:sg.GuildService.GuildRequest.name)
}
#if LANG_CXX11
inline void GuildService_GuildRequest::set_name(::std::string&& value) {
  set_has_name();
  name_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:sg.GuildService.GuildRequest.name)
}
#endif
inline void GuildService_GuildRequest::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:sg.GuildService.GuildRequest.name)
}
inline void GuildService_GuildRequest::set_name(const void* value,
    size_t size) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:sg.GuildService.GuildRequest.name)
}
inline ::std::string* GuildService_GuildRequest::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:sg.GuildService.GuildRequest.name)
  return name_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* GuildService_GuildRequest::release_name() {
  // @@protoc_insertion_point(field_release:sg.GuildService.GuildRequest.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void GuildService_GuildRequest::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:sg.GuildService.GuildRequest.name)
}
inline ::std::string* GuildService_GuildRequest::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.GuildService.GuildRequest.name)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_name();
  return name_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void GuildService_GuildRequest::unsafe_arena_set_allocated_name(
    ::std::string* name) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      name, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sg.GuildService.GuildRequest.name)
}

// optional bytes announcement = 4;
inline bool GuildService_GuildRequest::has_announcement() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GuildService_GuildRequest::set_has_announcement() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GuildService_GuildRequest::clear_has_announcement() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GuildService_GuildRequest::clear_announcement() {
  announcement_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_announcement();
}
inline const ::std::string& GuildService_GuildRequest::announcement() const {
  // @@protoc_insertion_point(field_get:sg.GuildService.GuildRequest.announcement)
  return announcement_.Get();
}
inline void GuildService_GuildRequest::set_announcement(const ::std::string& value) {
  set_has_announcement();
  announcement_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:sg.GuildService.GuildRequest.announcement)
}
#if LANG_CXX11
inline void GuildService_GuildRequest::set_announcement(::std::string&& value) {
  set_has_announcement();
  announcement_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:sg.GuildService.GuildRequest.announcement)
}
#endif
inline void GuildService_GuildRequest::set_announcement(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_announcement();
  announcement_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:sg.GuildService.GuildRequest.announcement)
}
inline void GuildService_GuildRequest::set_announcement(const void* value,
    size_t size) {
  set_has_announcement();
  announcement_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:sg.GuildService.GuildRequest.announcement)
}
inline ::std::string* GuildService_GuildRequest::mutable_announcement() {
  set_has_announcement();
  // @@protoc_insertion_point(field_mutable:sg.GuildService.GuildRequest.announcement)
  return announcement_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* GuildService_GuildRequest::release_announcement() {
  // @@protoc_insertion_point(field_release:sg.GuildService.GuildRequest.announcement)
  if (!has_announcement()) {
    return NULL;
  }
  clear_has_announcement();
  return announcement_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void GuildService_GuildRequest::set_allocated_announcement(::std::string* announcement) {
  if (announcement != NULL) {
    set_has_announcement();
  } else {
    clear_has_announcement();
  }
  announcement_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), announcement,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:sg.GuildService.GuildRequest.announcement)
}
inline ::std::string* GuildService_GuildRequest::unsafe_arena_release_announcement() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.GuildService.GuildRequest.announcement)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_announcement();
  return announcement_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void GuildService_GuildRequest::unsafe_arena_set_allocated_announcement(
    ::std::string* announcement) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (announcement != NULL) {
    set_has_announcement();
  } else {
    clear_has_announcement();
  }
  announcement_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      announcement, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sg.GuildService.GuildRequest.announcement)
}

// optional uint64 user_uuid = 5;
inline bool GuildService_GuildRequest::has_user_uuid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GuildService_GuildRequest::set_has_user_uuid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GuildService_GuildRequest::clear_has_user_uuid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GuildService_GuildRequest::clear_user_uuid() {
  user_uuid_ = GOOGLE_ULONGLONG(0);
  clear_has_user_uuid();
}
inline ::google::protobuf::uint64 GuildService_GuildRequest::user_uuid() const {
  // @@protoc_insertion_point(field_get:sg.GuildService.GuildRequest.user_uuid)
  return user_uuid_;
}
inline void GuildService_GuildRequest::set_user_uuid(::google::protobuf::uint64 value) {
  set_has_user_uuid();
  user_uuid_ = value;
  // @@protoc_insertion_point(field_set:sg.GuildService.GuildRequest.user_uuid)
}

// optional int32 user_title = 6;
inline bool GuildService_GuildRequest::has_user_title() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GuildService_GuildRequest::set_has_user_title() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GuildService_GuildRequest::clear_has_user_title() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GuildService_GuildRequest::clear_user_title() {
  user_title_ = 0;
  clear_has_user_title();
}
inline ::google::protobuf::int32 GuildService_GuildRequest::user_title() const {
  // @@protoc_insertion_point(field_get:sg.GuildService.GuildRequest.user_title)
  return user_title_;
}
inline void GuildService_GuildRequest::set_user_title(::google::protobuf::int32 value) {
  set_has_user_title();
  user_title_ = value;
  // @@protoc_insertion_point(field_set:sg.GuildService.GuildRequest.user_title)
}

// optional .sg.DonateItemList donate_list = 7;
inline bool GuildService_GuildRequest::has_donate_list() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GuildService_GuildRequest::set_has_donate_list() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GuildService_GuildRequest::clear_has_donate_list() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GuildService_GuildRequest::clear_donate_list() {
  if (donate_list_ != NULL) donate_list_->Clear();
  clear_has_donate_list();
}
inline const ::sg::DonateItemList& GuildService_GuildRequest::_internal_donate_list() const {
  return *donate_list_;
}
inline const ::sg::DonateItemList& GuildService_GuildRequest::donate_list() const {
  const ::sg::DonateItemList* p = donate_list_;
  // @@protoc_insertion_point(field_get:sg.GuildService.GuildRequest.donate_list)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::DonateItemList*>(
      &::sg::_DonateItemList_default_instance_);
}
inline ::sg::DonateItemList* GuildService_GuildRequest::release_donate_list() {
  // @@protoc_insertion_point(field_release:sg.GuildService.GuildRequest.donate_list)
  clear_has_donate_list();
  ::sg::DonateItemList* temp = donate_list_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  donate_list_ = NULL;
  return temp;
}
inline ::sg::DonateItemList* GuildService_GuildRequest::unsafe_arena_release_donate_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.GuildService.GuildRequest.donate_list)
  clear_has_donate_list();
  ::sg::DonateItemList* temp = donate_list_;
  donate_list_ = NULL;
  return temp;
}
inline ::sg::DonateItemList* GuildService_GuildRequest::mutable_donate_list() {
  set_has_donate_list();
  if (donate_list_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::DonateItemList>(GetArenaNoVirtual());
    donate_list_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.GuildService.GuildRequest.donate_list)
  return donate_list_;
}
inline void GuildService_GuildRequest::set_allocated_donate_list(::sg::DonateItemList* donate_list) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete donate_list_;
  }
  if (donate_list) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(donate_list);
    if (message_arena != submessage_arena) {
      donate_list = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, donate_list, submessage_arena);
    }
    set_has_donate_list();
  } else {
    clear_has_donate_list();
  }
  donate_list_ = donate_list;
  // @@protoc_insertion_point(field_set_allocated:sg.GuildService.GuildRequest.donate_list)
}

// optional bytes badge = 8;
inline bool GuildService_GuildRequest::has_badge() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GuildService_GuildRequest::set_has_badge() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GuildService_GuildRequest::clear_has_badge() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GuildService_GuildRequest::clear_badge() {
  badge_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_badge();
}
inline const ::std::string& GuildService_GuildRequest::badge() const {
  // @@protoc_insertion_point(field_get:sg.GuildService.GuildRequest.badge)
  return badge_.Get();
}
inline void GuildService_GuildRequest::set_badge(const ::std::string& value) {
  set_has_badge();
  badge_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:sg.GuildService.GuildRequest.badge)
}
#if LANG_CXX11
inline void GuildService_GuildRequest::set_badge(::std::string&& value) {
  set_has_badge();
  badge_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:sg.GuildService.GuildRequest.badge)
}
#endif
inline void GuildService_GuildRequest::set_badge(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_badge();
  badge_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:sg.GuildService.GuildRequest.badge)
}
inline void GuildService_GuildRequest::set_badge(const void* value,
    size_t size) {
  set_has_badge();
  badge_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:sg.GuildService.GuildRequest.badge)
}
inline ::std::string* GuildService_GuildRequest::mutable_badge() {
  set_has_badge();
  // @@protoc_insertion_point(field_mutable:sg.GuildService.GuildRequest.badge)
  return badge_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* GuildService_GuildRequest::release_badge() {
  // @@protoc_insertion_point(field_release:sg.GuildService.GuildRequest.badge)
  if (!has_badge()) {
    return NULL;
  }
  clear_has_badge();
  return badge_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void GuildService_GuildRequest::set_allocated_badge(::std::string* badge) {
  if (badge != NULL) {
    set_has_badge();
  } else {
    clear_has_badge();
  }
  badge_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), badge,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:sg.GuildService.GuildRequest.badge)
}
inline ::std::string* GuildService_GuildRequest::unsafe_arena_release_badge() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.GuildService.GuildRequest.badge)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_badge();
  return badge_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void GuildService_GuildRequest::unsafe_arena_set_allocated_badge(
    ::std::string* badge) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (badge != NULL) {
    set_has_badge();
  } else {
    clear_has_badge();
  }
  badge_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      badge, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sg.GuildService.GuildRequest.badge)
}

// optional .sg.GUILD_ACCEPT_TYPE accept_type = 11;
inline bool GuildService_GuildRequest::has_accept_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GuildService_GuildRequest::set_has_accept_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GuildService_GuildRequest::clear_has_accept_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GuildService_GuildRequest::clear_accept_type() {
  accept_type_ = 0;
  clear_has_accept_type();
}
inline ::sg::GUILD_ACCEPT_TYPE GuildService_GuildRequest::accept_type() const {
  // @@protoc_insertion_point(field_get:sg.GuildService.GuildRequest.accept_type)
  return static_cast< ::sg::GUILD_ACCEPT_TYPE >(accept_type_);
}
inline void GuildService_GuildRequest::set_accept_type(::sg::GUILD_ACCEPT_TYPE value) {
  assert(::sg::GUILD_ACCEPT_TYPE_IsValid(value));
  set_has_accept_type();
  accept_type_ = value;
  // @@protoc_insertion_point(field_set:sg.GuildService.GuildRequest.accept_type)
}

// optional int32 join_level = 12;
inline bool GuildService_GuildRequest::has_join_level() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GuildService_GuildRequest::set_has_join_level() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GuildService_GuildRequest::clear_has_join_level() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GuildService_GuildRequest::clear_join_level() {
  join_level_ = 0;
  clear_has_join_level();
}
inline ::google::protobuf::int32 GuildService_GuildRequest::join_level() const {
  // @@protoc_insertion_point(field_get:sg.GuildService.GuildRequest.join_level)
  return join_level_;
}
inline void GuildService_GuildRequest::set_join_level(::google::protobuf::int32 value) {
  set_has_join_level();
  join_level_ = value;
  // @@protoc_insertion_point(field_set:sg.GuildService.GuildRequest.join_level)
}

// optional int32 join_force = 13;
inline bool GuildService_GuildRequest::has_join_force() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GuildService_GuildRequest::set_has_join_force() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GuildService_GuildRequest::clear_has_join_force() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GuildService_GuildRequest::clear_join_force() {
  join_force_ = 0;
  clear_has_join_force();
}
inline ::google::protobuf::int32 GuildService_GuildRequest::join_force() const {
  // @@protoc_insertion_point(field_get:sg.GuildService.GuildRequest.join_force)
  return join_force_;
}
inline void GuildService_GuildRequest::set_join_force(::google::protobuf::int32 value) {
  set_has_join_force();
  join_force_ = value;
  // @@protoc_insertion_point(field_set:sg.GuildService.GuildRequest.join_force)
}

// optional int32 signin_type = 21;
inline bool GuildService_GuildRequest::has_signin_type() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GuildService_GuildRequest::set_has_signin_type() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GuildService_GuildRequest::clear_has_signin_type() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GuildService_GuildRequest::clear_signin_type() {
  signin_type_ = 0;
  clear_has_signin_type();
}
inline ::google::protobuf::int32 GuildService_GuildRequest::signin_type() const {
  // @@protoc_insertion_point(field_get:sg.GuildService.GuildRequest.signin_type)
  return signin_type_;
}
inline void GuildService_GuildRequest::set_signin_type(::google::protobuf::int32 value) {
  set_has_signin_type();
  signin_type_ = value;
  // @@protoc_insertion_point(field_set:sg.GuildService.GuildRequest.signin_type)
}

// optional int32 building_type = 31;
inline bool GuildService_GuildRequest::has_building_type() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GuildService_GuildRequest::set_has_building_type() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GuildService_GuildRequest::clear_has_building_type() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GuildService_GuildRequest::clear_building_type() {
  building_type_ = 0;
  clear_has_building_type();
}
inline ::google::protobuf::int32 GuildService_GuildRequest::building_type() const {
  // @@protoc_insertion_point(field_get:sg.GuildService.GuildRequest.building_type)
  return building_type_;
}
inline void GuildService_GuildRequest::set_building_type(::google::protobuf::int32 value) {
  set_has_building_type();
  building_type_ = value;
  // @@protoc_insertion_point(field_set:sg.GuildService.GuildRequest.building_type)
}

// -------------------------------------------------------------------

// GuildService_GuildResponse

// required int32 result = 1;
inline bool GuildService_GuildResponse::has_result() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GuildService_GuildResponse::set_has_result() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GuildService_GuildResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GuildService_GuildResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 GuildService_GuildResponse::result() const {
  // @@protoc_insertion_point(field_get:sg.GuildService.GuildResponse.result)
  return result_;
}
inline void GuildService_GuildResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:sg.GuildService.GuildResponse.result)
}

// optional .sg.GuildDataList guild_list = 2;
inline bool GuildService_GuildResponse::has_guild_list() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GuildService_GuildResponse::set_has_guild_list() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GuildService_GuildResponse::clear_has_guild_list() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GuildService_GuildResponse::clear_guild_list() {
  if (guild_list_ != NULL) guild_list_->Clear();
  clear_has_guild_list();
}
inline const ::sg::GuildDataList& GuildService_GuildResponse::_internal_guild_list() const {
  return *guild_list_;
}
inline const ::sg::GuildDataList& GuildService_GuildResponse::guild_list() const {
  const ::sg::GuildDataList* p = guild_list_;
  // @@protoc_insertion_point(field_get:sg.GuildService.GuildResponse.guild_list)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::GuildDataList*>(
      &::sg::_GuildDataList_default_instance_);
}
inline ::sg::GuildDataList* GuildService_GuildResponse::release_guild_list() {
  // @@protoc_insertion_point(field_release:sg.GuildService.GuildResponse.guild_list)
  clear_has_guild_list();
  ::sg::GuildDataList* temp = guild_list_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  guild_list_ = NULL;
  return temp;
}
inline ::sg::GuildDataList* GuildService_GuildResponse::unsafe_arena_release_guild_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.GuildService.GuildResponse.guild_list)
  clear_has_guild_list();
  ::sg::GuildDataList* temp = guild_list_;
  guild_list_ = NULL;
  return temp;
}
inline ::sg::GuildDataList* GuildService_GuildResponse::mutable_guild_list() {
  set_has_guild_list();
  if (guild_list_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::GuildDataList>(GetArenaNoVirtual());
    guild_list_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.GuildService.GuildResponse.guild_list)
  return guild_list_;
}
inline void GuildService_GuildResponse::set_allocated_guild_list(::sg::GuildDataList* guild_list) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete guild_list_;
  }
  if (guild_list) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(guild_list);
    if (message_arena != submessage_arena) {
      guild_list = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, guild_list, submessage_arena);
    }
    set_has_guild_list();
  } else {
    clear_has_guild_list();
  }
  guild_list_ = guild_list;
  // @@protoc_insertion_point(field_set_allocated:sg.GuildService.GuildResponse.guild_list)
}

// optional .sg.GuildTrackList track_list = 3;
inline bool GuildService_GuildResponse::has_track_list() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GuildService_GuildResponse::set_has_track_list() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GuildService_GuildResponse::clear_has_track_list() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GuildService_GuildResponse::clear_track_list() {
  if (track_list_ != NULL) track_list_->Clear();
  clear_has_track_list();
}
inline const ::sg::GuildTrackList& GuildService_GuildResponse::_internal_track_list() const {
  return *track_list_;
}
inline const ::sg::GuildTrackList& GuildService_GuildResponse::track_list() const {
  const ::sg::GuildTrackList* p = track_list_;
  // @@protoc_insertion_point(field_get:sg.GuildService.GuildResponse.track_list)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::GuildTrackList*>(
      &::sg::_GuildTrackList_default_instance_);
}
inline ::sg::GuildTrackList* GuildService_GuildResponse::release_track_list() {
  // @@protoc_insertion_point(field_release:sg.GuildService.GuildResponse.track_list)
  clear_has_track_list();
  ::sg::GuildTrackList* temp = track_list_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  track_list_ = NULL;
  return temp;
}
inline ::sg::GuildTrackList* GuildService_GuildResponse::unsafe_arena_release_track_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.GuildService.GuildResponse.track_list)
  clear_has_track_list();
  ::sg::GuildTrackList* temp = track_list_;
  track_list_ = NULL;
  return temp;
}
inline ::sg::GuildTrackList* GuildService_GuildResponse::mutable_track_list() {
  set_has_track_list();
  if (track_list_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::GuildTrackList>(GetArenaNoVirtual());
    track_list_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.GuildService.GuildResponse.track_list)
  return track_list_;
}
inline void GuildService_GuildResponse::set_allocated_track_list(::sg::GuildTrackList* track_list) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete track_list_;
  }
  if (track_list) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(track_list);
    if (message_arena != submessage_arena) {
      track_list = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, track_list, submessage_arena);
    }
    set_has_track_list();
  } else {
    clear_has_track_list();
  }
  track_list_ = track_list;
  // @@protoc_insertion_point(field_set_allocated:sg.GuildService.GuildResponse.track_list)
}

// repeated int32 self_joinning_list = 4;
inline int GuildService_GuildResponse::self_joinning_list_size() const {
  return self_joinning_list_.size();
}
inline void GuildService_GuildResponse::clear_self_joinning_list() {
  self_joinning_list_.Clear();
}
inline ::google::protobuf::int32 GuildService_GuildResponse::self_joinning_list(int index) const {
  // @@protoc_insertion_point(field_get:sg.GuildService.GuildResponse.self_joinning_list)
  return self_joinning_list_.Get(index);
}
inline void GuildService_GuildResponse::set_self_joinning_list(int index, ::google::protobuf::int32 value) {
  self_joinning_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:sg.GuildService.GuildResponse.self_joinning_list)
}
inline void GuildService_GuildResponse::add_self_joinning_list(::google::protobuf::int32 value) {
  self_joinning_list_.Add(value);
  // @@protoc_insertion_point(field_add:sg.GuildService.GuildResponse.self_joinning_list)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GuildService_GuildResponse::self_joinning_list() const {
  // @@protoc_insertion_point(field_list:sg.GuildService.GuildResponse.self_joinning_list)
  return self_joinning_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GuildService_GuildResponse::mutable_self_joinning_list() {
  // @@protoc_insertion_point(field_mutable_list:sg.GuildService.GuildResponse.self_joinning_list)
  return &self_joinning_list_;
}

// optional .sg.GuildSigninList signin_list = 11;
inline bool GuildService_GuildResponse::has_signin_list() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GuildService_GuildResponse::set_has_signin_list() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GuildService_GuildResponse::clear_has_signin_list() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GuildService_GuildResponse::clear_signin_list() {
  if (signin_list_ != NULL) signin_list_->Clear();
  clear_has_signin_list();
}
inline const ::sg::GuildSigninList& GuildService_GuildResponse::_internal_signin_list() const {
  return *signin_list_;
}
inline const ::sg::GuildSigninList& GuildService_GuildResponse::signin_list() const {
  const ::sg::GuildSigninList* p = signin_list_;
  // @@protoc_insertion_point(field_get:sg.GuildService.GuildResponse.signin_list)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::GuildSigninList*>(
      &::sg::_GuildSigninList_default_instance_);
}
inline ::sg::GuildSigninList* GuildService_GuildResponse::release_signin_list() {
  // @@protoc_insertion_point(field_release:sg.GuildService.GuildResponse.signin_list)
  clear_has_signin_list();
  ::sg::GuildSigninList* temp = signin_list_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  signin_list_ = NULL;
  return temp;
}
inline ::sg::GuildSigninList* GuildService_GuildResponse::unsafe_arena_release_signin_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.GuildService.GuildResponse.signin_list)
  clear_has_signin_list();
  ::sg::GuildSigninList* temp = signin_list_;
  signin_list_ = NULL;
  return temp;
}
inline ::sg::GuildSigninList* GuildService_GuildResponse::mutable_signin_list() {
  set_has_signin_list();
  if (signin_list_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::GuildSigninList>(GetArenaNoVirtual());
    signin_list_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.GuildService.GuildResponse.signin_list)
  return signin_list_;
}
inline void GuildService_GuildResponse::set_allocated_signin_list(::sg::GuildSigninList* signin_list) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete signin_list_;
  }
  if (signin_list) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(signin_list);
    if (message_arena != submessage_arena) {
      signin_list = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, signin_list, submessage_arena);
    }
    set_has_signin_list();
  } else {
    clear_has_signin_list();
  }
  signin_list_ = signin_list;
  // @@protoc_insertion_point(field_set_allocated:sg.GuildService.GuildResponse.signin_list)
}

// optional .sg.Reward signin_drop = 12;
inline bool GuildService_GuildResponse::has_signin_drop() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GuildService_GuildResponse::set_has_signin_drop() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GuildService_GuildResponse::clear_has_signin_drop() {
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::sg::Reward& GuildService_GuildResponse::_internal_signin_drop() const {
  return *signin_drop_;
}
inline const ::sg::Reward& GuildService_GuildResponse::signin_drop() const {
  const ::sg::Reward* p = signin_drop_;
  // @@protoc_insertion_point(field_get:sg.GuildService.GuildResponse.signin_drop)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::Reward*>(
      &::sg::_Reward_default_instance_);
}
inline ::sg::Reward* GuildService_GuildResponse::release_signin_drop() {
  // @@protoc_insertion_point(field_release:sg.GuildService.GuildResponse.signin_drop)
  clear_has_signin_drop();
  ::sg::Reward* temp = signin_drop_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  signin_drop_ = NULL;
  return temp;
}
inline ::sg::Reward* GuildService_GuildResponse::unsafe_arena_release_signin_drop() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.GuildService.GuildResponse.signin_drop)
  clear_has_signin_drop();
  ::sg::Reward* temp = signin_drop_;
  signin_drop_ = NULL;
  return temp;
}
inline ::sg::Reward* GuildService_GuildResponse::mutable_signin_drop() {
  set_has_signin_drop();
  if (signin_drop_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::Reward>(GetArenaNoVirtual());
    signin_drop_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.GuildService.GuildResponse.signin_drop)
  return signin_drop_;
}
inline void GuildService_GuildResponse::set_allocated_signin_drop(::sg::Reward* signin_drop) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(signin_drop_);
  }
  if (signin_drop) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(signin_drop)->GetArena();
    if (message_arena != submessage_arena) {
      signin_drop = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, signin_drop, submessage_arena);
    }
    set_has_signin_drop();
  } else {
    clear_has_signin_drop();
  }
  signin_drop_ = signin_drop;
  // @@protoc_insertion_point(field_set_allocated:sg.GuildService.GuildResponse.signin_drop)
}

// optional sfixed64 last_quit_optime = 13;
inline bool GuildService_GuildResponse::has_last_quit_optime() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GuildService_GuildResponse::set_has_last_quit_optime() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GuildService_GuildResponse::clear_has_last_quit_optime() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GuildService_GuildResponse::clear_last_quit_optime() {
  last_quit_optime_ = GOOGLE_LONGLONG(0);
  clear_has_last_quit_optime();
}
inline ::google::protobuf::int64 GuildService_GuildResponse::last_quit_optime() const {
  // @@protoc_insertion_point(field_get:sg.GuildService.GuildResponse.last_quit_optime)
  return last_quit_optime_;
}
inline void GuildService_GuildResponse::set_last_quit_optime(::google::protobuf::int64 value) {
  set_has_last_quit_optime();
  last_quit_optime_ = value;
  // @@protoc_insertion_point(field_set:sg.GuildService.GuildResponse.last_quit_optime)
}

// optional int32 quit_join_cd = 14;
inline bool GuildService_GuildResponse::has_quit_join_cd() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GuildService_GuildResponse::set_has_quit_join_cd() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GuildService_GuildResponse::clear_has_quit_join_cd() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GuildService_GuildResponse::clear_quit_join_cd() {
  quit_join_cd_ = 0;
  clear_has_quit_join_cd();
}
inline ::google::protobuf::int32 GuildService_GuildResponse::quit_join_cd() const {
  // @@protoc_insertion_point(field_get:sg.GuildService.GuildResponse.quit_join_cd)
  return quit_join_cd_;
}
inline void GuildService_GuildResponse::set_quit_join_cd(::google::protobuf::int32 value) {
  set_has_quit_join_cd();
  quit_join_cd_ = value;
  // @@protoc_insertion_point(field_set:sg.GuildService.GuildResponse.quit_join_cd)
}

// optional .sg.GuildStoreItemList store_item_list = 15;
inline bool GuildService_GuildResponse::has_store_item_list() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GuildService_GuildResponse::set_has_store_item_list() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GuildService_GuildResponse::clear_has_store_item_list() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GuildService_GuildResponse::clear_store_item_list() {
  if (store_item_list_ != NULL) store_item_list_->Clear();
  clear_has_store_item_list();
}
inline const ::sg::GuildStoreItemList& GuildService_GuildResponse::_internal_store_item_list() const {
  return *store_item_list_;
}
inline const ::sg::GuildStoreItemList& GuildService_GuildResponse::store_item_list() const {
  const ::sg::GuildStoreItemList* p = store_item_list_;
  // @@protoc_insertion_point(field_get:sg.GuildService.GuildResponse.store_item_list)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::GuildStoreItemList*>(
      &::sg::_GuildStoreItemList_default_instance_);
}
inline ::sg::GuildStoreItemList* GuildService_GuildResponse::release_store_item_list() {
  // @@protoc_insertion_point(field_release:sg.GuildService.GuildResponse.store_item_list)
  clear_has_store_item_list();
  ::sg::GuildStoreItemList* temp = store_item_list_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  store_item_list_ = NULL;
  return temp;
}
inline ::sg::GuildStoreItemList* GuildService_GuildResponse::unsafe_arena_release_store_item_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.GuildService.GuildResponse.store_item_list)
  clear_has_store_item_list();
  ::sg::GuildStoreItemList* temp = store_item_list_;
  store_item_list_ = NULL;
  return temp;
}
inline ::sg::GuildStoreItemList* GuildService_GuildResponse::mutable_store_item_list() {
  set_has_store_item_list();
  if (store_item_list_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::GuildStoreItemList>(GetArenaNoVirtual());
    store_item_list_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.GuildService.GuildResponse.store_item_list)
  return store_item_list_;
}
inline void GuildService_GuildResponse::set_allocated_store_item_list(::sg::GuildStoreItemList* store_item_list) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete store_item_list_;
  }
  if (store_item_list) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(store_item_list);
    if (message_arena != submessage_arena) {
      store_item_list = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, store_item_list, submessage_arena);
    }
    set_has_store_item_list();
  } else {
    clear_has_store_item_list();
  }
  store_item_list_ = store_item_list;
  // @@protoc_insertion_point(field_set_allocated:sg.GuildService.GuildResponse.store_item_list)
}

// optional .sg.Reward donate_drop = 16;
inline bool GuildService_GuildResponse::has_donate_drop() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GuildService_GuildResponse::set_has_donate_drop() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GuildService_GuildResponse::clear_has_donate_drop() {
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::sg::Reward& GuildService_GuildResponse::_internal_donate_drop() const {
  return *donate_drop_;
}
inline const ::sg::Reward& GuildService_GuildResponse::donate_drop() const {
  const ::sg::Reward* p = donate_drop_;
  // @@protoc_insertion_point(field_get:sg.GuildService.GuildResponse.donate_drop)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::Reward*>(
      &::sg::_Reward_default_instance_);
}
inline ::sg::Reward* GuildService_GuildResponse::release_donate_drop() {
  // @@protoc_insertion_point(field_release:sg.GuildService.GuildResponse.donate_drop)
  clear_has_donate_drop();
  ::sg::Reward* temp = donate_drop_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  donate_drop_ = NULL;
  return temp;
}
inline ::sg::Reward* GuildService_GuildResponse::unsafe_arena_release_donate_drop() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.GuildService.GuildResponse.donate_drop)
  clear_has_donate_drop();
  ::sg::Reward* temp = donate_drop_;
  donate_drop_ = NULL;
  return temp;
}
inline ::sg::Reward* GuildService_GuildResponse::mutable_donate_drop() {
  set_has_donate_drop();
  if (donate_drop_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::Reward>(GetArenaNoVirtual());
    donate_drop_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.GuildService.GuildResponse.donate_drop)
  return donate_drop_;
}
inline void GuildService_GuildResponse::set_allocated_donate_drop(::sg::Reward* donate_drop) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(donate_drop_);
  }
  if (donate_drop) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(donate_drop)->GetArena();
    if (message_arena != submessage_arena) {
      donate_drop = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, donate_drop, submessage_arena);
    }
    set_has_donate_drop();
  } else {
    clear_has_donate_drop();
  }
  donate_drop_ = donate_drop;
  // @@protoc_insertion_point(field_set_allocated:sg.GuildService.GuildResponse.donate_drop)
}

// optional .sg.GuildBuildingList building_list = 17;
inline bool GuildService_GuildResponse::has_building_list() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GuildService_GuildResponse::set_has_building_list() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GuildService_GuildResponse::clear_has_building_list() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GuildService_GuildResponse::clear_building_list() {
  if (building_list_ != NULL) building_list_->Clear();
  clear_has_building_list();
}
inline const ::sg::GuildBuildingList& GuildService_GuildResponse::_internal_building_list() const {
  return *building_list_;
}
inline const ::sg::GuildBuildingList& GuildService_GuildResponse::building_list() const {
  const ::sg::GuildBuildingList* p = building_list_;
  // @@protoc_insertion_point(field_get:sg.GuildService.GuildResponse.building_list)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::GuildBuildingList*>(
      &::sg::_GuildBuildingList_default_instance_);
}
inline ::sg::GuildBuildingList* GuildService_GuildResponse::release_building_list() {
  // @@protoc_insertion_point(field_release:sg.GuildService.GuildResponse.building_list)
  clear_has_building_list();
  ::sg::GuildBuildingList* temp = building_list_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  building_list_ = NULL;
  return temp;
}
inline ::sg::GuildBuildingList* GuildService_GuildResponse::unsafe_arena_release_building_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.GuildService.GuildResponse.building_list)
  clear_has_building_list();
  ::sg::GuildBuildingList* temp = building_list_;
  building_list_ = NULL;
  return temp;
}
inline ::sg::GuildBuildingList* GuildService_GuildResponse::mutable_building_list() {
  set_has_building_list();
  if (building_list_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::GuildBuildingList>(GetArenaNoVirtual());
    building_list_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.GuildService.GuildResponse.building_list)
  return building_list_;
}
inline void GuildService_GuildResponse::set_allocated_building_list(::sg::GuildBuildingList* building_list) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete building_list_;
  }
  if (building_list) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(building_list);
    if (message_arena != submessage_arena) {
      building_list = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, building_list, submessage_arena);
    }
    set_has_building_list();
  } else {
    clear_has_building_list();
  }
  building_list_ = building_list;
  // @@protoc_insertion_point(field_set_allocated:sg.GuildService.GuildResponse.building_list)
}

// -------------------------------------------------------------------

// GuildService

// optional .sg.GuildService.GuildRequest req = 1;
inline bool GuildService::has_req() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GuildService::set_has_req() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GuildService::clear_has_req() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GuildService::clear_req() {
  if (req_ != NULL) req_->Clear();
  clear_has_req();
}
inline const ::sg::GuildService_GuildRequest& GuildService::_internal_req() const {
  return *req_;
}
inline const ::sg::GuildService_GuildRequest& GuildService::req() const {
  const ::sg::GuildService_GuildRequest* p = req_;
  // @@protoc_insertion_point(field_get:sg.GuildService.req)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::GuildService_GuildRequest*>(
      &::sg::_GuildService_GuildRequest_default_instance_);
}
inline ::sg::GuildService_GuildRequest* GuildService::release_req() {
  // @@protoc_insertion_point(field_release:sg.GuildService.req)
  clear_has_req();
  ::sg::GuildService_GuildRequest* temp = req_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  req_ = NULL;
  return temp;
}
inline ::sg::GuildService_GuildRequest* GuildService::unsafe_arena_release_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.GuildService.req)
  clear_has_req();
  ::sg::GuildService_GuildRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline ::sg::GuildService_GuildRequest* GuildService::mutable_req() {
  set_has_req();
  if (req_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::GuildService_GuildRequest>(GetArenaNoVirtual());
    req_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.GuildService.req)
  return req_;
}
inline void GuildService::set_allocated_req(::sg::GuildService_GuildRequest* req) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete req_;
  }
  if (req) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(req);
    if (message_arena != submessage_arena) {
      req = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, req, submessage_arena);
    }
    set_has_req();
  } else {
    clear_has_req();
  }
  req_ = req;
  // @@protoc_insertion_point(field_set_allocated:sg.GuildService.req)
}

// optional .sg.GuildService.GuildResponse resp = 2;
inline bool GuildService::has_resp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GuildService::set_has_resp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GuildService::clear_has_resp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GuildService::clear_resp() {
  if (resp_ != NULL) resp_->Clear();
  clear_has_resp();
}
inline const ::sg::GuildService_GuildResponse& GuildService::_internal_resp() const {
  return *resp_;
}
inline const ::sg::GuildService_GuildResponse& GuildService::resp() const {
  const ::sg::GuildService_GuildResponse* p = resp_;
  // @@protoc_insertion_point(field_get:sg.GuildService.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::GuildService_GuildResponse*>(
      &::sg::_GuildService_GuildResponse_default_instance_);
}
inline ::sg::GuildService_GuildResponse* GuildService::release_resp() {
  // @@protoc_insertion_point(field_release:sg.GuildService.resp)
  clear_has_resp();
  ::sg::GuildService_GuildResponse* temp = resp_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  resp_ = NULL;
  return temp;
}
inline ::sg::GuildService_GuildResponse* GuildService::unsafe_arena_release_resp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.GuildService.resp)
  clear_has_resp();
  ::sg::GuildService_GuildResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline ::sg::GuildService_GuildResponse* GuildService::mutable_resp() {
  set_has_resp();
  if (resp_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::GuildService_GuildResponse>(GetArenaNoVirtual());
    resp_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.GuildService.resp)
  return resp_;
}
inline void GuildService::set_allocated_resp(::sg::GuildService_GuildResponse* resp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete resp_;
  }
  if (resp) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(resp);
    if (message_arena != submessage_arena) {
      resp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, resp, submessage_arena);
    }
    set_has_resp();
  } else {
    clear_has_resp();
  }
  resp_ = resp;
  // @@protoc_insertion_point(field_set_allocated:sg.GuildService.resp)
}

// -------------------------------------------------------------------

// GameGuildTrackNotify

// required .sg.GuildTrack track = 1;
inline bool GameGuildTrackNotify::has_track() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameGuildTrackNotify::set_has_track() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameGuildTrackNotify::clear_has_track() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameGuildTrackNotify::clear_track() {
  if (track_ != NULL) track_->Clear();
  clear_has_track();
}
inline const ::sg::GuildTrack& GameGuildTrackNotify::_internal_track() const {
  return *track_;
}
inline const ::sg::GuildTrack& GameGuildTrackNotify::track() const {
  const ::sg::GuildTrack* p = track_;
  // @@protoc_insertion_point(field_get:sg.GameGuildTrackNotify.track)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::GuildTrack*>(
      &::sg::_GuildTrack_default_instance_);
}
inline ::sg::GuildTrack* GameGuildTrackNotify::release_track() {
  // @@protoc_insertion_point(field_release:sg.GameGuildTrackNotify.track)
  clear_has_track();
  ::sg::GuildTrack* temp = track_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  track_ = NULL;
  return temp;
}
inline ::sg::GuildTrack* GameGuildTrackNotify::unsafe_arena_release_track() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.GameGuildTrackNotify.track)
  clear_has_track();
  ::sg::GuildTrack* temp = track_;
  track_ = NULL;
  return temp;
}
inline ::sg::GuildTrack* GameGuildTrackNotify::mutable_track() {
  set_has_track();
  if (track_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::GuildTrack>(GetArenaNoVirtual());
    track_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.GameGuildTrackNotify.track)
  return track_;
}
inline void GameGuildTrackNotify::set_allocated_track(::sg::GuildTrack* track) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete track_;
  }
  if (track) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(track);
    if (message_arena != submessage_arena) {
      track = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, track, submessage_arena);
    }
    set_has_track();
  } else {
    clear_has_track();
  }
  track_ = track;
  // @@protoc_insertion_point(field_set_allocated:sg.GameGuildTrackNotify.track)
}

// optional .sg.GuildData guild = 2;
inline bool GameGuildTrackNotify::has_guild() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameGuildTrackNotify::set_has_guild() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameGuildTrackNotify::clear_has_guild() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameGuildTrackNotify::clear_guild() {
  if (guild_ != NULL) guild_->Clear();
  clear_has_guild();
}
inline const ::sg::GuildData& GameGuildTrackNotify::_internal_guild() const {
  return *guild_;
}
inline const ::sg::GuildData& GameGuildTrackNotify::guild() const {
  const ::sg::GuildData* p = guild_;
  // @@protoc_insertion_point(field_get:sg.GameGuildTrackNotify.guild)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::GuildData*>(
      &::sg::_GuildData_default_instance_);
}
inline ::sg::GuildData* GameGuildTrackNotify::release_guild() {
  // @@protoc_insertion_point(field_release:sg.GameGuildTrackNotify.guild)
  clear_has_guild();
  ::sg::GuildData* temp = guild_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  guild_ = NULL;
  return temp;
}
inline ::sg::GuildData* GameGuildTrackNotify::unsafe_arena_release_guild() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.GameGuildTrackNotify.guild)
  clear_has_guild();
  ::sg::GuildData* temp = guild_;
  guild_ = NULL;
  return temp;
}
inline ::sg::GuildData* GameGuildTrackNotify::mutable_guild() {
  set_has_guild();
  if (guild_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::GuildData>(GetArenaNoVirtual());
    guild_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.GameGuildTrackNotify.guild)
  return guild_;
}
inline void GameGuildTrackNotify::set_allocated_guild(::sg::GuildData* guild) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete guild_;
  }
  if (guild) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(guild);
    if (message_arena != submessage_arena) {
      guild = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, guild, submessage_arena);
    }
    set_has_guild();
  } else {
    clear_has_guild();
  }
  guild_ = guild;
  // @@protoc_insertion_point(field_set_allocated:sg.GameGuildTrackNotify.guild)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace sg

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::sg::GuildBuilding_BUILDING_TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::GuildBuilding_BUILDING_TYPE>() {
  return ::sg::GuildBuilding_BUILDING_TYPE_descriptor();
}
template <> struct is_proto_enum< ::sg::GuildBuilding_BUILDING_STATE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::GuildBuilding_BUILDING_STATE>() {
  return ::sg::GuildBuilding_BUILDING_STATE_descriptor();
}
template <> struct is_proto_enum< ::sg::GuildSignin_STATE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::GuildSignin_STATE>() {
  return ::sg::GuildSignin_STATE_descriptor();
}
template <> struct is_proto_enum< ::sg::GuildTrack_TRACK_ACTION_TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::GuildTrack_TRACK_ACTION_TYPE>() {
  return ::sg::GuildTrack_TRACK_ACTION_TYPE_descriptor();
}
template <> struct is_proto_enum< ::sg::GuildService_GUILD_COMMAND> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::GuildService_GUILD_COMMAND>() {
  return ::sg::GuildService_GUILD_COMMAND_descriptor();
}
template <> struct is_proto_enum< ::sg::GUILD_STATE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::GUILD_STATE>() {
  return ::sg::GUILD_STATE_descriptor();
}
template <> struct is_proto_enum< ::sg::GUILD_ACCEPT_TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::GUILD_ACCEPT_TYPE>() {
  return ::sg::GUILD_ACCEPT_TYPE_descriptor();
}
template <> struct is_proto_enum< ::sg::GUILD_USER_TITLE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::GUILD_USER_TITLE>() {
  return ::sg::GUILD_USER_TITLE_descriptor();
}
template <> struct is_proto_enum< ::sg::GUILD_USER_STATE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::GUILD_USER_STATE>() {
  return ::sg::GUILD_USER_STATE_descriptor();
}
template <> struct is_proto_enum< ::sg::GUILD_SIGNIN_TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::GUILD_SIGNIN_TYPE>() {
  return ::sg::GUILD_SIGNIN_TYPE_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_Guild_2eproto
