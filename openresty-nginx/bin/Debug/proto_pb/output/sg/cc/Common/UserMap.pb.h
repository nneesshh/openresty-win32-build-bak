// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: UserMap.proto

#ifndef PROTOBUF_INCLUDED_UserMap_2eproto
#define PROTOBUF_INCLUDED_UserMap_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "BaseStruct.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_UserMap_2eproto 

namespace protobuf_UserMap_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[23];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_UserMap_2eproto
namespace sg {
class GarrisonRoom;
class GarrisonRoomDefaultTypeInternal;
extern GarrisonRoomDefaultTypeInternal _GarrisonRoom_default_instance_;
class HarvestTime;
class HarvestTimeDefaultTypeInternal;
extern HarvestTimeDefaultTypeInternal _HarvestTime_default_instance_;
class MapArea;
class MapAreaDefaultTypeInternal;
extern MapAreaDefaultTypeInternal _MapArea_default_instance_;
class MapAreaList;
class MapAreaListDefaultTypeInternal;
extern MapAreaListDefaultTypeInternal _MapAreaList_default_instance_;
class MapEntry;
class MapEntryDefaultTypeInternal;
extern MapEntryDefaultTypeInternal _MapEntry_default_instance_;
class MapEntryList;
class MapEntryListDefaultTypeInternal;
extern MapEntryListDefaultTypeInternal _MapEntryList_default_instance_;
class MapEntryStateNotify;
class MapEntryStateNotifyDefaultTypeInternal;
extern MapEntryStateNotifyDefaultTypeInternal _MapEntryStateNotify_default_instance_;
class OccupierData;
class OccupierDataDefaultTypeInternal;
extern OccupierDataDefaultTypeInternal _OccupierData_default_instance_;
class PirateShip;
class PirateShipDefaultTypeInternal;
extern PirateShipDefaultTypeInternal _PirateShip_default_instance_;
class PlayerShip;
class PlayerShipDefaultTypeInternal;
extern PlayerShipDefaultTypeInternal _PlayerShip_default_instance_;
class UserMapService;
class UserMapServiceDefaultTypeInternal;
extern UserMapServiceDefaultTypeInternal _UserMapService_default_instance_;
class UserMapService_MapRequest;
class UserMapService_MapRequestDefaultTypeInternal;
extern UserMapService_MapRequestDefaultTypeInternal _UserMapService_MapRequest_default_instance_;
class UserMapService_MapResponse;
class UserMapService_MapResponseDefaultTypeInternal;
extern UserMapService_MapResponseDefaultTypeInternal _UserMapService_MapResponse_default_instance_;
class WildIsland;
class WildIslandDefaultTypeInternal;
extern WildIslandDefaultTypeInternal _WildIsland_default_instance_;
class WildIslandHarvestLog;
class WildIslandHarvestLogDefaultTypeInternal;
extern WildIslandHarvestLogDefaultTypeInternal _WildIslandHarvestLog_default_instance_;
class WildIslandHarvestLog_HarvestItem;
class WildIslandHarvestLog_HarvestItemDefaultTypeInternal;
extern WildIslandHarvestLog_HarvestItemDefaultTypeInternal _WildIslandHarvestLog_HarvestItem_default_instance_;
class WildIslandHarvestLog_HarvestItemList;
class WildIslandHarvestLog_HarvestItemListDefaultTypeInternal;
extern WildIslandHarvestLog_HarvestItemListDefaultTypeInternal _WildIslandHarvestLog_HarvestItemList_default_instance_;
class WildIslandHarvestLog_HarvestLog;
class WildIslandHarvestLog_HarvestLogDefaultTypeInternal;
extern WildIslandHarvestLog_HarvestLogDefaultTypeInternal _WildIslandHarvestLog_HarvestLog_default_instance_;
class WildIslandHarvestLog_HarvestLogList;
class WildIslandHarvestLog_HarvestLogListDefaultTypeInternal;
extern WildIslandHarvestLog_HarvestLogListDefaultTypeInternal _WildIslandHarvestLog_HarvestLogList_default_instance_;
class WildIslandList;
class WildIslandListDefaultTypeInternal;
extern WildIslandListDefaultTypeInternal _WildIslandList_default_instance_;
class WildIslandStateNotify;
class WildIslandStateNotifyDefaultTypeInternal;
extern WildIslandStateNotifyDefaultTypeInternal _WildIslandStateNotify_default_instance_;
class WildIsland_Workshop;
class WildIsland_WorkshopDefaultTypeInternal;
extern WildIsland_WorkshopDefaultTypeInternal _WildIsland_Workshop_default_instance_;
class WildIsland_WorkshopOption;
class WildIsland_WorkshopOptionDefaultTypeInternal;
extern WildIsland_WorkshopOptionDefaultTypeInternal _WildIsland_WorkshopOption_default_instance_;
}  // namespace sg
namespace google {
namespace protobuf {
template<> ::sg::GarrisonRoom* Arena::CreateMaybeMessage<::sg::GarrisonRoom>(Arena*);
template<> ::sg::HarvestTime* Arena::CreateMaybeMessage<::sg::HarvestTime>(Arena*);
template<> ::sg::MapArea* Arena::CreateMaybeMessage<::sg::MapArea>(Arena*);
template<> ::sg::MapAreaList* Arena::CreateMaybeMessage<::sg::MapAreaList>(Arena*);
template<> ::sg::MapEntry* Arena::CreateMaybeMessage<::sg::MapEntry>(Arena*);
template<> ::sg::MapEntryList* Arena::CreateMaybeMessage<::sg::MapEntryList>(Arena*);
template<> ::sg::MapEntryStateNotify* Arena::CreateMaybeMessage<::sg::MapEntryStateNotify>(Arena*);
template<> ::sg::OccupierData* Arena::CreateMaybeMessage<::sg::OccupierData>(Arena*);
template<> ::sg::PirateShip* Arena::CreateMaybeMessage<::sg::PirateShip>(Arena*);
template<> ::sg::PlayerShip* Arena::CreateMaybeMessage<::sg::PlayerShip>(Arena*);
template<> ::sg::UserMapService* Arena::CreateMaybeMessage<::sg::UserMapService>(Arena*);
template<> ::sg::UserMapService_MapRequest* Arena::CreateMaybeMessage<::sg::UserMapService_MapRequest>(Arena*);
template<> ::sg::UserMapService_MapResponse* Arena::CreateMaybeMessage<::sg::UserMapService_MapResponse>(Arena*);
template<> ::sg::WildIsland* Arena::CreateMaybeMessage<::sg::WildIsland>(Arena*);
template<> ::sg::WildIslandHarvestLog* Arena::CreateMaybeMessage<::sg::WildIslandHarvestLog>(Arena*);
template<> ::sg::WildIslandHarvestLog_HarvestItem* Arena::CreateMaybeMessage<::sg::WildIslandHarvestLog_HarvestItem>(Arena*);
template<> ::sg::WildIslandHarvestLog_HarvestItemList* Arena::CreateMaybeMessage<::sg::WildIslandHarvestLog_HarvestItemList>(Arena*);
template<> ::sg::WildIslandHarvestLog_HarvestLog* Arena::CreateMaybeMessage<::sg::WildIslandHarvestLog_HarvestLog>(Arena*);
template<> ::sg::WildIslandHarvestLog_HarvestLogList* Arena::CreateMaybeMessage<::sg::WildIslandHarvestLog_HarvestLogList>(Arena*);
template<> ::sg::WildIslandList* Arena::CreateMaybeMessage<::sg::WildIslandList>(Arena*);
template<> ::sg::WildIslandStateNotify* Arena::CreateMaybeMessage<::sg::WildIslandStateNotify>(Arena*);
template<> ::sg::WildIsland_Workshop* Arena::CreateMaybeMessage<::sg::WildIsland_Workshop>(Arena*);
template<> ::sg::WildIsland_WorkshopOption* Arena::CreateMaybeMessage<::sg::WildIsland_WorkshopOption>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace sg {

enum UserMapService_MAP_COMMAND {
  UserMapService_MAP_COMMAND_QUERY_AREA = 1,
  UserMapService_MAP_COMMAND_QUERY_ENTRY = 2,
  UserMapService_MAP_COMMAND_QUERY_ENTRY_WILD_ISLAND = 3,
  UserMapService_MAP_COMMAND_UNLOCK_AREA = 4,
  UserMapService_MAP_COMMAND_BUILD_WORKSHOP = 5,
  UserMapService_MAP_COMMAND_GARRISON_WORKSHOP = 6,
  UserMapService_MAP_COMMAND_HARVEST = 11,
  UserMapService_MAP_COMMAND_QUERY_HARVEST_TIME = 12,
  UserMapService_MAP_COMMAND_QUERY_HARVEST_LOG = 13
};
bool UserMapService_MAP_COMMAND_IsValid(int value);
const UserMapService_MAP_COMMAND UserMapService_MAP_COMMAND_MAP_COMMAND_MIN = UserMapService_MAP_COMMAND_QUERY_AREA;
const UserMapService_MAP_COMMAND UserMapService_MAP_COMMAND_MAP_COMMAND_MAX = UserMapService_MAP_COMMAND_QUERY_HARVEST_LOG;
const int UserMapService_MAP_COMMAND_MAP_COMMAND_ARRAYSIZE = UserMapService_MAP_COMMAND_MAP_COMMAND_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserMapService_MAP_COMMAND_descriptor();
inline const ::std::string& UserMapService_MAP_COMMAND_Name(UserMapService_MAP_COMMAND value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserMapService_MAP_COMMAND_descriptor(), value);
}
inline bool UserMapService_MAP_COMMAND_Parse(
    const ::std::string& name, UserMapService_MAP_COMMAND* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserMapService_MAP_COMMAND>(
    UserMapService_MAP_COMMAND_descriptor(), name, value);
}
enum MAP_AREA_UNLOCK_COND {
  MAP_AREA_UNLOCK_COND_NONE = 0,
  MAP_AREA_UNLOCK_COND_SHIP = 1,
  MAP_AREA_UNLOCK_COND_QUEST = 2,
  MAP_AREA_UNLOCK_COND_ACHIEVEMENT = 3,
  MAP_AREA_UNLOCK_COND_LEVEL = 4,
  MAP_AREA_UNLOCK_COND_CAPTAIN_LEVEL = 5,
  MAP_AREA_UNLOCK_COND_HERO_NUM = 6
};
bool MAP_AREA_UNLOCK_COND_IsValid(int value);
const MAP_AREA_UNLOCK_COND MAP_AREA_UNLOCK_COND_MIN = MAP_AREA_UNLOCK_COND_NONE;
const MAP_AREA_UNLOCK_COND MAP_AREA_UNLOCK_COND_MAX = MAP_AREA_UNLOCK_COND_HERO_NUM;
const int MAP_AREA_UNLOCK_COND_ARRAYSIZE = MAP_AREA_UNLOCK_COND_MAX + 1;

const ::google::protobuf::EnumDescriptor* MAP_AREA_UNLOCK_COND_descriptor();
inline const ::std::string& MAP_AREA_UNLOCK_COND_Name(MAP_AREA_UNLOCK_COND value) {
  return ::google::protobuf::internal::NameOfEnum(
    MAP_AREA_UNLOCK_COND_descriptor(), value);
}
inline bool MAP_AREA_UNLOCK_COND_Parse(
    const ::std::string& name, MAP_AREA_UNLOCK_COND* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MAP_AREA_UNLOCK_COND>(
    MAP_AREA_UNLOCK_COND_descriptor(), name, value);
}
enum MAP_AREA_UNLOCK_TYPE {
  MAP_AREA_UNLOCK_TYPE_GOLD = 1,
  MAP_AREA_UNLOCK_TYPE_DIAMOND = 2
};
bool MAP_AREA_UNLOCK_TYPE_IsValid(int value);
const MAP_AREA_UNLOCK_TYPE MAP_AREA_UNLOCK_TYPE_MIN = MAP_AREA_UNLOCK_TYPE_GOLD;
const MAP_AREA_UNLOCK_TYPE MAP_AREA_UNLOCK_TYPE_MAX = MAP_AREA_UNLOCK_TYPE_DIAMOND;
const int MAP_AREA_UNLOCK_TYPE_ARRAYSIZE = MAP_AREA_UNLOCK_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* MAP_AREA_UNLOCK_TYPE_descriptor();
inline const ::std::string& MAP_AREA_UNLOCK_TYPE_Name(MAP_AREA_UNLOCK_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    MAP_AREA_UNLOCK_TYPE_descriptor(), value);
}
inline bool MAP_AREA_UNLOCK_TYPE_Parse(
    const ::std::string& name, MAP_AREA_UNLOCK_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MAP_AREA_UNLOCK_TYPE>(
    MAP_AREA_UNLOCK_TYPE_descriptor(), name, value);
}
enum MAP_AREA_UNLOCK_STATE {
  MAP_AREA_STATE_LOCKED = 0,
  MAP_AREA_STATE_UNLOCKED = 1
};
bool MAP_AREA_UNLOCK_STATE_IsValid(int value);
const MAP_AREA_UNLOCK_STATE MAP_AREA_UNLOCK_STATE_MIN = MAP_AREA_STATE_LOCKED;
const MAP_AREA_UNLOCK_STATE MAP_AREA_UNLOCK_STATE_MAX = MAP_AREA_STATE_UNLOCKED;
const int MAP_AREA_UNLOCK_STATE_ARRAYSIZE = MAP_AREA_UNLOCK_STATE_MAX + 1;

const ::google::protobuf::EnumDescriptor* MAP_AREA_UNLOCK_STATE_descriptor();
inline const ::std::string& MAP_AREA_UNLOCK_STATE_Name(MAP_AREA_UNLOCK_STATE value) {
  return ::google::protobuf::internal::NameOfEnum(
    MAP_AREA_UNLOCK_STATE_descriptor(), value);
}
inline bool MAP_AREA_UNLOCK_STATE_Parse(
    const ::std::string& name, MAP_AREA_UNLOCK_STATE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MAP_AREA_UNLOCK_STATE>(
    MAP_AREA_UNLOCK_STATE_descriptor(), name, value);
}
enum MAP_ENTRY_TYPE {
  MAP_ENTRY_TYPE_NONE = 0,
  MAP_ENTRY_TYPE_BORN = 1,
  MAP_ENTRY_TYPE_HARBOR = 2,
  MAP_ENTRY_TYPE_WILD_ISLAND = 3,
  MAP_ENTRY_TYPE_PIRATE_SHIP = 4,
  MAP_ENTRY_TYPE_PLAYER_SHIP = 5,
  MAP_ENTRY_TYPE_TAVERN = 6,
  MAP_ENTRY_TYPE_HUNTING_GROUND = 7,
  MAP_ENTRY_TYPE_FISHING_GROUND = 8,
  MAP_ENTRY_TYPE_ARENA = 9,
  MAP_ENTRY_TYPE_GHOST_SHIP = 10,
  MAP_ENTRY_TYPE_MAELSTROM = 11
};
bool MAP_ENTRY_TYPE_IsValid(int value);
const MAP_ENTRY_TYPE MAP_ENTRY_TYPE_MIN = MAP_ENTRY_TYPE_NONE;
const MAP_ENTRY_TYPE MAP_ENTRY_TYPE_MAX = MAP_ENTRY_TYPE_MAELSTROM;
const int MAP_ENTRY_TYPE_ARRAYSIZE = MAP_ENTRY_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* MAP_ENTRY_TYPE_descriptor();
inline const ::std::string& MAP_ENTRY_TYPE_Name(MAP_ENTRY_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    MAP_ENTRY_TYPE_descriptor(), value);
}
inline bool MAP_ENTRY_TYPE_Parse(
    const ::std::string& name, MAP_ENTRY_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MAP_ENTRY_TYPE>(
    MAP_ENTRY_TYPE_descriptor(), name, value);
}
enum MAP_ENTRY_STATE {
  MAP_ENTRY_STATE_INVISIBLE = 0,
  MAP_ENTRY_STATE_NORMAL = 1
};
bool MAP_ENTRY_STATE_IsValid(int value);
const MAP_ENTRY_STATE MAP_ENTRY_STATE_MIN = MAP_ENTRY_STATE_INVISIBLE;
const MAP_ENTRY_STATE MAP_ENTRY_STATE_MAX = MAP_ENTRY_STATE_NORMAL;
const int MAP_ENTRY_STATE_ARRAYSIZE = MAP_ENTRY_STATE_MAX + 1;

const ::google::protobuf::EnumDescriptor* MAP_ENTRY_STATE_descriptor();
inline const ::std::string& MAP_ENTRY_STATE_Name(MAP_ENTRY_STATE value) {
  return ::google::protobuf::internal::NameOfEnum(
    MAP_ENTRY_STATE_descriptor(), value);
}
inline bool MAP_ENTRY_STATE_Parse(
    const ::std::string& name, MAP_ENTRY_STATE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MAP_ENTRY_STATE>(
    MAP_ENTRY_STATE_descriptor(), name, value);
}
enum MAP_ENTRY_OWNERSHIP_STATE {
  MAP_ENTRY_OWNERSHIP_STATE_NONE = 0,
  MAP_ENTRY_OWNERSHIP_STATE_OWN = 1,
  MAP_ENTRY_OWNERSHIP_STATE_LOST = 2
};
bool MAP_ENTRY_OWNERSHIP_STATE_IsValid(int value);
const MAP_ENTRY_OWNERSHIP_STATE MAP_ENTRY_OWNERSHIP_STATE_MIN = MAP_ENTRY_OWNERSHIP_STATE_NONE;
const MAP_ENTRY_OWNERSHIP_STATE MAP_ENTRY_OWNERSHIP_STATE_MAX = MAP_ENTRY_OWNERSHIP_STATE_LOST;
const int MAP_ENTRY_OWNERSHIP_STATE_ARRAYSIZE = MAP_ENTRY_OWNERSHIP_STATE_MAX + 1;

const ::google::protobuf::EnumDescriptor* MAP_ENTRY_OWNERSHIP_STATE_descriptor();
inline const ::std::string& MAP_ENTRY_OWNERSHIP_STATE_Name(MAP_ENTRY_OWNERSHIP_STATE value) {
  return ::google::protobuf::internal::NameOfEnum(
    MAP_ENTRY_OWNERSHIP_STATE_descriptor(), value);
}
inline bool MAP_ENTRY_OWNERSHIP_STATE_Parse(
    const ::std::string& name, MAP_ENTRY_OWNERSHIP_STATE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MAP_ENTRY_OWNERSHIP_STATE>(
    MAP_ENTRY_OWNERSHIP_STATE_descriptor(), name, value);
}
enum MAP_ENTRY_HARVEST_TYPE {
  MAP_ENTRY_HARVEST_TYPE_UNKNOWN = 0,
  MAP_ENTRY_HARVEST_TYPE_WOOD = 1,
  MAP_ENTRY_HARVEST_TYPE_STONE = 2,
  MAP_ENTRY_HARVEST_TYPE_COPPER = 3,
  MAP_ENTRY_HARVEST_TYPE_IRON = 4
};
bool MAP_ENTRY_HARVEST_TYPE_IsValid(int value);
const MAP_ENTRY_HARVEST_TYPE MAP_ENTRY_HARVEST_TYPE_MIN = MAP_ENTRY_HARVEST_TYPE_UNKNOWN;
const MAP_ENTRY_HARVEST_TYPE MAP_ENTRY_HARVEST_TYPE_MAX = MAP_ENTRY_HARVEST_TYPE_IRON;
const int MAP_ENTRY_HARVEST_TYPE_ARRAYSIZE = MAP_ENTRY_HARVEST_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* MAP_ENTRY_HARVEST_TYPE_descriptor();
inline const ::std::string& MAP_ENTRY_HARVEST_TYPE_Name(MAP_ENTRY_HARVEST_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    MAP_ENTRY_HARVEST_TYPE_descriptor(), value);
}
inline bool MAP_ENTRY_HARVEST_TYPE_Parse(
    const ::std::string& name, MAP_ENTRY_HARVEST_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MAP_ENTRY_HARVEST_TYPE>(
    MAP_ENTRY_HARVEST_TYPE_descriptor(), name, value);
}
enum WILD_ISLAND_TYPE {
  WILD_ISLAND_TYPE_DUMMY = 0,
  WILD_ISLAND_TYPE_COMMON = 1,
  WILD_ISLAND_TYPE_PIRATE = 2,
  WILD_ISLAND_TYPE_GROUP = 3
};
bool WILD_ISLAND_TYPE_IsValid(int value);
const WILD_ISLAND_TYPE WILD_ISLAND_TYPE_MIN = WILD_ISLAND_TYPE_DUMMY;
const WILD_ISLAND_TYPE WILD_ISLAND_TYPE_MAX = WILD_ISLAND_TYPE_GROUP;
const int WILD_ISLAND_TYPE_ARRAYSIZE = WILD_ISLAND_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* WILD_ISLAND_TYPE_descriptor();
inline const ::std::string& WILD_ISLAND_TYPE_Name(WILD_ISLAND_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    WILD_ISLAND_TYPE_descriptor(), value);
}
inline bool WILD_ISLAND_TYPE_Parse(
    const ::std::string& name, WILD_ISLAND_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<WILD_ISLAND_TYPE>(
    WILD_ISLAND_TYPE_descriptor(), name, value);
}
enum WILD_ISLAND_STATE {
  WILD_ISLAND_STATE_UNKNOWN = 0,
  WILD_ISLAND_STATE_OPEN = 1,
  WILD_ISLAND_STATE_PROTECTED = 2,
  WILD_ISLAND_STATE_CLOSE = 3
};
bool WILD_ISLAND_STATE_IsValid(int value);
const WILD_ISLAND_STATE WILD_ISLAND_STATE_MIN = WILD_ISLAND_STATE_UNKNOWN;
const WILD_ISLAND_STATE WILD_ISLAND_STATE_MAX = WILD_ISLAND_STATE_CLOSE;
const int WILD_ISLAND_STATE_ARRAYSIZE = WILD_ISLAND_STATE_MAX + 1;

const ::google::protobuf::EnumDescriptor* WILD_ISLAND_STATE_descriptor();
inline const ::std::string& WILD_ISLAND_STATE_Name(WILD_ISLAND_STATE value) {
  return ::google::protobuf::internal::NameOfEnum(
    WILD_ISLAND_STATE_descriptor(), value);
}
inline bool WILD_ISLAND_STATE_Parse(
    const ::std::string& name, WILD_ISLAND_STATE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<WILD_ISLAND_STATE>(
    WILD_ISLAND_STATE_descriptor(), name, value);
}
enum WILD_ISLAND_GATHER_STATE {
  WILD_ISLAND_GATHER_STATE_IDLE = 0,
  WILD_ISLAND_GATHER_STATE_GATHER_BUSY = 1,
  WILD_ISLAND_GATHER_STATE_GATHER_OVER = 2,
  WILD_ISLAND_GATHER_STATE_HARVEST = 3
};
bool WILD_ISLAND_GATHER_STATE_IsValid(int value);
const WILD_ISLAND_GATHER_STATE WILD_ISLAND_GATHER_STATE_MIN = WILD_ISLAND_GATHER_STATE_IDLE;
const WILD_ISLAND_GATHER_STATE WILD_ISLAND_GATHER_STATE_MAX = WILD_ISLAND_GATHER_STATE_HARVEST;
const int WILD_ISLAND_GATHER_STATE_ARRAYSIZE = WILD_ISLAND_GATHER_STATE_MAX + 1;

const ::google::protobuf::EnumDescriptor* WILD_ISLAND_GATHER_STATE_descriptor();
inline const ::std::string& WILD_ISLAND_GATHER_STATE_Name(WILD_ISLAND_GATHER_STATE value) {
  return ::google::protobuf::internal::NameOfEnum(
    WILD_ISLAND_GATHER_STATE_descriptor(), value);
}
inline bool WILD_ISLAND_GATHER_STATE_Parse(
    const ::std::string& name, WILD_ISLAND_GATHER_STATE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<WILD_ISLAND_GATHER_STATE>(
    WILD_ISLAND_GATHER_STATE_descriptor(), name, value);
}
enum WILD_ISLAND_WORKSHOP_STATE {
  WILD_ISLAND_WORKSHOP_STATE_NONE = 0,
  WILD_ISLAND_WORKSHOP_STATE_WORKING = 1
};
bool WILD_ISLAND_WORKSHOP_STATE_IsValid(int value);
const WILD_ISLAND_WORKSHOP_STATE WILD_ISLAND_WORKSHOP_STATE_MIN = WILD_ISLAND_WORKSHOP_STATE_NONE;
const WILD_ISLAND_WORKSHOP_STATE WILD_ISLAND_WORKSHOP_STATE_MAX = WILD_ISLAND_WORKSHOP_STATE_WORKING;
const int WILD_ISLAND_WORKSHOP_STATE_ARRAYSIZE = WILD_ISLAND_WORKSHOP_STATE_MAX + 1;

const ::google::protobuf::EnumDescriptor* WILD_ISLAND_WORKSHOP_STATE_descriptor();
inline const ::std::string& WILD_ISLAND_WORKSHOP_STATE_Name(WILD_ISLAND_WORKSHOP_STATE value) {
  return ::google::protobuf::internal::NameOfEnum(
    WILD_ISLAND_WORKSHOP_STATE_descriptor(), value);
}
inline bool WILD_ISLAND_WORKSHOP_STATE_Parse(
    const ::std::string& name, WILD_ISLAND_WORKSHOP_STATE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<WILD_ISLAND_WORKSHOP_STATE>(
    WILD_ISLAND_WORKSHOP_STATE_descriptor(), name, value);
}
// ===================================================================

class MapArea : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.MapArea) */ {
 public:
  MapArea();
  virtual ~MapArea();

  MapArea(const MapArea& from);

  inline MapArea& operator=(const MapArea& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapArea(MapArea&& from) noexcept
    : MapArea() {
    *this = ::std::move(from);
  }

  inline MapArea& operator=(MapArea&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapArea& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapArea* internal_default_instance() {
    return reinterpret_cast<const MapArea*>(
               &_MapArea_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void UnsafeArenaSwap(MapArea* other);
  void Swap(MapArea* other);
  friend void swap(MapArea& a, MapArea& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapArea* New() const final {
    return CreateMaybeMessage<MapArea>(NULL);
  }

  MapArea* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MapArea>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MapArea& from);
  void MergeFrom(const MapArea& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapArea* other);
  protected:
  explicit MapArea(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 areaid = 1;
  bool has_areaid() const;
  void clear_areaid();
  static const int kAreaidFieldNumber = 1;
  ::google::protobuf::uint64 areaid() const;
  void set_areaid(::google::protobuf::uint64 value);

  // required .sg.MAP_AREA_UNLOCK_STATE area_state = 2;
  bool has_area_state() const;
  void clear_area_state();
  static const int kAreaStateFieldNumber = 2;
  ::sg::MAP_AREA_UNLOCK_STATE area_state() const;
  void set_area_state(::sg::MAP_AREA_UNLOCK_STATE value);

  // @@protoc_insertion_point(class_scope:sg.MapArea)
 private:
  void set_has_areaid();
  void clear_has_areaid();
  void set_has_area_state();
  void clear_has_area_state();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 areaid_;
  int area_state_;
  friend struct ::protobuf_UserMap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MapAreaList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.MapAreaList) */ {
 public:
  MapAreaList();
  virtual ~MapAreaList();

  MapAreaList(const MapAreaList& from);

  inline MapAreaList& operator=(const MapAreaList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapAreaList(MapAreaList&& from) noexcept
    : MapAreaList() {
    *this = ::std::move(from);
  }

  inline MapAreaList& operator=(MapAreaList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapAreaList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapAreaList* internal_default_instance() {
    return reinterpret_cast<const MapAreaList*>(
               &_MapAreaList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void UnsafeArenaSwap(MapAreaList* other);
  void Swap(MapAreaList* other);
  friend void swap(MapAreaList& a, MapAreaList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapAreaList* New() const final {
    return CreateMaybeMessage<MapAreaList>(NULL);
  }

  MapAreaList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MapAreaList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MapAreaList& from);
  void MergeFrom(const MapAreaList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapAreaList* other);
  protected:
  explicit MapAreaList(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sg.MapArea list = 1;
  int list_size() const;
  void clear_list();
  static const int kListFieldNumber = 1;
  ::sg::MapArea* mutable_list(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::MapArea >*
      mutable_list();
  const ::sg::MapArea& list(int index) const;
  ::sg::MapArea* add_list();
  const ::google::protobuf::RepeatedPtrField< ::sg::MapArea >&
      list() const;

  // @@protoc_insertion_point(class_scope:sg.MapAreaList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::MapArea > list_;
  friend struct ::protobuf_UserMap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PirateShip : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.PirateShip) */ {
 public:
  PirateShip();
  virtual ~PirateShip();

  PirateShip(const PirateShip& from);

  inline PirateShip& operator=(const PirateShip& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PirateShip(PirateShip&& from) noexcept
    : PirateShip() {
    *this = ::std::move(from);
  }

  inline PirateShip& operator=(PirateShip&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const PirateShip& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PirateShip* internal_default_instance() {
    return reinterpret_cast<const PirateShip*>(
               &_PirateShip_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void UnsafeArenaSwap(PirateShip* other);
  void Swap(PirateShip* other);
  friend void swap(PirateShip& a, PirateShip& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PirateShip* New() const final {
    return CreateMaybeMessage<PirateShip>(NULL);
  }

  PirateShip* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PirateShip>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PirateShip& from);
  void MergeFrom(const PirateShip& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PirateShip* other);
  protected:
  explicit PirateShip(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 shipid = 1;
  bool has_shipid() const;
  void clear_shipid();
  static const int kShipidFieldNumber = 1;
  ::google::protobuf::int32 shipid() const;
  void set_shipid(::google::protobuf::int32 value);

  // optional int32 type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // optional sfixed64 refresh_time = 3;
  bool has_refresh_time() const;
  void clear_refresh_time();
  static const int kRefreshTimeFieldNumber = 3;
  ::google::protobuf::int64 refresh_time() const;
  void set_refresh_time(::google::protobuf::int64 value);

  // optional int32 fight_num = 4;
  bool has_fight_num() const;
  void clear_fight_num();
  static const int kFightNumFieldNumber = 4;
  ::google::protobuf::int32 fight_num() const;
  void set_fight_num(::google::protobuf::int32 value);

  // optional int32 fight_num_max = 5;
  bool has_fight_num_max() const;
  void clear_fight_num_max();
  static const int kFightNumMaxFieldNumber = 5;
  ::google::protobuf::int32 fight_num_max() const;
  void set_fight_num_max(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.PirateShip)
 private:
  void set_has_shipid();
  void clear_has_shipid();
  void set_has_type();
  void clear_has_type();
  void set_has_refresh_time();
  void clear_has_refresh_time();
  void set_has_fight_num();
  void clear_has_fight_num();
  void set_has_fight_num_max();
  void clear_has_fight_num_max();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 shipid_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int64 refresh_time_;
  ::google::protobuf::int32 fight_num_;
  ::google::protobuf::int32 fight_num_max_;
  friend struct ::protobuf_UserMap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PlayerShip : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.PlayerShip) */ {
 public:
  PlayerShip();
  virtual ~PlayerShip();

  PlayerShip(const PlayerShip& from);

  inline PlayerShip& operator=(const PlayerShip& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayerShip(PlayerShip&& from) noexcept
    : PlayerShip() {
    *this = ::std::move(from);
  }

  inline PlayerShip& operator=(PlayerShip&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerShip& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerShip* internal_default_instance() {
    return reinterpret_cast<const PlayerShip*>(
               &_PlayerShip_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void UnsafeArenaSwap(PlayerShip* other);
  void Swap(PlayerShip* other);
  friend void swap(PlayerShip& a, PlayerShip& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayerShip* New() const final {
    return CreateMaybeMessage<PlayerShip>(NULL);
  }

  PlayerShip* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PlayerShip>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PlayerShip& from);
  void MergeFrom(const PlayerShip& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerShip* other);
  protected:
  explicit PlayerShip(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .sg.UserInfo player = 1;
  bool has_player() const;
  void clear_player();
  static const int kPlayerFieldNumber = 1;
  private:
  const ::sg::UserInfo& _internal_player() const;
  public:
  const ::sg::UserInfo& player() const;
  ::sg::UserInfo* release_player();
  ::sg::UserInfo* mutable_player();
  void set_allocated_player(::sg::UserInfo* player);
  void unsafe_arena_set_allocated_player(
      ::sg::UserInfo* player);
  ::sg::UserInfo* unsafe_arena_release_player();

  // @@protoc_insertion_point(class_scope:sg.PlayerShip)
 private:
  void set_has_player();
  void clear_has_player();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::sg::UserInfo* player_;
  friend struct ::protobuf_UserMap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MapEntry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.MapEntry) */ {
 public:
  MapEntry();
  virtual ~MapEntry();

  MapEntry(const MapEntry& from);

  inline MapEntry& operator=(const MapEntry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapEntry(MapEntry&& from) noexcept
    : MapEntry() {
    *this = ::std::move(from);
  }

  inline MapEntry& operator=(MapEntry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapEntry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapEntry* internal_default_instance() {
    return reinterpret_cast<const MapEntry*>(
               &_MapEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void UnsafeArenaSwap(MapEntry* other);
  void Swap(MapEntry* other);
  friend void swap(MapEntry& a, MapEntry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapEntry* New() const final {
    return CreateMaybeMessage<MapEntry>(NULL);
  }

  MapEntry* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MapEntry>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MapEntry& from);
  void MergeFrom(const MapEntry& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapEntry* other);
  protected:
  explicit MapEntry(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes occupier_nick = 12;
  bool has_occupier_nick() const;
  void clear_occupier_nick();
  static const int kOccupierNickFieldNumber = 12;
  const ::std::string& occupier_nick() const;
  void set_occupier_nick(const ::std::string& value);
  #if LANG_CXX11
  void set_occupier_nick(::std::string&& value);
  #endif
  void set_occupier_nick(const char* value);
  void set_occupier_nick(const void* value, size_t size);
  ::std::string* mutable_occupier_nick();
  ::std::string* release_occupier_nick();
  void set_allocated_occupier_nick(::std::string* occupier_nick);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_occupier_nick();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_occupier_nick(
      ::std::string* occupier_nick);

  // optional .sg.PirateShip pirate_ship = 41;
  bool has_pirate_ship() const;
  void clear_pirate_ship();
  static const int kPirateShipFieldNumber = 41;
  private:
  const ::sg::PirateShip& _internal_pirate_ship() const;
  public:
  const ::sg::PirateShip& pirate_ship() const;
  ::sg::PirateShip* release_pirate_ship();
  ::sg::PirateShip* mutable_pirate_ship();
  void set_allocated_pirate_ship(::sg::PirateShip* pirate_ship);
  void unsafe_arena_set_allocated_pirate_ship(
      ::sg::PirateShip* pirate_ship);
  ::sg::PirateShip* unsafe_arena_release_pirate_ship();

  // optional .sg.PlayerShip player_ship = 42;
  bool has_player_ship() const;
  void clear_player_ship();
  static const int kPlayerShipFieldNumber = 42;
  private:
  const ::sg::PlayerShip& _internal_player_ship() const;
  public:
  const ::sg::PlayerShip& player_ship() const;
  ::sg::PlayerShip* release_player_ship();
  ::sg::PlayerShip* mutable_player_ship();
  void set_allocated_player_ship(::sg::PlayerShip* player_ship);
  void unsafe_arena_set_allocated_player_ship(
      ::sg::PlayerShip* player_ship);
  ::sg::PlayerShip* unsafe_arena_release_player_ship();

  // required uint64 entryid = 1;
  bool has_entryid() const;
  void clear_entryid();
  static const int kEntryidFieldNumber = 1;
  ::google::protobuf::uint64 entryid() const;
  void set_entryid(::google::protobuf::uint64 value);

  // required .sg.MAP_ENTRY_STATE entry_state = 2;
  bool has_entry_state() const;
  void clear_entry_state();
  static const int kEntryStateFieldNumber = 2;
  ::sg::MAP_ENTRY_STATE entry_state() const;
  void set_entry_state(::sg::MAP_ENTRY_STATE value);

  // optional .sg.MAP_ENTRY_HARVEST_TYPE harvest_type = 4;
  bool has_harvest_type() const;
  void clear_harvest_type();
  static const int kHarvestTypeFieldNumber = 4;
  ::sg::MAP_ENTRY_HARVEST_TYPE harvest_type() const;
  void set_harvest_type(::sg::MAP_ENTRY_HARVEST_TYPE value);

  // optional int32 type = 5;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 5;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // optional bool passable = 3;
  bool has_passable() const;
  void clear_passable();
  static const int kPassableFieldNumber = 3;
  bool passable() const;
  void set_passable(bool value);

  // optional bool occupy_protect = 21;
  bool has_occupy_protect() const;
  void clear_occupy_protect();
  static const int kOccupyProtectFieldNumber = 21;
  bool occupy_protect() const;
  void set_occupy_protect(bool value);

  // optional uint64 occupier_uuid = 11;
  bool has_occupier_uuid() const;
  void clear_occupier_uuid();
  static const int kOccupierUuidFieldNumber = 11;
  ::google::protobuf::uint64 occupier_uuid() const;
  void set_occupier_uuid(::google::protobuf::uint64 value);

  // optional int32 occupier_level = 13;
  bool has_occupier_level() const;
  void clear_occupier_level();
  static const int kOccupierLevelFieldNumber = 13;
  ::google::protobuf::int32 occupier_level() const;
  void set_occupier_level(::google::protobuf::int32 value);

  // optional int32 occupier_exp = 14;
  bool has_occupier_exp() const;
  void clear_occupier_exp();
  static const int kOccupierExpFieldNumber = 14;
  ::google::protobuf::int32 occupier_exp() const;
  void set_occupier_exp(::google::protobuf::int32 value);

  // optional int32 occupier_rank = 15;
  bool has_occupier_rank() const;
  void clear_occupier_rank();
  static const int kOccupierRankFieldNumber = 15;
  ::google::protobuf::int32 occupier_rank() const;
  void set_occupier_rank(::google::protobuf::int32 value);

  // optional int32 occupy_protect_seconds = 23;
  bool has_occupy_protect_seconds() const;
  void clear_occupy_protect_seconds();
  static const int kOccupyProtectSecondsFieldNumber = 23;
  ::google::protobuf::int32 occupy_protect_seconds() const;
  void set_occupy_protect_seconds(::google::protobuf::int32 value);

  // optional sfixed64 occupy_protect_starttime = 22;
  bool has_occupy_protect_starttime() const;
  void clear_occupy_protect_starttime();
  static const int kOccupyProtectStarttimeFieldNumber = 22;
  ::google::protobuf::int64 occupy_protect_starttime() const;
  void set_occupy_protect_starttime(::google::protobuf::int64 value);

  // optional int32 workshop_level = 31;
  bool has_workshop_level() const;
  void clear_workshop_level();
  static const int kWorkshopLevelFieldNumber = 31;
  ::google::protobuf::int32 workshop_level() const;
  void set_workshop_level(::google::protobuf::int32 value);

  // optional .sg.WILD_ISLAND_WORKSHOP_STATE workshop_state = 32;
  bool has_workshop_state() const;
  void clear_workshop_state();
  static const int kWorkshopStateFieldNumber = 32;
  ::sg::WILD_ISLAND_WORKSHOP_STATE workshop_state() const;
  void set_workshop_state(::sg::WILD_ISLAND_WORKSHOP_STATE value);

  // optional sfixed64 refresh_time = 43;
  bool has_refresh_time() const;
  void clear_refresh_time();
  static const int kRefreshTimeFieldNumber = 43;
  ::google::protobuf::int64 refresh_time() const;
  void set_refresh_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:sg.MapEntry)
 private:
  void set_has_entryid();
  void clear_has_entryid();
  void set_has_entry_state();
  void clear_has_entry_state();
  void set_has_passable();
  void clear_has_passable();
  void set_has_harvest_type();
  void clear_has_harvest_type();
  void set_has_type();
  void clear_has_type();
  void set_has_occupier_uuid();
  void clear_has_occupier_uuid();
  void set_has_occupier_nick();
  void clear_has_occupier_nick();
  void set_has_occupier_level();
  void clear_has_occupier_level();
  void set_has_occupier_exp();
  void clear_has_occupier_exp();
  void set_has_occupier_rank();
  void clear_has_occupier_rank();
  void set_has_occupy_protect();
  void clear_has_occupy_protect();
  void set_has_occupy_protect_starttime();
  void clear_has_occupy_protect_starttime();
  void set_has_occupy_protect_seconds();
  void clear_has_occupy_protect_seconds();
  void set_has_workshop_level();
  void clear_has_workshop_level();
  void set_has_workshop_state();
  void clear_has_workshop_state();
  void set_has_pirate_ship();
  void clear_has_pirate_ship();
  void set_has_player_ship();
  void clear_has_player_ship();
  void set_has_refresh_time();
  void clear_has_refresh_time();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr occupier_nick_;
  ::sg::PirateShip* pirate_ship_;
  ::sg::PlayerShip* player_ship_;
  ::google::protobuf::uint64 entryid_;
  int entry_state_;
  int harvest_type_;
  ::google::protobuf::int32 type_;
  bool passable_;
  bool occupy_protect_;
  ::google::protobuf::uint64 occupier_uuid_;
  ::google::protobuf::int32 occupier_level_;
  ::google::protobuf::int32 occupier_exp_;
  ::google::protobuf::int32 occupier_rank_;
  ::google::protobuf::int32 occupy_protect_seconds_;
  ::google::protobuf::int64 occupy_protect_starttime_;
  ::google::protobuf::int32 workshop_level_;
  int workshop_state_;
  ::google::protobuf::int64 refresh_time_;
  friend struct ::protobuf_UserMap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MapEntryList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.MapEntryList) */ {
 public:
  MapEntryList();
  virtual ~MapEntryList();

  MapEntryList(const MapEntryList& from);

  inline MapEntryList& operator=(const MapEntryList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapEntryList(MapEntryList&& from) noexcept
    : MapEntryList() {
    *this = ::std::move(from);
  }

  inline MapEntryList& operator=(MapEntryList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapEntryList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapEntryList* internal_default_instance() {
    return reinterpret_cast<const MapEntryList*>(
               &_MapEntryList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void UnsafeArenaSwap(MapEntryList* other);
  void Swap(MapEntryList* other);
  friend void swap(MapEntryList& a, MapEntryList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapEntryList* New() const final {
    return CreateMaybeMessage<MapEntryList>(NULL);
  }

  MapEntryList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MapEntryList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MapEntryList& from);
  void MergeFrom(const MapEntryList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapEntryList* other);
  protected:
  explicit MapEntryList(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sg.MapEntry list = 1;
  int list_size() const;
  void clear_list();
  static const int kListFieldNumber = 1;
  ::sg::MapEntry* mutable_list(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::MapEntry >*
      mutable_list();
  const ::sg::MapEntry& list(int index) const;
  ::sg::MapEntry* add_list();
  const ::google::protobuf::RepeatedPtrField< ::sg::MapEntry >&
      list() const;

  // @@protoc_insertion_point(class_scope:sg.MapEntryList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::MapEntry > list_;
  friend struct ::protobuf_UserMap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OccupierData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.OccupierData) */ {
 public:
  OccupierData();
  virtual ~OccupierData();

  OccupierData(const OccupierData& from);

  inline OccupierData& operator=(const OccupierData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OccupierData(OccupierData&& from) noexcept
    : OccupierData() {
    *this = ::std::move(from);
  }

  inline OccupierData& operator=(OccupierData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const OccupierData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OccupierData* internal_default_instance() {
    return reinterpret_cast<const OccupierData*>(
               &_OccupierData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void UnsafeArenaSwap(OccupierData* other);
  void Swap(OccupierData* other);
  friend void swap(OccupierData& a, OccupierData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OccupierData* New() const final {
    return CreateMaybeMessage<OccupierData>(NULL);
  }

  OccupierData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OccupierData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OccupierData& from);
  void MergeFrom(const OccupierData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OccupierData* other);
  protected:
  explicit OccupierData(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes nick = 2;
  bool has_nick() const;
  void clear_nick();
  static const int kNickFieldNumber = 2;
  const ::std::string& nick() const;
  void set_nick(const ::std::string& value);
  #if LANG_CXX11
  void set_nick(::std::string&& value);
  #endif
  void set_nick(const char* value);
  void set_nick(const void* value, size_t size);
  ::std::string* mutable_nick();
  ::std::string* release_nick();
  void set_allocated_nick(::std::string* nick);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_nick();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_nick(
      ::std::string* nick);

  // required uint64 uuid = 1;
  bool has_uuid() const;
  void clear_uuid();
  static const int kUuidFieldNumber = 1;
  ::google::protobuf::uint64 uuid() const;
  void set_uuid(::google::protobuf::uint64 value);

  // optional int32 level = 3;
  bool has_level() const;
  void clear_level();
  static const int kLevelFieldNumber = 3;
  ::google::protobuf::int32 level() const;
  void set_level(::google::protobuf::int32 value);

  // optional int32 rank = 4;
  bool has_rank() const;
  void clear_rank();
  static const int kRankFieldNumber = 4;
  ::google::protobuf::int32 rank() const;
  void set_rank(::google::protobuf::int32 value);

  // optional sfixed64 occupy_time = 5;
  bool has_occupy_time() const;
  void clear_occupy_time();
  static const int kOccupyTimeFieldNumber = 5;
  ::google::protobuf::int64 occupy_time() const;
  void set_occupy_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:sg.OccupierData)
 private:
  void set_has_uuid();
  void clear_has_uuid();
  void set_has_nick();
  void clear_has_nick();
  void set_has_level();
  void clear_has_level();
  void set_has_rank();
  void clear_has_rank();
  void set_has_occupy_time();
  void clear_has_occupy_time();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr nick_;
  ::google::protobuf::uint64 uuid_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 rank_;
  ::google::protobuf::int64 occupy_time_;
  friend struct ::protobuf_UserMap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WildIsland_Workshop : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.WildIsland.Workshop) */ {
 public:
  WildIsland_Workshop();
  virtual ~WildIsland_Workshop();

  WildIsland_Workshop(const WildIsland_Workshop& from);

  inline WildIsland_Workshop& operator=(const WildIsland_Workshop& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WildIsland_Workshop(WildIsland_Workshop&& from) noexcept
    : WildIsland_Workshop() {
    *this = ::std::move(from);
  }

  inline WildIsland_Workshop& operator=(WildIsland_Workshop&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const WildIsland_Workshop& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WildIsland_Workshop* internal_default_instance() {
    return reinterpret_cast<const WildIsland_Workshop*>(
               &_WildIsland_Workshop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void UnsafeArenaSwap(WildIsland_Workshop* other);
  void Swap(WildIsland_Workshop* other);
  friend void swap(WildIsland_Workshop& a, WildIsland_Workshop& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WildIsland_Workshop* New() const final {
    return CreateMaybeMessage<WildIsland_Workshop>(NULL);
  }

  WildIsland_Workshop* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WildIsland_Workshop>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WildIsland_Workshop& from);
  void MergeFrom(const WildIsland_Workshop& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WildIsland_Workshop* other);
  protected:
  explicit WildIsland_Workshop(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 level = 1;
  bool has_level() const;
  void clear_level();
  static const int kLevelFieldNumber = 1;
  ::google::protobuf::int32 level() const;
  void set_level(::google::protobuf::int32 value);

  // required .sg.WILD_ISLAND_WORKSHOP_STATE state = 2;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 2;
  ::sg::WILD_ISLAND_WORKSHOP_STATE state() const;
  void set_state(::sg::WILD_ISLAND_WORKSHOP_STATE value);

  // required float gather_per_min = 3;
  bool has_gather_per_min() const;
  void clear_gather_per_min();
  static const int kGatherPerMinFieldNumber = 3;
  float gather_per_min() const;
  void set_gather_per_min(float value);

  // required float gather_add_ratio = 4;
  bool has_gather_add_ratio() const;
  void clear_gather_add_ratio();
  static const int kGatherAddRatioFieldNumber = 4;
  float gather_add_ratio() const;
  void set_gather_add_ratio(float value);

  // required sfixed64 gather_time = 5;
  bool has_gather_time() const;
  void clear_gather_time();
  static const int kGatherTimeFieldNumber = 5;
  ::google::protobuf::int64 gather_time() const;
  void set_gather_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:sg.WildIsland.Workshop)
 private:
  void set_has_level();
  void clear_has_level();
  void set_has_state();
  void clear_has_state();
  void set_has_gather_per_min();
  void clear_has_gather_per_min();
  void set_has_gather_add_ratio();
  void clear_has_gather_add_ratio();
  void set_has_gather_time();
  void clear_has_gather_time();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 level_;
  int state_;
  float gather_per_min_;
  float gather_add_ratio_;
  ::google::protobuf::int64 gather_time_;
  friend struct ::protobuf_UserMap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WildIsland_WorkshopOption : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.WildIsland.WorkshopOption) */ {
 public:
  WildIsland_WorkshopOption();
  virtual ~WildIsland_WorkshopOption();

  WildIsland_WorkshopOption(const WildIsland_WorkshopOption& from);

  inline WildIsland_WorkshopOption& operator=(const WildIsland_WorkshopOption& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WildIsland_WorkshopOption(WildIsland_WorkshopOption&& from) noexcept
    : WildIsland_WorkshopOption() {
    *this = ::std::move(from);
  }

  inline WildIsland_WorkshopOption& operator=(WildIsland_WorkshopOption&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const WildIsland_WorkshopOption& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WildIsland_WorkshopOption* internal_default_instance() {
    return reinterpret_cast<const WildIsland_WorkshopOption*>(
               &_WildIsland_WorkshopOption_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void UnsafeArenaSwap(WildIsland_WorkshopOption* other);
  void Swap(WildIsland_WorkshopOption* other);
  friend void swap(WildIsland_WorkshopOption& a, WildIsland_WorkshopOption& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WildIsland_WorkshopOption* New() const final {
    return CreateMaybeMessage<WildIsland_WorkshopOption>(NULL);
  }

  WildIsland_WorkshopOption* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WildIsland_WorkshopOption>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WildIsland_WorkshopOption& from);
  void MergeFrom(const WildIsland_WorkshopOption& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WildIsland_WorkshopOption* other);
  protected:
  explicit WildIsland_WorkshopOption(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float gather_per_min = 1;
  bool has_gather_per_min() const;
  void clear_gather_per_min();
  static const int kGatherPerMinFieldNumber = 1;
  float gather_per_min() const;
  void set_gather_per_min(float value);

  // @@protoc_insertion_point(class_scope:sg.WildIsland.WorkshopOption)
 private:
  void set_has_gather_per_min();
  void clear_has_gather_per_min();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float gather_per_min_;
  friend struct ::protobuf_UserMap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WildIsland : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.WildIsland) */ {
 public:
  WildIsland();
  virtual ~WildIsland();

  WildIsland(const WildIsland& from);

  inline WildIsland& operator=(const WildIsland& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WildIsland(WildIsland&& from) noexcept
    : WildIsland() {
    *this = ::std::move(from);
  }

  inline WildIsland& operator=(WildIsland&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const WildIsland& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WildIsland* internal_default_instance() {
    return reinterpret_cast<const WildIsland*>(
               &_WildIsland_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void UnsafeArenaSwap(WildIsland* other);
  void Swap(WildIsland* other);
  friend void swap(WildIsland& a, WildIsland& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WildIsland* New() const final {
    return CreateMaybeMessage<WildIsland>(NULL);
  }

  WildIsland* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WildIsland>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WildIsland& from);
  void MergeFrom(const WildIsland& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WildIsland* other);
  protected:
  explicit WildIsland(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef WildIsland_Workshop Workshop;
  typedef WildIsland_WorkshopOption WorkshopOption;

  // accessors -------------------------------------------------------

  // optional bytes map_data = 12;
  bool has_map_data() const;
  void clear_map_data();
  static const int kMapDataFieldNumber = 12;
  const ::std::string& map_data() const;
  void set_map_data(const ::std::string& value);
  #if LANG_CXX11
  void set_map_data(::std::string&& value);
  #endif
  void set_map_data(const char* value);
  void set_map_data(const void* value, size_t size);
  ::std::string* mutable_map_data();
  ::std::string* release_map_data();
  void set_allocated_map_data(::std::string* map_data);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_map_data();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_map_data(
      ::std::string* map_data);

  // required .sg.OccupierData occupier_data = 4;
  bool has_occupier_data() const;
  void clear_occupier_data();
  static const int kOccupierDataFieldNumber = 4;
  private:
  const ::sg::OccupierData& _internal_occupier_data() const;
  public:
  const ::sg::OccupierData& occupier_data() const;
  ::sg::OccupierData* release_occupier_data();
  ::sg::OccupierData* mutable_occupier_data();
  void set_allocated_occupier_data(::sg::OccupierData* occupier_data);
  void unsafe_arena_set_allocated_occupier_data(
      ::sg::OccupierData* occupier_data);
  ::sg::OccupierData* unsafe_arena_release_occupier_data();

  // optional .sg.WildIsland.Workshop workshop = 11;
  bool has_workshop() const;
  void clear_workshop();
  static const int kWorkshopFieldNumber = 11;
  private:
  const ::sg::WildIsland_Workshop& _internal_workshop() const;
  public:
  const ::sg::WildIsland_Workshop& workshop() const;
  ::sg::WildIsland_Workshop* release_workshop();
  ::sg::WildIsland_Workshop* mutable_workshop();
  void set_allocated_workshop(::sg::WildIsland_Workshop* workshop);
  void unsafe_arena_set_allocated_workshop(
      ::sg::WildIsland_Workshop* workshop);
  ::sg::WildIsland_Workshop* unsafe_arena_release_workshop();

  // required uint64 entryid = 1;
  bool has_entryid() const;
  void clear_entryid();
  static const int kEntryidFieldNumber = 1;
  ::google::protobuf::uint64 entryid() const;
  void set_entryid(::google::protobuf::uint64 value);

  // required int32 island_cfgid = 2;
  bool has_island_cfgid() const;
  void clear_island_cfgid();
  static const int kIslandCfgidFieldNumber = 2;
  ::google::protobuf::int32 island_cfgid() const;
  void set_island_cfgid(::google::protobuf::int32 value);

  // required .sg.WILD_ISLAND_STATE island_state = 3;
  bool has_island_state() const;
  void clear_island_state();
  static const int kIslandStateFieldNumber = 3;
  ::sg::WILD_ISLAND_STATE island_state() const;
  void set_island_state(::sg::WILD_ISLAND_STATE value);

  // @@protoc_insertion_point(class_scope:sg.WildIsland)
 private:
  void set_has_entryid();
  void clear_has_entryid();
  void set_has_island_cfgid();
  void clear_has_island_cfgid();
  void set_has_island_state();
  void clear_has_island_state();
  void set_has_occupier_data();
  void clear_has_occupier_data();
  void set_has_workshop();
  void clear_has_workshop();
  void set_has_map_data();
  void clear_has_map_data();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr map_data_;
  ::sg::OccupierData* occupier_data_;
  ::sg::WildIsland_Workshop* workshop_;
  ::google::protobuf::uint64 entryid_;
  ::google::protobuf::int32 island_cfgid_;
  int island_state_;
  friend struct ::protobuf_UserMap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WildIslandList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.WildIslandList) */ {
 public:
  WildIslandList();
  virtual ~WildIslandList();

  WildIslandList(const WildIslandList& from);

  inline WildIslandList& operator=(const WildIslandList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WildIslandList(WildIslandList&& from) noexcept
    : WildIslandList() {
    *this = ::std::move(from);
  }

  inline WildIslandList& operator=(WildIslandList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const WildIslandList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WildIslandList* internal_default_instance() {
    return reinterpret_cast<const WildIslandList*>(
               &_WildIslandList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void UnsafeArenaSwap(WildIslandList* other);
  void Swap(WildIslandList* other);
  friend void swap(WildIslandList& a, WildIslandList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WildIslandList* New() const final {
    return CreateMaybeMessage<WildIslandList>(NULL);
  }

  WildIslandList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WildIslandList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WildIslandList& from);
  void MergeFrom(const WildIslandList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WildIslandList* other);
  protected:
  explicit WildIslandList(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sg.WildIsland list = 1;
  int list_size() const;
  void clear_list();
  static const int kListFieldNumber = 1;
  ::sg::WildIsland* mutable_list(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::WildIsland >*
      mutable_list();
  const ::sg::WildIsland& list(int index) const;
  ::sg::WildIsland* add_list();
  const ::google::protobuf::RepeatedPtrField< ::sg::WildIsland >&
      list() const;

  // @@protoc_insertion_point(class_scope:sg.WildIslandList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::WildIsland > list_;
  friend struct ::protobuf_UserMap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WildIslandHarvestLog_HarvestItem : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.WildIslandHarvestLog.HarvestItem) */ {
 public:
  WildIslandHarvestLog_HarvestItem();
  virtual ~WildIslandHarvestLog_HarvestItem();

  WildIslandHarvestLog_HarvestItem(const WildIslandHarvestLog_HarvestItem& from);

  inline WildIslandHarvestLog_HarvestItem& operator=(const WildIslandHarvestLog_HarvestItem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WildIslandHarvestLog_HarvestItem(WildIslandHarvestLog_HarvestItem&& from) noexcept
    : WildIslandHarvestLog_HarvestItem() {
    *this = ::std::move(from);
  }

  inline WildIslandHarvestLog_HarvestItem& operator=(WildIslandHarvestLog_HarvestItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const WildIslandHarvestLog_HarvestItem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WildIslandHarvestLog_HarvestItem* internal_default_instance() {
    return reinterpret_cast<const WildIslandHarvestLog_HarvestItem*>(
               &_WildIslandHarvestLog_HarvestItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void UnsafeArenaSwap(WildIslandHarvestLog_HarvestItem* other);
  void Swap(WildIslandHarvestLog_HarvestItem* other);
  friend void swap(WildIslandHarvestLog_HarvestItem& a, WildIslandHarvestLog_HarvestItem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WildIslandHarvestLog_HarvestItem* New() const final {
    return CreateMaybeMessage<WildIslandHarvestLog_HarvestItem>(NULL);
  }

  WildIslandHarvestLog_HarvestItem* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WildIslandHarvestLog_HarvestItem>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WildIslandHarvestLog_HarvestItem& from);
  void MergeFrom(const WildIslandHarvestLog_HarvestItem& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WildIslandHarvestLog_HarvestItem* other);
  protected:
  explicit WildIslandHarvestLog_HarvestItem(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 item_type = 1;
  bool has_item_type() const;
  void clear_item_type();
  static const int kItemTypeFieldNumber = 1;
  ::google::protobuf::int32 item_type() const;
  void set_item_type(::google::protobuf::int32 value);

  // required int32 item_num = 2;
  bool has_item_num() const;
  void clear_item_num();
  static const int kItemNumFieldNumber = 2;
  ::google::protobuf::int32 item_num() const;
  void set_item_num(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.WildIslandHarvestLog.HarvestItem)
 private:
  void set_has_item_type();
  void clear_has_item_type();
  void set_has_item_num();
  void clear_has_item_num();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 item_type_;
  ::google::protobuf::int32 item_num_;
  friend struct ::protobuf_UserMap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WildIslandHarvestLog_HarvestItemList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.WildIslandHarvestLog.HarvestItemList) */ {
 public:
  WildIslandHarvestLog_HarvestItemList();
  virtual ~WildIslandHarvestLog_HarvestItemList();

  WildIslandHarvestLog_HarvestItemList(const WildIslandHarvestLog_HarvestItemList& from);

  inline WildIslandHarvestLog_HarvestItemList& operator=(const WildIslandHarvestLog_HarvestItemList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WildIslandHarvestLog_HarvestItemList(WildIslandHarvestLog_HarvestItemList&& from) noexcept
    : WildIslandHarvestLog_HarvestItemList() {
    *this = ::std::move(from);
  }

  inline WildIslandHarvestLog_HarvestItemList& operator=(WildIslandHarvestLog_HarvestItemList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const WildIslandHarvestLog_HarvestItemList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WildIslandHarvestLog_HarvestItemList* internal_default_instance() {
    return reinterpret_cast<const WildIslandHarvestLog_HarvestItemList*>(
               &_WildIslandHarvestLog_HarvestItemList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void UnsafeArenaSwap(WildIslandHarvestLog_HarvestItemList* other);
  void Swap(WildIslandHarvestLog_HarvestItemList* other);
  friend void swap(WildIslandHarvestLog_HarvestItemList& a, WildIslandHarvestLog_HarvestItemList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WildIslandHarvestLog_HarvestItemList* New() const final {
    return CreateMaybeMessage<WildIslandHarvestLog_HarvestItemList>(NULL);
  }

  WildIslandHarvestLog_HarvestItemList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WildIslandHarvestLog_HarvestItemList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WildIslandHarvestLog_HarvestItemList& from);
  void MergeFrom(const WildIslandHarvestLog_HarvestItemList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WildIslandHarvestLog_HarvestItemList* other);
  protected:
  explicit WildIslandHarvestLog_HarvestItemList(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sg.WildIslandHarvestLog.HarvestItem list = 1;
  int list_size() const;
  void clear_list();
  static const int kListFieldNumber = 1;
  ::sg::WildIslandHarvestLog_HarvestItem* mutable_list(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::WildIslandHarvestLog_HarvestItem >*
      mutable_list();
  const ::sg::WildIslandHarvestLog_HarvestItem& list(int index) const;
  ::sg::WildIslandHarvestLog_HarvestItem* add_list();
  const ::google::protobuf::RepeatedPtrField< ::sg::WildIslandHarvestLog_HarvestItem >&
      list() const;

  // @@protoc_insertion_point(class_scope:sg.WildIslandHarvestLog.HarvestItemList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::WildIslandHarvestLog_HarvestItem > list_;
  friend struct ::protobuf_UserMap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WildIslandHarvestLog_HarvestLog : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.WildIslandHarvestLog.HarvestLog) */ {
 public:
  WildIslandHarvestLog_HarvestLog();
  virtual ~WildIslandHarvestLog_HarvestLog();

  WildIslandHarvestLog_HarvestLog(const WildIslandHarvestLog_HarvestLog& from);

  inline WildIslandHarvestLog_HarvestLog& operator=(const WildIslandHarvestLog_HarvestLog& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WildIslandHarvestLog_HarvestLog(WildIslandHarvestLog_HarvestLog&& from) noexcept
    : WildIslandHarvestLog_HarvestLog() {
    *this = ::std::move(from);
  }

  inline WildIslandHarvestLog_HarvestLog& operator=(WildIslandHarvestLog_HarvestLog&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const WildIslandHarvestLog_HarvestLog& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WildIslandHarvestLog_HarvestLog* internal_default_instance() {
    return reinterpret_cast<const WildIslandHarvestLog_HarvestLog*>(
               &_WildIslandHarvestLog_HarvestLog_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void UnsafeArenaSwap(WildIslandHarvestLog_HarvestLog* other);
  void Swap(WildIslandHarvestLog_HarvestLog* other);
  friend void swap(WildIslandHarvestLog_HarvestLog& a, WildIslandHarvestLog_HarvestLog& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WildIslandHarvestLog_HarvestLog* New() const final {
    return CreateMaybeMessage<WildIslandHarvestLog_HarvestLog>(NULL);
  }

  WildIslandHarvestLog_HarvestLog* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WildIslandHarvestLog_HarvestLog>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WildIslandHarvestLog_HarvestLog& from);
  void MergeFrom(const WildIslandHarvestLog_HarvestLog& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WildIslandHarvestLog_HarvestLog* other);
  protected:
  explicit WildIslandHarvestLog_HarvestLog(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .sg.WildIslandHarvestLog.HarvestItemList item_list = 2;
  bool has_item_list() const;
  void clear_item_list();
  static const int kItemListFieldNumber = 2;
  private:
  const ::sg::WildIslandHarvestLog_HarvestItemList& _internal_item_list() const;
  public:
  const ::sg::WildIslandHarvestLog_HarvestItemList& item_list() const;
  ::sg::WildIslandHarvestLog_HarvestItemList* release_item_list();
  ::sg::WildIslandHarvestLog_HarvestItemList* mutable_item_list();
  void set_allocated_item_list(::sg::WildIslandHarvestLog_HarvestItemList* item_list);
  void unsafe_arena_set_allocated_item_list(
      ::sg::WildIslandHarvestLog_HarvestItemList* item_list);
  ::sg::WildIslandHarvestLog_HarvestItemList* unsafe_arena_release_item_list();

  // optional sfixed64 harvest_time = 1;
  bool has_harvest_time() const;
  void clear_harvest_time();
  static const int kHarvestTimeFieldNumber = 1;
  ::google::protobuf::int64 harvest_time() const;
  void set_harvest_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:sg.WildIslandHarvestLog.HarvestLog)
 private:
  void set_has_harvest_time();
  void clear_has_harvest_time();
  void set_has_item_list();
  void clear_has_item_list();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::sg::WildIslandHarvestLog_HarvestItemList* item_list_;
  ::google::protobuf::int64 harvest_time_;
  friend struct ::protobuf_UserMap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WildIslandHarvestLog_HarvestLogList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.WildIslandHarvestLog.HarvestLogList) */ {
 public:
  WildIslandHarvestLog_HarvestLogList();
  virtual ~WildIslandHarvestLog_HarvestLogList();

  WildIslandHarvestLog_HarvestLogList(const WildIslandHarvestLog_HarvestLogList& from);

  inline WildIslandHarvestLog_HarvestLogList& operator=(const WildIslandHarvestLog_HarvestLogList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WildIslandHarvestLog_HarvestLogList(WildIslandHarvestLog_HarvestLogList&& from) noexcept
    : WildIslandHarvestLog_HarvestLogList() {
    *this = ::std::move(from);
  }

  inline WildIslandHarvestLog_HarvestLogList& operator=(WildIslandHarvestLog_HarvestLogList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const WildIslandHarvestLog_HarvestLogList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WildIslandHarvestLog_HarvestLogList* internal_default_instance() {
    return reinterpret_cast<const WildIslandHarvestLog_HarvestLogList*>(
               &_WildIslandHarvestLog_HarvestLogList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void UnsafeArenaSwap(WildIslandHarvestLog_HarvestLogList* other);
  void Swap(WildIslandHarvestLog_HarvestLogList* other);
  friend void swap(WildIslandHarvestLog_HarvestLogList& a, WildIslandHarvestLog_HarvestLogList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WildIslandHarvestLog_HarvestLogList* New() const final {
    return CreateMaybeMessage<WildIslandHarvestLog_HarvestLogList>(NULL);
  }

  WildIslandHarvestLog_HarvestLogList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WildIslandHarvestLog_HarvestLogList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WildIslandHarvestLog_HarvestLogList& from);
  void MergeFrom(const WildIslandHarvestLog_HarvestLogList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WildIslandHarvestLog_HarvestLogList* other);
  protected:
  explicit WildIslandHarvestLog_HarvestLogList(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sg.WildIslandHarvestLog.HarvestLog list = 1;
  int list_size() const;
  void clear_list();
  static const int kListFieldNumber = 1;
  ::sg::WildIslandHarvestLog_HarvestLog* mutable_list(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::WildIslandHarvestLog_HarvestLog >*
      mutable_list();
  const ::sg::WildIslandHarvestLog_HarvestLog& list(int index) const;
  ::sg::WildIslandHarvestLog_HarvestLog* add_list();
  const ::google::protobuf::RepeatedPtrField< ::sg::WildIslandHarvestLog_HarvestLog >&
      list() const;

  // @@protoc_insertion_point(class_scope:sg.WildIslandHarvestLog.HarvestLogList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::WildIslandHarvestLog_HarvestLog > list_;
  friend struct ::protobuf_UserMap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WildIslandHarvestLog : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.WildIslandHarvestLog) */ {
 public:
  WildIslandHarvestLog();
  virtual ~WildIslandHarvestLog();

  WildIslandHarvestLog(const WildIslandHarvestLog& from);

  inline WildIslandHarvestLog& operator=(const WildIslandHarvestLog& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WildIslandHarvestLog(WildIslandHarvestLog&& from) noexcept
    : WildIslandHarvestLog() {
    *this = ::std::move(from);
  }

  inline WildIslandHarvestLog& operator=(WildIslandHarvestLog&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const WildIslandHarvestLog& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WildIslandHarvestLog* internal_default_instance() {
    return reinterpret_cast<const WildIslandHarvestLog*>(
               &_WildIslandHarvestLog_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void UnsafeArenaSwap(WildIslandHarvestLog* other);
  void Swap(WildIslandHarvestLog* other);
  friend void swap(WildIslandHarvestLog& a, WildIslandHarvestLog& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WildIslandHarvestLog* New() const final {
    return CreateMaybeMessage<WildIslandHarvestLog>(NULL);
  }

  WildIslandHarvestLog* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WildIslandHarvestLog>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WildIslandHarvestLog& from);
  void MergeFrom(const WildIslandHarvestLog& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WildIslandHarvestLog* other);
  protected:
  explicit WildIslandHarvestLog(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef WildIslandHarvestLog_HarvestItem HarvestItem;
  typedef WildIslandHarvestLog_HarvestItemList HarvestItemList;
  typedef WildIslandHarvestLog_HarvestLog HarvestLog;
  typedef WildIslandHarvestLog_HarvestLogList HarvestLogList;

  // accessors -------------------------------------------------------

  // optional .sg.WildIslandHarvestLog.HarvestLogList harvest_log_list = 1;
  bool has_harvest_log_list() const;
  void clear_harvest_log_list();
  static const int kHarvestLogListFieldNumber = 1;
  private:
  const ::sg::WildIslandHarvestLog_HarvestLogList& _internal_harvest_log_list() const;
  public:
  const ::sg::WildIslandHarvestLog_HarvestLogList& harvest_log_list() const;
  ::sg::WildIslandHarvestLog_HarvestLogList* release_harvest_log_list();
  ::sg::WildIslandHarvestLog_HarvestLogList* mutable_harvest_log_list();
  void set_allocated_harvest_log_list(::sg::WildIslandHarvestLog_HarvestLogList* harvest_log_list);
  void unsafe_arena_set_allocated_harvest_log_list(
      ::sg::WildIslandHarvestLog_HarvestLogList* harvest_log_list);
  ::sg::WildIslandHarvestLog_HarvestLogList* unsafe_arena_release_harvest_log_list();

  // @@protoc_insertion_point(class_scope:sg.WildIslandHarvestLog)
 private:
  void set_has_harvest_log_list();
  void clear_has_harvest_log_list();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::sg::WildIslandHarvestLog_HarvestLogList* harvest_log_list_;
  friend struct ::protobuf_UserMap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HarvestTime : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.HarvestTime) */ {
 public:
  HarvestTime();
  virtual ~HarvestTime();

  HarvestTime(const HarvestTime& from);

  inline HarvestTime& operator=(const HarvestTime& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HarvestTime(HarvestTime&& from) noexcept
    : HarvestTime() {
    *this = ::std::move(from);
  }

  inline HarvestTime& operator=(HarvestTime&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const HarvestTime& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HarvestTime* internal_default_instance() {
    return reinterpret_cast<const HarvestTime*>(
               &_HarvestTime_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void UnsafeArenaSwap(HarvestTime* other);
  void Swap(HarvestTime* other);
  friend void swap(HarvestTime& a, HarvestTime& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HarvestTime* New() const final {
    return CreateMaybeMessage<HarvestTime>(NULL);
  }

  HarvestTime* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HarvestTime>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HarvestTime& from);
  void MergeFrom(const HarvestTime& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HarvestTime* other);
  protected:
  explicit HarvestTime(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required sfixed64 harvest_time = 2;
  bool has_harvest_time() const;
  void clear_harvest_time();
  static const int kHarvestTimeFieldNumber = 2;
  ::google::protobuf::int64 harvest_time() const;
  void set_harvest_time(::google::protobuf::int64 value);

  // required .sg.MAP_ENTRY_HARVEST_TYPE harvest_type = 1;
  bool has_harvest_type() const;
  void clear_harvest_type();
  static const int kHarvestTypeFieldNumber = 1;
  ::sg::MAP_ENTRY_HARVEST_TYPE harvest_type() const;
  void set_harvest_type(::sg::MAP_ENTRY_HARVEST_TYPE value);

  // @@protoc_insertion_point(class_scope:sg.HarvestTime)
 private:
  void set_has_harvest_type();
  void clear_has_harvest_type();
  void set_has_harvest_time();
  void clear_has_harvest_time();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int64 harvest_time_;
  int harvest_type_;
  friend struct ::protobuf_UserMap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GarrisonRoom : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.GarrisonRoom) */ {
 public:
  GarrisonRoom();
  virtual ~GarrisonRoom();

  GarrisonRoom(const GarrisonRoom& from);

  inline GarrisonRoom& operator=(const GarrisonRoom& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GarrisonRoom(GarrisonRoom&& from) noexcept
    : GarrisonRoom() {
    *this = ::std::move(from);
  }

  inline GarrisonRoom& operator=(GarrisonRoom&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const GarrisonRoom& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GarrisonRoom* internal_default_instance() {
    return reinterpret_cast<const GarrisonRoom*>(
               &_GarrisonRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void UnsafeArenaSwap(GarrisonRoom* other);
  void Swap(GarrisonRoom* other);
  friend void swap(GarrisonRoom& a, GarrisonRoom& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GarrisonRoom* New() const final {
    return CreateMaybeMessage<GarrisonRoom>(NULL);
  }

  GarrisonRoom* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GarrisonRoom>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GarrisonRoom& from);
  void MergeFrom(const GarrisonRoom& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GarrisonRoom* other);
  protected:
  explicit GarrisonRoom(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 garrison_list = 2;
  int garrison_list_size() const;
  void clear_garrison_list();
  static const int kGarrisonListFieldNumber = 2;
  ::google::protobuf::int32 garrison_list(int index) const;
  void set_garrison_list(int index, ::google::protobuf::int32 value);
  void add_garrison_list(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      garrison_list() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_garrison_list();

  // required int32 roomid = 1;
  bool has_roomid() const;
  void clear_roomid();
  static const int kRoomidFieldNumber = 1;
  ::google::protobuf::int32 roomid() const;
  void set_roomid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.GarrisonRoom)
 private:
  void set_has_roomid();
  void clear_has_roomid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > garrison_list_;
  ::google::protobuf::int32 roomid_;
  friend struct ::protobuf_UserMap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserMapService_MapRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.UserMapService.MapRequest) */ {
 public:
  UserMapService_MapRequest();
  virtual ~UserMapService_MapRequest();

  UserMapService_MapRequest(const UserMapService_MapRequest& from);

  inline UserMapService_MapRequest& operator=(const UserMapService_MapRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserMapService_MapRequest(UserMapService_MapRequest&& from) noexcept
    : UserMapService_MapRequest() {
    *this = ::std::move(from);
  }

  inline UserMapService_MapRequest& operator=(UserMapService_MapRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserMapService_MapRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserMapService_MapRequest* internal_default_instance() {
    return reinterpret_cast<const UserMapService_MapRequest*>(
               &_UserMapService_MapRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void UnsafeArenaSwap(UserMapService_MapRequest* other);
  void Swap(UserMapService_MapRequest* other);
  friend void swap(UserMapService_MapRequest& a, UserMapService_MapRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserMapService_MapRequest* New() const final {
    return CreateMaybeMessage<UserMapService_MapRequest>(NULL);
  }

  UserMapService_MapRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserMapService_MapRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserMapService_MapRequest& from);
  void MergeFrom(const UserMapService_MapRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserMapService_MapRequest* other);
  protected:
  explicit UserMapService_MapRequest(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .sg.GarrisonRoom garrison_room = 4;
  bool has_garrison_room() const;
  void clear_garrison_room();
  static const int kGarrisonRoomFieldNumber = 4;
  private:
  const ::sg::GarrisonRoom& _internal_garrison_room() const;
  public:
  const ::sg::GarrisonRoom& garrison_room() const;
  ::sg::GarrisonRoom* release_garrison_room();
  ::sg::GarrisonRoom* mutable_garrison_room();
  void set_allocated_garrison_room(::sg::GarrisonRoom* garrison_room);
  void unsafe_arena_set_allocated_garrison_room(
      ::sg::GarrisonRoom* garrison_room);
  ::sg::GarrisonRoom* unsafe_arena_release_garrison_room();

  // optional uint64 entryid = 3;
  bool has_entryid() const;
  void clear_entryid();
  static const int kEntryidFieldNumber = 3;
  ::google::protobuf::uint64 entryid() const;
  void set_entryid(::google::protobuf::uint64 value);

  // optional int32 areaid = 2;
  bool has_areaid() const;
  void clear_areaid();
  static const int kAreaidFieldNumber = 2;
  ::google::protobuf::int32 areaid() const;
  void set_areaid(::google::protobuf::int32 value);

  // optional .sg.MAP_ENTRY_HARVEST_TYPE harvest_type = 5;
  bool has_harvest_type() const;
  void clear_harvest_type();
  static const int kHarvestTypeFieldNumber = 5;
  ::sg::MAP_ENTRY_HARVEST_TYPE harvest_type() const;
  void set_harvest_type(::sg::MAP_ENTRY_HARVEST_TYPE value);

  // required .sg.UserMapService.MAP_COMMAND cmd = 1;
  bool has_cmd() const;
  void clear_cmd();
  static const int kCmdFieldNumber = 1;
  ::sg::UserMapService_MAP_COMMAND cmd() const;
  void set_cmd(::sg::UserMapService_MAP_COMMAND value);

  // @@protoc_insertion_point(class_scope:sg.UserMapService.MapRequest)
 private:
  void set_has_cmd();
  void clear_has_cmd();
  void set_has_areaid();
  void clear_has_areaid();
  void set_has_entryid();
  void clear_has_entryid();
  void set_has_garrison_room();
  void clear_has_garrison_room();
  void set_has_harvest_type();
  void clear_has_harvest_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::sg::GarrisonRoom* garrison_room_;
  ::google::protobuf::uint64 entryid_;
  ::google::protobuf::int32 areaid_;
  int harvest_type_;
  int cmd_;
  friend struct ::protobuf_UserMap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserMapService_MapResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.UserMapService.MapResponse) */ {
 public:
  UserMapService_MapResponse();
  virtual ~UserMapService_MapResponse();

  UserMapService_MapResponse(const UserMapService_MapResponse& from);

  inline UserMapService_MapResponse& operator=(const UserMapService_MapResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserMapService_MapResponse(UserMapService_MapResponse&& from) noexcept
    : UserMapService_MapResponse() {
    *this = ::std::move(from);
  }

  inline UserMapService_MapResponse& operator=(UserMapService_MapResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserMapService_MapResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserMapService_MapResponse* internal_default_instance() {
    return reinterpret_cast<const UserMapService_MapResponse*>(
               &_UserMapService_MapResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void UnsafeArenaSwap(UserMapService_MapResponse* other);
  void Swap(UserMapService_MapResponse* other);
  friend void swap(UserMapService_MapResponse& a, UserMapService_MapResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserMapService_MapResponse* New() const final {
    return CreateMaybeMessage<UserMapService_MapResponse>(NULL);
  }

  UserMapService_MapResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserMapService_MapResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserMapService_MapResponse& from);
  void MergeFrom(const UserMapService_MapResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserMapService_MapResponse* other);
  protected:
  explicit UserMapService_MapResponse(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sg.HarvestTime harvest_time = 12;
  int harvest_time_size() const;
  void clear_harvest_time();
  static const int kHarvestTimeFieldNumber = 12;
  ::sg::HarvestTime* mutable_harvest_time(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::HarvestTime >*
      mutable_harvest_time();
  const ::sg::HarvestTime& harvest_time(int index) const;
  ::sg::HarvestTime* add_harvest_time();
  const ::google::protobuf::RepeatedPtrField< ::sg::HarvestTime >&
      harvest_time() const;

  // optional .sg.MapAreaList area_list = 2;
  bool has_area_list() const;
  void clear_area_list();
  static const int kAreaListFieldNumber = 2;
  private:
  const ::sg::MapAreaList& _internal_area_list() const;
  public:
  const ::sg::MapAreaList& area_list() const;
  ::sg::MapAreaList* release_area_list();
  ::sg::MapAreaList* mutable_area_list();
  void set_allocated_area_list(::sg::MapAreaList* area_list);
  void unsafe_arena_set_allocated_area_list(
      ::sg::MapAreaList* area_list);
  ::sg::MapAreaList* unsafe_arena_release_area_list();

  // optional .sg.MapEntryList entry_list = 3;
  bool has_entry_list() const;
  void clear_entry_list();
  static const int kEntryListFieldNumber = 3;
  private:
  const ::sg::MapEntryList& _internal_entry_list() const;
  public:
  const ::sg::MapEntryList& entry_list() const;
  ::sg::MapEntryList* release_entry_list();
  ::sg::MapEntryList* mutable_entry_list();
  void set_allocated_entry_list(::sg::MapEntryList* entry_list);
  void unsafe_arena_set_allocated_entry_list(
      ::sg::MapEntryList* entry_list);
  ::sg::MapEntryList* unsafe_arena_release_entry_list();

  // optional .sg.WildIslandList island_list = 4;
  bool has_island_list() const;
  void clear_island_list();
  static const int kIslandListFieldNumber = 4;
  private:
  const ::sg::WildIslandList& _internal_island_list() const;
  public:
  const ::sg::WildIslandList& island_list() const;
  ::sg::WildIslandList* release_island_list();
  ::sg::WildIslandList* mutable_island_list();
  void set_allocated_island_list(::sg::WildIslandList* island_list);
  void unsafe_arena_set_allocated_island_list(
      ::sg::WildIslandList* island_list);
  ::sg::WildIslandList* unsafe_arena_release_island_list();

  // optional .sg.WildIslandHarvestLog harvest_log = 11;
  bool has_harvest_log() const;
  void clear_harvest_log();
  static const int kHarvestLogFieldNumber = 11;
  private:
  const ::sg::WildIslandHarvestLog& _internal_harvest_log() const;
  public:
  const ::sg::WildIslandHarvestLog& harvest_log() const;
  ::sg::WildIslandHarvestLog* release_harvest_log();
  ::sg::WildIslandHarvestLog* mutable_harvest_log();
  void set_allocated_harvest_log(::sg::WildIslandHarvestLog* harvest_log);
  void unsafe_arena_set_allocated_harvest_log(
      ::sg::WildIslandHarvestLog* harvest_log);
  ::sg::WildIslandHarvestLog* unsafe_arena_release_harvest_log();

  // required int32 result = 1;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::google::protobuf::int32 result() const;
  void set_result(::google::protobuf::int32 value);

  // optional int32 cfg_harvest_interval_seconds = 13;
  bool has_cfg_harvest_interval_seconds() const;
  void clear_cfg_harvest_interval_seconds();
  static const int kCfgHarvestIntervalSecondsFieldNumber = 13;
  ::google::protobuf::int32 cfg_harvest_interval_seconds() const;
  void set_cfg_harvest_interval_seconds(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.UserMapService.MapResponse)
 private:
  void set_has_result();
  void clear_has_result();
  void set_has_area_list();
  void clear_has_area_list();
  void set_has_entry_list();
  void clear_has_entry_list();
  void set_has_island_list();
  void clear_has_island_list();
  void set_has_harvest_log();
  void clear_has_harvest_log();
  void set_has_cfg_harvest_interval_seconds();
  void clear_has_cfg_harvest_interval_seconds();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::HarvestTime > harvest_time_;
  ::sg::MapAreaList* area_list_;
  ::sg::MapEntryList* entry_list_;
  ::sg::WildIslandList* island_list_;
  ::sg::WildIslandHarvestLog* harvest_log_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 cfg_harvest_interval_seconds_;
  friend struct ::protobuf_UserMap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserMapService : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.UserMapService) */ {
 public:
  UserMapService();
  virtual ~UserMapService();

  UserMapService(const UserMapService& from);

  inline UserMapService& operator=(const UserMapService& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserMapService(UserMapService&& from) noexcept
    : UserMapService() {
    *this = ::std::move(from);
  }

  inline UserMapService& operator=(UserMapService&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserMapService& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserMapService* internal_default_instance() {
    return reinterpret_cast<const UserMapService*>(
               &_UserMapService_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void UnsafeArenaSwap(UserMapService* other);
  void Swap(UserMapService* other);
  friend void swap(UserMapService& a, UserMapService& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserMapService* New() const final {
    return CreateMaybeMessage<UserMapService>(NULL);
  }

  UserMapService* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserMapService>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserMapService& from);
  void MergeFrom(const UserMapService& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserMapService* other);
  protected:
  explicit UserMapService(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UserMapService_MapRequest MapRequest;
  typedef UserMapService_MapResponse MapResponse;

  typedef UserMapService_MAP_COMMAND MAP_COMMAND;
  static const MAP_COMMAND QUERY_AREA =
    UserMapService_MAP_COMMAND_QUERY_AREA;
  static const MAP_COMMAND QUERY_ENTRY =
    UserMapService_MAP_COMMAND_QUERY_ENTRY;
  static const MAP_COMMAND QUERY_ENTRY_WILD_ISLAND =
    UserMapService_MAP_COMMAND_QUERY_ENTRY_WILD_ISLAND;
  static const MAP_COMMAND UNLOCK_AREA =
    UserMapService_MAP_COMMAND_UNLOCK_AREA;
  static const MAP_COMMAND BUILD_WORKSHOP =
    UserMapService_MAP_COMMAND_BUILD_WORKSHOP;
  static const MAP_COMMAND GARRISON_WORKSHOP =
    UserMapService_MAP_COMMAND_GARRISON_WORKSHOP;
  static const MAP_COMMAND HARVEST =
    UserMapService_MAP_COMMAND_HARVEST;
  static const MAP_COMMAND QUERY_HARVEST_TIME =
    UserMapService_MAP_COMMAND_QUERY_HARVEST_TIME;
  static const MAP_COMMAND QUERY_HARVEST_LOG =
    UserMapService_MAP_COMMAND_QUERY_HARVEST_LOG;
  static inline bool MAP_COMMAND_IsValid(int value) {
    return UserMapService_MAP_COMMAND_IsValid(value);
  }
  static const MAP_COMMAND MAP_COMMAND_MIN =
    UserMapService_MAP_COMMAND_MAP_COMMAND_MIN;
  static const MAP_COMMAND MAP_COMMAND_MAX =
    UserMapService_MAP_COMMAND_MAP_COMMAND_MAX;
  static const int MAP_COMMAND_ARRAYSIZE =
    UserMapService_MAP_COMMAND_MAP_COMMAND_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MAP_COMMAND_descriptor() {
    return UserMapService_MAP_COMMAND_descriptor();
  }
  static inline const ::std::string& MAP_COMMAND_Name(MAP_COMMAND value) {
    return UserMapService_MAP_COMMAND_Name(value);
  }
  static inline bool MAP_COMMAND_Parse(const ::std::string& name,
      MAP_COMMAND* value) {
    return UserMapService_MAP_COMMAND_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .sg.UserMapService.MapRequest req = 1;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 1;
  private:
  const ::sg::UserMapService_MapRequest& _internal_req() const;
  public:
  const ::sg::UserMapService_MapRequest& req() const;
  ::sg::UserMapService_MapRequest* release_req();
  ::sg::UserMapService_MapRequest* mutable_req();
  void set_allocated_req(::sg::UserMapService_MapRequest* req);
  void unsafe_arena_set_allocated_req(
      ::sg::UserMapService_MapRequest* req);
  ::sg::UserMapService_MapRequest* unsafe_arena_release_req();

  // optional .sg.UserMapService.MapResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  private:
  const ::sg::UserMapService_MapResponse& _internal_resp() const;
  public:
  const ::sg::UserMapService_MapResponse& resp() const;
  ::sg::UserMapService_MapResponse* release_resp();
  ::sg::UserMapService_MapResponse* mutable_resp();
  void set_allocated_resp(::sg::UserMapService_MapResponse* resp);
  void unsafe_arena_set_allocated_resp(
      ::sg::UserMapService_MapResponse* resp);
  ::sg::UserMapService_MapResponse* unsafe_arena_release_resp();

  // @@protoc_insertion_point(class_scope:sg.UserMapService)
 private:
  void set_has_req();
  void clear_has_req();
  void set_has_resp();
  void clear_has_resp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::sg::UserMapService_MapRequest* req_;
  ::sg::UserMapService_MapResponse* resp_;
  friend struct ::protobuf_UserMap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MapEntryStateNotify : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.MapEntryStateNotify) */ {
 public:
  MapEntryStateNotify();
  virtual ~MapEntryStateNotify();

  MapEntryStateNotify(const MapEntryStateNotify& from);

  inline MapEntryStateNotify& operator=(const MapEntryStateNotify& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapEntryStateNotify(MapEntryStateNotify&& from) noexcept
    : MapEntryStateNotify() {
    *this = ::std::move(from);
  }

  inline MapEntryStateNotify& operator=(MapEntryStateNotify&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapEntryStateNotify& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapEntryStateNotify* internal_default_instance() {
    return reinterpret_cast<const MapEntryStateNotify*>(
               &_MapEntryStateNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void UnsafeArenaSwap(MapEntryStateNotify* other);
  void Swap(MapEntryStateNotify* other);
  friend void swap(MapEntryStateNotify& a, MapEntryStateNotify& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapEntryStateNotify* New() const final {
    return CreateMaybeMessage<MapEntryStateNotify>(NULL);
  }

  MapEntryStateNotify* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MapEntryStateNotify>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MapEntryStateNotify& from);
  void MergeFrom(const MapEntryStateNotify& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapEntryStateNotify* other);
  protected:
  explicit MapEntryStateNotify(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .sg.MapEntryList entry_list = 1;
  bool has_entry_list() const;
  void clear_entry_list();
  static const int kEntryListFieldNumber = 1;
  private:
  const ::sg::MapEntryList& _internal_entry_list() const;
  public:
  const ::sg::MapEntryList& entry_list() const;
  ::sg::MapEntryList* release_entry_list();
  ::sg::MapEntryList* mutable_entry_list();
  void set_allocated_entry_list(::sg::MapEntryList* entry_list);
  void unsafe_arena_set_allocated_entry_list(
      ::sg::MapEntryList* entry_list);
  ::sg::MapEntryList* unsafe_arena_release_entry_list();

  // @@protoc_insertion_point(class_scope:sg.MapEntryStateNotify)
 private:
  void set_has_entry_list();
  void clear_has_entry_list();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::sg::MapEntryList* entry_list_;
  friend struct ::protobuf_UserMap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WildIslandStateNotify : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.WildIslandStateNotify) */ {
 public:
  WildIslandStateNotify();
  virtual ~WildIslandStateNotify();

  WildIslandStateNotify(const WildIslandStateNotify& from);

  inline WildIslandStateNotify& operator=(const WildIslandStateNotify& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WildIslandStateNotify(WildIslandStateNotify&& from) noexcept
    : WildIslandStateNotify() {
    *this = ::std::move(from);
  }

  inline WildIslandStateNotify& operator=(WildIslandStateNotify&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const WildIslandStateNotify& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WildIslandStateNotify* internal_default_instance() {
    return reinterpret_cast<const WildIslandStateNotify*>(
               &_WildIslandStateNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void UnsafeArenaSwap(WildIslandStateNotify* other);
  void Swap(WildIslandStateNotify* other);
  friend void swap(WildIslandStateNotify& a, WildIslandStateNotify& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WildIslandStateNotify* New() const final {
    return CreateMaybeMessage<WildIslandStateNotify>(NULL);
  }

  WildIslandStateNotify* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WildIslandStateNotify>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WildIslandStateNotify& from);
  void MergeFrom(const WildIslandStateNotify& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WildIslandStateNotify* other);
  protected:
  explicit WildIslandStateNotify(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .sg.WildIslandList island_list = 1;
  bool has_island_list() const;
  void clear_island_list();
  static const int kIslandListFieldNumber = 1;
  private:
  const ::sg::WildIslandList& _internal_island_list() const;
  public:
  const ::sg::WildIslandList& island_list() const;
  ::sg::WildIslandList* release_island_list();
  ::sg::WildIslandList* mutable_island_list();
  void set_allocated_island_list(::sg::WildIslandList* island_list);
  void unsafe_arena_set_allocated_island_list(
      ::sg::WildIslandList* island_list);
  ::sg::WildIslandList* unsafe_arena_release_island_list();

  // @@protoc_insertion_point(class_scope:sg.WildIslandStateNotify)
 private:
  void set_has_island_list();
  void clear_has_island_list();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::sg::WildIslandList* island_list_;
  friend struct ::protobuf_UserMap_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MapArea

// required uint64 areaid = 1;
inline bool MapArea::has_areaid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapArea::set_has_areaid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapArea::clear_has_areaid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapArea::clear_areaid() {
  areaid_ = GOOGLE_ULONGLONG(0);
  clear_has_areaid();
}
inline ::google::protobuf::uint64 MapArea::areaid() const {
  // @@protoc_insertion_point(field_get:sg.MapArea.areaid)
  return areaid_;
}
inline void MapArea::set_areaid(::google::protobuf::uint64 value) {
  set_has_areaid();
  areaid_ = value;
  // @@protoc_insertion_point(field_set:sg.MapArea.areaid)
}

// required .sg.MAP_AREA_UNLOCK_STATE area_state = 2;
inline bool MapArea::has_area_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapArea::set_has_area_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapArea::clear_has_area_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapArea::clear_area_state() {
  area_state_ = 0;
  clear_has_area_state();
}
inline ::sg::MAP_AREA_UNLOCK_STATE MapArea::area_state() const {
  // @@protoc_insertion_point(field_get:sg.MapArea.area_state)
  return static_cast< ::sg::MAP_AREA_UNLOCK_STATE >(area_state_);
}
inline void MapArea::set_area_state(::sg::MAP_AREA_UNLOCK_STATE value) {
  assert(::sg::MAP_AREA_UNLOCK_STATE_IsValid(value));
  set_has_area_state();
  area_state_ = value;
  // @@protoc_insertion_point(field_set:sg.MapArea.area_state)
}

// -------------------------------------------------------------------

// MapAreaList

// repeated .sg.MapArea list = 1;
inline int MapAreaList::list_size() const {
  return list_.size();
}
inline void MapAreaList::clear_list() {
  list_.Clear();
}
inline ::sg::MapArea* MapAreaList::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:sg.MapAreaList.list)
  return list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::MapArea >*
MapAreaList::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:sg.MapAreaList.list)
  return &list_;
}
inline const ::sg::MapArea& MapAreaList::list(int index) const {
  // @@protoc_insertion_point(field_get:sg.MapAreaList.list)
  return list_.Get(index);
}
inline ::sg::MapArea* MapAreaList::add_list() {
  // @@protoc_insertion_point(field_add:sg.MapAreaList.list)
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::MapArea >&
MapAreaList::list() const {
  // @@protoc_insertion_point(field_list:sg.MapAreaList.list)
  return list_;
}

// -------------------------------------------------------------------

// PirateShip

// required int32 shipid = 1;
inline bool PirateShip::has_shipid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PirateShip::set_has_shipid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PirateShip::clear_has_shipid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PirateShip::clear_shipid() {
  shipid_ = 0;
  clear_has_shipid();
}
inline ::google::protobuf::int32 PirateShip::shipid() const {
  // @@protoc_insertion_point(field_get:sg.PirateShip.shipid)
  return shipid_;
}
inline void PirateShip::set_shipid(::google::protobuf::int32 value) {
  set_has_shipid();
  shipid_ = value;
  // @@protoc_insertion_point(field_set:sg.PirateShip.shipid)
}

// optional int32 type = 2;
inline bool PirateShip::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PirateShip::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PirateShip::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PirateShip::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 PirateShip::type() const {
  // @@protoc_insertion_point(field_get:sg.PirateShip.type)
  return type_;
}
inline void PirateShip::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:sg.PirateShip.type)
}

// optional sfixed64 refresh_time = 3;
inline bool PirateShip::has_refresh_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PirateShip::set_has_refresh_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PirateShip::clear_has_refresh_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PirateShip::clear_refresh_time() {
  refresh_time_ = GOOGLE_LONGLONG(0);
  clear_has_refresh_time();
}
inline ::google::protobuf::int64 PirateShip::refresh_time() const {
  // @@protoc_insertion_point(field_get:sg.PirateShip.refresh_time)
  return refresh_time_;
}
inline void PirateShip::set_refresh_time(::google::protobuf::int64 value) {
  set_has_refresh_time();
  refresh_time_ = value;
  // @@protoc_insertion_point(field_set:sg.PirateShip.refresh_time)
}

// optional int32 fight_num = 4;
inline bool PirateShip::has_fight_num() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PirateShip::set_has_fight_num() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PirateShip::clear_has_fight_num() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PirateShip::clear_fight_num() {
  fight_num_ = 0;
  clear_has_fight_num();
}
inline ::google::protobuf::int32 PirateShip::fight_num() const {
  // @@protoc_insertion_point(field_get:sg.PirateShip.fight_num)
  return fight_num_;
}
inline void PirateShip::set_fight_num(::google::protobuf::int32 value) {
  set_has_fight_num();
  fight_num_ = value;
  // @@protoc_insertion_point(field_set:sg.PirateShip.fight_num)
}

// optional int32 fight_num_max = 5;
inline bool PirateShip::has_fight_num_max() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PirateShip::set_has_fight_num_max() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PirateShip::clear_has_fight_num_max() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PirateShip::clear_fight_num_max() {
  fight_num_max_ = 0;
  clear_has_fight_num_max();
}
inline ::google::protobuf::int32 PirateShip::fight_num_max() const {
  // @@protoc_insertion_point(field_get:sg.PirateShip.fight_num_max)
  return fight_num_max_;
}
inline void PirateShip::set_fight_num_max(::google::protobuf::int32 value) {
  set_has_fight_num_max();
  fight_num_max_ = value;
  // @@protoc_insertion_point(field_set:sg.PirateShip.fight_num_max)
}

// -------------------------------------------------------------------

// PlayerShip

// required .sg.UserInfo player = 1;
inline bool PlayerShip::has_player() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerShip::set_has_player() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerShip::clear_has_player() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::sg::UserInfo& PlayerShip::_internal_player() const {
  return *player_;
}
inline const ::sg::UserInfo& PlayerShip::player() const {
  const ::sg::UserInfo* p = player_;
  // @@protoc_insertion_point(field_get:sg.PlayerShip.player)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::UserInfo*>(
      &::sg::_UserInfo_default_instance_);
}
inline ::sg::UserInfo* PlayerShip::release_player() {
  // @@protoc_insertion_point(field_release:sg.PlayerShip.player)
  clear_has_player();
  ::sg::UserInfo* temp = player_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  player_ = NULL;
  return temp;
}
inline ::sg::UserInfo* PlayerShip::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.PlayerShip.player)
  clear_has_player();
  ::sg::UserInfo* temp = player_;
  player_ = NULL;
  return temp;
}
inline ::sg::UserInfo* PlayerShip::mutable_player() {
  set_has_player();
  if (player_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::UserInfo>(GetArenaNoVirtual());
    player_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.PlayerShip.player)
  return player_;
}
inline void PlayerShip::set_allocated_player(::sg::UserInfo* player) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(player_);
  }
  if (player) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(player)->GetArena();
    if (message_arena != submessage_arena) {
      player = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    set_has_player();
  } else {
    clear_has_player();
  }
  player_ = player;
  // @@protoc_insertion_point(field_set_allocated:sg.PlayerShip.player)
}

// -------------------------------------------------------------------

// MapEntry

// required uint64 entryid = 1;
inline bool MapEntry::has_entryid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MapEntry::set_has_entryid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MapEntry::clear_has_entryid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MapEntry::clear_entryid() {
  entryid_ = GOOGLE_ULONGLONG(0);
  clear_has_entryid();
}
inline ::google::protobuf::uint64 MapEntry::entryid() const {
  // @@protoc_insertion_point(field_get:sg.MapEntry.entryid)
  return entryid_;
}
inline void MapEntry::set_entryid(::google::protobuf::uint64 value) {
  set_has_entryid();
  entryid_ = value;
  // @@protoc_insertion_point(field_set:sg.MapEntry.entryid)
}

// required .sg.MAP_ENTRY_STATE entry_state = 2;
inline bool MapEntry::has_entry_state() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MapEntry::set_has_entry_state() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MapEntry::clear_has_entry_state() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MapEntry::clear_entry_state() {
  entry_state_ = 0;
  clear_has_entry_state();
}
inline ::sg::MAP_ENTRY_STATE MapEntry::entry_state() const {
  // @@protoc_insertion_point(field_get:sg.MapEntry.entry_state)
  return static_cast< ::sg::MAP_ENTRY_STATE >(entry_state_);
}
inline void MapEntry::set_entry_state(::sg::MAP_ENTRY_STATE value) {
  assert(::sg::MAP_ENTRY_STATE_IsValid(value));
  set_has_entry_state();
  entry_state_ = value;
  // @@protoc_insertion_point(field_set:sg.MapEntry.entry_state)
}

// optional bool passable = 3;
inline bool MapEntry::has_passable() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MapEntry::set_has_passable() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MapEntry::clear_has_passable() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MapEntry::clear_passable() {
  passable_ = false;
  clear_has_passable();
}
inline bool MapEntry::passable() const {
  // @@protoc_insertion_point(field_get:sg.MapEntry.passable)
  return passable_;
}
inline void MapEntry::set_passable(bool value) {
  set_has_passable();
  passable_ = value;
  // @@protoc_insertion_point(field_set:sg.MapEntry.passable)
}

// optional .sg.MAP_ENTRY_HARVEST_TYPE harvest_type = 4;
inline bool MapEntry::has_harvest_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MapEntry::set_has_harvest_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MapEntry::clear_has_harvest_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MapEntry::clear_harvest_type() {
  harvest_type_ = 0;
  clear_has_harvest_type();
}
inline ::sg::MAP_ENTRY_HARVEST_TYPE MapEntry::harvest_type() const {
  // @@protoc_insertion_point(field_get:sg.MapEntry.harvest_type)
  return static_cast< ::sg::MAP_ENTRY_HARVEST_TYPE >(harvest_type_);
}
inline void MapEntry::set_harvest_type(::sg::MAP_ENTRY_HARVEST_TYPE value) {
  assert(::sg::MAP_ENTRY_HARVEST_TYPE_IsValid(value));
  set_has_harvest_type();
  harvest_type_ = value;
  // @@protoc_insertion_point(field_set:sg.MapEntry.harvest_type)
}

// optional int32 type = 5;
inline bool MapEntry::has_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MapEntry::set_has_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MapEntry::clear_has_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MapEntry::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 MapEntry::type() const {
  // @@protoc_insertion_point(field_get:sg.MapEntry.type)
  return type_;
}
inline void MapEntry::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:sg.MapEntry.type)
}

// optional uint64 occupier_uuid = 11;
inline bool MapEntry::has_occupier_uuid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MapEntry::set_has_occupier_uuid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MapEntry::clear_has_occupier_uuid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MapEntry::clear_occupier_uuid() {
  occupier_uuid_ = GOOGLE_ULONGLONG(0);
  clear_has_occupier_uuid();
}
inline ::google::protobuf::uint64 MapEntry::occupier_uuid() const {
  // @@protoc_insertion_point(field_get:sg.MapEntry.occupier_uuid)
  return occupier_uuid_;
}
inline void MapEntry::set_occupier_uuid(::google::protobuf::uint64 value) {
  set_has_occupier_uuid();
  occupier_uuid_ = value;
  // @@protoc_insertion_point(field_set:sg.MapEntry.occupier_uuid)
}

// optional bytes occupier_nick = 12;
inline bool MapEntry::has_occupier_nick() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapEntry::set_has_occupier_nick() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapEntry::clear_has_occupier_nick() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapEntry::clear_occupier_nick() {
  occupier_nick_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_occupier_nick();
}
inline const ::std::string& MapEntry::occupier_nick() const {
  // @@protoc_insertion_point(field_get:sg.MapEntry.occupier_nick)
  return occupier_nick_.Get();
}
inline void MapEntry::set_occupier_nick(const ::std::string& value) {
  set_has_occupier_nick();
  occupier_nick_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:sg.MapEntry.occupier_nick)
}
#if LANG_CXX11
inline void MapEntry::set_occupier_nick(::std::string&& value) {
  set_has_occupier_nick();
  occupier_nick_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:sg.MapEntry.occupier_nick)
}
#endif
inline void MapEntry::set_occupier_nick(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_occupier_nick();
  occupier_nick_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:sg.MapEntry.occupier_nick)
}
inline void MapEntry::set_occupier_nick(const void* value,
    size_t size) {
  set_has_occupier_nick();
  occupier_nick_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:sg.MapEntry.occupier_nick)
}
inline ::std::string* MapEntry::mutable_occupier_nick() {
  set_has_occupier_nick();
  // @@protoc_insertion_point(field_mutable:sg.MapEntry.occupier_nick)
  return occupier_nick_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* MapEntry::release_occupier_nick() {
  // @@protoc_insertion_point(field_release:sg.MapEntry.occupier_nick)
  if (!has_occupier_nick()) {
    return NULL;
  }
  clear_has_occupier_nick();
  return occupier_nick_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void MapEntry::set_allocated_occupier_nick(::std::string* occupier_nick) {
  if (occupier_nick != NULL) {
    set_has_occupier_nick();
  } else {
    clear_has_occupier_nick();
  }
  occupier_nick_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), occupier_nick,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:sg.MapEntry.occupier_nick)
}
inline ::std::string* MapEntry::unsafe_arena_release_occupier_nick() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.MapEntry.occupier_nick)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_occupier_nick();
  return occupier_nick_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void MapEntry::unsafe_arena_set_allocated_occupier_nick(
    ::std::string* occupier_nick) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (occupier_nick != NULL) {
    set_has_occupier_nick();
  } else {
    clear_has_occupier_nick();
  }
  occupier_nick_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      occupier_nick, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sg.MapEntry.occupier_nick)
}

// optional int32 occupier_level = 13;
inline bool MapEntry::has_occupier_level() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MapEntry::set_has_occupier_level() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MapEntry::clear_has_occupier_level() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MapEntry::clear_occupier_level() {
  occupier_level_ = 0;
  clear_has_occupier_level();
}
inline ::google::protobuf::int32 MapEntry::occupier_level() const {
  // @@protoc_insertion_point(field_get:sg.MapEntry.occupier_level)
  return occupier_level_;
}
inline void MapEntry::set_occupier_level(::google::protobuf::int32 value) {
  set_has_occupier_level();
  occupier_level_ = value;
  // @@protoc_insertion_point(field_set:sg.MapEntry.occupier_level)
}

// optional int32 occupier_exp = 14;
inline bool MapEntry::has_occupier_exp() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MapEntry::set_has_occupier_exp() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MapEntry::clear_has_occupier_exp() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MapEntry::clear_occupier_exp() {
  occupier_exp_ = 0;
  clear_has_occupier_exp();
}
inline ::google::protobuf::int32 MapEntry::occupier_exp() const {
  // @@protoc_insertion_point(field_get:sg.MapEntry.occupier_exp)
  return occupier_exp_;
}
inline void MapEntry::set_occupier_exp(::google::protobuf::int32 value) {
  set_has_occupier_exp();
  occupier_exp_ = value;
  // @@protoc_insertion_point(field_set:sg.MapEntry.occupier_exp)
}

// optional int32 occupier_rank = 15;
inline bool MapEntry::has_occupier_rank() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MapEntry::set_has_occupier_rank() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MapEntry::clear_has_occupier_rank() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MapEntry::clear_occupier_rank() {
  occupier_rank_ = 0;
  clear_has_occupier_rank();
}
inline ::google::protobuf::int32 MapEntry::occupier_rank() const {
  // @@protoc_insertion_point(field_get:sg.MapEntry.occupier_rank)
  return occupier_rank_;
}
inline void MapEntry::set_occupier_rank(::google::protobuf::int32 value) {
  set_has_occupier_rank();
  occupier_rank_ = value;
  // @@protoc_insertion_point(field_set:sg.MapEntry.occupier_rank)
}

// optional bool occupy_protect = 21;
inline bool MapEntry::has_occupy_protect() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MapEntry::set_has_occupy_protect() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MapEntry::clear_has_occupy_protect() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MapEntry::clear_occupy_protect() {
  occupy_protect_ = false;
  clear_has_occupy_protect();
}
inline bool MapEntry::occupy_protect() const {
  // @@protoc_insertion_point(field_get:sg.MapEntry.occupy_protect)
  return occupy_protect_;
}
inline void MapEntry::set_occupy_protect(bool value) {
  set_has_occupy_protect();
  occupy_protect_ = value;
  // @@protoc_insertion_point(field_set:sg.MapEntry.occupy_protect)
}

// optional sfixed64 occupy_protect_starttime = 22;
inline bool MapEntry::has_occupy_protect_starttime() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void MapEntry::set_has_occupy_protect_starttime() {
  _has_bits_[0] |= 0x00004000u;
}
inline void MapEntry::clear_has_occupy_protect_starttime() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void MapEntry::clear_occupy_protect_starttime() {
  occupy_protect_starttime_ = GOOGLE_LONGLONG(0);
  clear_has_occupy_protect_starttime();
}
inline ::google::protobuf::int64 MapEntry::occupy_protect_starttime() const {
  // @@protoc_insertion_point(field_get:sg.MapEntry.occupy_protect_starttime)
  return occupy_protect_starttime_;
}
inline void MapEntry::set_occupy_protect_starttime(::google::protobuf::int64 value) {
  set_has_occupy_protect_starttime();
  occupy_protect_starttime_ = value;
  // @@protoc_insertion_point(field_set:sg.MapEntry.occupy_protect_starttime)
}

// optional int32 occupy_protect_seconds = 23;
inline bool MapEntry::has_occupy_protect_seconds() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void MapEntry::set_has_occupy_protect_seconds() {
  _has_bits_[0] |= 0x00002000u;
}
inline void MapEntry::clear_has_occupy_protect_seconds() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void MapEntry::clear_occupy_protect_seconds() {
  occupy_protect_seconds_ = 0;
  clear_has_occupy_protect_seconds();
}
inline ::google::protobuf::int32 MapEntry::occupy_protect_seconds() const {
  // @@protoc_insertion_point(field_get:sg.MapEntry.occupy_protect_seconds)
  return occupy_protect_seconds_;
}
inline void MapEntry::set_occupy_protect_seconds(::google::protobuf::int32 value) {
  set_has_occupy_protect_seconds();
  occupy_protect_seconds_ = value;
  // @@protoc_insertion_point(field_set:sg.MapEntry.occupy_protect_seconds)
}

// optional int32 workshop_level = 31;
inline bool MapEntry::has_workshop_level() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void MapEntry::set_has_workshop_level() {
  _has_bits_[0] |= 0x00008000u;
}
inline void MapEntry::clear_has_workshop_level() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void MapEntry::clear_workshop_level() {
  workshop_level_ = 0;
  clear_has_workshop_level();
}
inline ::google::protobuf::int32 MapEntry::workshop_level() const {
  // @@protoc_insertion_point(field_get:sg.MapEntry.workshop_level)
  return workshop_level_;
}
inline void MapEntry::set_workshop_level(::google::protobuf::int32 value) {
  set_has_workshop_level();
  workshop_level_ = value;
  // @@protoc_insertion_point(field_set:sg.MapEntry.workshop_level)
}

// optional .sg.WILD_ISLAND_WORKSHOP_STATE workshop_state = 32;
inline bool MapEntry::has_workshop_state() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void MapEntry::set_has_workshop_state() {
  _has_bits_[0] |= 0x00010000u;
}
inline void MapEntry::clear_has_workshop_state() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void MapEntry::clear_workshop_state() {
  workshop_state_ = 0;
  clear_has_workshop_state();
}
inline ::sg::WILD_ISLAND_WORKSHOP_STATE MapEntry::workshop_state() const {
  // @@protoc_insertion_point(field_get:sg.MapEntry.workshop_state)
  return static_cast< ::sg::WILD_ISLAND_WORKSHOP_STATE >(workshop_state_);
}
inline void MapEntry::set_workshop_state(::sg::WILD_ISLAND_WORKSHOP_STATE value) {
  assert(::sg::WILD_ISLAND_WORKSHOP_STATE_IsValid(value));
  set_has_workshop_state();
  workshop_state_ = value;
  // @@protoc_insertion_point(field_set:sg.MapEntry.workshop_state)
}

// optional .sg.PirateShip pirate_ship = 41;
inline bool MapEntry::has_pirate_ship() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapEntry::set_has_pirate_ship() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapEntry::clear_has_pirate_ship() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapEntry::clear_pirate_ship() {
  if (pirate_ship_ != NULL) pirate_ship_->Clear();
  clear_has_pirate_ship();
}
inline const ::sg::PirateShip& MapEntry::_internal_pirate_ship() const {
  return *pirate_ship_;
}
inline const ::sg::PirateShip& MapEntry::pirate_ship() const {
  const ::sg::PirateShip* p = pirate_ship_;
  // @@protoc_insertion_point(field_get:sg.MapEntry.pirate_ship)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::PirateShip*>(
      &::sg::_PirateShip_default_instance_);
}
inline ::sg::PirateShip* MapEntry::release_pirate_ship() {
  // @@protoc_insertion_point(field_release:sg.MapEntry.pirate_ship)
  clear_has_pirate_ship();
  ::sg::PirateShip* temp = pirate_ship_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  pirate_ship_ = NULL;
  return temp;
}
inline ::sg::PirateShip* MapEntry::unsafe_arena_release_pirate_ship() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.MapEntry.pirate_ship)
  clear_has_pirate_ship();
  ::sg::PirateShip* temp = pirate_ship_;
  pirate_ship_ = NULL;
  return temp;
}
inline ::sg::PirateShip* MapEntry::mutable_pirate_ship() {
  set_has_pirate_ship();
  if (pirate_ship_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::PirateShip>(GetArenaNoVirtual());
    pirate_ship_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.MapEntry.pirate_ship)
  return pirate_ship_;
}
inline void MapEntry::set_allocated_pirate_ship(::sg::PirateShip* pirate_ship) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete pirate_ship_;
  }
  if (pirate_ship) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(pirate_ship);
    if (message_arena != submessage_arena) {
      pirate_ship = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pirate_ship, submessage_arena);
    }
    set_has_pirate_ship();
  } else {
    clear_has_pirate_ship();
  }
  pirate_ship_ = pirate_ship;
  // @@protoc_insertion_point(field_set_allocated:sg.MapEntry.pirate_ship)
}

// optional .sg.PlayerShip player_ship = 42;
inline bool MapEntry::has_player_ship() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MapEntry::set_has_player_ship() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MapEntry::clear_has_player_ship() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MapEntry::clear_player_ship() {
  if (player_ship_ != NULL) player_ship_->Clear();
  clear_has_player_ship();
}
inline const ::sg::PlayerShip& MapEntry::_internal_player_ship() const {
  return *player_ship_;
}
inline const ::sg::PlayerShip& MapEntry::player_ship() const {
  const ::sg::PlayerShip* p = player_ship_;
  // @@protoc_insertion_point(field_get:sg.MapEntry.player_ship)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::PlayerShip*>(
      &::sg::_PlayerShip_default_instance_);
}
inline ::sg::PlayerShip* MapEntry::release_player_ship() {
  // @@protoc_insertion_point(field_release:sg.MapEntry.player_ship)
  clear_has_player_ship();
  ::sg::PlayerShip* temp = player_ship_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  player_ship_ = NULL;
  return temp;
}
inline ::sg::PlayerShip* MapEntry::unsafe_arena_release_player_ship() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.MapEntry.player_ship)
  clear_has_player_ship();
  ::sg::PlayerShip* temp = player_ship_;
  player_ship_ = NULL;
  return temp;
}
inline ::sg::PlayerShip* MapEntry::mutable_player_ship() {
  set_has_player_ship();
  if (player_ship_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::PlayerShip>(GetArenaNoVirtual());
    player_ship_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.MapEntry.player_ship)
  return player_ship_;
}
inline void MapEntry::set_allocated_player_ship(::sg::PlayerShip* player_ship) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete player_ship_;
  }
  if (player_ship) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(player_ship);
    if (message_arena != submessage_arena) {
      player_ship = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, player_ship, submessage_arena);
    }
    set_has_player_ship();
  } else {
    clear_has_player_ship();
  }
  player_ship_ = player_ship;
  // @@protoc_insertion_point(field_set_allocated:sg.MapEntry.player_ship)
}

// optional sfixed64 refresh_time = 43;
inline bool MapEntry::has_refresh_time() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void MapEntry::set_has_refresh_time() {
  _has_bits_[0] |= 0x00020000u;
}
inline void MapEntry::clear_has_refresh_time() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void MapEntry::clear_refresh_time() {
  refresh_time_ = GOOGLE_LONGLONG(0);
  clear_has_refresh_time();
}
inline ::google::protobuf::int64 MapEntry::refresh_time() const {
  // @@protoc_insertion_point(field_get:sg.MapEntry.refresh_time)
  return refresh_time_;
}
inline void MapEntry::set_refresh_time(::google::protobuf::int64 value) {
  set_has_refresh_time();
  refresh_time_ = value;
  // @@protoc_insertion_point(field_set:sg.MapEntry.refresh_time)
}

// -------------------------------------------------------------------

// MapEntryList

// repeated .sg.MapEntry list = 1;
inline int MapEntryList::list_size() const {
  return list_.size();
}
inline void MapEntryList::clear_list() {
  list_.Clear();
}
inline ::sg::MapEntry* MapEntryList::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:sg.MapEntryList.list)
  return list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::MapEntry >*
MapEntryList::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:sg.MapEntryList.list)
  return &list_;
}
inline const ::sg::MapEntry& MapEntryList::list(int index) const {
  // @@protoc_insertion_point(field_get:sg.MapEntryList.list)
  return list_.Get(index);
}
inline ::sg::MapEntry* MapEntryList::add_list() {
  // @@protoc_insertion_point(field_add:sg.MapEntryList.list)
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::MapEntry >&
MapEntryList::list() const {
  // @@protoc_insertion_point(field_list:sg.MapEntryList.list)
  return list_;
}

// -------------------------------------------------------------------

// OccupierData

// required uint64 uuid = 1;
inline bool OccupierData::has_uuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OccupierData::set_has_uuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OccupierData::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OccupierData::clear_uuid() {
  uuid_ = GOOGLE_ULONGLONG(0);
  clear_has_uuid();
}
inline ::google::protobuf::uint64 OccupierData::uuid() const {
  // @@protoc_insertion_point(field_get:sg.OccupierData.uuid)
  return uuid_;
}
inline void OccupierData::set_uuid(::google::protobuf::uint64 value) {
  set_has_uuid();
  uuid_ = value;
  // @@protoc_insertion_point(field_set:sg.OccupierData.uuid)
}

// optional bytes nick = 2;
inline bool OccupierData::has_nick() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OccupierData::set_has_nick() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OccupierData::clear_has_nick() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OccupierData::clear_nick() {
  nick_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_nick();
}
inline const ::std::string& OccupierData::nick() const {
  // @@protoc_insertion_point(field_get:sg.OccupierData.nick)
  return nick_.Get();
}
inline void OccupierData::set_nick(const ::std::string& value) {
  set_has_nick();
  nick_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:sg.OccupierData.nick)
}
#if LANG_CXX11
inline void OccupierData::set_nick(::std::string&& value) {
  set_has_nick();
  nick_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:sg.OccupierData.nick)
}
#endif
inline void OccupierData::set_nick(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_nick();
  nick_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:sg.OccupierData.nick)
}
inline void OccupierData::set_nick(const void* value,
    size_t size) {
  set_has_nick();
  nick_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:sg.OccupierData.nick)
}
inline ::std::string* OccupierData::mutable_nick() {
  set_has_nick();
  // @@protoc_insertion_point(field_mutable:sg.OccupierData.nick)
  return nick_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* OccupierData::release_nick() {
  // @@protoc_insertion_point(field_release:sg.OccupierData.nick)
  if (!has_nick()) {
    return NULL;
  }
  clear_has_nick();
  return nick_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void OccupierData::set_allocated_nick(::std::string* nick) {
  if (nick != NULL) {
    set_has_nick();
  } else {
    clear_has_nick();
  }
  nick_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nick,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:sg.OccupierData.nick)
}
inline ::std::string* OccupierData::unsafe_arena_release_nick() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.OccupierData.nick)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_nick();
  return nick_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void OccupierData::unsafe_arena_set_allocated_nick(
    ::std::string* nick) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (nick != NULL) {
    set_has_nick();
  } else {
    clear_has_nick();
  }
  nick_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      nick, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sg.OccupierData.nick)
}

// optional int32 level = 3;
inline bool OccupierData::has_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OccupierData::set_has_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OccupierData::clear_has_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OccupierData::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 OccupierData::level() const {
  // @@protoc_insertion_point(field_get:sg.OccupierData.level)
  return level_;
}
inline void OccupierData::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:sg.OccupierData.level)
}

// optional int32 rank = 4;
inline bool OccupierData::has_rank() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OccupierData::set_has_rank() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OccupierData::clear_has_rank() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OccupierData::clear_rank() {
  rank_ = 0;
  clear_has_rank();
}
inline ::google::protobuf::int32 OccupierData::rank() const {
  // @@protoc_insertion_point(field_get:sg.OccupierData.rank)
  return rank_;
}
inline void OccupierData::set_rank(::google::protobuf::int32 value) {
  set_has_rank();
  rank_ = value;
  // @@protoc_insertion_point(field_set:sg.OccupierData.rank)
}

// optional sfixed64 occupy_time = 5;
inline bool OccupierData::has_occupy_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OccupierData::set_has_occupy_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OccupierData::clear_has_occupy_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OccupierData::clear_occupy_time() {
  occupy_time_ = GOOGLE_LONGLONG(0);
  clear_has_occupy_time();
}
inline ::google::protobuf::int64 OccupierData::occupy_time() const {
  // @@protoc_insertion_point(field_get:sg.OccupierData.occupy_time)
  return occupy_time_;
}
inline void OccupierData::set_occupy_time(::google::protobuf::int64 value) {
  set_has_occupy_time();
  occupy_time_ = value;
  // @@protoc_insertion_point(field_set:sg.OccupierData.occupy_time)
}

// -------------------------------------------------------------------

// WildIsland_Workshop

// required int32 level = 1;
inline bool WildIsland_Workshop::has_level() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WildIsland_Workshop::set_has_level() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WildIsland_Workshop::clear_has_level() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WildIsland_Workshop::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 WildIsland_Workshop::level() const {
  // @@protoc_insertion_point(field_get:sg.WildIsland.Workshop.level)
  return level_;
}
inline void WildIsland_Workshop::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:sg.WildIsland.Workshop.level)
}

// required .sg.WILD_ISLAND_WORKSHOP_STATE state = 2;
inline bool WildIsland_Workshop::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WildIsland_Workshop::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WildIsland_Workshop::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WildIsland_Workshop::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::sg::WILD_ISLAND_WORKSHOP_STATE WildIsland_Workshop::state() const {
  // @@protoc_insertion_point(field_get:sg.WildIsland.Workshop.state)
  return static_cast< ::sg::WILD_ISLAND_WORKSHOP_STATE >(state_);
}
inline void WildIsland_Workshop::set_state(::sg::WILD_ISLAND_WORKSHOP_STATE value) {
  assert(::sg::WILD_ISLAND_WORKSHOP_STATE_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:sg.WildIsland.Workshop.state)
}

// required float gather_per_min = 3;
inline bool WildIsland_Workshop::has_gather_per_min() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WildIsland_Workshop::set_has_gather_per_min() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WildIsland_Workshop::clear_has_gather_per_min() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WildIsland_Workshop::clear_gather_per_min() {
  gather_per_min_ = 0;
  clear_has_gather_per_min();
}
inline float WildIsland_Workshop::gather_per_min() const {
  // @@protoc_insertion_point(field_get:sg.WildIsland.Workshop.gather_per_min)
  return gather_per_min_;
}
inline void WildIsland_Workshop::set_gather_per_min(float value) {
  set_has_gather_per_min();
  gather_per_min_ = value;
  // @@protoc_insertion_point(field_set:sg.WildIsland.Workshop.gather_per_min)
}

// required float gather_add_ratio = 4;
inline bool WildIsland_Workshop::has_gather_add_ratio() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WildIsland_Workshop::set_has_gather_add_ratio() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WildIsland_Workshop::clear_has_gather_add_ratio() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WildIsland_Workshop::clear_gather_add_ratio() {
  gather_add_ratio_ = 0;
  clear_has_gather_add_ratio();
}
inline float WildIsland_Workshop::gather_add_ratio() const {
  // @@protoc_insertion_point(field_get:sg.WildIsland.Workshop.gather_add_ratio)
  return gather_add_ratio_;
}
inline void WildIsland_Workshop::set_gather_add_ratio(float value) {
  set_has_gather_add_ratio();
  gather_add_ratio_ = value;
  // @@protoc_insertion_point(field_set:sg.WildIsland.Workshop.gather_add_ratio)
}

// required sfixed64 gather_time = 5;
inline bool WildIsland_Workshop::has_gather_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void WildIsland_Workshop::set_has_gather_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void WildIsland_Workshop::clear_has_gather_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void WildIsland_Workshop::clear_gather_time() {
  gather_time_ = GOOGLE_LONGLONG(0);
  clear_has_gather_time();
}
inline ::google::protobuf::int64 WildIsland_Workshop::gather_time() const {
  // @@protoc_insertion_point(field_get:sg.WildIsland.Workshop.gather_time)
  return gather_time_;
}
inline void WildIsland_Workshop::set_gather_time(::google::protobuf::int64 value) {
  set_has_gather_time();
  gather_time_ = value;
  // @@protoc_insertion_point(field_set:sg.WildIsland.Workshop.gather_time)
}

// -------------------------------------------------------------------

// WildIsland_WorkshopOption

// required float gather_per_min = 1;
inline bool WildIsland_WorkshopOption::has_gather_per_min() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WildIsland_WorkshopOption::set_has_gather_per_min() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WildIsland_WorkshopOption::clear_has_gather_per_min() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WildIsland_WorkshopOption::clear_gather_per_min() {
  gather_per_min_ = 0;
  clear_has_gather_per_min();
}
inline float WildIsland_WorkshopOption::gather_per_min() const {
  // @@protoc_insertion_point(field_get:sg.WildIsland.WorkshopOption.gather_per_min)
  return gather_per_min_;
}
inline void WildIsland_WorkshopOption::set_gather_per_min(float value) {
  set_has_gather_per_min();
  gather_per_min_ = value;
  // @@protoc_insertion_point(field_set:sg.WildIsland.WorkshopOption.gather_per_min)
}

// -------------------------------------------------------------------

// WildIsland

// required uint64 entryid = 1;
inline bool WildIsland::has_entryid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WildIsland::set_has_entryid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WildIsland::clear_has_entryid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WildIsland::clear_entryid() {
  entryid_ = GOOGLE_ULONGLONG(0);
  clear_has_entryid();
}
inline ::google::protobuf::uint64 WildIsland::entryid() const {
  // @@protoc_insertion_point(field_get:sg.WildIsland.entryid)
  return entryid_;
}
inline void WildIsland::set_entryid(::google::protobuf::uint64 value) {
  set_has_entryid();
  entryid_ = value;
  // @@protoc_insertion_point(field_set:sg.WildIsland.entryid)
}

// required int32 island_cfgid = 2;
inline bool WildIsland::has_island_cfgid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void WildIsland::set_has_island_cfgid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void WildIsland::clear_has_island_cfgid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void WildIsland::clear_island_cfgid() {
  island_cfgid_ = 0;
  clear_has_island_cfgid();
}
inline ::google::protobuf::int32 WildIsland::island_cfgid() const {
  // @@protoc_insertion_point(field_get:sg.WildIsland.island_cfgid)
  return island_cfgid_;
}
inline void WildIsland::set_island_cfgid(::google::protobuf::int32 value) {
  set_has_island_cfgid();
  island_cfgid_ = value;
  // @@protoc_insertion_point(field_set:sg.WildIsland.island_cfgid)
}

// required .sg.WILD_ISLAND_STATE island_state = 3;
inline bool WildIsland::has_island_state() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void WildIsland::set_has_island_state() {
  _has_bits_[0] |= 0x00000020u;
}
inline void WildIsland::clear_has_island_state() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void WildIsland::clear_island_state() {
  island_state_ = 0;
  clear_has_island_state();
}
inline ::sg::WILD_ISLAND_STATE WildIsland::island_state() const {
  // @@protoc_insertion_point(field_get:sg.WildIsland.island_state)
  return static_cast< ::sg::WILD_ISLAND_STATE >(island_state_);
}
inline void WildIsland::set_island_state(::sg::WILD_ISLAND_STATE value) {
  assert(::sg::WILD_ISLAND_STATE_IsValid(value));
  set_has_island_state();
  island_state_ = value;
  // @@protoc_insertion_point(field_set:sg.WildIsland.island_state)
}

// required .sg.OccupierData occupier_data = 4;
inline bool WildIsland::has_occupier_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WildIsland::set_has_occupier_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WildIsland::clear_has_occupier_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WildIsland::clear_occupier_data() {
  if (occupier_data_ != NULL) occupier_data_->Clear();
  clear_has_occupier_data();
}
inline const ::sg::OccupierData& WildIsland::_internal_occupier_data() const {
  return *occupier_data_;
}
inline const ::sg::OccupierData& WildIsland::occupier_data() const {
  const ::sg::OccupierData* p = occupier_data_;
  // @@protoc_insertion_point(field_get:sg.WildIsland.occupier_data)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::OccupierData*>(
      &::sg::_OccupierData_default_instance_);
}
inline ::sg::OccupierData* WildIsland::release_occupier_data() {
  // @@protoc_insertion_point(field_release:sg.WildIsland.occupier_data)
  clear_has_occupier_data();
  ::sg::OccupierData* temp = occupier_data_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  occupier_data_ = NULL;
  return temp;
}
inline ::sg::OccupierData* WildIsland::unsafe_arena_release_occupier_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.WildIsland.occupier_data)
  clear_has_occupier_data();
  ::sg::OccupierData* temp = occupier_data_;
  occupier_data_ = NULL;
  return temp;
}
inline ::sg::OccupierData* WildIsland::mutable_occupier_data() {
  set_has_occupier_data();
  if (occupier_data_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::OccupierData>(GetArenaNoVirtual());
    occupier_data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.WildIsland.occupier_data)
  return occupier_data_;
}
inline void WildIsland::set_allocated_occupier_data(::sg::OccupierData* occupier_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete occupier_data_;
  }
  if (occupier_data) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(occupier_data);
    if (message_arena != submessage_arena) {
      occupier_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, occupier_data, submessage_arena);
    }
    set_has_occupier_data();
  } else {
    clear_has_occupier_data();
  }
  occupier_data_ = occupier_data;
  // @@protoc_insertion_point(field_set_allocated:sg.WildIsland.occupier_data)
}

// optional .sg.WildIsland.Workshop workshop = 11;
inline bool WildIsland::has_workshop() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WildIsland::set_has_workshop() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WildIsland::clear_has_workshop() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WildIsland::clear_workshop() {
  if (workshop_ != NULL) workshop_->Clear();
  clear_has_workshop();
}
inline const ::sg::WildIsland_Workshop& WildIsland::_internal_workshop() const {
  return *workshop_;
}
inline const ::sg::WildIsland_Workshop& WildIsland::workshop() const {
  const ::sg::WildIsland_Workshop* p = workshop_;
  // @@protoc_insertion_point(field_get:sg.WildIsland.workshop)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::WildIsland_Workshop*>(
      &::sg::_WildIsland_Workshop_default_instance_);
}
inline ::sg::WildIsland_Workshop* WildIsland::release_workshop() {
  // @@protoc_insertion_point(field_release:sg.WildIsland.workshop)
  clear_has_workshop();
  ::sg::WildIsland_Workshop* temp = workshop_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  workshop_ = NULL;
  return temp;
}
inline ::sg::WildIsland_Workshop* WildIsland::unsafe_arena_release_workshop() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.WildIsland.workshop)
  clear_has_workshop();
  ::sg::WildIsland_Workshop* temp = workshop_;
  workshop_ = NULL;
  return temp;
}
inline ::sg::WildIsland_Workshop* WildIsland::mutable_workshop() {
  set_has_workshop();
  if (workshop_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::WildIsland_Workshop>(GetArenaNoVirtual());
    workshop_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.WildIsland.workshop)
  return workshop_;
}
inline void WildIsland::set_allocated_workshop(::sg::WildIsland_Workshop* workshop) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete workshop_;
  }
  if (workshop) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(workshop);
    if (message_arena != submessage_arena) {
      workshop = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, workshop, submessage_arena);
    }
    set_has_workshop();
  } else {
    clear_has_workshop();
  }
  workshop_ = workshop;
  // @@protoc_insertion_point(field_set_allocated:sg.WildIsland.workshop)
}

// optional bytes map_data = 12;
inline bool WildIsland::has_map_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WildIsland::set_has_map_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WildIsland::clear_has_map_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WildIsland::clear_map_data() {
  map_data_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_map_data();
}
inline const ::std::string& WildIsland::map_data() const {
  // @@protoc_insertion_point(field_get:sg.WildIsland.map_data)
  return map_data_.Get();
}
inline void WildIsland::set_map_data(const ::std::string& value) {
  set_has_map_data();
  map_data_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:sg.WildIsland.map_data)
}
#if LANG_CXX11
inline void WildIsland::set_map_data(::std::string&& value) {
  set_has_map_data();
  map_data_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:sg.WildIsland.map_data)
}
#endif
inline void WildIsland::set_map_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_map_data();
  map_data_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:sg.WildIsland.map_data)
}
inline void WildIsland::set_map_data(const void* value,
    size_t size) {
  set_has_map_data();
  map_data_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:sg.WildIsland.map_data)
}
inline ::std::string* WildIsland::mutable_map_data() {
  set_has_map_data();
  // @@protoc_insertion_point(field_mutable:sg.WildIsland.map_data)
  return map_data_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* WildIsland::release_map_data() {
  // @@protoc_insertion_point(field_release:sg.WildIsland.map_data)
  if (!has_map_data()) {
    return NULL;
  }
  clear_has_map_data();
  return map_data_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void WildIsland::set_allocated_map_data(::std::string* map_data) {
  if (map_data != NULL) {
    set_has_map_data();
  } else {
    clear_has_map_data();
  }
  map_data_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), map_data,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:sg.WildIsland.map_data)
}
inline ::std::string* WildIsland::unsafe_arena_release_map_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.WildIsland.map_data)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_map_data();
  return map_data_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void WildIsland::unsafe_arena_set_allocated_map_data(
    ::std::string* map_data) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (map_data != NULL) {
    set_has_map_data();
  } else {
    clear_has_map_data();
  }
  map_data_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      map_data, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sg.WildIsland.map_data)
}

// -------------------------------------------------------------------

// WildIslandList

// repeated .sg.WildIsland list = 1;
inline int WildIslandList::list_size() const {
  return list_.size();
}
inline void WildIslandList::clear_list() {
  list_.Clear();
}
inline ::sg::WildIsland* WildIslandList::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:sg.WildIslandList.list)
  return list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::WildIsland >*
WildIslandList::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:sg.WildIslandList.list)
  return &list_;
}
inline const ::sg::WildIsland& WildIslandList::list(int index) const {
  // @@protoc_insertion_point(field_get:sg.WildIslandList.list)
  return list_.Get(index);
}
inline ::sg::WildIsland* WildIslandList::add_list() {
  // @@protoc_insertion_point(field_add:sg.WildIslandList.list)
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::WildIsland >&
WildIslandList::list() const {
  // @@protoc_insertion_point(field_list:sg.WildIslandList.list)
  return list_;
}

// -------------------------------------------------------------------

// WildIslandHarvestLog_HarvestItem

// required int32 item_type = 1;
inline bool WildIslandHarvestLog_HarvestItem::has_item_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WildIslandHarvestLog_HarvestItem::set_has_item_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WildIslandHarvestLog_HarvestItem::clear_has_item_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WildIslandHarvestLog_HarvestItem::clear_item_type() {
  item_type_ = 0;
  clear_has_item_type();
}
inline ::google::protobuf::int32 WildIslandHarvestLog_HarvestItem::item_type() const {
  // @@protoc_insertion_point(field_get:sg.WildIslandHarvestLog.HarvestItem.item_type)
  return item_type_;
}
inline void WildIslandHarvestLog_HarvestItem::set_item_type(::google::protobuf::int32 value) {
  set_has_item_type();
  item_type_ = value;
  // @@protoc_insertion_point(field_set:sg.WildIslandHarvestLog.HarvestItem.item_type)
}

// required int32 item_num = 2;
inline bool WildIslandHarvestLog_HarvestItem::has_item_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WildIslandHarvestLog_HarvestItem::set_has_item_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WildIslandHarvestLog_HarvestItem::clear_has_item_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WildIslandHarvestLog_HarvestItem::clear_item_num() {
  item_num_ = 0;
  clear_has_item_num();
}
inline ::google::protobuf::int32 WildIslandHarvestLog_HarvestItem::item_num() const {
  // @@protoc_insertion_point(field_get:sg.WildIslandHarvestLog.HarvestItem.item_num)
  return item_num_;
}
inline void WildIslandHarvestLog_HarvestItem::set_item_num(::google::protobuf::int32 value) {
  set_has_item_num();
  item_num_ = value;
  // @@protoc_insertion_point(field_set:sg.WildIslandHarvestLog.HarvestItem.item_num)
}

// -------------------------------------------------------------------

// WildIslandHarvestLog_HarvestItemList

// repeated .sg.WildIslandHarvestLog.HarvestItem list = 1;
inline int WildIslandHarvestLog_HarvestItemList::list_size() const {
  return list_.size();
}
inline void WildIslandHarvestLog_HarvestItemList::clear_list() {
  list_.Clear();
}
inline ::sg::WildIslandHarvestLog_HarvestItem* WildIslandHarvestLog_HarvestItemList::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:sg.WildIslandHarvestLog.HarvestItemList.list)
  return list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::WildIslandHarvestLog_HarvestItem >*
WildIslandHarvestLog_HarvestItemList::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:sg.WildIslandHarvestLog.HarvestItemList.list)
  return &list_;
}
inline const ::sg::WildIslandHarvestLog_HarvestItem& WildIslandHarvestLog_HarvestItemList::list(int index) const {
  // @@protoc_insertion_point(field_get:sg.WildIslandHarvestLog.HarvestItemList.list)
  return list_.Get(index);
}
inline ::sg::WildIslandHarvestLog_HarvestItem* WildIslandHarvestLog_HarvestItemList::add_list() {
  // @@protoc_insertion_point(field_add:sg.WildIslandHarvestLog.HarvestItemList.list)
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::WildIslandHarvestLog_HarvestItem >&
WildIslandHarvestLog_HarvestItemList::list() const {
  // @@protoc_insertion_point(field_list:sg.WildIslandHarvestLog.HarvestItemList.list)
  return list_;
}

// -------------------------------------------------------------------

// WildIslandHarvestLog_HarvestLog

// optional sfixed64 harvest_time = 1;
inline bool WildIslandHarvestLog_HarvestLog::has_harvest_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WildIslandHarvestLog_HarvestLog::set_has_harvest_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WildIslandHarvestLog_HarvestLog::clear_has_harvest_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WildIslandHarvestLog_HarvestLog::clear_harvest_time() {
  harvest_time_ = GOOGLE_LONGLONG(0);
  clear_has_harvest_time();
}
inline ::google::protobuf::int64 WildIslandHarvestLog_HarvestLog::harvest_time() const {
  // @@protoc_insertion_point(field_get:sg.WildIslandHarvestLog.HarvestLog.harvest_time)
  return harvest_time_;
}
inline void WildIslandHarvestLog_HarvestLog::set_harvest_time(::google::protobuf::int64 value) {
  set_has_harvest_time();
  harvest_time_ = value;
  // @@protoc_insertion_point(field_set:sg.WildIslandHarvestLog.HarvestLog.harvest_time)
}

// optional .sg.WildIslandHarvestLog.HarvestItemList item_list = 2;
inline bool WildIslandHarvestLog_HarvestLog::has_item_list() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WildIslandHarvestLog_HarvestLog::set_has_item_list() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WildIslandHarvestLog_HarvestLog::clear_has_item_list() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WildIslandHarvestLog_HarvestLog::clear_item_list() {
  if (item_list_ != NULL) item_list_->Clear();
  clear_has_item_list();
}
inline const ::sg::WildIslandHarvestLog_HarvestItemList& WildIslandHarvestLog_HarvestLog::_internal_item_list() const {
  return *item_list_;
}
inline const ::sg::WildIslandHarvestLog_HarvestItemList& WildIslandHarvestLog_HarvestLog::item_list() const {
  const ::sg::WildIslandHarvestLog_HarvestItemList* p = item_list_;
  // @@protoc_insertion_point(field_get:sg.WildIslandHarvestLog.HarvestLog.item_list)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::WildIslandHarvestLog_HarvestItemList*>(
      &::sg::_WildIslandHarvestLog_HarvestItemList_default_instance_);
}
inline ::sg::WildIslandHarvestLog_HarvestItemList* WildIslandHarvestLog_HarvestLog::release_item_list() {
  // @@protoc_insertion_point(field_release:sg.WildIslandHarvestLog.HarvestLog.item_list)
  clear_has_item_list();
  ::sg::WildIslandHarvestLog_HarvestItemList* temp = item_list_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  item_list_ = NULL;
  return temp;
}
inline ::sg::WildIslandHarvestLog_HarvestItemList* WildIslandHarvestLog_HarvestLog::unsafe_arena_release_item_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.WildIslandHarvestLog.HarvestLog.item_list)
  clear_has_item_list();
  ::sg::WildIslandHarvestLog_HarvestItemList* temp = item_list_;
  item_list_ = NULL;
  return temp;
}
inline ::sg::WildIslandHarvestLog_HarvestItemList* WildIslandHarvestLog_HarvestLog::mutable_item_list() {
  set_has_item_list();
  if (item_list_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::WildIslandHarvestLog_HarvestItemList>(GetArenaNoVirtual());
    item_list_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.WildIslandHarvestLog.HarvestLog.item_list)
  return item_list_;
}
inline void WildIslandHarvestLog_HarvestLog::set_allocated_item_list(::sg::WildIslandHarvestLog_HarvestItemList* item_list) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete item_list_;
  }
  if (item_list) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(item_list);
    if (message_arena != submessage_arena) {
      item_list = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, item_list, submessage_arena);
    }
    set_has_item_list();
  } else {
    clear_has_item_list();
  }
  item_list_ = item_list;
  // @@protoc_insertion_point(field_set_allocated:sg.WildIslandHarvestLog.HarvestLog.item_list)
}

// -------------------------------------------------------------------

// WildIslandHarvestLog_HarvestLogList

// repeated .sg.WildIslandHarvestLog.HarvestLog list = 1;
inline int WildIslandHarvestLog_HarvestLogList::list_size() const {
  return list_.size();
}
inline void WildIslandHarvestLog_HarvestLogList::clear_list() {
  list_.Clear();
}
inline ::sg::WildIslandHarvestLog_HarvestLog* WildIslandHarvestLog_HarvestLogList::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:sg.WildIslandHarvestLog.HarvestLogList.list)
  return list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::WildIslandHarvestLog_HarvestLog >*
WildIslandHarvestLog_HarvestLogList::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:sg.WildIslandHarvestLog.HarvestLogList.list)
  return &list_;
}
inline const ::sg::WildIslandHarvestLog_HarvestLog& WildIslandHarvestLog_HarvestLogList::list(int index) const {
  // @@protoc_insertion_point(field_get:sg.WildIslandHarvestLog.HarvestLogList.list)
  return list_.Get(index);
}
inline ::sg::WildIslandHarvestLog_HarvestLog* WildIslandHarvestLog_HarvestLogList::add_list() {
  // @@protoc_insertion_point(field_add:sg.WildIslandHarvestLog.HarvestLogList.list)
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::WildIslandHarvestLog_HarvestLog >&
WildIslandHarvestLog_HarvestLogList::list() const {
  // @@protoc_insertion_point(field_list:sg.WildIslandHarvestLog.HarvestLogList.list)
  return list_;
}

// -------------------------------------------------------------------

// WildIslandHarvestLog

// optional .sg.WildIslandHarvestLog.HarvestLogList harvest_log_list = 1;
inline bool WildIslandHarvestLog::has_harvest_log_list() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WildIslandHarvestLog::set_has_harvest_log_list() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WildIslandHarvestLog::clear_has_harvest_log_list() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WildIslandHarvestLog::clear_harvest_log_list() {
  if (harvest_log_list_ != NULL) harvest_log_list_->Clear();
  clear_has_harvest_log_list();
}
inline const ::sg::WildIslandHarvestLog_HarvestLogList& WildIslandHarvestLog::_internal_harvest_log_list() const {
  return *harvest_log_list_;
}
inline const ::sg::WildIslandHarvestLog_HarvestLogList& WildIslandHarvestLog::harvest_log_list() const {
  const ::sg::WildIslandHarvestLog_HarvestLogList* p = harvest_log_list_;
  // @@protoc_insertion_point(field_get:sg.WildIslandHarvestLog.harvest_log_list)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::WildIslandHarvestLog_HarvestLogList*>(
      &::sg::_WildIslandHarvestLog_HarvestLogList_default_instance_);
}
inline ::sg::WildIslandHarvestLog_HarvestLogList* WildIslandHarvestLog::release_harvest_log_list() {
  // @@protoc_insertion_point(field_release:sg.WildIslandHarvestLog.harvest_log_list)
  clear_has_harvest_log_list();
  ::sg::WildIslandHarvestLog_HarvestLogList* temp = harvest_log_list_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  harvest_log_list_ = NULL;
  return temp;
}
inline ::sg::WildIslandHarvestLog_HarvestLogList* WildIslandHarvestLog::unsafe_arena_release_harvest_log_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.WildIslandHarvestLog.harvest_log_list)
  clear_has_harvest_log_list();
  ::sg::WildIslandHarvestLog_HarvestLogList* temp = harvest_log_list_;
  harvest_log_list_ = NULL;
  return temp;
}
inline ::sg::WildIslandHarvestLog_HarvestLogList* WildIslandHarvestLog::mutable_harvest_log_list() {
  set_has_harvest_log_list();
  if (harvest_log_list_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::WildIslandHarvestLog_HarvestLogList>(GetArenaNoVirtual());
    harvest_log_list_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.WildIslandHarvestLog.harvest_log_list)
  return harvest_log_list_;
}
inline void WildIslandHarvestLog::set_allocated_harvest_log_list(::sg::WildIslandHarvestLog_HarvestLogList* harvest_log_list) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete harvest_log_list_;
  }
  if (harvest_log_list) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(harvest_log_list);
    if (message_arena != submessage_arena) {
      harvest_log_list = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, harvest_log_list, submessage_arena);
    }
    set_has_harvest_log_list();
  } else {
    clear_has_harvest_log_list();
  }
  harvest_log_list_ = harvest_log_list;
  // @@protoc_insertion_point(field_set_allocated:sg.WildIslandHarvestLog.harvest_log_list)
}

// -------------------------------------------------------------------

// HarvestTime

// required .sg.MAP_ENTRY_HARVEST_TYPE harvest_type = 1;
inline bool HarvestTime::has_harvest_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HarvestTime::set_has_harvest_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HarvestTime::clear_has_harvest_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HarvestTime::clear_harvest_type() {
  harvest_type_ = 0;
  clear_has_harvest_type();
}
inline ::sg::MAP_ENTRY_HARVEST_TYPE HarvestTime::harvest_type() const {
  // @@protoc_insertion_point(field_get:sg.HarvestTime.harvest_type)
  return static_cast< ::sg::MAP_ENTRY_HARVEST_TYPE >(harvest_type_);
}
inline void HarvestTime::set_harvest_type(::sg::MAP_ENTRY_HARVEST_TYPE value) {
  assert(::sg::MAP_ENTRY_HARVEST_TYPE_IsValid(value));
  set_has_harvest_type();
  harvest_type_ = value;
  // @@protoc_insertion_point(field_set:sg.HarvestTime.harvest_type)
}

// required sfixed64 harvest_time = 2;
inline bool HarvestTime::has_harvest_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HarvestTime::set_has_harvest_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HarvestTime::clear_has_harvest_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HarvestTime::clear_harvest_time() {
  harvest_time_ = GOOGLE_LONGLONG(0);
  clear_has_harvest_time();
}
inline ::google::protobuf::int64 HarvestTime::harvest_time() const {
  // @@protoc_insertion_point(field_get:sg.HarvestTime.harvest_time)
  return harvest_time_;
}
inline void HarvestTime::set_harvest_time(::google::protobuf::int64 value) {
  set_has_harvest_time();
  harvest_time_ = value;
  // @@protoc_insertion_point(field_set:sg.HarvestTime.harvest_time)
}

// -------------------------------------------------------------------

// GarrisonRoom

// required int32 roomid = 1;
inline bool GarrisonRoom::has_roomid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GarrisonRoom::set_has_roomid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GarrisonRoom::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GarrisonRoom::clear_roomid() {
  roomid_ = 0;
  clear_has_roomid();
}
inline ::google::protobuf::int32 GarrisonRoom::roomid() const {
  // @@protoc_insertion_point(field_get:sg.GarrisonRoom.roomid)
  return roomid_;
}
inline void GarrisonRoom::set_roomid(::google::protobuf::int32 value) {
  set_has_roomid();
  roomid_ = value;
  // @@protoc_insertion_point(field_set:sg.GarrisonRoom.roomid)
}

// repeated int32 garrison_list = 2;
inline int GarrisonRoom::garrison_list_size() const {
  return garrison_list_.size();
}
inline void GarrisonRoom::clear_garrison_list() {
  garrison_list_.Clear();
}
inline ::google::protobuf::int32 GarrisonRoom::garrison_list(int index) const {
  // @@protoc_insertion_point(field_get:sg.GarrisonRoom.garrison_list)
  return garrison_list_.Get(index);
}
inline void GarrisonRoom::set_garrison_list(int index, ::google::protobuf::int32 value) {
  garrison_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:sg.GarrisonRoom.garrison_list)
}
inline void GarrisonRoom::add_garrison_list(::google::protobuf::int32 value) {
  garrison_list_.Add(value);
  // @@protoc_insertion_point(field_add:sg.GarrisonRoom.garrison_list)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GarrisonRoom::garrison_list() const {
  // @@protoc_insertion_point(field_list:sg.GarrisonRoom.garrison_list)
  return garrison_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GarrisonRoom::mutable_garrison_list() {
  // @@protoc_insertion_point(field_mutable_list:sg.GarrisonRoom.garrison_list)
  return &garrison_list_;
}

// -------------------------------------------------------------------

// UserMapService_MapRequest

// required .sg.UserMapService.MAP_COMMAND cmd = 1;
inline bool UserMapService_MapRequest::has_cmd() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserMapService_MapRequest::set_has_cmd() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserMapService_MapRequest::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserMapService_MapRequest::clear_cmd() {
  cmd_ = 1;
  clear_has_cmd();
}
inline ::sg::UserMapService_MAP_COMMAND UserMapService_MapRequest::cmd() const {
  // @@protoc_insertion_point(field_get:sg.UserMapService.MapRequest.cmd)
  return static_cast< ::sg::UserMapService_MAP_COMMAND >(cmd_);
}
inline void UserMapService_MapRequest::set_cmd(::sg::UserMapService_MAP_COMMAND value) {
  assert(::sg::UserMapService_MAP_COMMAND_IsValid(value));
  set_has_cmd();
  cmd_ = value;
  // @@protoc_insertion_point(field_set:sg.UserMapService.MapRequest.cmd)
}

// optional int32 areaid = 2;
inline bool UserMapService_MapRequest::has_areaid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserMapService_MapRequest::set_has_areaid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserMapService_MapRequest::clear_has_areaid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserMapService_MapRequest::clear_areaid() {
  areaid_ = 0;
  clear_has_areaid();
}
inline ::google::protobuf::int32 UserMapService_MapRequest::areaid() const {
  // @@protoc_insertion_point(field_get:sg.UserMapService.MapRequest.areaid)
  return areaid_;
}
inline void UserMapService_MapRequest::set_areaid(::google::protobuf::int32 value) {
  set_has_areaid();
  areaid_ = value;
  // @@protoc_insertion_point(field_set:sg.UserMapService.MapRequest.areaid)
}

// optional uint64 entryid = 3;
inline bool UserMapService_MapRequest::has_entryid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserMapService_MapRequest::set_has_entryid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserMapService_MapRequest::clear_has_entryid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserMapService_MapRequest::clear_entryid() {
  entryid_ = GOOGLE_ULONGLONG(0);
  clear_has_entryid();
}
inline ::google::protobuf::uint64 UserMapService_MapRequest::entryid() const {
  // @@protoc_insertion_point(field_get:sg.UserMapService.MapRequest.entryid)
  return entryid_;
}
inline void UserMapService_MapRequest::set_entryid(::google::protobuf::uint64 value) {
  set_has_entryid();
  entryid_ = value;
  // @@protoc_insertion_point(field_set:sg.UserMapService.MapRequest.entryid)
}

// optional .sg.GarrisonRoom garrison_room = 4;
inline bool UserMapService_MapRequest::has_garrison_room() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserMapService_MapRequest::set_has_garrison_room() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserMapService_MapRequest::clear_has_garrison_room() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserMapService_MapRequest::clear_garrison_room() {
  if (garrison_room_ != NULL) garrison_room_->Clear();
  clear_has_garrison_room();
}
inline const ::sg::GarrisonRoom& UserMapService_MapRequest::_internal_garrison_room() const {
  return *garrison_room_;
}
inline const ::sg::GarrisonRoom& UserMapService_MapRequest::garrison_room() const {
  const ::sg::GarrisonRoom* p = garrison_room_;
  // @@protoc_insertion_point(field_get:sg.UserMapService.MapRequest.garrison_room)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::GarrisonRoom*>(
      &::sg::_GarrisonRoom_default_instance_);
}
inline ::sg::GarrisonRoom* UserMapService_MapRequest::release_garrison_room() {
  // @@protoc_insertion_point(field_release:sg.UserMapService.MapRequest.garrison_room)
  clear_has_garrison_room();
  ::sg::GarrisonRoom* temp = garrison_room_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  garrison_room_ = NULL;
  return temp;
}
inline ::sg::GarrisonRoom* UserMapService_MapRequest::unsafe_arena_release_garrison_room() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.UserMapService.MapRequest.garrison_room)
  clear_has_garrison_room();
  ::sg::GarrisonRoom* temp = garrison_room_;
  garrison_room_ = NULL;
  return temp;
}
inline ::sg::GarrisonRoom* UserMapService_MapRequest::mutable_garrison_room() {
  set_has_garrison_room();
  if (garrison_room_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::GarrisonRoom>(GetArenaNoVirtual());
    garrison_room_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.UserMapService.MapRequest.garrison_room)
  return garrison_room_;
}
inline void UserMapService_MapRequest::set_allocated_garrison_room(::sg::GarrisonRoom* garrison_room) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete garrison_room_;
  }
  if (garrison_room) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(garrison_room);
    if (message_arena != submessage_arena) {
      garrison_room = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, garrison_room, submessage_arena);
    }
    set_has_garrison_room();
  } else {
    clear_has_garrison_room();
  }
  garrison_room_ = garrison_room;
  // @@protoc_insertion_point(field_set_allocated:sg.UserMapService.MapRequest.garrison_room)
}

// optional .sg.MAP_ENTRY_HARVEST_TYPE harvest_type = 5;
inline bool UserMapService_MapRequest::has_harvest_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserMapService_MapRequest::set_has_harvest_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserMapService_MapRequest::clear_has_harvest_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserMapService_MapRequest::clear_harvest_type() {
  harvest_type_ = 0;
  clear_has_harvest_type();
}
inline ::sg::MAP_ENTRY_HARVEST_TYPE UserMapService_MapRequest::harvest_type() const {
  // @@protoc_insertion_point(field_get:sg.UserMapService.MapRequest.harvest_type)
  return static_cast< ::sg::MAP_ENTRY_HARVEST_TYPE >(harvest_type_);
}
inline void UserMapService_MapRequest::set_harvest_type(::sg::MAP_ENTRY_HARVEST_TYPE value) {
  assert(::sg::MAP_ENTRY_HARVEST_TYPE_IsValid(value));
  set_has_harvest_type();
  harvest_type_ = value;
  // @@protoc_insertion_point(field_set:sg.UserMapService.MapRequest.harvest_type)
}

// -------------------------------------------------------------------

// UserMapService_MapResponse

// required int32 result = 1;
inline bool UserMapService_MapResponse::has_result() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserMapService_MapResponse::set_has_result() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserMapService_MapResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserMapService_MapResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 UserMapService_MapResponse::result() const {
  // @@protoc_insertion_point(field_get:sg.UserMapService.MapResponse.result)
  return result_;
}
inline void UserMapService_MapResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:sg.UserMapService.MapResponse.result)
}

// optional .sg.MapAreaList area_list = 2;
inline bool UserMapService_MapResponse::has_area_list() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserMapService_MapResponse::set_has_area_list() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserMapService_MapResponse::clear_has_area_list() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserMapService_MapResponse::clear_area_list() {
  if (area_list_ != NULL) area_list_->Clear();
  clear_has_area_list();
}
inline const ::sg::MapAreaList& UserMapService_MapResponse::_internal_area_list() const {
  return *area_list_;
}
inline const ::sg::MapAreaList& UserMapService_MapResponse::area_list() const {
  const ::sg::MapAreaList* p = area_list_;
  // @@protoc_insertion_point(field_get:sg.UserMapService.MapResponse.area_list)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::MapAreaList*>(
      &::sg::_MapAreaList_default_instance_);
}
inline ::sg::MapAreaList* UserMapService_MapResponse::release_area_list() {
  // @@protoc_insertion_point(field_release:sg.UserMapService.MapResponse.area_list)
  clear_has_area_list();
  ::sg::MapAreaList* temp = area_list_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  area_list_ = NULL;
  return temp;
}
inline ::sg::MapAreaList* UserMapService_MapResponse::unsafe_arena_release_area_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.UserMapService.MapResponse.area_list)
  clear_has_area_list();
  ::sg::MapAreaList* temp = area_list_;
  area_list_ = NULL;
  return temp;
}
inline ::sg::MapAreaList* UserMapService_MapResponse::mutable_area_list() {
  set_has_area_list();
  if (area_list_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::MapAreaList>(GetArenaNoVirtual());
    area_list_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.UserMapService.MapResponse.area_list)
  return area_list_;
}
inline void UserMapService_MapResponse::set_allocated_area_list(::sg::MapAreaList* area_list) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete area_list_;
  }
  if (area_list) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(area_list);
    if (message_arena != submessage_arena) {
      area_list = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, area_list, submessage_arena);
    }
    set_has_area_list();
  } else {
    clear_has_area_list();
  }
  area_list_ = area_list;
  // @@protoc_insertion_point(field_set_allocated:sg.UserMapService.MapResponse.area_list)
}

// optional .sg.MapEntryList entry_list = 3;
inline bool UserMapService_MapResponse::has_entry_list() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserMapService_MapResponse::set_has_entry_list() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserMapService_MapResponse::clear_has_entry_list() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserMapService_MapResponse::clear_entry_list() {
  if (entry_list_ != NULL) entry_list_->Clear();
  clear_has_entry_list();
}
inline const ::sg::MapEntryList& UserMapService_MapResponse::_internal_entry_list() const {
  return *entry_list_;
}
inline const ::sg::MapEntryList& UserMapService_MapResponse::entry_list() const {
  const ::sg::MapEntryList* p = entry_list_;
  // @@protoc_insertion_point(field_get:sg.UserMapService.MapResponse.entry_list)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::MapEntryList*>(
      &::sg::_MapEntryList_default_instance_);
}
inline ::sg::MapEntryList* UserMapService_MapResponse::release_entry_list() {
  // @@protoc_insertion_point(field_release:sg.UserMapService.MapResponse.entry_list)
  clear_has_entry_list();
  ::sg::MapEntryList* temp = entry_list_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  entry_list_ = NULL;
  return temp;
}
inline ::sg::MapEntryList* UserMapService_MapResponse::unsafe_arena_release_entry_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.UserMapService.MapResponse.entry_list)
  clear_has_entry_list();
  ::sg::MapEntryList* temp = entry_list_;
  entry_list_ = NULL;
  return temp;
}
inline ::sg::MapEntryList* UserMapService_MapResponse::mutable_entry_list() {
  set_has_entry_list();
  if (entry_list_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::MapEntryList>(GetArenaNoVirtual());
    entry_list_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.UserMapService.MapResponse.entry_list)
  return entry_list_;
}
inline void UserMapService_MapResponse::set_allocated_entry_list(::sg::MapEntryList* entry_list) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete entry_list_;
  }
  if (entry_list) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(entry_list);
    if (message_arena != submessage_arena) {
      entry_list = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, entry_list, submessage_arena);
    }
    set_has_entry_list();
  } else {
    clear_has_entry_list();
  }
  entry_list_ = entry_list;
  // @@protoc_insertion_point(field_set_allocated:sg.UserMapService.MapResponse.entry_list)
}

// optional .sg.WildIslandList island_list = 4;
inline bool UserMapService_MapResponse::has_island_list() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserMapService_MapResponse::set_has_island_list() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserMapService_MapResponse::clear_has_island_list() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserMapService_MapResponse::clear_island_list() {
  if (island_list_ != NULL) island_list_->Clear();
  clear_has_island_list();
}
inline const ::sg::WildIslandList& UserMapService_MapResponse::_internal_island_list() const {
  return *island_list_;
}
inline const ::sg::WildIslandList& UserMapService_MapResponse::island_list() const {
  const ::sg::WildIslandList* p = island_list_;
  // @@protoc_insertion_point(field_get:sg.UserMapService.MapResponse.island_list)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::WildIslandList*>(
      &::sg::_WildIslandList_default_instance_);
}
inline ::sg::WildIslandList* UserMapService_MapResponse::release_island_list() {
  // @@protoc_insertion_point(field_release:sg.UserMapService.MapResponse.island_list)
  clear_has_island_list();
  ::sg::WildIslandList* temp = island_list_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  island_list_ = NULL;
  return temp;
}
inline ::sg::WildIslandList* UserMapService_MapResponse::unsafe_arena_release_island_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.UserMapService.MapResponse.island_list)
  clear_has_island_list();
  ::sg::WildIslandList* temp = island_list_;
  island_list_ = NULL;
  return temp;
}
inline ::sg::WildIslandList* UserMapService_MapResponse::mutable_island_list() {
  set_has_island_list();
  if (island_list_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::WildIslandList>(GetArenaNoVirtual());
    island_list_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.UserMapService.MapResponse.island_list)
  return island_list_;
}
inline void UserMapService_MapResponse::set_allocated_island_list(::sg::WildIslandList* island_list) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete island_list_;
  }
  if (island_list) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(island_list);
    if (message_arena != submessage_arena) {
      island_list = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, island_list, submessage_arena);
    }
    set_has_island_list();
  } else {
    clear_has_island_list();
  }
  island_list_ = island_list;
  // @@protoc_insertion_point(field_set_allocated:sg.UserMapService.MapResponse.island_list)
}

// optional .sg.WildIslandHarvestLog harvest_log = 11;
inline bool UserMapService_MapResponse::has_harvest_log() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserMapService_MapResponse::set_has_harvest_log() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserMapService_MapResponse::clear_has_harvest_log() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserMapService_MapResponse::clear_harvest_log() {
  if (harvest_log_ != NULL) harvest_log_->Clear();
  clear_has_harvest_log();
}
inline const ::sg::WildIslandHarvestLog& UserMapService_MapResponse::_internal_harvest_log() const {
  return *harvest_log_;
}
inline const ::sg::WildIslandHarvestLog& UserMapService_MapResponse::harvest_log() const {
  const ::sg::WildIslandHarvestLog* p = harvest_log_;
  // @@protoc_insertion_point(field_get:sg.UserMapService.MapResponse.harvest_log)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::WildIslandHarvestLog*>(
      &::sg::_WildIslandHarvestLog_default_instance_);
}
inline ::sg::WildIslandHarvestLog* UserMapService_MapResponse::release_harvest_log() {
  // @@protoc_insertion_point(field_release:sg.UserMapService.MapResponse.harvest_log)
  clear_has_harvest_log();
  ::sg::WildIslandHarvestLog* temp = harvest_log_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  harvest_log_ = NULL;
  return temp;
}
inline ::sg::WildIslandHarvestLog* UserMapService_MapResponse::unsafe_arena_release_harvest_log() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.UserMapService.MapResponse.harvest_log)
  clear_has_harvest_log();
  ::sg::WildIslandHarvestLog* temp = harvest_log_;
  harvest_log_ = NULL;
  return temp;
}
inline ::sg::WildIslandHarvestLog* UserMapService_MapResponse::mutable_harvest_log() {
  set_has_harvest_log();
  if (harvest_log_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::WildIslandHarvestLog>(GetArenaNoVirtual());
    harvest_log_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.UserMapService.MapResponse.harvest_log)
  return harvest_log_;
}
inline void UserMapService_MapResponse::set_allocated_harvest_log(::sg::WildIslandHarvestLog* harvest_log) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete harvest_log_;
  }
  if (harvest_log) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(harvest_log);
    if (message_arena != submessage_arena) {
      harvest_log = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, harvest_log, submessage_arena);
    }
    set_has_harvest_log();
  } else {
    clear_has_harvest_log();
  }
  harvest_log_ = harvest_log;
  // @@protoc_insertion_point(field_set_allocated:sg.UserMapService.MapResponse.harvest_log)
}

// repeated .sg.HarvestTime harvest_time = 12;
inline int UserMapService_MapResponse::harvest_time_size() const {
  return harvest_time_.size();
}
inline void UserMapService_MapResponse::clear_harvest_time() {
  harvest_time_.Clear();
}
inline ::sg::HarvestTime* UserMapService_MapResponse::mutable_harvest_time(int index) {
  // @@protoc_insertion_point(field_mutable:sg.UserMapService.MapResponse.harvest_time)
  return harvest_time_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::HarvestTime >*
UserMapService_MapResponse::mutable_harvest_time() {
  // @@protoc_insertion_point(field_mutable_list:sg.UserMapService.MapResponse.harvest_time)
  return &harvest_time_;
}
inline const ::sg::HarvestTime& UserMapService_MapResponse::harvest_time(int index) const {
  // @@protoc_insertion_point(field_get:sg.UserMapService.MapResponse.harvest_time)
  return harvest_time_.Get(index);
}
inline ::sg::HarvestTime* UserMapService_MapResponse::add_harvest_time() {
  // @@protoc_insertion_point(field_add:sg.UserMapService.MapResponse.harvest_time)
  return harvest_time_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::HarvestTime >&
UserMapService_MapResponse::harvest_time() const {
  // @@protoc_insertion_point(field_list:sg.UserMapService.MapResponse.harvest_time)
  return harvest_time_;
}

// optional int32 cfg_harvest_interval_seconds = 13;
inline bool UserMapService_MapResponse::has_cfg_harvest_interval_seconds() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserMapService_MapResponse::set_has_cfg_harvest_interval_seconds() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserMapService_MapResponse::clear_has_cfg_harvest_interval_seconds() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserMapService_MapResponse::clear_cfg_harvest_interval_seconds() {
  cfg_harvest_interval_seconds_ = 0;
  clear_has_cfg_harvest_interval_seconds();
}
inline ::google::protobuf::int32 UserMapService_MapResponse::cfg_harvest_interval_seconds() const {
  // @@protoc_insertion_point(field_get:sg.UserMapService.MapResponse.cfg_harvest_interval_seconds)
  return cfg_harvest_interval_seconds_;
}
inline void UserMapService_MapResponse::set_cfg_harvest_interval_seconds(::google::protobuf::int32 value) {
  set_has_cfg_harvest_interval_seconds();
  cfg_harvest_interval_seconds_ = value;
  // @@protoc_insertion_point(field_set:sg.UserMapService.MapResponse.cfg_harvest_interval_seconds)
}

// -------------------------------------------------------------------

// UserMapService

// optional .sg.UserMapService.MapRequest req = 1;
inline bool UserMapService::has_req() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserMapService::set_has_req() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserMapService::clear_has_req() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserMapService::clear_req() {
  if (req_ != NULL) req_->Clear();
  clear_has_req();
}
inline const ::sg::UserMapService_MapRequest& UserMapService::_internal_req() const {
  return *req_;
}
inline const ::sg::UserMapService_MapRequest& UserMapService::req() const {
  const ::sg::UserMapService_MapRequest* p = req_;
  // @@protoc_insertion_point(field_get:sg.UserMapService.req)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::UserMapService_MapRequest*>(
      &::sg::_UserMapService_MapRequest_default_instance_);
}
inline ::sg::UserMapService_MapRequest* UserMapService::release_req() {
  // @@protoc_insertion_point(field_release:sg.UserMapService.req)
  clear_has_req();
  ::sg::UserMapService_MapRequest* temp = req_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  req_ = NULL;
  return temp;
}
inline ::sg::UserMapService_MapRequest* UserMapService::unsafe_arena_release_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.UserMapService.req)
  clear_has_req();
  ::sg::UserMapService_MapRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline ::sg::UserMapService_MapRequest* UserMapService::mutable_req() {
  set_has_req();
  if (req_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::UserMapService_MapRequest>(GetArenaNoVirtual());
    req_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.UserMapService.req)
  return req_;
}
inline void UserMapService::set_allocated_req(::sg::UserMapService_MapRequest* req) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete req_;
  }
  if (req) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(req);
    if (message_arena != submessage_arena) {
      req = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, req, submessage_arena);
    }
    set_has_req();
  } else {
    clear_has_req();
  }
  req_ = req;
  // @@protoc_insertion_point(field_set_allocated:sg.UserMapService.req)
}

// optional .sg.UserMapService.MapResponse resp = 2;
inline bool UserMapService::has_resp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserMapService::set_has_resp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserMapService::clear_has_resp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserMapService::clear_resp() {
  if (resp_ != NULL) resp_->Clear();
  clear_has_resp();
}
inline const ::sg::UserMapService_MapResponse& UserMapService::_internal_resp() const {
  return *resp_;
}
inline const ::sg::UserMapService_MapResponse& UserMapService::resp() const {
  const ::sg::UserMapService_MapResponse* p = resp_;
  // @@protoc_insertion_point(field_get:sg.UserMapService.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::UserMapService_MapResponse*>(
      &::sg::_UserMapService_MapResponse_default_instance_);
}
inline ::sg::UserMapService_MapResponse* UserMapService::release_resp() {
  // @@protoc_insertion_point(field_release:sg.UserMapService.resp)
  clear_has_resp();
  ::sg::UserMapService_MapResponse* temp = resp_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  resp_ = NULL;
  return temp;
}
inline ::sg::UserMapService_MapResponse* UserMapService::unsafe_arena_release_resp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.UserMapService.resp)
  clear_has_resp();
  ::sg::UserMapService_MapResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline ::sg::UserMapService_MapResponse* UserMapService::mutable_resp() {
  set_has_resp();
  if (resp_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::UserMapService_MapResponse>(GetArenaNoVirtual());
    resp_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.UserMapService.resp)
  return resp_;
}
inline void UserMapService::set_allocated_resp(::sg::UserMapService_MapResponse* resp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete resp_;
  }
  if (resp) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(resp);
    if (message_arena != submessage_arena) {
      resp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, resp, submessage_arena);
    }
    set_has_resp();
  } else {
    clear_has_resp();
  }
  resp_ = resp;
  // @@protoc_insertion_point(field_set_allocated:sg.UserMapService.resp)
}

// -------------------------------------------------------------------

// MapEntryStateNotify

// optional .sg.MapEntryList entry_list = 1;
inline bool MapEntryStateNotify::has_entry_list() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapEntryStateNotify::set_has_entry_list() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapEntryStateNotify::clear_has_entry_list() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapEntryStateNotify::clear_entry_list() {
  if (entry_list_ != NULL) entry_list_->Clear();
  clear_has_entry_list();
}
inline const ::sg::MapEntryList& MapEntryStateNotify::_internal_entry_list() const {
  return *entry_list_;
}
inline const ::sg::MapEntryList& MapEntryStateNotify::entry_list() const {
  const ::sg::MapEntryList* p = entry_list_;
  // @@protoc_insertion_point(field_get:sg.MapEntryStateNotify.entry_list)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::MapEntryList*>(
      &::sg::_MapEntryList_default_instance_);
}
inline ::sg::MapEntryList* MapEntryStateNotify::release_entry_list() {
  // @@protoc_insertion_point(field_release:sg.MapEntryStateNotify.entry_list)
  clear_has_entry_list();
  ::sg::MapEntryList* temp = entry_list_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  entry_list_ = NULL;
  return temp;
}
inline ::sg::MapEntryList* MapEntryStateNotify::unsafe_arena_release_entry_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.MapEntryStateNotify.entry_list)
  clear_has_entry_list();
  ::sg::MapEntryList* temp = entry_list_;
  entry_list_ = NULL;
  return temp;
}
inline ::sg::MapEntryList* MapEntryStateNotify::mutable_entry_list() {
  set_has_entry_list();
  if (entry_list_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::MapEntryList>(GetArenaNoVirtual());
    entry_list_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.MapEntryStateNotify.entry_list)
  return entry_list_;
}
inline void MapEntryStateNotify::set_allocated_entry_list(::sg::MapEntryList* entry_list) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete entry_list_;
  }
  if (entry_list) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(entry_list);
    if (message_arena != submessage_arena) {
      entry_list = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, entry_list, submessage_arena);
    }
    set_has_entry_list();
  } else {
    clear_has_entry_list();
  }
  entry_list_ = entry_list;
  // @@protoc_insertion_point(field_set_allocated:sg.MapEntryStateNotify.entry_list)
}

// -------------------------------------------------------------------

// WildIslandStateNotify

// required .sg.WildIslandList island_list = 1;
inline bool WildIslandStateNotify::has_island_list() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WildIslandStateNotify::set_has_island_list() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WildIslandStateNotify::clear_has_island_list() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WildIslandStateNotify::clear_island_list() {
  if (island_list_ != NULL) island_list_->Clear();
  clear_has_island_list();
}
inline const ::sg::WildIslandList& WildIslandStateNotify::_internal_island_list() const {
  return *island_list_;
}
inline const ::sg::WildIslandList& WildIslandStateNotify::island_list() const {
  const ::sg::WildIslandList* p = island_list_;
  // @@protoc_insertion_point(field_get:sg.WildIslandStateNotify.island_list)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::WildIslandList*>(
      &::sg::_WildIslandList_default_instance_);
}
inline ::sg::WildIslandList* WildIslandStateNotify::release_island_list() {
  // @@protoc_insertion_point(field_release:sg.WildIslandStateNotify.island_list)
  clear_has_island_list();
  ::sg::WildIslandList* temp = island_list_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  island_list_ = NULL;
  return temp;
}
inline ::sg::WildIslandList* WildIslandStateNotify::unsafe_arena_release_island_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.WildIslandStateNotify.island_list)
  clear_has_island_list();
  ::sg::WildIslandList* temp = island_list_;
  island_list_ = NULL;
  return temp;
}
inline ::sg::WildIslandList* WildIslandStateNotify::mutable_island_list() {
  set_has_island_list();
  if (island_list_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::WildIslandList>(GetArenaNoVirtual());
    island_list_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.WildIslandStateNotify.island_list)
  return island_list_;
}
inline void WildIslandStateNotify::set_allocated_island_list(::sg::WildIslandList* island_list) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete island_list_;
  }
  if (island_list) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(island_list);
    if (message_arena != submessage_arena) {
      island_list = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, island_list, submessage_arena);
    }
    set_has_island_list();
  } else {
    clear_has_island_list();
  }
  island_list_ = island_list;
  // @@protoc_insertion_point(field_set_allocated:sg.WildIslandStateNotify.island_list)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace sg

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::sg::UserMapService_MAP_COMMAND> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::UserMapService_MAP_COMMAND>() {
  return ::sg::UserMapService_MAP_COMMAND_descriptor();
}
template <> struct is_proto_enum< ::sg::MAP_AREA_UNLOCK_COND> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::MAP_AREA_UNLOCK_COND>() {
  return ::sg::MAP_AREA_UNLOCK_COND_descriptor();
}
template <> struct is_proto_enum< ::sg::MAP_AREA_UNLOCK_TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::MAP_AREA_UNLOCK_TYPE>() {
  return ::sg::MAP_AREA_UNLOCK_TYPE_descriptor();
}
template <> struct is_proto_enum< ::sg::MAP_AREA_UNLOCK_STATE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::MAP_AREA_UNLOCK_STATE>() {
  return ::sg::MAP_AREA_UNLOCK_STATE_descriptor();
}
template <> struct is_proto_enum< ::sg::MAP_ENTRY_TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::MAP_ENTRY_TYPE>() {
  return ::sg::MAP_ENTRY_TYPE_descriptor();
}
template <> struct is_proto_enum< ::sg::MAP_ENTRY_STATE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::MAP_ENTRY_STATE>() {
  return ::sg::MAP_ENTRY_STATE_descriptor();
}
template <> struct is_proto_enum< ::sg::MAP_ENTRY_OWNERSHIP_STATE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::MAP_ENTRY_OWNERSHIP_STATE>() {
  return ::sg::MAP_ENTRY_OWNERSHIP_STATE_descriptor();
}
template <> struct is_proto_enum< ::sg::MAP_ENTRY_HARVEST_TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::MAP_ENTRY_HARVEST_TYPE>() {
  return ::sg::MAP_ENTRY_HARVEST_TYPE_descriptor();
}
template <> struct is_proto_enum< ::sg::WILD_ISLAND_TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::WILD_ISLAND_TYPE>() {
  return ::sg::WILD_ISLAND_TYPE_descriptor();
}
template <> struct is_proto_enum< ::sg::WILD_ISLAND_STATE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::WILD_ISLAND_STATE>() {
  return ::sg::WILD_ISLAND_STATE_descriptor();
}
template <> struct is_proto_enum< ::sg::WILD_ISLAND_GATHER_STATE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::WILD_ISLAND_GATHER_STATE>() {
  return ::sg::WILD_ISLAND_GATHER_STATE_descriptor();
}
template <> struct is_proto_enum< ::sg::WILD_ISLAND_WORKSHOP_STATE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::WILD_ISLAND_WORKSHOP_STATE>() {
  return ::sg::WILD_ISLAND_WORKSHOP_STATE_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_UserMap_2eproto
