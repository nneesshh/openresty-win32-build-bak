// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: BaseStruct.proto

#ifndef PROTOBUF_INCLUDED_BaseStruct_2eproto
#define PROTOBUF_INCLUDED_BaseStruct_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_BaseStruct_2eproto 

namespace protobuf_BaseStruct_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[24];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_BaseStruct_2eproto
namespace sg {
class Equip;
class EquipDefaultTypeInternal;
extern EquipDefaultTypeInternal _Equip_default_instance_;
class Equip_EquipAttributeSlot;
class Equip_EquipAttributeSlotDefaultTypeInternal;
extern Equip_EquipAttributeSlotDefaultTypeInternal _Equip_EquipAttributeSlot_default_instance_;
class Equip_SpecialAttribute;
class Equip_SpecialAttributeDefaultTypeInternal;
extern Equip_SpecialAttributeDefaultTypeInternal _Equip_SpecialAttribute_default_instance_;
class Facility;
class FacilityDefaultTypeInternal;
extern FacilityDefaultTypeInternal _Facility_default_instance_;
class Facility_OrderSlot;
class Facility_OrderSlotDefaultTypeInternal;
extern Facility_OrderSlotDefaultTypeInternal _Facility_OrderSlot_default_instance_;
class Facility_SpecialData;
class Facility_SpecialDataDefaultTypeInternal;
extern Facility_SpecialDataDefaultTypeInternal _Facility_SpecialData_default_instance_;
class Item;
class ItemDefaultTypeInternal;
extern ItemDefaultTypeInternal _Item_default_instance_;
class Locale;
class LocaleDefaultTypeInternal;
extern LocaleDefaultTypeInternal _Locale_default_instance_;
class NPC;
class NPCDefaultTypeInternal;
extern NPCDefaultTypeInternal _NPC_default_instance_;
class RegionState;
class RegionStateDefaultTypeInternal;
extern RegionStateDefaultTypeInternal _RegionState_default_instance_;
class Reward;
class RewardDefaultTypeInternal;
extern RewardDefaultTypeInternal _Reward_default_instance_;
class Sailor;
class SailorDefaultTypeInternal;
extern SailorDefaultTypeInternal _Sailor_default_instance_;
class SailorFarmSkill;
class SailorFarmSkillDefaultTypeInternal;
extern SailorFarmSkillDefaultTypeInternal _SailorFarmSkill_default_instance_;
class SailorSkill;
class SailorSkillDefaultTypeInternal;
extern SailorSkillDefaultTypeInternal _SailorSkill_default_instance_;
class SailorTalent;
class SailorTalentDefaultTypeInternal;
extern SailorTalentDefaultTypeInternal _SailorTalent_default_instance_;
class SpecialEventNotify;
class SpecialEventNotifyDefaultTypeInternal;
extern SpecialEventNotifyDefaultTypeInternal _SpecialEventNotify_default_instance_;
class UserInfo;
class UserInfoDefaultTypeInternal;
extern UserInfoDefaultTypeInternal _UserInfo_default_instance_;
class UserRoom;
class UserRoomDefaultTypeInternal;
extern UserRoomDefaultTypeInternal _UserRoom_default_instance_;
class UserState;
class UserStateDefaultTypeInternal;
extern UserStateDefaultTypeInternal _UserState_default_instance_;
class pb_pair_int64_int;
class pb_pair_int64_intDefaultTypeInternal;
extern pb_pair_int64_intDefaultTypeInternal _pb_pair_int64_int_default_instance_;
class pb_pair_int_float;
class pb_pair_int_floatDefaultTypeInternal;
extern pb_pair_int_floatDefaultTypeInternal _pb_pair_int_float_default_instance_;
class pb_pair_int_int;
class pb_pair_int_intDefaultTypeInternal;
extern pb_pair_int_intDefaultTypeInternal _pb_pair_int_int_default_instance_;
class pb_pair_int_time;
class pb_pair_int_timeDefaultTypeInternal;
extern pb_pair_int_timeDefaultTypeInternal _pb_pair_int_time_default_instance_;
class pb_pair_string_int;
class pb_pair_string_intDefaultTypeInternal;
extern pb_pair_string_intDefaultTypeInternal _pb_pair_string_int_default_instance_;
}  // namespace sg
namespace google {
namespace protobuf {
template<> ::sg::Equip* Arena::CreateMaybeMessage<::sg::Equip>(Arena*);
template<> ::sg::Equip_EquipAttributeSlot* Arena::CreateMaybeMessage<::sg::Equip_EquipAttributeSlot>(Arena*);
template<> ::sg::Equip_SpecialAttribute* Arena::CreateMaybeMessage<::sg::Equip_SpecialAttribute>(Arena*);
template<> ::sg::Facility* Arena::CreateMaybeMessage<::sg::Facility>(Arena*);
template<> ::sg::Facility_OrderSlot* Arena::CreateMaybeMessage<::sg::Facility_OrderSlot>(Arena*);
template<> ::sg::Facility_SpecialData* Arena::CreateMaybeMessage<::sg::Facility_SpecialData>(Arena*);
template<> ::sg::Item* Arena::CreateMaybeMessage<::sg::Item>(Arena*);
template<> ::sg::Locale* Arena::CreateMaybeMessage<::sg::Locale>(Arena*);
template<> ::sg::NPC* Arena::CreateMaybeMessage<::sg::NPC>(Arena*);
template<> ::sg::RegionState* Arena::CreateMaybeMessage<::sg::RegionState>(Arena*);
template<> ::sg::Reward* Arena::CreateMaybeMessage<::sg::Reward>(Arena*);
template<> ::sg::Sailor* Arena::CreateMaybeMessage<::sg::Sailor>(Arena*);
template<> ::sg::SailorFarmSkill* Arena::CreateMaybeMessage<::sg::SailorFarmSkill>(Arena*);
template<> ::sg::SailorSkill* Arena::CreateMaybeMessage<::sg::SailorSkill>(Arena*);
template<> ::sg::SailorTalent* Arena::CreateMaybeMessage<::sg::SailorTalent>(Arena*);
template<> ::sg::SpecialEventNotify* Arena::CreateMaybeMessage<::sg::SpecialEventNotify>(Arena*);
template<> ::sg::UserInfo* Arena::CreateMaybeMessage<::sg::UserInfo>(Arena*);
template<> ::sg::UserRoom* Arena::CreateMaybeMessage<::sg::UserRoom>(Arena*);
template<> ::sg::UserState* Arena::CreateMaybeMessage<::sg::UserState>(Arena*);
template<> ::sg::pb_pair_int64_int* Arena::CreateMaybeMessage<::sg::pb_pair_int64_int>(Arena*);
template<> ::sg::pb_pair_int_float* Arena::CreateMaybeMessage<::sg::pb_pair_int_float>(Arena*);
template<> ::sg::pb_pair_int_int* Arena::CreateMaybeMessage<::sg::pb_pair_int_int>(Arena*);
template<> ::sg::pb_pair_int_time* Arena::CreateMaybeMessage<::sg::pb_pair_int_time>(Arena*);
template<> ::sg::pb_pair_string_int* Arena::CreateMaybeMessage<::sg::pb_pair_string_int>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace sg {

enum GAME_GOODS_TYPE {
  GAME_GOODS_TYPE_ITEM = 1,
  GAME_GOODS_TYPE_SAILOR = 2,
  GAME_GOODS_TYPE_SHIP_MODEL = 3,
  GAME_GOODS_TYPE_DEVICE = 4,
  GAME_GOODS_TYPE_FORMULA = 5,
  GAME_GOODS_TYPE_MONTH_CARD = 6,
  GAME_GOODS_TYPE_MAP = 7,
  GAME_GOODS_TYPE_EQUIP = 8,
  GAME_GOODS_TYPE_TREASURE_TICKET = 9,
  GAME_GOODS_TYPE_GROW_GIFT = 10,
  GAME_GOODS_CUSTOMER = 11
};
bool GAME_GOODS_TYPE_IsValid(int value);
const GAME_GOODS_TYPE GAME_GOODS_TYPE_MIN = GAME_GOODS_TYPE_ITEM;
const GAME_GOODS_TYPE GAME_GOODS_TYPE_MAX = GAME_GOODS_CUSTOMER;
const int GAME_GOODS_TYPE_ARRAYSIZE = GAME_GOODS_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* GAME_GOODS_TYPE_descriptor();
inline const ::std::string& GAME_GOODS_TYPE_Name(GAME_GOODS_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    GAME_GOODS_TYPE_descriptor(), value);
}
inline bool GAME_GOODS_TYPE_Parse(
    const ::std::string& name, GAME_GOODS_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GAME_GOODS_TYPE>(
    GAME_GOODS_TYPE_descriptor(), name, value);
}
enum ROOM_TYPE {
  ROOM_NONE = 0,
  ROOM_EMPTY = 1,
  ROOM_STOREHOUSE = 2,
  ROOM_KITCHEN = 3,
  ROOM_MAGAZINE = 4,
  ROOM_BREED = 5,
  ROOM_CULTIVATE = 6,
  ROOM_RESTAURANT = 7,
  ROOM_FACTORY = 8,
  ROOM_STATUE = 9,
  ROOM_SMITHY = 10,
  ROOM_POWER = 11,
  ROOM_BEDROOM = 12,
  ROOM_REST = 13,
  ROOM_SHRINE = 14,
  ROOM_LABORATORY = 15,
  ROOM_VINTRY = 16,
  ROOM_TRAIN = 17,
  ROOM_CELL = 18,
  ROOM_BOARD = 19,
  ROOM_ENTER = 20,
  ROOM_CAPTAIN = 21,
  ROOM_TASK = 22,
  ROOM_PLAY = 23,
  ROOM_CRAFT = 24,
  ROOM_STORE = 25,
  ROOM_SEWING = 26,
  ROOM_COLLECTION_1 = 28,
  ROOM_COLLECTION_2 = 30,
  ROOM_COLLECTION_3 = 33,
  ROOM_WOOD = 101,
  ROOM_STONE_ORE = 102,
  ROOM_GOLD_ORE = 103,
  ROOM_IRON_ORE = 104
};
bool ROOM_TYPE_IsValid(int value);
const ROOM_TYPE ROOM_TYPE_MIN = ROOM_NONE;
const ROOM_TYPE ROOM_TYPE_MAX = ROOM_IRON_ORE;
const int ROOM_TYPE_ARRAYSIZE = ROOM_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* ROOM_TYPE_descriptor();
inline const ::std::string& ROOM_TYPE_Name(ROOM_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    ROOM_TYPE_descriptor(), value);
}
inline bool ROOM_TYPE_Parse(
    const ::std::string& name, ROOM_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ROOM_TYPE>(
    ROOM_TYPE_descriptor(), name, value);
}
enum SAILOR_STATE {
  SAILOR_STATE_NONE = 0,
  SAILOR_STATE_IDLE = 1,
  SAILOR_STATE_WORKING = 101,
  SAILOR_STATE_DO_EVENT = 102,
  SAILOR_STATE_COOKING = 103,
  SAILOR_STATE_REST = 205,
  SAILOR_STATE_SLEEP = 206,
  SAILOR_STATE_SLEEP_WITHOUT_BED = 207,
  SAILOR_STATE_SENDING = 307,
  SAILOR_STATE_DEFENDING = 1000
};
bool SAILOR_STATE_IsValid(int value);
const SAILOR_STATE SAILOR_STATE_MIN = SAILOR_STATE_NONE;
const SAILOR_STATE SAILOR_STATE_MAX = SAILOR_STATE_DEFENDING;
const int SAILOR_STATE_ARRAYSIZE = SAILOR_STATE_MAX + 1;

const ::google::protobuf::EnumDescriptor* SAILOR_STATE_descriptor();
inline const ::std::string& SAILOR_STATE_Name(SAILOR_STATE value) {
  return ::google::protobuf::internal::NameOfEnum(
    SAILOR_STATE_descriptor(), value);
}
inline bool SAILOR_STATE_Parse(
    const ::std::string& name, SAILOR_STATE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SAILOR_STATE>(
    SAILOR_STATE_descriptor(), name, value);
}
enum SAILOR_SKILL_TYPE {
  SAILOR_SKILL_TYPE_FALL = 1,
  SAILOR_SKILL_TYPE_BUFF = 2,
  SAILOR_SKILL_TYPE_SELF = 3
};
bool SAILOR_SKILL_TYPE_IsValid(int value);
const SAILOR_SKILL_TYPE SAILOR_SKILL_TYPE_MIN = SAILOR_SKILL_TYPE_FALL;
const SAILOR_SKILL_TYPE SAILOR_SKILL_TYPE_MAX = SAILOR_SKILL_TYPE_SELF;
const int SAILOR_SKILL_TYPE_ARRAYSIZE = SAILOR_SKILL_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* SAILOR_SKILL_TYPE_descriptor();
inline const ::std::string& SAILOR_SKILL_TYPE_Name(SAILOR_SKILL_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    SAILOR_SKILL_TYPE_descriptor(), value);
}
inline bool SAILOR_SKILL_TYPE_Parse(
    const ::std::string& name, SAILOR_SKILL_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SAILOR_SKILL_TYPE>(
    SAILOR_SKILL_TYPE_descriptor(), name, value);
}
// ===================================================================

class UserRoom : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.UserRoom) */ {
 public:
  UserRoom();
  virtual ~UserRoom();

  UserRoom(const UserRoom& from);

  inline UserRoom& operator=(const UserRoom& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserRoom(UserRoom&& from) noexcept
    : UserRoom() {
    *this = ::std::move(from);
  }

  inline UserRoom& operator=(UserRoom&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserRoom& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserRoom* internal_default_instance() {
    return reinterpret_cast<const UserRoom*>(
               &_UserRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void UnsafeArenaSwap(UserRoom* other);
  void Swap(UserRoom* other);
  friend void swap(UserRoom& a, UserRoom& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserRoom* New() const final {
    return CreateMaybeMessage<UserRoom>(NULL);
  }

  UserRoom* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserRoom>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserRoom& from);
  void MergeFrom(const UserRoom& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserRoom* other);
  protected:
  explicit UserRoom(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // required int32 room_type = 2;
  bool has_room_type() const;
  void clear_room_type();
  static const int kRoomTypeFieldNumber = 2;
  ::google::protobuf::int32 room_type() const;
  void set_room_type(::google::protobuf::int32 value);

  // optional int32 comfort = 3;
  bool has_comfort() const;
  void clear_comfort();
  static const int kComfortFieldNumber = 3;
  ::google::protobuf::int32 comfort() const;
  void set_comfort(::google::protobuf::int32 value);

  // optional int32 machine_capacity = 4;
  bool has_machine_capacity() const;
  void clear_machine_capacity();
  static const int kMachineCapacityFieldNumber = 4;
  ::google::protobuf::int32 machine_capacity() const;
  void set_machine_capacity(::google::protobuf::int32 value);

  // optional int32 machine_value = 5;
  bool has_machine_value() const;
  void clear_machine_value();
  static const int kMachineValueFieldNumber = 5;
  ::google::protobuf::int32 machine_value() const;
  void set_machine_value(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.UserRoom)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_room_type();
  void clear_has_room_type();
  void set_has_comfort();
  void clear_has_comfort();
  void set_has_machine_capacity();
  void clear_has_machine_capacity();
  void set_has_machine_value();
  void clear_has_machine_value();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 room_type_;
  ::google::protobuf::int32 comfort_;
  ::google::protobuf::int32 machine_capacity_;
  ::google::protobuf::int32 machine_value_;
  friend struct ::protobuf_BaseStruct_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Locale : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.Locale) */ {
 public:
  Locale();
  virtual ~Locale();

  Locale(const Locale& from);

  inline Locale& operator=(const Locale& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Locale(Locale&& from) noexcept
    : Locale() {
    *this = ::std::move(from);
  }

  inline Locale& operator=(Locale&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Locale& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Locale* internal_default_instance() {
    return reinterpret_cast<const Locale*>(
               &_Locale_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void UnsafeArenaSwap(Locale* other);
  void Swap(Locale* other);
  friend void swap(Locale& a, Locale& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Locale* New() const final {
    return CreateMaybeMessage<Locale>(NULL);
  }

  Locale* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Locale>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Locale& from);
  void MergeFrom(const Locale& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Locale* other);
  protected:
  explicit Locale(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 place_id = 1;
  bool has_place_id() const;
  void clear_place_id();
  static const int kPlaceIdFieldNumber = 1;
  ::google::protobuf::int32 place_id() const;
  void set_place_id(::google::protobuf::int32 value);

  // required int32 pos_type = 2;
  bool has_pos_type() const;
  void clear_pos_type();
  static const int kPosTypeFieldNumber = 2;
  ::google::protobuf::int32 pos_type() const;
  void set_pos_type(::google::protobuf::int32 value);

  // required int32 pos_x = 3;
  bool has_pos_x() const;
  void clear_pos_x();
  static const int kPosXFieldNumber = 3;
  ::google::protobuf::int32 pos_x() const;
  void set_pos_x(::google::protobuf::int32 value);

  // required int32 pos_y = 4;
  bool has_pos_y() const;
  void clear_pos_y();
  static const int kPosYFieldNumber = 4;
  ::google::protobuf::int32 pos_y() const;
  void set_pos_y(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.Locale)
 private:
  void set_has_place_id();
  void clear_has_place_id();
  void set_has_pos_type();
  void clear_has_pos_type();
  void set_has_pos_x();
  void clear_has_pos_x();
  void set_has_pos_y();
  void clear_has_pos_y();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 place_id_;
  ::google::protobuf::int32 pos_type_;
  ::google::protobuf::int32 pos_x_;
  ::google::protobuf::int32 pos_y_;
  friend struct ::protobuf_BaseStruct_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class pb_pair_int_int : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.pb_pair_int_int) */ {
 public:
  pb_pair_int_int();
  virtual ~pb_pair_int_int();

  pb_pair_int_int(const pb_pair_int_int& from);

  inline pb_pair_int_int& operator=(const pb_pair_int_int& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  pb_pair_int_int(pb_pair_int_int&& from) noexcept
    : pb_pair_int_int() {
    *this = ::std::move(from);
  }

  inline pb_pair_int_int& operator=(pb_pair_int_int&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const pb_pair_int_int& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const pb_pair_int_int* internal_default_instance() {
    return reinterpret_cast<const pb_pair_int_int*>(
               &_pb_pair_int_int_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void UnsafeArenaSwap(pb_pair_int_int* other);
  void Swap(pb_pair_int_int* other);
  friend void swap(pb_pair_int_int& a, pb_pair_int_int& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline pb_pair_int_int* New() const final {
    return CreateMaybeMessage<pb_pair_int_int>(NULL);
  }

  pb_pair_int_int* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<pb_pair_int_int>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const pb_pair_int_int& from);
  void MergeFrom(const pb_pair_int_int& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(pb_pair_int_int* other);
  protected:
  explicit pb_pair_int_int(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  ::google::protobuf::int32 key() const;
  void set_key(::google::protobuf::int32 value);

  // required int32 value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  ::google::protobuf::int32 value() const;
  void set_value(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.pb_pair_int_int)
 private:
  void set_has_key();
  void clear_has_key();
  void set_has_value();
  void clear_has_value();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 key_;
  ::google::protobuf::int32 value_;
  friend struct ::protobuf_BaseStruct_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class pb_pair_int_time : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.pb_pair_int_time) */ {
 public:
  pb_pair_int_time();
  virtual ~pb_pair_int_time();

  pb_pair_int_time(const pb_pair_int_time& from);

  inline pb_pair_int_time& operator=(const pb_pair_int_time& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  pb_pair_int_time(pb_pair_int_time&& from) noexcept
    : pb_pair_int_time() {
    *this = ::std::move(from);
  }

  inline pb_pair_int_time& operator=(pb_pair_int_time&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const pb_pair_int_time& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const pb_pair_int_time* internal_default_instance() {
    return reinterpret_cast<const pb_pair_int_time*>(
               &_pb_pair_int_time_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void UnsafeArenaSwap(pb_pair_int_time* other);
  void Swap(pb_pair_int_time* other);
  friend void swap(pb_pair_int_time& a, pb_pair_int_time& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline pb_pair_int_time* New() const final {
    return CreateMaybeMessage<pb_pair_int_time>(NULL);
  }

  pb_pair_int_time* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<pb_pair_int_time>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const pb_pair_int_time& from);
  void MergeFrom(const pb_pair_int_time& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(pb_pair_int_time* other);
  protected:
  explicit pb_pair_int_time(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required sfixed64 value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  ::google::protobuf::int64 value() const;
  void set_value(::google::protobuf::int64 value);

  // required int32 key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  ::google::protobuf::int32 key() const;
  void set_key(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.pb_pair_int_time)
 private:
  void set_has_key();
  void clear_has_key();
  void set_has_value();
  void clear_has_value();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int64 value_;
  ::google::protobuf::int32 key_;
  friend struct ::protobuf_BaseStruct_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class pb_pair_int64_int : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.pb_pair_int64_int) */ {
 public:
  pb_pair_int64_int();
  virtual ~pb_pair_int64_int();

  pb_pair_int64_int(const pb_pair_int64_int& from);

  inline pb_pair_int64_int& operator=(const pb_pair_int64_int& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  pb_pair_int64_int(pb_pair_int64_int&& from) noexcept
    : pb_pair_int64_int() {
    *this = ::std::move(from);
  }

  inline pb_pair_int64_int& operator=(pb_pair_int64_int&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const pb_pair_int64_int& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const pb_pair_int64_int* internal_default_instance() {
    return reinterpret_cast<const pb_pair_int64_int*>(
               &_pb_pair_int64_int_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void UnsafeArenaSwap(pb_pair_int64_int* other);
  void Swap(pb_pair_int64_int* other);
  friend void swap(pb_pair_int64_int& a, pb_pair_int64_int& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline pb_pair_int64_int* New() const final {
    return CreateMaybeMessage<pb_pair_int64_int>(NULL);
  }

  pb_pair_int64_int* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<pb_pair_int64_int>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const pb_pair_int64_int& from);
  void MergeFrom(const pb_pair_int64_int& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(pb_pair_int64_int* other);
  protected:
  explicit pb_pair_int64_int(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  ::google::protobuf::int64 key() const;
  void set_key(::google::protobuf::int64 value);

  // required int32 value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  ::google::protobuf::int32 value() const;
  void set_value(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.pb_pair_int64_int)
 private:
  void set_has_key();
  void clear_has_key();
  void set_has_value();
  void clear_has_value();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int64 key_;
  ::google::protobuf::int32 value_;
  friend struct ::protobuf_BaseStruct_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class pb_pair_string_int : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.pb_pair_string_int) */ {
 public:
  pb_pair_string_int();
  virtual ~pb_pair_string_int();

  pb_pair_string_int(const pb_pair_string_int& from);

  inline pb_pair_string_int& operator=(const pb_pair_string_int& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  pb_pair_string_int(pb_pair_string_int&& from) noexcept
    : pb_pair_string_int() {
    *this = ::std::move(from);
  }

  inline pb_pair_string_int& operator=(pb_pair_string_int&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const pb_pair_string_int& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const pb_pair_string_int* internal_default_instance() {
    return reinterpret_cast<const pb_pair_string_int*>(
               &_pb_pair_string_int_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void UnsafeArenaSwap(pb_pair_string_int* other);
  void Swap(pb_pair_string_int* other);
  friend void swap(pb_pair_string_int& a, pb_pair_string_int& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline pb_pair_string_int* New() const final {
    return CreateMaybeMessage<pb_pair_string_int>(NULL);
  }

  pb_pair_string_int* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<pb_pair_string_int>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const pb_pair_string_int& from);
  void MergeFrom(const pb_pair_string_int& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(pb_pair_string_int* other);
  protected:
  explicit pb_pair_string_int(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_key();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_key(
      ::std::string* key);

  // required int32 value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  ::google::protobuf::int32 value() const;
  void set_value(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.pb_pair_string_int)
 private:
  void set_has_key();
  void clear_has_key();
  void set_has_value();
  void clear_has_value();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::int32 value_;
  friend struct ::protobuf_BaseStruct_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class pb_pair_int_float : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.pb_pair_int_float) */ {
 public:
  pb_pair_int_float();
  virtual ~pb_pair_int_float();

  pb_pair_int_float(const pb_pair_int_float& from);

  inline pb_pair_int_float& operator=(const pb_pair_int_float& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  pb_pair_int_float(pb_pair_int_float&& from) noexcept
    : pb_pair_int_float() {
    *this = ::std::move(from);
  }

  inline pb_pair_int_float& operator=(pb_pair_int_float&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const pb_pair_int_float& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const pb_pair_int_float* internal_default_instance() {
    return reinterpret_cast<const pb_pair_int_float*>(
               &_pb_pair_int_float_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void UnsafeArenaSwap(pb_pair_int_float* other);
  void Swap(pb_pair_int_float* other);
  friend void swap(pb_pair_int_float& a, pb_pair_int_float& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline pb_pair_int_float* New() const final {
    return CreateMaybeMessage<pb_pair_int_float>(NULL);
  }

  pb_pair_int_float* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<pb_pair_int_float>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const pb_pair_int_float& from);
  void MergeFrom(const pb_pair_int_float& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(pb_pair_int_float* other);
  protected:
  explicit pb_pair_int_float(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  ::google::protobuf::int32 key() const;
  void set_key(::google::protobuf::int32 value);

  // required float value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  float value() const;
  void set_value(float value);

  // @@protoc_insertion_point(class_scope:sg.pb_pair_int_float)
 private:
  void set_has_key();
  void clear_has_key();
  void set_has_value();
  void clear_has_value();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 key_;
  float value_;
  friend struct ::protobuf_BaseStruct_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.UserInfo) */ {
 public:
  UserInfo();
  virtual ~UserInfo();

  UserInfo(const UserInfo& from);

  inline UserInfo& operator=(const UserInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserInfo(UserInfo&& from) noexcept
    : UserInfo() {
    *this = ::std::move(from);
  }

  inline UserInfo& operator=(UserInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserInfo* internal_default_instance() {
    return reinterpret_cast<const UserInfo*>(
               &_UserInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void UnsafeArenaSwap(UserInfo* other);
  void Swap(UserInfo* other);
  friend void swap(UserInfo& a, UserInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserInfo* New() const final {
    return CreateMaybeMessage<UserInfo>(NULL);
  }

  UserInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserInfo& from);
  void MergeFrom(const UserInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserInfo* other);
  protected:
  explicit UserInfo(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes nick = 3;
  bool has_nick() const;
  void clear_nick();
  static const int kNickFieldNumber = 3;
  const ::std::string& nick() const;
  void set_nick(const ::std::string& value);
  #if LANG_CXX11
  void set_nick(::std::string&& value);
  #endif
  void set_nick(const char* value);
  void set_nick(const void* value, size_t size);
  ::std::string* mutable_nick();
  ::std::string* release_nick();
  void set_allocated_nick(::std::string* nick);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_nick();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_nick(
      ::std::string* nick);

  // required bytes signature = 5;
  bool has_signature() const;
  void clear_signature();
  static const int kSignatureFieldNumber = 5;
  const ::std::string& signature() const;
  void set_signature(const ::std::string& value);
  #if LANG_CXX11
  void set_signature(::std::string&& value);
  #endif
  void set_signature(const char* value);
  void set_signature(const void* value, size_t size);
  ::std::string* mutable_signature();
  ::std::string* release_signature();
  void set_allocated_signature(::std::string* signature);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_signature();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_signature(
      ::std::string* signature);

  // required uint64 uuid = 1;
  bool has_uuid() const;
  void clear_uuid();
  static const int kUuidFieldNumber = 1;
  ::google::protobuf::uint64 uuid() const;
  void set_uuid(::google::protobuf::uint64 value);

  // required int32 level = 2;
  bool has_level() const;
  void clear_level();
  static const int kLevelFieldNumber = 2;
  ::google::protobuf::int32 level() const;
  void set_level(::google::protobuf::int32 value);

  // required int32 portrait = 4;
  bool has_portrait() const;
  void clear_portrait();
  static const int kPortraitFieldNumber = 4;
  ::google::protobuf::int32 portrait() const;
  void set_portrait(::google::protobuf::int32 value);

  // optional int32 portrait_frame = 6;
  bool has_portrait_frame() const;
  void clear_portrait_frame();
  static const int kPortraitFrameFieldNumber = 6;
  ::google::protobuf::int32 portrait_frame() const;
  void set_portrait_frame(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.UserInfo)
 private:
  void set_has_uuid();
  void clear_has_uuid();
  void set_has_level();
  void clear_has_level();
  void set_has_nick();
  void clear_has_nick();
  void set_has_portrait();
  void clear_has_portrait();
  void set_has_signature();
  void clear_has_signature();
  void set_has_portrait_frame();
  void clear_has_portrait_frame();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr nick_;
  ::google::protobuf::internal::ArenaStringPtr signature_;
  ::google::protobuf::uint64 uuid_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 portrait_;
  ::google::protobuf::int32 portrait_frame_;
  friend struct ::protobuf_BaseStruct_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.UserState) */ {
 public:
  UserState();
  virtual ~UserState();

  UserState(const UserState& from);

  inline UserState& operator=(const UserState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserState(UserState&& from) noexcept
    : UserState() {
    *this = ::std::move(from);
  }

  inline UserState& operator=(UserState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserState* internal_default_instance() {
    return reinterpret_cast<const UserState*>(
               &_UserState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void UnsafeArenaSwap(UserState* other);
  void Swap(UserState* other);
  friend void swap(UserState& a, UserState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserState* New() const final {
    return CreateMaybeMessage<UserState>(NULL);
  }

  UserState* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserState>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserState& from);
  void MergeFrom(const UserState& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserState* other);
  protected:
  explicit UserState(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes guide_val = 2;
  bool has_guide_val() const;
  void clear_guide_val();
  static const int kGuideValFieldNumber = 2;
  const ::std::string& guide_val() const;
  void set_guide_val(const ::std::string& value);
  #if LANG_CXX11
  void set_guide_val(::std::string&& value);
  #endif
  void set_guide_val(const char* value);
  void set_guide_val(const void* value, size_t size);
  ::std::string* mutable_guide_val();
  ::std::string* release_guide_val();
  void set_allocated_guide_val(::std::string* guide_val);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_guide_val();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_guide_val(
      ::std::string* guide_val);

  // optional int32 occupy_monster_ship_times = 3;
  bool has_occupy_monster_ship_times() const;
  void clear_occupy_monster_ship_times();
  static const int kOccupyMonsterShipTimesFieldNumber = 3;
  ::google::protobuf::int32 occupy_monster_ship_times() const;
  void set_occupy_monster_ship_times(::google::protobuf::int32 value);

  // optional int32 occupy_player_ship_times = 4;
  bool has_occupy_player_ship_times() const;
  void clear_occupy_player_ship_times();
  static const int kOccupyPlayerShipTimesFieldNumber = 4;
  ::google::protobuf::int32 occupy_player_ship_times() const;
  void set_occupy_player_ship_times(::google::protobuf::int32 value);

  // optional int32 occupy_special_ship_times = 5;
  bool has_occupy_special_ship_times() const;
  void clear_occupy_special_ship_times();
  static const int kOccupySpecialShipTimesFieldNumber = 5;
  ::google::protobuf::int32 occupy_special_ship_times() const;
  void set_occupy_special_ship_times(::google::protobuf::int32 value);

  // optional int32 max_occupy_monster_ship_times = 6;
  bool has_max_occupy_monster_ship_times() const;
  void clear_max_occupy_monster_ship_times();
  static const int kMaxOccupyMonsterShipTimesFieldNumber = 6;
  ::google::protobuf::int32 max_occupy_monster_ship_times() const;
  void set_max_occupy_monster_ship_times(::google::protobuf::int32 value);

  // optional int32 max_occupy_player_ship_times = 7;
  bool has_max_occupy_player_ship_times() const;
  void clear_max_occupy_player_ship_times();
  static const int kMaxOccupyPlayerShipTimesFieldNumber = 7;
  ::google::protobuf::int32 max_occupy_player_ship_times() const;
  void set_max_occupy_player_ship_times(::google::protobuf::int32 value);

  // optional int32 max_occupy_special_ship_times = 8;
  bool has_max_occupy_special_ship_times() const;
  void clear_max_occupy_special_ship_times();
  static const int kMaxOccupySpecialShipTimesFieldNumber = 8;
  ::google::protobuf::int32 max_occupy_special_ship_times() const;
  void set_max_occupy_special_ship_times(::google::protobuf::int32 value);

  // optional int32 daily_buy_vitality_times = 9;
  bool has_daily_buy_vitality_times() const;
  void clear_daily_buy_vitality_times();
  static const int kDailyBuyVitalityTimesFieldNumber = 9;
  ::google::protobuf::int32 daily_buy_vitality_times() const;
  void set_daily_buy_vitality_times(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.UserState)
 private:
  void set_has_guide_val();
  void clear_has_guide_val();
  void set_has_occupy_monster_ship_times();
  void clear_has_occupy_monster_ship_times();
  void set_has_occupy_player_ship_times();
  void clear_has_occupy_player_ship_times();
  void set_has_occupy_special_ship_times();
  void clear_has_occupy_special_ship_times();
  void set_has_max_occupy_monster_ship_times();
  void clear_has_max_occupy_monster_ship_times();
  void set_has_max_occupy_player_ship_times();
  void clear_has_max_occupy_player_ship_times();
  void set_has_max_occupy_special_ship_times();
  void clear_has_max_occupy_special_ship_times();
  void set_has_daily_buy_vitality_times();
  void clear_has_daily_buy_vitality_times();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr guide_val_;
  ::google::protobuf::int32 occupy_monster_ship_times_;
  ::google::protobuf::int32 occupy_player_ship_times_;
  ::google::protobuf::int32 occupy_special_ship_times_;
  ::google::protobuf::int32 max_occupy_monster_ship_times_;
  ::google::protobuf::int32 max_occupy_player_ship_times_;
  ::google::protobuf::int32 max_occupy_special_ship_times_;
  ::google::protobuf::int32 daily_buy_vitality_times_;
  friend struct ::protobuf_BaseStruct_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Equip_SpecialAttribute : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.Equip.SpecialAttribute) */ {
 public:
  Equip_SpecialAttribute();
  virtual ~Equip_SpecialAttribute();

  Equip_SpecialAttribute(const Equip_SpecialAttribute& from);

  inline Equip_SpecialAttribute& operator=(const Equip_SpecialAttribute& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Equip_SpecialAttribute(Equip_SpecialAttribute&& from) noexcept
    : Equip_SpecialAttribute() {
    *this = ::std::move(from);
  }

  inline Equip_SpecialAttribute& operator=(Equip_SpecialAttribute&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Equip_SpecialAttribute& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Equip_SpecialAttribute* internal_default_instance() {
    return reinterpret_cast<const Equip_SpecialAttribute*>(
               &_Equip_SpecialAttribute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void UnsafeArenaSwap(Equip_SpecialAttribute* other);
  void Swap(Equip_SpecialAttribute* other);
  friend void swap(Equip_SpecialAttribute& a, Equip_SpecialAttribute& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Equip_SpecialAttribute* New() const final {
    return CreateMaybeMessage<Equip_SpecialAttribute>(NULL);
  }

  Equip_SpecialAttribute* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Equip_SpecialAttribute>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Equip_SpecialAttribute& from);
  void MergeFrom(const Equip_SpecialAttribute& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Equip_SpecialAttribute* other);
  protected:
  explicit Equip_SpecialAttribute(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // required int32 target = 2;
  bool has_target() const;
  void clear_target();
  static const int kTargetFieldNumber = 2;
  ::google::protobuf::int32 target() const;
  void set_target(::google::protobuf::int32 value);

  // required float value = 3;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 3;
  float value() const;
  void set_value(float value);

  // @@protoc_insertion_point(class_scope:sg.Equip.SpecialAttribute)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_target();
  void clear_has_target();
  void set_has_value();
  void clear_has_value();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 target_;
  float value_;
  friend struct ::protobuf_BaseStruct_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Equip_EquipAttributeSlot : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.Equip.EquipAttributeSlot) */ {
 public:
  Equip_EquipAttributeSlot();
  virtual ~Equip_EquipAttributeSlot();

  Equip_EquipAttributeSlot(const Equip_EquipAttributeSlot& from);

  inline Equip_EquipAttributeSlot& operator=(const Equip_EquipAttributeSlot& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Equip_EquipAttributeSlot(Equip_EquipAttributeSlot&& from) noexcept
    : Equip_EquipAttributeSlot() {
    *this = ::std::move(from);
  }

  inline Equip_EquipAttributeSlot& operator=(Equip_EquipAttributeSlot&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Equip_EquipAttributeSlot& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Equip_EquipAttributeSlot* internal_default_instance() {
    return reinterpret_cast<const Equip_EquipAttributeSlot*>(
               &_Equip_EquipAttributeSlot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void UnsafeArenaSwap(Equip_EquipAttributeSlot* other);
  void Swap(Equip_EquipAttributeSlot* other);
  friend void swap(Equip_EquipAttributeSlot& a, Equip_EquipAttributeSlot& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Equip_EquipAttributeSlot* New() const final {
    return CreateMaybeMessage<Equip_EquipAttributeSlot>(NULL);
  }

  Equip_EquipAttributeSlot* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Equip_EquipAttributeSlot>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Equip_EquipAttributeSlot& from);
  void MergeFrom(const Equip_EquipAttributeSlot& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Equip_EquipAttributeSlot* other);
  protected:
  explicit Equip_EquipAttributeSlot(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // required int32 type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // required int32 typeid = 3;
  bool has_typeid_() const;
  void clear_typeid_();
  static const int kTypeidFieldNumber = 3;
  ::google::protobuf::int32 typeid_() const;
  void set_typeid_(::google::protobuf::int32 value);

  // required float value = 4;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 4;
  float value() const;
  void set_value(float value);

  // required int32 refine_times = 5;
  bool has_refine_times() const;
  void clear_refine_times();
  static const int kRefineTimesFieldNumber = 5;
  ::google::protobuf::int32 refine_times() const;
  void set_refine_times(::google::protobuf::int32 value);

  // optional bool big_success = 6;
  bool has_big_success() const;
  void clear_big_success();
  static const int kBigSuccessFieldNumber = 6;
  bool big_success() const;
  void set_big_success(bool value);

  // @@protoc_insertion_point(class_scope:sg.Equip.EquipAttributeSlot)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_type();
  void clear_has_type();
  void set_has_typeid_();
  void clear_has_typeid_();
  void set_has_value();
  void clear_has_value();
  void set_has_refine_times();
  void clear_has_refine_times();
  void set_has_big_success();
  void clear_has_big_success();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 typeid__;
  float value_;
  ::google::protobuf::int32 refine_times_;
  bool big_success_;
  friend struct ::protobuf_BaseStruct_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Equip : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.Equip) */ {
 public:
  Equip();
  virtual ~Equip();

  Equip(const Equip& from);

  inline Equip& operator=(const Equip& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Equip(Equip&& from) noexcept
    : Equip() {
    *this = ::std::move(from);
  }

  inline Equip& operator=(Equip&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Equip& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Equip* internal_default_instance() {
    return reinterpret_cast<const Equip*>(
               &_Equip_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void UnsafeArenaSwap(Equip* other);
  void Swap(Equip* other);
  friend void swap(Equip& a, Equip& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Equip* New() const final {
    return CreateMaybeMessage<Equip>(NULL);
  }

  Equip* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Equip>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Equip& from);
  void MergeFrom(const Equip& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Equip* other);
  protected:
  explicit Equip(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Equip_SpecialAttribute SpecialAttribute;
  typedef Equip_EquipAttributeSlot EquipAttributeSlot;

  // accessors -------------------------------------------------------

  // repeated .sg.pb_pair_int_float attribute = 6;
  int attribute_size() const;
  void clear_attribute();
  static const int kAttributeFieldNumber = 6;
  ::sg::pb_pair_int_float* mutable_attribute(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_float >*
      mutable_attribute();
  const ::sg::pb_pair_int_float& attribute(int index) const;
  ::sg::pb_pair_int_float* add_attribute();
  const ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_float >&
      attribute() const;

  // repeated .sg.Equip.SpecialAttribute special_attr = 7;
  int special_attr_size() const;
  void clear_special_attr();
  static const int kSpecialAttrFieldNumber = 7;
  ::sg::Equip_SpecialAttribute* mutable_special_attr(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::Equip_SpecialAttribute >*
      mutable_special_attr();
  const ::sg::Equip_SpecialAttribute& special_attr(int index) const;
  ::sg::Equip_SpecialAttribute* add_special_attr();
  const ::google::protobuf::RepeatedPtrField< ::sg::Equip_SpecialAttribute >&
      special_attr() const;

  // repeated .sg.Equip.EquipAttributeSlot attr_slots = 8;
  int attr_slots_size() const;
  void clear_attr_slots();
  static const int kAttrSlotsFieldNumber = 8;
  ::sg::Equip_EquipAttributeSlot* mutable_attr_slots(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::Equip_EquipAttributeSlot >*
      mutable_attr_slots();
  const ::sg::Equip_EquipAttributeSlot& attr_slots(int index) const;
  ::sg::Equip_EquipAttributeSlot* add_attr_slots();
  const ::google::protobuf::RepeatedPtrField< ::sg::Equip_EquipAttributeSlot >&
      attr_slots() const;

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // required int32 typeid = 2;
  bool has_typeid_() const;
  void clear_typeid_();
  static const int kTypeidFieldNumber = 2;
  ::google::protobuf::int32 typeid_() const;
  void set_typeid_(::google::protobuf::int32 value);

  // required int32 quality = 3;
  bool has_quality() const;
  void clear_quality();
  static const int kQualityFieldNumber = 3;
  ::google::protobuf::int32 quality() const;
  void set_quality(::google::protobuf::int32 value);

  // required int32 state = 4;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 4;
  ::google::protobuf::int32 state() const;
  void set_state(::google::protobuf::int32 value);

  // required int32 belong_to = 5;
  bool has_belong_to() const;
  void clear_belong_to();
  static const int kBelongToFieldNumber = 5;
  ::google::protobuf::int32 belong_to() const;
  void set_belong_to(::google::protobuf::int32 value);

  // optional int32 quality_refine_times = 9;
  bool has_quality_refine_times() const;
  void clear_quality_refine_times();
  static const int kQualityRefineTimesFieldNumber = 9;
  ::google::protobuf::int32 quality_refine_times() const;
  void set_quality_refine_times(::google::protobuf::int32 value);

  // optional int64 skill = 10;
  bool has_skill() const;
  void clear_skill();
  static const int kSkillFieldNumber = 10;
  ::google::protobuf::int64 skill() const;
  void set_skill(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:sg.Equip)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_typeid_();
  void clear_has_typeid_();
  void set_has_quality();
  void clear_has_quality();
  void set_has_state();
  void clear_has_state();
  void set_has_belong_to();
  void clear_has_belong_to();
  void set_has_quality_refine_times();
  void clear_has_quality_refine_times();
  void set_has_skill();
  void clear_has_skill();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_float > attribute_;
  ::google::protobuf::RepeatedPtrField< ::sg::Equip_SpecialAttribute > special_attr_;
  ::google::protobuf::RepeatedPtrField< ::sg::Equip_EquipAttributeSlot > attr_slots_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 typeid__;
  ::google::protobuf::int32 quality_;
  ::google::protobuf::int32 state_;
  ::google::protobuf::int32 belong_to_;
  ::google::protobuf::int32 quality_refine_times_;
  ::google::protobuf::int64 skill_;
  friend struct ::protobuf_BaseStruct_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SailorSkill : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.SailorSkill) */ {
 public:
  SailorSkill();
  virtual ~SailorSkill();

  SailorSkill(const SailorSkill& from);

  inline SailorSkill& operator=(const SailorSkill& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SailorSkill(SailorSkill&& from) noexcept
    : SailorSkill() {
    *this = ::std::move(from);
  }

  inline SailorSkill& operator=(SailorSkill&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const SailorSkill& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SailorSkill* internal_default_instance() {
    return reinterpret_cast<const SailorSkill*>(
               &_SailorSkill_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void UnsafeArenaSwap(SailorSkill* other);
  void Swap(SailorSkill* other);
  friend void swap(SailorSkill& a, SailorSkill& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SailorSkill* New() const final {
    return CreateMaybeMessage<SailorSkill>(NULL);
  }

  SailorSkill* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SailorSkill>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SailorSkill& from);
  void MergeFrom(const SailorSkill& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SailorSkill* other);
  protected:
  explicit SailorSkill(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 slotid = 1;
  bool has_slotid() const;
  void clear_slotid();
  static const int kSlotidFieldNumber = 1;
  ::google::protobuf::int32 slotid() const;
  void set_slotid(::google::protobuf::int32 value);

  // required int32 type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // required uint64 skillid = 4;
  bool has_skillid() const;
  void clear_skillid();
  static const int kSkillidFieldNumber = 4;
  ::google::protobuf::uint64 skillid() const;
  void set_skillid(::google::protobuf::uint64 value);

  // required int32 state = 3;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 3;
  ::google::protobuf::int32 state() const;
  void set_state(::google::protobuf::int32 value);

  // required int32 level = 5;
  bool has_level() const;
  void clear_level();
  static const int kLevelFieldNumber = 5;
  ::google::protobuf::int32 level() const;
  void set_level(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.SailorSkill)
 private:
  void set_has_slotid();
  void clear_has_slotid();
  void set_has_type();
  void clear_has_type();
  void set_has_state();
  void clear_has_state();
  void set_has_skillid();
  void clear_has_skillid();
  void set_has_level();
  void clear_has_level();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 slotid_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::uint64 skillid_;
  ::google::protobuf::int32 state_;
  ::google::protobuf::int32 level_;
  friend struct ::protobuf_BaseStruct_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SailorFarmSkill : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.SailorFarmSkill) */ {
 public:
  SailorFarmSkill();
  virtual ~SailorFarmSkill();

  SailorFarmSkill(const SailorFarmSkill& from);

  inline SailorFarmSkill& operator=(const SailorFarmSkill& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SailorFarmSkill(SailorFarmSkill&& from) noexcept
    : SailorFarmSkill() {
    *this = ::std::move(from);
  }

  inline SailorFarmSkill& operator=(SailorFarmSkill&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const SailorFarmSkill& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SailorFarmSkill* internal_default_instance() {
    return reinterpret_cast<const SailorFarmSkill*>(
               &_SailorFarmSkill_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void UnsafeArenaSwap(SailorFarmSkill* other);
  void Swap(SailorFarmSkill* other);
  friend void swap(SailorFarmSkill& a, SailorFarmSkill& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SailorFarmSkill* New() const final {
    return CreateMaybeMessage<SailorFarmSkill>(NULL);
  }

  SailorFarmSkill* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SailorFarmSkill>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SailorFarmSkill& from);
  void MergeFrom(const SailorFarmSkill& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SailorFarmSkill* other);
  protected:
  explicit SailorFarmSkill(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint64 id() const;
  void set_id(::google::protobuf::uint64 value);

  // required int32 level = 2;
  bool has_level() const;
  void clear_level();
  static const int kLevelFieldNumber = 2;
  ::google::protobuf::int32 level() const;
  void set_level(::google::protobuf::int32 value);

  // required int32 exp = 3;
  bool has_exp() const;
  void clear_exp();
  static const int kExpFieldNumber = 3;
  ::google::protobuf::int32 exp() const;
  void set_exp(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.SailorFarmSkill)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_level();
  void clear_has_level();
  void set_has_exp();
  void clear_has_exp();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 id_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 exp_;
  friend struct ::protobuf_BaseStruct_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SailorTalent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.SailorTalent) */ {
 public:
  SailorTalent();
  virtual ~SailorTalent();

  SailorTalent(const SailorTalent& from);

  inline SailorTalent& operator=(const SailorTalent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SailorTalent(SailorTalent&& from) noexcept
    : SailorTalent() {
    *this = ::std::move(from);
  }

  inline SailorTalent& operator=(SailorTalent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const SailorTalent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SailorTalent* internal_default_instance() {
    return reinterpret_cast<const SailorTalent*>(
               &_SailorTalent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void UnsafeArenaSwap(SailorTalent* other);
  void Swap(SailorTalent* other);
  friend void swap(SailorTalent& a, SailorTalent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SailorTalent* New() const final {
    return CreateMaybeMessage<SailorTalent>(NULL);
  }

  SailorTalent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SailorTalent>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SailorTalent& from);
  void MergeFrom(const SailorTalent& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SailorTalent* other);
  protected:
  explicit SailorTalent(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint64 id() const;
  void set_id(::google::protobuf::uint64 value);

  // required int32 level = 2;
  bool has_level() const;
  void clear_level();
  static const int kLevelFieldNumber = 2;
  ::google::protobuf::int32 level() const;
  void set_level(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.SailorTalent)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_level();
  void clear_has_level();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 id_;
  ::google::protobuf::int32 level_;
  friend struct ::protobuf_BaseStruct_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Sailor : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.Sailor) */ {
 public:
  Sailor();
  virtual ~Sailor();

  Sailor(const Sailor& from);

  inline Sailor& operator=(const Sailor& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Sailor(Sailor&& from) noexcept
    : Sailor() {
    *this = ::std::move(from);
  }

  inline Sailor& operator=(Sailor&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Sailor& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Sailor* internal_default_instance() {
    return reinterpret_cast<const Sailor*>(
               &_Sailor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void UnsafeArenaSwap(Sailor* other);
  void Swap(Sailor* other);
  friend void swap(Sailor& a, Sailor& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Sailor* New() const final {
    return CreateMaybeMessage<Sailor>(NULL);
  }

  Sailor* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Sailor>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Sailor& from);
  void MergeFrom(const Sailor& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Sailor* other);
  protected:
  explicit Sailor(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sg.pb_pair_int_float attribute = 16;
  int attribute_size() const;
  void clear_attribute();
  static const int kAttributeFieldNumber = 16;
  ::sg::pb_pair_int_float* mutable_attribute(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_float >*
      mutable_attribute();
  const ::sg::pb_pair_int_float& attribute(int index) const;
  ::sg::pb_pair_int_float* add_attribute();
  const ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_float >&
      attribute() const;

  // repeated .sg.pb_pair_int_float aptitude = 17;
  int aptitude_size() const;
  void clear_aptitude();
  static const int kAptitudeFieldNumber = 17;
  ::sg::pb_pair_int_float* mutable_aptitude(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_float >*
      mutable_aptitude();
  const ::sg::pb_pair_int_float& aptitude(int index) const;
  ::sg::pb_pair_int_float* add_aptitude();
  const ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_float >&
      aptitude() const;

  // repeated .sg.Equip equip = 18;
  int equip_size() const;
  void clear_equip();
  static const int kEquipFieldNumber = 18;
  ::sg::Equip* mutable_equip(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::Equip >*
      mutable_equip();
  const ::sg::Equip& equip(int index) const;
  ::sg::Equip* add_equip();
  const ::google::protobuf::RepeatedPtrField< ::sg::Equip >&
      equip() const;

  // repeated .sg.SailorSkill skills = 19;
  int skills_size() const;
  void clear_skills();
  static const int kSkillsFieldNumber = 19;
  ::sg::SailorSkill* mutable_skills(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::SailorSkill >*
      mutable_skills();
  const ::sg::SailorSkill& skills(int index) const;
  ::sg::SailorSkill* add_skills();
  const ::google::protobuf::RepeatedPtrField< ::sg::SailorSkill >&
      skills() const;

  // repeated .sg.SailorFarmSkill farm_skills = 20;
  int farm_skills_size() const;
  void clear_farm_skills();
  static const int kFarmSkillsFieldNumber = 20;
  ::sg::SailorFarmSkill* mutable_farm_skills(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::SailorFarmSkill >*
      mutable_farm_skills();
  const ::sg::SailorFarmSkill& farm_skills(int index) const;
  ::sg::SailorFarmSkill* add_farm_skills();
  const ::google::protobuf::RepeatedPtrField< ::sg::SailorFarmSkill >&
      farm_skills() const;

  // optional .sg.SailorTalent talent = 21;
  bool has_talent() const;
  void clear_talent();
  static const int kTalentFieldNumber = 21;
  private:
  const ::sg::SailorTalent& _internal_talent() const;
  public:
  const ::sg::SailorTalent& talent() const;
  ::sg::SailorTalent* release_talent();
  ::sg::SailorTalent* mutable_talent();
  void set_allocated_talent(::sg::SailorTalent* talent);
  void unsafe_arena_set_allocated_talent(
      ::sg::SailorTalent* talent);
  ::sg::SailorTalent* unsafe_arena_release_talent();

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // required int32 typeid = 2;
  bool has_typeid_() const;
  void clear_typeid_();
  static const int kTypeidFieldNumber = 2;
  ::google::protobuf::int32 typeid_() const;
  void set_typeid_(::google::protobuf::int32 value);

  // required uint64 place = 4;
  bool has_place() const;
  void clear_place();
  static const int kPlaceFieldNumber = 4;
  ::google::protobuf::uint64 place() const;
  void set_place(::google::protobuf::uint64 value);

  // required .sg.SAILOR_STATE state = 3;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 3;
  ::sg::SAILOR_STATE state() const;
  void set_state(::sg::SAILOR_STATE value);

  // required int32 facility_id = 5;
  bool has_facility_id() const;
  void clear_facility_id();
  static const int kFacilityIdFieldNumber = 5;
  ::google::protobuf::int32 facility_id() const;
  void set_facility_id(::google::protobuf::int32 value);

  // required int32 level = 6;
  bool has_level() const;
  void clear_level();
  static const int kLevelFieldNumber = 6;
  ::google::protobuf::int32 level() const;
  void set_level(::google::protobuf::int32 value);

  // required int32 star = 7;
  bool has_star() const;
  void clear_star();
  static const int kStarFieldNumber = 7;
  ::google::protobuf::int32 star() const;
  void set_star(::google::protobuf::int32 value);

  // required int32 phase = 8;
  bool has_phase() const;
  void clear_phase();
  static const int kPhaseFieldNumber = 8;
  ::google::protobuf::int32 phase() const;
  void set_phase(::google::protobuf::int32 value);

  // required int32 hp_lost = 9;
  bool has_hp_lost() const;
  void clear_hp_lost();
  static const int kHpLostFieldNumber = 9;
  ::google::protobuf::int32 hp_lost() const;
  void set_hp_lost(::google::protobuf::int32 value);

  // required float vim = 10;
  bool has_vim() const;
  void clear_vim();
  static const int kVimFieldNumber = 10;
  float vim() const;
  void set_vim(float value);

  // required int32 exp = 11;
  bool has_exp() const;
  void clear_exp();
  static const int kExpFieldNumber = 11;
  ::google::protobuf::int32 exp() const;
  void set_exp(::google::protobuf::int32 value);

  // optional sfixed64 last_rest_time = 14;
  bool has_last_rest_time() const;
  void clear_last_rest_time();
  static const int kLastRestTimeFieldNumber = 14;
  ::google::protobuf::int64 last_rest_time() const;
  void set_last_rest_time(::google::protobuf::int64 value);

  // optional int32 orderid = 13;
  bool has_orderid() const;
  void clear_orderid();
  static const int kOrderidFieldNumber = 13;
  ::google::protobuf::int32 orderid() const;
  void set_orderid(::google::protobuf::int32 value);

  // optional int32 job = 15;
  bool has_job() const;
  void clear_job();
  static const int kJobFieldNumber = 15;
  ::google::protobuf::int32 job() const;
  void set_job(::google::protobuf::int32 value);

  // optional int32 practice = 22;
  bool has_practice() const;
  void clear_practice();
  static const int kPracticeFieldNumber = 22;
  ::google::protobuf::int32 practice() const;
  void set_practice(::google::protobuf::int32 value);

  // optional int32 region = 23;
  bool has_region() const;
  void clear_region();
  static const int kRegionFieldNumber = 23;
  ::google::protobuf::int32 region() const;
  void set_region(::google::protobuf::int32 value);

  // optional float hunger = 24;
  bool has_hunger() const;
  void clear_hunger();
  static const int kHungerFieldNumber = 24;
  float hunger() const;
  void set_hunger(float value);

  // @@protoc_insertion_point(class_scope:sg.Sailor)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_typeid_();
  void clear_has_typeid_();
  void set_has_state();
  void clear_has_state();
  void set_has_place();
  void clear_has_place();
  void set_has_facility_id();
  void clear_has_facility_id();
  void set_has_level();
  void clear_has_level();
  void set_has_star();
  void clear_has_star();
  void set_has_phase();
  void clear_has_phase();
  void set_has_hp_lost();
  void clear_has_hp_lost();
  void set_has_vim();
  void clear_has_vim();
  void set_has_exp();
  void clear_has_exp();
  void set_has_orderid();
  void clear_has_orderid();
  void set_has_last_rest_time();
  void clear_has_last_rest_time();
  void set_has_job();
  void clear_has_job();
  void set_has_talent();
  void clear_has_talent();
  void set_has_practice();
  void clear_has_practice();
  void set_has_region();
  void clear_has_region();
  void set_has_hunger();
  void clear_has_hunger();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_float > attribute_;
  ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_float > aptitude_;
  ::google::protobuf::RepeatedPtrField< ::sg::Equip > equip_;
  ::google::protobuf::RepeatedPtrField< ::sg::SailorSkill > skills_;
  ::google::protobuf::RepeatedPtrField< ::sg::SailorFarmSkill > farm_skills_;
  ::sg::SailorTalent* talent_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 typeid__;
  ::google::protobuf::uint64 place_;
  int state_;
  ::google::protobuf::int32 facility_id_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 star_;
  ::google::protobuf::int32 phase_;
  ::google::protobuf::int32 hp_lost_;
  float vim_;
  ::google::protobuf::int32 exp_;
  ::google::protobuf::int64 last_rest_time_;
  ::google::protobuf::int32 orderid_;
  ::google::protobuf::int32 job_;
  ::google::protobuf::int32 practice_;
  ::google::protobuf::int32 region_;
  float hunger_;
  friend struct ::protobuf_BaseStruct_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NPC : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.NPC) */ {
 public:
  NPC();
  virtual ~NPC();

  NPC(const NPC& from);

  inline NPC& operator=(const NPC& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NPC(NPC&& from) noexcept
    : NPC() {
    *this = ::std::move(from);
  }

  inline NPC& operator=(NPC&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const NPC& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NPC* internal_default_instance() {
    return reinterpret_cast<const NPC*>(
               &_NPC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void UnsafeArenaSwap(NPC* other);
  void Swap(NPC* other);
  friend void swap(NPC& a, NPC& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NPC* New() const final {
    return CreateMaybeMessage<NPC>(NULL);
  }

  NPC* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NPC>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NPC& from);
  void MergeFrom(const NPC& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NPC* other);
  protected:
  explicit NPC(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .sg.Locale locale = 3;
  bool has_locale() const;
  void clear_locale();
  static const int kLocaleFieldNumber = 3;
  private:
  const ::sg::Locale& _internal_locale() const;
  public:
  const ::sg::Locale& locale() const;
  ::sg::Locale* release_locale();
  ::sg::Locale* mutable_locale();
  void set_allocated_locale(::sg::Locale* locale);
  void unsafe_arena_set_allocated_locale(
      ::sg::Locale* locale);
  ::sg::Locale* unsafe_arena_release_locale();

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // required int32 state = 2;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 2;
  ::google::protobuf::int32 state() const;
  void set_state(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.NPC)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_state();
  void clear_has_state();
  void set_has_locale();
  void clear_has_locale();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::sg::Locale* locale_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 state_;
  friend struct ::protobuf_BaseStruct_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Item : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.Item) */ {
 public:
  Item();
  virtual ~Item();

  Item(const Item& from);

  inline Item& operator=(const Item& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Item(Item&& from) noexcept
    : Item() {
    *this = ::std::move(from);
  }

  inline Item& operator=(Item&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Item& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Item* internal_default_instance() {
    return reinterpret_cast<const Item*>(
               &_Item_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void UnsafeArenaSwap(Item* other);
  void Swap(Item* other);
  friend void swap(Item& a, Item& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Item* New() const final {
    return CreateMaybeMessage<Item>(NULL);
  }

  Item* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Item>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Item& from);
  void MergeFrom(const Item& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Item* other);
  protected:
  explicit Item(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 num = 2;
  bool has_num() const;
  void clear_num();
  static const int kNumFieldNumber = 2;
  ::google::protobuf::int64 num() const;
  void set_num(::google::protobuf::int64 value);

  // required int32 typeid = 1;
  bool has_typeid_() const;
  void clear_typeid_();
  static const int kTypeidFieldNumber = 1;
  ::google::protobuf::int32 typeid_() const;
  void set_typeid_(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.Item)
 private:
  void set_has_typeid_();
  void clear_has_typeid_();
  void set_has_num();
  void clear_has_num();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int64 num_;
  ::google::protobuf::int32 typeid__;
  friend struct ::protobuf_BaseStruct_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Facility_SpecialData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.Facility.SpecialData) */ {
 public:
  Facility_SpecialData();
  virtual ~Facility_SpecialData();

  Facility_SpecialData(const Facility_SpecialData& from);

  inline Facility_SpecialData& operator=(const Facility_SpecialData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Facility_SpecialData(Facility_SpecialData&& from) noexcept
    : Facility_SpecialData() {
    *this = ::std::move(from);
  }

  inline Facility_SpecialData& operator=(Facility_SpecialData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Facility_SpecialData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Facility_SpecialData* internal_default_instance() {
    return reinterpret_cast<const Facility_SpecialData*>(
               &_Facility_SpecialData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void UnsafeArenaSwap(Facility_SpecialData* other);
  void Swap(Facility_SpecialData* other);
  friend void swap(Facility_SpecialData& a, Facility_SpecialData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Facility_SpecialData* New() const final {
    return CreateMaybeMessage<Facility_SpecialData>(NULL);
  }

  Facility_SpecialData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Facility_SpecialData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Facility_SpecialData& from);
  void MergeFrom(const Facility_SpecialData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Facility_SpecialData* other);
  protected:
  explicit Facility_SpecialData(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sg.Item contain = 3;
  int contain_size() const;
  void clear_contain();
  static const int kContainFieldNumber = 3;
  ::sg::Item* mutable_contain(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::Item >*
      mutable_contain();
  const ::sg::Item& contain(int index) const;
  ::sg::Item* add_contain();
  const ::google::protobuf::RepeatedPtrField< ::sg::Item >&
      contain() const;

  // required int32 property_type = 1;
  bool has_property_type() const;
  void clear_property_type();
  static const int kPropertyTypeFieldNumber = 1;
  ::google::protobuf::int32 property_type() const;
  void set_property_type(::google::protobuf::int32 value);

  // required int32 count_times = 2;
  bool has_count_times() const;
  void clear_count_times();
  static const int kCountTimesFieldNumber = 2;
  ::google::protobuf::int32 count_times() const;
  void set_count_times(::google::protobuf::int32 value);

  // optional sfixed64 timestamp = 4;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 4;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:sg.Facility.SpecialData)
 private:
  void set_has_property_type();
  void clear_has_property_type();
  void set_has_count_times();
  void clear_has_count_times();
  void set_has_timestamp();
  void clear_has_timestamp();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::Item > contain_;
  ::google::protobuf::int32 property_type_;
  ::google::protobuf::int32 count_times_;
  ::google::protobuf::int64 timestamp_;
  friend struct ::protobuf_BaseStruct_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Facility_OrderSlot : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.Facility.OrderSlot) */ {
 public:
  Facility_OrderSlot();
  virtual ~Facility_OrderSlot();

  Facility_OrderSlot(const Facility_OrderSlot& from);

  inline Facility_OrderSlot& operator=(const Facility_OrderSlot& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Facility_OrderSlot(Facility_OrderSlot&& from) noexcept
    : Facility_OrderSlot() {
    *this = ::std::move(from);
  }

  inline Facility_OrderSlot& operator=(Facility_OrderSlot&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Facility_OrderSlot& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Facility_OrderSlot* internal_default_instance() {
    return reinterpret_cast<const Facility_OrderSlot*>(
               &_Facility_OrderSlot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void UnsafeArenaSwap(Facility_OrderSlot* other);
  void Swap(Facility_OrderSlot* other);
  friend void swap(Facility_OrderSlot& a, Facility_OrderSlot& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Facility_OrderSlot* New() const final {
    return CreateMaybeMessage<Facility_OrderSlot>(NULL);
  }

  Facility_OrderSlot* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Facility_OrderSlot>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Facility_OrderSlot& from);
  void MergeFrom(const Facility_OrderSlot& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Facility_OrderSlot* other);
  protected:
  explicit Facility_OrderSlot(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 orderid = 1;
  bool has_orderid() const;
  void clear_orderid();
  static const int kOrderidFieldNumber = 1;
  ::google::protobuf::int32 orderid() const;
  void set_orderid(::google::protobuf::int32 value);

  // required int32 state = 2;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 2;
  ::google::protobuf::int32 state() const;
  void set_state(::google::protobuf::int32 value);

  // required int32 index = 3;
  bool has_index() const;
  void clear_index();
  static const int kIndexFieldNumber = 3;
  ::google::protobuf::int32 index() const;
  void set_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.Facility.OrderSlot)
 private:
  void set_has_orderid();
  void clear_has_orderid();
  void set_has_state();
  void clear_has_state();
  void set_has_index();
  void clear_has_index();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 orderid_;
  ::google::protobuf::int32 state_;
  ::google::protobuf::int32 index_;
  friend struct ::protobuf_BaseStruct_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Facility : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.Facility) */ {
 public:
  Facility();
  virtual ~Facility();

  Facility(const Facility& from);

  inline Facility& operator=(const Facility& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Facility(Facility&& from) noexcept
    : Facility() {
    *this = ::std::move(from);
  }

  inline Facility& operator=(Facility&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Facility& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Facility* internal_default_instance() {
    return reinterpret_cast<const Facility*>(
               &_Facility_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void UnsafeArenaSwap(Facility* other);
  void Swap(Facility* other);
  friend void swap(Facility& a, Facility& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Facility* New() const final {
    return CreateMaybeMessage<Facility>(NULL);
  }

  Facility* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Facility>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Facility& from);
  void MergeFrom(const Facility& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Facility* other);
  protected:
  explicit Facility(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Facility_SpecialData SpecialData;
  typedef Facility_OrderSlot OrderSlot;

  // accessors -------------------------------------------------------

  // repeated .sg.Facility.OrderSlot order_list = 4;
  int order_list_size() const;
  void clear_order_list();
  static const int kOrderListFieldNumber = 4;
  ::sg::Facility_OrderSlot* mutable_order_list(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::Facility_OrderSlot >*
      mutable_order_list();
  const ::sg::Facility_OrderSlot& order_list(int index) const;
  ::sg::Facility_OrderSlot* add_order_list();
  const ::google::protobuf::RepeatedPtrField< ::sg::Facility_OrderSlot >&
      order_list() const;

  // repeated int32 worker_list = 6;
  int worker_list_size() const;
  void clear_worker_list();
  static const int kWorkerListFieldNumber = 6;
  ::google::protobuf::int32 worker_list(int index) const;
  void set_worker_list(int index, ::google::protobuf::int32 value);
  void add_worker_list(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      worker_list() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_worker_list();

  // repeated .sg.Facility.SpecialData special_data = 11;
  int special_data_size() const;
  void clear_special_data();
  static const int kSpecialDataFieldNumber = 11;
  ::sg::Facility_SpecialData* mutable_special_data(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::Facility_SpecialData >*
      mutable_special_data();
  const ::sg::Facility_SpecialData& special_data(int index) const;
  ::sg::Facility_SpecialData* add_special_data();
  const ::google::protobuf::RepeatedPtrField< ::sg::Facility_SpecialData >&
      special_data() const;

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // required int32 typeid = 2;
  bool has_typeid_() const;
  void clear_typeid_();
  static const int kTypeidFieldNumber = 2;
  ::google::protobuf::int32 typeid_() const;
  void set_typeid_(::google::protobuf::int32 value);

  // required int32 style = 3;
  bool has_style() const;
  void clear_style();
  static const int kStyleFieldNumber = 3;
  ::google::protobuf::int32 style() const;
  void set_style(::google::protobuf::int32 value);

  // optional int32 roomid = 5;
  bool has_roomid() const;
  void clear_roomid();
  static const int kRoomidFieldNumber = 5;
  ::google::protobuf::int32 roomid() const;
  void set_roomid(::google::protobuf::int32 value);

  // optional int32 pos_x = 7;
  bool has_pos_x() const;
  void clear_pos_x();
  static const int kPosXFieldNumber = 7;
  ::google::protobuf::int32 pos_x() const;
  void set_pos_x(::google::protobuf::int32 value);

  // optional int32 pos_y = 8;
  bool has_pos_y() const;
  void clear_pos_y();
  static const int kPosYFieldNumber = 8;
  ::google::protobuf::int32 pos_y() const;
  void set_pos_y(::google::protobuf::int32 value);

  // optional int32 level = 9;
  bool has_level() const;
  void clear_level();
  static const int kLevelFieldNumber = 9;
  ::google::protobuf::int32 level() const;
  void set_level(::google::protobuf::int32 value);

  // optional int32 region = 10;
  bool has_region() const;
  void clear_region();
  static const int kRegionFieldNumber = 10;
  ::google::protobuf::int32 region() const;
  void set_region(::google::protobuf::int32 value);

  // optional sfixed64 level_up_starttime = 13;
  bool has_level_up_starttime() const;
  void clear_level_up_starttime();
  static const int kLevelUpStarttimeFieldNumber = 13;
  ::google::protobuf::int64 level_up_starttime() const;
  void set_level_up_starttime(::google::protobuf::int64 value);

  // optional int32 remain_food = 12;
  bool has_remain_food() const;
  void clear_remain_food();
  static const int kRemainFoodFieldNumber = 12;
  ::google::protobuf::int32 remain_food() const;
  void set_remain_food(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.Facility)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_typeid_();
  void clear_has_typeid_();
  void set_has_style();
  void clear_has_style();
  void set_has_roomid();
  void clear_has_roomid();
  void set_has_pos_x();
  void clear_has_pos_x();
  void set_has_pos_y();
  void clear_has_pos_y();
  void set_has_level();
  void clear_has_level();
  void set_has_region();
  void clear_has_region();
  void set_has_remain_food();
  void clear_has_remain_food();
  void set_has_level_up_starttime();
  void clear_has_level_up_starttime();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::Facility_OrderSlot > order_list_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > worker_list_;
  ::google::protobuf::RepeatedPtrField< ::sg::Facility_SpecialData > special_data_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 typeid__;
  ::google::protobuf::int32 style_;
  ::google::protobuf::int32 roomid_;
  ::google::protobuf::int32 pos_x_;
  ::google::protobuf::int32 pos_y_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 region_;
  ::google::protobuf::int64 level_up_starttime_;
  ::google::protobuf::int32 remain_food_;
  friend struct ::protobuf_BaseStruct_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Reward : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.Reward) */ {
 public:
  Reward();
  virtual ~Reward();

  Reward(const Reward& from);

  inline Reward& operator=(const Reward& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Reward(Reward&& from) noexcept
    : Reward() {
    *this = ::std::move(from);
  }

  inline Reward& operator=(Reward&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Reward& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Reward* internal_default_instance() {
    return reinterpret_cast<const Reward*>(
               &_Reward_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void UnsafeArenaSwap(Reward* other);
  void Swap(Reward* other);
  friend void swap(Reward& a, Reward& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Reward* New() const final {
    return CreateMaybeMessage<Reward>(NULL);
  }

  Reward* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Reward>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Reward& from);
  void MergeFrom(const Reward& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Reward* other);
  protected:
  explicit Reward(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sg.Item items = 1;
  int items_size() const;
  void clear_items();
  static const int kItemsFieldNumber = 1;
  ::sg::Item* mutable_items(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::Item >*
      mutable_items();
  const ::sg::Item& items(int index) const;
  ::sg::Item* add_items();
  const ::google::protobuf::RepeatedPtrField< ::sg::Item >&
      items() const;

  // repeated .sg.Sailor sailors = 2;
  int sailors_size() const;
  void clear_sailors();
  static const int kSailorsFieldNumber = 2;
  ::sg::Sailor* mutable_sailors(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::Sailor >*
      mutable_sailors();
  const ::sg::Sailor& sailors(int index) const;
  ::sg::Sailor* add_sailors();
  const ::google::protobuf::RepeatedPtrField< ::sg::Sailor >&
      sailors() const;

  // repeated .sg.Facility facilitys = 3;
  int facilitys_size() const;
  void clear_facilitys();
  static const int kFacilitysFieldNumber = 3;
  ::sg::Facility* mutable_facilitys(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::Facility >*
      mutable_facilitys();
  const ::sg::Facility& facilitys(int index) const;
  ::sg::Facility* add_facilitys();
  const ::google::protobuf::RepeatedPtrField< ::sg::Facility >&
      facilitys() const;

  // repeated int32 models = 4;
  int models_size() const;
  void clear_models();
  static const int kModelsFieldNumber = 4;
  ::google::protobuf::int32 models(int index) const;
  void set_models(int index, ::google::protobuf::int32 value);
  void add_models(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      models() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_models();

  // repeated int32 formulas = 5;
  int formulas_size() const;
  void clear_formulas();
  static const int kFormulasFieldNumber = 5;
  ::google::protobuf::int32 formulas(int index) const;
  void set_formulas(int index, ::google::protobuf::int32 value);
  void add_formulas(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      formulas() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_formulas();

  // repeated int32 maps = 6;
  int maps_size() const;
  void clear_maps();
  static const int kMapsFieldNumber = 6;
  ::google::protobuf::int32 maps(int index) const;
  void set_maps(int index, ::google::protobuf::int32 value);
  void add_maps(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      maps() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_maps();

  // repeated int32 month_cards = 7;
  int month_cards_size() const;
  void clear_month_cards();
  static const int kMonthCardsFieldNumber = 7;
  ::google::protobuf::int32 month_cards(int index) const;
  void set_month_cards(int index, ::google::protobuf::int32 value);
  void add_month_cards(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      month_cards() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_month_cards();

  // repeated .sg.Equip equips = 8;
  int equips_size() const;
  void clear_equips();
  static const int kEquipsFieldNumber = 8;
  ::sg::Equip* mutable_equips(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::Equip >*
      mutable_equips();
  const ::sg::Equip& equips(int index) const;
  ::sg::Equip* add_equips();
  const ::google::protobuf::RepeatedPtrField< ::sg::Equip >&
      equips() const;

  // repeated .sg.pb_pair_int_int sailor_add_exp = 10;
  int sailor_add_exp_size() const;
  void clear_sailor_add_exp();
  static const int kSailorAddExpFieldNumber = 10;
  ::sg::pb_pair_int_int* mutable_sailor_add_exp(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int >*
      mutable_sailor_add_exp();
  const ::sg::pb_pair_int_int& sailor_add_exp(int index) const;
  ::sg::pb_pair_int_int* add_sailor_add_exp();
  const ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int >&
      sailor_add_exp() const;

  // repeated int32 treasure_ticket = 11;
  int treasure_ticket_size() const;
  void clear_treasure_ticket();
  static const int kTreasureTicketFieldNumber = 11;
  ::google::protobuf::int32 treasure_ticket(int index) const;
  void set_treasure_ticket(int index, ::google::protobuf::int32 value);
  void add_treasure_ticket(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      treasure_ticket() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_treasure_ticket();

  // repeated int32 grow_gift = 12;
  int grow_gift_size() const;
  void clear_grow_gift();
  static const int kGrowGiftFieldNumber = 12;
  ::google::protobuf::int32 grow_gift(int index) const;
  void set_grow_gift(int index, ::google::protobuf::int32 value);
  void add_grow_gift(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      grow_gift() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_grow_gift();

  // optional int32 exp = 9;
  bool has_exp() const;
  void clear_exp();
  static const int kExpFieldNumber = 9;
  ::google::protobuf::int32 exp() const;
  void set_exp(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.Reward)
 private:
  void set_has_exp();
  void clear_has_exp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::Item > items_;
  ::google::protobuf::RepeatedPtrField< ::sg::Sailor > sailors_;
  ::google::protobuf::RepeatedPtrField< ::sg::Facility > facilitys_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > models_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > formulas_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > maps_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > month_cards_;
  ::google::protobuf::RepeatedPtrField< ::sg::Equip > equips_;
  ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int > sailor_add_exp_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > treasure_ticket_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > grow_gift_;
  ::google::protobuf::int32 exp_;
  friend struct ::protobuf_BaseStruct_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RegionState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.RegionState) */ {
 public:
  RegionState();
  virtual ~RegionState();

  RegionState(const RegionState& from);

  inline RegionState& operator=(const RegionState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegionState(RegionState&& from) noexcept
    : RegionState() {
    *this = ::std::move(from);
  }

  inline RegionState& operator=(RegionState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const RegionState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegionState* internal_default_instance() {
    return reinterpret_cast<const RegionState*>(
               &_RegionState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void UnsafeArenaSwap(RegionState* other);
  void Swap(RegionState* other);
  friend void swap(RegionState& a, RegionState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegionState* New() const final {
    return CreateMaybeMessage<RegionState>(NULL);
  }

  RegionState* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegionState>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegionState& from);
  void MergeFrom(const RegionState& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegionState* other);
  protected:
  explicit RegionState(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 comfort_grade = 1;
  bool has_comfort_grade() const;
  void clear_comfort_grade();
  static const int kComfortGradeFieldNumber = 1;
  ::google::protobuf::int32 comfort_grade() const;
  void set_comfort_grade(::google::protobuf::int32 value);

  // optional int32 item_capacity = 2;
  bool has_item_capacity() const;
  void clear_item_capacity();
  static const int kItemCapacityFieldNumber = 2;
  ::google::protobuf::int32 item_capacity() const;
  void set_item_capacity(::google::protobuf::int32 value);

  // optional int32 equip_capacity = 3;
  bool has_equip_capacity() const;
  void clear_equip_capacity();
  static const int kEquipCapacityFieldNumber = 3;
  ::google::protobuf::int32 equip_capacity() const;
  void set_equip_capacity(::google::protobuf::int32 value);

  // optional int32 facility_capacity = 4;
  bool has_facility_capacity() const;
  void clear_facility_capacity();
  static const int kFacilityCapacityFieldNumber = 4;
  ::google::protobuf::int32 facility_capacity() const;
  void set_facility_capacity(::google::protobuf::int32 value);

  // optional int32 food_capacity = 5;
  bool has_food_capacity() const;
  void clear_food_capacity();
  static const int kFoodCapacityFieldNumber = 5;
  ::google::protobuf::int32 food_capacity() const;
  void set_food_capacity(::google::protobuf::int32 value);

  // optional int32 resource_capacity = 6;
  bool has_resource_capacity() const;
  void clear_resource_capacity();
  static const int kResourceCapacityFieldNumber = 6;
  ::google::protobuf::int32 resource_capacity() const;
  void set_resource_capacity(::google::protobuf::int32 value);

  // optional float resource_product_add = 7;
  bool has_resource_product_add() const;
  void clear_resource_product_add();
  static const int kResourceProductAddFieldNumber = 7;
  float resource_product_add() const;
  void set_resource_product_add(float value);

  // optional int32 food_resource_capacity = 8;
  bool has_food_resource_capacity() const;
  void clear_food_resource_capacity();
  static const int kFoodResourceCapacityFieldNumber = 8;
  ::google::protobuf::int32 food_resource_capacity() const;
  void set_food_resource_capacity(::google::protobuf::int32 value);

  // optional int32 wood_resource_capacity = 9;
  bool has_wood_resource_capacity() const;
  void clear_wood_resource_capacity();
  static const int kWoodResourceCapacityFieldNumber = 9;
  ::google::protobuf::int32 wood_resource_capacity() const;
  void set_wood_resource_capacity(::google::protobuf::int32 value);

  // optional int32 iron_resource_capacity = 10;
  bool has_iron_resource_capacity() const;
  void clear_iron_resource_capacity();
  static const int kIronResourceCapacityFieldNumber = 10;
  ::google::protobuf::int32 iron_resource_capacity() const;
  void set_iron_resource_capacity(::google::protobuf::int32 value);

  // optional int32 machine_capacity = 11;
  bool has_machine_capacity() const;
  void clear_machine_capacity();
  static const int kMachineCapacityFieldNumber = 11;
  ::google::protobuf::int32 machine_capacity() const;
  void set_machine_capacity(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.RegionState)
 private:
  void set_has_comfort_grade();
  void clear_has_comfort_grade();
  void set_has_item_capacity();
  void clear_has_item_capacity();
  void set_has_equip_capacity();
  void clear_has_equip_capacity();
  void set_has_facility_capacity();
  void clear_has_facility_capacity();
  void set_has_food_capacity();
  void clear_has_food_capacity();
  void set_has_resource_capacity();
  void clear_has_resource_capacity();
  void set_has_resource_product_add();
  void clear_has_resource_product_add();
  void set_has_food_resource_capacity();
  void clear_has_food_resource_capacity();
  void set_has_wood_resource_capacity();
  void clear_has_wood_resource_capacity();
  void set_has_iron_resource_capacity();
  void clear_has_iron_resource_capacity();
  void set_has_machine_capacity();
  void clear_has_machine_capacity();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 comfort_grade_;
  ::google::protobuf::int32 item_capacity_;
  ::google::protobuf::int32 equip_capacity_;
  ::google::protobuf::int32 facility_capacity_;
  ::google::protobuf::int32 food_capacity_;
  ::google::protobuf::int32 resource_capacity_;
  float resource_product_add_;
  ::google::protobuf::int32 food_resource_capacity_;
  ::google::protobuf::int32 wood_resource_capacity_;
  ::google::protobuf::int32 iron_resource_capacity_;
  ::google::protobuf::int32 machine_capacity_;
  friend struct ::protobuf_BaseStruct_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SpecialEventNotify : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.SpecialEventNotify) */ {
 public:
  SpecialEventNotify();
  virtual ~SpecialEventNotify();

  SpecialEventNotify(const SpecialEventNotify& from);

  inline SpecialEventNotify& operator=(const SpecialEventNotify& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SpecialEventNotify(SpecialEventNotify&& from) noexcept
    : SpecialEventNotify() {
    *this = ::std::move(from);
  }

  inline SpecialEventNotify& operator=(SpecialEventNotify&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const SpecialEventNotify& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpecialEventNotify* internal_default_instance() {
    return reinterpret_cast<const SpecialEventNotify*>(
               &_SpecialEventNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void UnsafeArenaSwap(SpecialEventNotify* other);
  void Swap(SpecialEventNotify* other);
  friend void swap(SpecialEventNotify& a, SpecialEventNotify& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SpecialEventNotify* New() const final {
    return CreateMaybeMessage<SpecialEventNotify>(NULL);
  }

  SpecialEventNotify* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SpecialEventNotify>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SpecialEventNotify& from);
  void MergeFrom(const SpecialEventNotify& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpecialEventNotify* other);
  protected:
  explicit SpecialEventNotify(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .sg.Reward reward = 2;
  bool has_reward() const;
  void clear_reward();
  static const int kRewardFieldNumber = 2;
  private:
  const ::sg::Reward& _internal_reward() const;
  public:
  const ::sg::Reward& reward() const;
  ::sg::Reward* release_reward();
  ::sg::Reward* mutable_reward();
  void set_allocated_reward(::sg::Reward* reward);
  void unsafe_arena_set_allocated_reward(
      ::sg::Reward* reward);
  ::sg::Reward* unsafe_arena_release_reward();

  // required int64 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int64 id() const;
  void set_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:sg.SpecialEventNotify)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_reward();
  void clear_has_reward();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::sg::Reward* reward_;
  ::google::protobuf::int64 id_;
  friend struct ::protobuf_BaseStruct_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// UserRoom

// required int32 id = 1;
inline bool UserRoom::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserRoom::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserRoom::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserRoom::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 UserRoom::id() const {
  // @@protoc_insertion_point(field_get:sg.UserRoom.id)
  return id_;
}
inline void UserRoom::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:sg.UserRoom.id)
}

// required int32 room_type = 2;
inline bool UserRoom::has_room_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserRoom::set_has_room_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserRoom::clear_has_room_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserRoom::clear_room_type() {
  room_type_ = 0;
  clear_has_room_type();
}
inline ::google::protobuf::int32 UserRoom::room_type() const {
  // @@protoc_insertion_point(field_get:sg.UserRoom.room_type)
  return room_type_;
}
inline void UserRoom::set_room_type(::google::protobuf::int32 value) {
  set_has_room_type();
  room_type_ = value;
  // @@protoc_insertion_point(field_set:sg.UserRoom.room_type)
}

// optional int32 comfort = 3;
inline bool UserRoom::has_comfort() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserRoom::set_has_comfort() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserRoom::clear_has_comfort() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserRoom::clear_comfort() {
  comfort_ = 0;
  clear_has_comfort();
}
inline ::google::protobuf::int32 UserRoom::comfort() const {
  // @@protoc_insertion_point(field_get:sg.UserRoom.comfort)
  return comfort_;
}
inline void UserRoom::set_comfort(::google::protobuf::int32 value) {
  set_has_comfort();
  comfort_ = value;
  // @@protoc_insertion_point(field_set:sg.UserRoom.comfort)
}

// optional int32 machine_capacity = 4;
inline bool UserRoom::has_machine_capacity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserRoom::set_has_machine_capacity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserRoom::clear_has_machine_capacity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserRoom::clear_machine_capacity() {
  machine_capacity_ = 0;
  clear_has_machine_capacity();
}
inline ::google::protobuf::int32 UserRoom::machine_capacity() const {
  // @@protoc_insertion_point(field_get:sg.UserRoom.machine_capacity)
  return machine_capacity_;
}
inline void UserRoom::set_machine_capacity(::google::protobuf::int32 value) {
  set_has_machine_capacity();
  machine_capacity_ = value;
  // @@protoc_insertion_point(field_set:sg.UserRoom.machine_capacity)
}

// optional int32 machine_value = 5;
inline bool UserRoom::has_machine_value() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserRoom::set_has_machine_value() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserRoom::clear_has_machine_value() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserRoom::clear_machine_value() {
  machine_value_ = 0;
  clear_has_machine_value();
}
inline ::google::protobuf::int32 UserRoom::machine_value() const {
  // @@protoc_insertion_point(field_get:sg.UserRoom.machine_value)
  return machine_value_;
}
inline void UserRoom::set_machine_value(::google::protobuf::int32 value) {
  set_has_machine_value();
  machine_value_ = value;
  // @@protoc_insertion_point(field_set:sg.UserRoom.machine_value)
}

// -------------------------------------------------------------------

// Locale

// required int32 place_id = 1;
inline bool Locale::has_place_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Locale::set_has_place_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Locale::clear_has_place_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Locale::clear_place_id() {
  place_id_ = 0;
  clear_has_place_id();
}
inline ::google::protobuf::int32 Locale::place_id() const {
  // @@protoc_insertion_point(field_get:sg.Locale.place_id)
  return place_id_;
}
inline void Locale::set_place_id(::google::protobuf::int32 value) {
  set_has_place_id();
  place_id_ = value;
  // @@protoc_insertion_point(field_set:sg.Locale.place_id)
}

// required int32 pos_type = 2;
inline bool Locale::has_pos_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Locale::set_has_pos_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Locale::clear_has_pos_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Locale::clear_pos_type() {
  pos_type_ = 0;
  clear_has_pos_type();
}
inline ::google::protobuf::int32 Locale::pos_type() const {
  // @@protoc_insertion_point(field_get:sg.Locale.pos_type)
  return pos_type_;
}
inline void Locale::set_pos_type(::google::protobuf::int32 value) {
  set_has_pos_type();
  pos_type_ = value;
  // @@protoc_insertion_point(field_set:sg.Locale.pos_type)
}

// required int32 pos_x = 3;
inline bool Locale::has_pos_x() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Locale::set_has_pos_x() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Locale::clear_has_pos_x() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Locale::clear_pos_x() {
  pos_x_ = 0;
  clear_has_pos_x();
}
inline ::google::protobuf::int32 Locale::pos_x() const {
  // @@protoc_insertion_point(field_get:sg.Locale.pos_x)
  return pos_x_;
}
inline void Locale::set_pos_x(::google::protobuf::int32 value) {
  set_has_pos_x();
  pos_x_ = value;
  // @@protoc_insertion_point(field_set:sg.Locale.pos_x)
}

// required int32 pos_y = 4;
inline bool Locale::has_pos_y() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Locale::set_has_pos_y() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Locale::clear_has_pos_y() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Locale::clear_pos_y() {
  pos_y_ = 0;
  clear_has_pos_y();
}
inline ::google::protobuf::int32 Locale::pos_y() const {
  // @@protoc_insertion_point(field_get:sg.Locale.pos_y)
  return pos_y_;
}
inline void Locale::set_pos_y(::google::protobuf::int32 value) {
  set_has_pos_y();
  pos_y_ = value;
  // @@protoc_insertion_point(field_set:sg.Locale.pos_y)
}

// -------------------------------------------------------------------

// pb_pair_int_int

// required int32 key = 1;
inline bool pb_pair_int_int::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pb_pair_int_int::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pb_pair_int_int::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pb_pair_int_int::clear_key() {
  key_ = 0;
  clear_has_key();
}
inline ::google::protobuf::int32 pb_pair_int_int::key() const {
  // @@protoc_insertion_point(field_get:sg.pb_pair_int_int.key)
  return key_;
}
inline void pb_pair_int_int::set_key(::google::protobuf::int32 value) {
  set_has_key();
  key_ = value;
  // @@protoc_insertion_point(field_set:sg.pb_pair_int_int.key)
}

// required int32 value = 2;
inline bool pb_pair_int_int::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pb_pair_int_int::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pb_pair_int_int::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pb_pair_int_int::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::google::protobuf::int32 pb_pair_int_int::value() const {
  // @@protoc_insertion_point(field_get:sg.pb_pair_int_int.value)
  return value_;
}
inline void pb_pair_int_int::set_value(::google::protobuf::int32 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:sg.pb_pair_int_int.value)
}

// -------------------------------------------------------------------

// pb_pair_int_time

// required int32 key = 1;
inline bool pb_pair_int_time::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pb_pair_int_time::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pb_pair_int_time::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pb_pair_int_time::clear_key() {
  key_ = 0;
  clear_has_key();
}
inline ::google::protobuf::int32 pb_pair_int_time::key() const {
  // @@protoc_insertion_point(field_get:sg.pb_pair_int_time.key)
  return key_;
}
inline void pb_pair_int_time::set_key(::google::protobuf::int32 value) {
  set_has_key();
  key_ = value;
  // @@protoc_insertion_point(field_set:sg.pb_pair_int_time.key)
}

// required sfixed64 value = 2;
inline bool pb_pair_int_time::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pb_pair_int_time::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pb_pair_int_time::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pb_pair_int_time::clear_value() {
  value_ = GOOGLE_LONGLONG(0);
  clear_has_value();
}
inline ::google::protobuf::int64 pb_pair_int_time::value() const {
  // @@protoc_insertion_point(field_get:sg.pb_pair_int_time.value)
  return value_;
}
inline void pb_pair_int_time::set_value(::google::protobuf::int64 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:sg.pb_pair_int_time.value)
}

// -------------------------------------------------------------------

// pb_pair_int64_int

// required int64 key = 1;
inline bool pb_pair_int64_int::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pb_pair_int64_int::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pb_pair_int64_int::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pb_pair_int64_int::clear_key() {
  key_ = GOOGLE_LONGLONG(0);
  clear_has_key();
}
inline ::google::protobuf::int64 pb_pair_int64_int::key() const {
  // @@protoc_insertion_point(field_get:sg.pb_pair_int64_int.key)
  return key_;
}
inline void pb_pair_int64_int::set_key(::google::protobuf::int64 value) {
  set_has_key();
  key_ = value;
  // @@protoc_insertion_point(field_set:sg.pb_pair_int64_int.key)
}

// required int32 value = 2;
inline bool pb_pair_int64_int::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pb_pair_int64_int::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pb_pair_int64_int::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pb_pair_int64_int::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::google::protobuf::int32 pb_pair_int64_int::value() const {
  // @@protoc_insertion_point(field_get:sg.pb_pair_int64_int.value)
  return value_;
}
inline void pb_pair_int64_int::set_value(::google::protobuf::int32 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:sg.pb_pair_int64_int.value)
}

// -------------------------------------------------------------------

// pb_pair_string_int

// required bytes key = 1;
inline bool pb_pair_string_int::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pb_pair_string_int::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pb_pair_string_int::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pb_pair_string_int::clear_key() {
  key_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_key();
}
inline const ::std::string& pb_pair_string_int::key() const {
  // @@protoc_insertion_point(field_get:sg.pb_pair_string_int.key)
  return key_.Get();
}
inline void pb_pair_string_int::set_key(const ::std::string& value) {
  set_has_key();
  key_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:sg.pb_pair_string_int.key)
}
#if LANG_CXX11
inline void pb_pair_string_int::set_key(::std::string&& value) {
  set_has_key();
  key_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:sg.pb_pair_string_int.key)
}
#endif
inline void pb_pair_string_int::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key();
  key_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:sg.pb_pair_string_int.key)
}
inline void pb_pair_string_int::set_key(const void* value,
    size_t size) {
  set_has_key();
  key_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:sg.pb_pair_string_int.key)
}
inline ::std::string* pb_pair_string_int::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:sg.pb_pair_string_int.key)
  return key_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* pb_pair_string_int::release_key() {
  // @@protoc_insertion_point(field_release:sg.pb_pair_string_int.key)
  if (!has_key()) {
    return NULL;
  }
  clear_has_key();
  return key_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void pb_pair_string_int::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:sg.pb_pair_string_int.key)
}
inline ::std::string* pb_pair_string_int::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.pb_pair_string_int.key)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_key();
  return key_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void pb_pair_string_int::unsafe_arena_set_allocated_key(
    ::std::string* key) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      key, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sg.pb_pair_string_int.key)
}

// required int32 value = 2;
inline bool pb_pair_string_int::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pb_pair_string_int::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pb_pair_string_int::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pb_pair_string_int::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::google::protobuf::int32 pb_pair_string_int::value() const {
  // @@protoc_insertion_point(field_get:sg.pb_pair_string_int.value)
  return value_;
}
inline void pb_pair_string_int::set_value(::google::protobuf::int32 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:sg.pb_pair_string_int.value)
}

// -------------------------------------------------------------------

// pb_pair_int_float

// required int32 key = 1;
inline bool pb_pair_int_float::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pb_pair_int_float::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pb_pair_int_float::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pb_pair_int_float::clear_key() {
  key_ = 0;
  clear_has_key();
}
inline ::google::protobuf::int32 pb_pair_int_float::key() const {
  // @@protoc_insertion_point(field_get:sg.pb_pair_int_float.key)
  return key_;
}
inline void pb_pair_int_float::set_key(::google::protobuf::int32 value) {
  set_has_key();
  key_ = value;
  // @@protoc_insertion_point(field_set:sg.pb_pair_int_float.key)
}

// required float value = 2;
inline bool pb_pair_int_float::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pb_pair_int_float::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pb_pair_int_float::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pb_pair_int_float::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline float pb_pair_int_float::value() const {
  // @@protoc_insertion_point(field_get:sg.pb_pair_int_float.value)
  return value_;
}
inline void pb_pair_int_float::set_value(float value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:sg.pb_pair_int_float.value)
}

// -------------------------------------------------------------------

// UserInfo

// required uint64 uuid = 1;
inline bool UserInfo::has_uuid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserInfo::set_has_uuid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserInfo::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserInfo::clear_uuid() {
  uuid_ = GOOGLE_ULONGLONG(0);
  clear_has_uuid();
}
inline ::google::protobuf::uint64 UserInfo::uuid() const {
  // @@protoc_insertion_point(field_get:sg.UserInfo.uuid)
  return uuid_;
}
inline void UserInfo::set_uuid(::google::protobuf::uint64 value) {
  set_has_uuid();
  uuid_ = value;
  // @@protoc_insertion_point(field_set:sg.UserInfo.uuid)
}

// required int32 level = 2;
inline bool UserInfo::has_level() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserInfo::set_has_level() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserInfo::clear_has_level() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserInfo::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 UserInfo::level() const {
  // @@protoc_insertion_point(field_get:sg.UserInfo.level)
  return level_;
}
inline void UserInfo::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:sg.UserInfo.level)
}

// required bytes nick = 3;
inline bool UserInfo::has_nick() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserInfo::set_has_nick() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserInfo::clear_has_nick() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserInfo::clear_nick() {
  nick_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_nick();
}
inline const ::std::string& UserInfo::nick() const {
  // @@protoc_insertion_point(field_get:sg.UserInfo.nick)
  return nick_.Get();
}
inline void UserInfo::set_nick(const ::std::string& value) {
  set_has_nick();
  nick_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:sg.UserInfo.nick)
}
#if LANG_CXX11
inline void UserInfo::set_nick(::std::string&& value) {
  set_has_nick();
  nick_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:sg.UserInfo.nick)
}
#endif
inline void UserInfo::set_nick(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_nick();
  nick_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:sg.UserInfo.nick)
}
inline void UserInfo::set_nick(const void* value,
    size_t size) {
  set_has_nick();
  nick_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:sg.UserInfo.nick)
}
inline ::std::string* UserInfo::mutable_nick() {
  set_has_nick();
  // @@protoc_insertion_point(field_mutable:sg.UserInfo.nick)
  return nick_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* UserInfo::release_nick() {
  // @@protoc_insertion_point(field_release:sg.UserInfo.nick)
  if (!has_nick()) {
    return NULL;
  }
  clear_has_nick();
  return nick_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void UserInfo::set_allocated_nick(::std::string* nick) {
  if (nick != NULL) {
    set_has_nick();
  } else {
    clear_has_nick();
  }
  nick_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nick,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:sg.UserInfo.nick)
}
inline ::std::string* UserInfo::unsafe_arena_release_nick() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.UserInfo.nick)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_nick();
  return nick_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void UserInfo::unsafe_arena_set_allocated_nick(
    ::std::string* nick) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (nick != NULL) {
    set_has_nick();
  } else {
    clear_has_nick();
  }
  nick_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      nick, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sg.UserInfo.nick)
}

// required int32 portrait = 4;
inline bool UserInfo::has_portrait() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserInfo::set_has_portrait() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserInfo::clear_has_portrait() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserInfo::clear_portrait() {
  portrait_ = 0;
  clear_has_portrait();
}
inline ::google::protobuf::int32 UserInfo::portrait() const {
  // @@protoc_insertion_point(field_get:sg.UserInfo.portrait)
  return portrait_;
}
inline void UserInfo::set_portrait(::google::protobuf::int32 value) {
  set_has_portrait();
  portrait_ = value;
  // @@protoc_insertion_point(field_set:sg.UserInfo.portrait)
}

// required bytes signature = 5;
inline bool UserInfo::has_signature() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserInfo::set_has_signature() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserInfo::clear_has_signature() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserInfo::clear_signature() {
  signature_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_signature();
}
inline const ::std::string& UserInfo::signature() const {
  // @@protoc_insertion_point(field_get:sg.UserInfo.signature)
  return signature_.Get();
}
inline void UserInfo::set_signature(const ::std::string& value) {
  set_has_signature();
  signature_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:sg.UserInfo.signature)
}
#if LANG_CXX11
inline void UserInfo::set_signature(::std::string&& value) {
  set_has_signature();
  signature_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:sg.UserInfo.signature)
}
#endif
inline void UserInfo::set_signature(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_signature();
  signature_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:sg.UserInfo.signature)
}
inline void UserInfo::set_signature(const void* value,
    size_t size) {
  set_has_signature();
  signature_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:sg.UserInfo.signature)
}
inline ::std::string* UserInfo::mutable_signature() {
  set_has_signature();
  // @@protoc_insertion_point(field_mutable:sg.UserInfo.signature)
  return signature_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* UserInfo::release_signature() {
  // @@protoc_insertion_point(field_release:sg.UserInfo.signature)
  if (!has_signature()) {
    return NULL;
  }
  clear_has_signature();
  return signature_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void UserInfo::set_allocated_signature(::std::string* signature) {
  if (signature != NULL) {
    set_has_signature();
  } else {
    clear_has_signature();
  }
  signature_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:sg.UserInfo.signature)
}
inline ::std::string* UserInfo::unsafe_arena_release_signature() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.UserInfo.signature)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_signature();
  return signature_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void UserInfo::unsafe_arena_set_allocated_signature(
    ::std::string* signature) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (signature != NULL) {
    set_has_signature();
  } else {
    clear_has_signature();
  }
  signature_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      signature, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sg.UserInfo.signature)
}

// optional int32 portrait_frame = 6;
inline bool UserInfo::has_portrait_frame() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserInfo::set_has_portrait_frame() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserInfo::clear_has_portrait_frame() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserInfo::clear_portrait_frame() {
  portrait_frame_ = 0;
  clear_has_portrait_frame();
}
inline ::google::protobuf::int32 UserInfo::portrait_frame() const {
  // @@protoc_insertion_point(field_get:sg.UserInfo.portrait_frame)
  return portrait_frame_;
}
inline void UserInfo::set_portrait_frame(::google::protobuf::int32 value) {
  set_has_portrait_frame();
  portrait_frame_ = value;
  // @@protoc_insertion_point(field_set:sg.UserInfo.portrait_frame)
}

// -------------------------------------------------------------------

// UserState

// optional bytes guide_val = 2;
inline bool UserState::has_guide_val() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserState::set_has_guide_val() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserState::clear_has_guide_val() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserState::clear_guide_val() {
  guide_val_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_guide_val();
}
inline const ::std::string& UserState::guide_val() const {
  // @@protoc_insertion_point(field_get:sg.UserState.guide_val)
  return guide_val_.Get();
}
inline void UserState::set_guide_val(const ::std::string& value) {
  set_has_guide_val();
  guide_val_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:sg.UserState.guide_val)
}
#if LANG_CXX11
inline void UserState::set_guide_val(::std::string&& value) {
  set_has_guide_val();
  guide_val_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:sg.UserState.guide_val)
}
#endif
inline void UserState::set_guide_val(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_guide_val();
  guide_val_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:sg.UserState.guide_val)
}
inline void UserState::set_guide_val(const void* value,
    size_t size) {
  set_has_guide_val();
  guide_val_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:sg.UserState.guide_val)
}
inline ::std::string* UserState::mutable_guide_val() {
  set_has_guide_val();
  // @@protoc_insertion_point(field_mutable:sg.UserState.guide_val)
  return guide_val_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* UserState::release_guide_val() {
  // @@protoc_insertion_point(field_release:sg.UserState.guide_val)
  if (!has_guide_val()) {
    return NULL;
  }
  clear_has_guide_val();
  return guide_val_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void UserState::set_allocated_guide_val(::std::string* guide_val) {
  if (guide_val != NULL) {
    set_has_guide_val();
  } else {
    clear_has_guide_val();
  }
  guide_val_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), guide_val,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:sg.UserState.guide_val)
}
inline ::std::string* UserState::unsafe_arena_release_guide_val() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.UserState.guide_val)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_guide_val();
  return guide_val_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void UserState::unsafe_arena_set_allocated_guide_val(
    ::std::string* guide_val) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (guide_val != NULL) {
    set_has_guide_val();
  } else {
    clear_has_guide_val();
  }
  guide_val_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      guide_val, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sg.UserState.guide_val)
}

// optional int32 occupy_monster_ship_times = 3;
inline bool UserState::has_occupy_monster_ship_times() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserState::set_has_occupy_monster_ship_times() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserState::clear_has_occupy_monster_ship_times() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserState::clear_occupy_monster_ship_times() {
  occupy_monster_ship_times_ = 0;
  clear_has_occupy_monster_ship_times();
}
inline ::google::protobuf::int32 UserState::occupy_monster_ship_times() const {
  // @@protoc_insertion_point(field_get:sg.UserState.occupy_monster_ship_times)
  return occupy_monster_ship_times_;
}
inline void UserState::set_occupy_monster_ship_times(::google::protobuf::int32 value) {
  set_has_occupy_monster_ship_times();
  occupy_monster_ship_times_ = value;
  // @@protoc_insertion_point(field_set:sg.UserState.occupy_monster_ship_times)
}

// optional int32 occupy_player_ship_times = 4;
inline bool UserState::has_occupy_player_ship_times() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserState::set_has_occupy_player_ship_times() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserState::clear_has_occupy_player_ship_times() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserState::clear_occupy_player_ship_times() {
  occupy_player_ship_times_ = 0;
  clear_has_occupy_player_ship_times();
}
inline ::google::protobuf::int32 UserState::occupy_player_ship_times() const {
  // @@protoc_insertion_point(field_get:sg.UserState.occupy_player_ship_times)
  return occupy_player_ship_times_;
}
inline void UserState::set_occupy_player_ship_times(::google::protobuf::int32 value) {
  set_has_occupy_player_ship_times();
  occupy_player_ship_times_ = value;
  // @@protoc_insertion_point(field_set:sg.UserState.occupy_player_ship_times)
}

// optional int32 occupy_special_ship_times = 5;
inline bool UserState::has_occupy_special_ship_times() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserState::set_has_occupy_special_ship_times() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserState::clear_has_occupy_special_ship_times() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserState::clear_occupy_special_ship_times() {
  occupy_special_ship_times_ = 0;
  clear_has_occupy_special_ship_times();
}
inline ::google::protobuf::int32 UserState::occupy_special_ship_times() const {
  // @@protoc_insertion_point(field_get:sg.UserState.occupy_special_ship_times)
  return occupy_special_ship_times_;
}
inline void UserState::set_occupy_special_ship_times(::google::protobuf::int32 value) {
  set_has_occupy_special_ship_times();
  occupy_special_ship_times_ = value;
  // @@protoc_insertion_point(field_set:sg.UserState.occupy_special_ship_times)
}

// optional int32 max_occupy_monster_ship_times = 6;
inline bool UserState::has_max_occupy_monster_ship_times() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserState::set_has_max_occupy_monster_ship_times() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserState::clear_has_max_occupy_monster_ship_times() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserState::clear_max_occupy_monster_ship_times() {
  max_occupy_monster_ship_times_ = 0;
  clear_has_max_occupy_monster_ship_times();
}
inline ::google::protobuf::int32 UserState::max_occupy_monster_ship_times() const {
  // @@protoc_insertion_point(field_get:sg.UserState.max_occupy_monster_ship_times)
  return max_occupy_monster_ship_times_;
}
inline void UserState::set_max_occupy_monster_ship_times(::google::protobuf::int32 value) {
  set_has_max_occupy_monster_ship_times();
  max_occupy_monster_ship_times_ = value;
  // @@protoc_insertion_point(field_set:sg.UserState.max_occupy_monster_ship_times)
}

// optional int32 max_occupy_player_ship_times = 7;
inline bool UserState::has_max_occupy_player_ship_times() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserState::set_has_max_occupy_player_ship_times() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserState::clear_has_max_occupy_player_ship_times() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserState::clear_max_occupy_player_ship_times() {
  max_occupy_player_ship_times_ = 0;
  clear_has_max_occupy_player_ship_times();
}
inline ::google::protobuf::int32 UserState::max_occupy_player_ship_times() const {
  // @@protoc_insertion_point(field_get:sg.UserState.max_occupy_player_ship_times)
  return max_occupy_player_ship_times_;
}
inline void UserState::set_max_occupy_player_ship_times(::google::protobuf::int32 value) {
  set_has_max_occupy_player_ship_times();
  max_occupy_player_ship_times_ = value;
  // @@protoc_insertion_point(field_set:sg.UserState.max_occupy_player_ship_times)
}

// optional int32 max_occupy_special_ship_times = 8;
inline bool UserState::has_max_occupy_special_ship_times() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserState::set_has_max_occupy_special_ship_times() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserState::clear_has_max_occupy_special_ship_times() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserState::clear_max_occupy_special_ship_times() {
  max_occupy_special_ship_times_ = 0;
  clear_has_max_occupy_special_ship_times();
}
inline ::google::protobuf::int32 UserState::max_occupy_special_ship_times() const {
  // @@protoc_insertion_point(field_get:sg.UserState.max_occupy_special_ship_times)
  return max_occupy_special_ship_times_;
}
inline void UserState::set_max_occupy_special_ship_times(::google::protobuf::int32 value) {
  set_has_max_occupy_special_ship_times();
  max_occupy_special_ship_times_ = value;
  // @@protoc_insertion_point(field_set:sg.UserState.max_occupy_special_ship_times)
}

// optional int32 daily_buy_vitality_times = 9;
inline bool UserState::has_daily_buy_vitality_times() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserState::set_has_daily_buy_vitality_times() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserState::clear_has_daily_buy_vitality_times() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserState::clear_daily_buy_vitality_times() {
  daily_buy_vitality_times_ = 0;
  clear_has_daily_buy_vitality_times();
}
inline ::google::protobuf::int32 UserState::daily_buy_vitality_times() const {
  // @@protoc_insertion_point(field_get:sg.UserState.daily_buy_vitality_times)
  return daily_buy_vitality_times_;
}
inline void UserState::set_daily_buy_vitality_times(::google::protobuf::int32 value) {
  set_has_daily_buy_vitality_times();
  daily_buy_vitality_times_ = value;
  // @@protoc_insertion_point(field_set:sg.UserState.daily_buy_vitality_times)
}

// -------------------------------------------------------------------

// Equip_SpecialAttribute

// required int32 id = 1;
inline bool Equip_SpecialAttribute::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Equip_SpecialAttribute::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Equip_SpecialAttribute::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Equip_SpecialAttribute::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Equip_SpecialAttribute::id() const {
  // @@protoc_insertion_point(field_get:sg.Equip.SpecialAttribute.id)
  return id_;
}
inline void Equip_SpecialAttribute::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:sg.Equip.SpecialAttribute.id)
}

// required int32 target = 2;
inline bool Equip_SpecialAttribute::has_target() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Equip_SpecialAttribute::set_has_target() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Equip_SpecialAttribute::clear_has_target() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Equip_SpecialAttribute::clear_target() {
  target_ = 0;
  clear_has_target();
}
inline ::google::protobuf::int32 Equip_SpecialAttribute::target() const {
  // @@protoc_insertion_point(field_get:sg.Equip.SpecialAttribute.target)
  return target_;
}
inline void Equip_SpecialAttribute::set_target(::google::protobuf::int32 value) {
  set_has_target();
  target_ = value;
  // @@protoc_insertion_point(field_set:sg.Equip.SpecialAttribute.target)
}

// required float value = 3;
inline bool Equip_SpecialAttribute::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Equip_SpecialAttribute::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Equip_SpecialAttribute::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Equip_SpecialAttribute::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline float Equip_SpecialAttribute::value() const {
  // @@protoc_insertion_point(field_get:sg.Equip.SpecialAttribute.value)
  return value_;
}
inline void Equip_SpecialAttribute::set_value(float value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:sg.Equip.SpecialAttribute.value)
}

// -------------------------------------------------------------------

// Equip_EquipAttributeSlot

// required int32 id = 1;
inline bool Equip_EquipAttributeSlot::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Equip_EquipAttributeSlot::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Equip_EquipAttributeSlot::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Equip_EquipAttributeSlot::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Equip_EquipAttributeSlot::id() const {
  // @@protoc_insertion_point(field_get:sg.Equip.EquipAttributeSlot.id)
  return id_;
}
inline void Equip_EquipAttributeSlot::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:sg.Equip.EquipAttributeSlot.id)
}

// required int32 type = 2;
inline bool Equip_EquipAttributeSlot::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Equip_EquipAttributeSlot::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Equip_EquipAttributeSlot::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Equip_EquipAttributeSlot::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 Equip_EquipAttributeSlot::type() const {
  // @@protoc_insertion_point(field_get:sg.Equip.EquipAttributeSlot.type)
  return type_;
}
inline void Equip_EquipAttributeSlot::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:sg.Equip.EquipAttributeSlot.type)
}

// required int32 typeid = 3;
inline bool Equip_EquipAttributeSlot::has_typeid_() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Equip_EquipAttributeSlot::set_has_typeid_() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Equip_EquipAttributeSlot::clear_has_typeid_() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Equip_EquipAttributeSlot::clear_typeid_() {
  typeid__ = 0;
  clear_has_typeid_();
}
inline ::google::protobuf::int32 Equip_EquipAttributeSlot::typeid_() const {
  // @@protoc_insertion_point(field_get:sg.Equip.EquipAttributeSlot.typeid)
  return typeid__;
}
inline void Equip_EquipAttributeSlot::set_typeid_(::google::protobuf::int32 value) {
  set_has_typeid_();
  typeid__ = value;
  // @@protoc_insertion_point(field_set:sg.Equip.EquipAttributeSlot.typeid)
}

// required float value = 4;
inline bool Equip_EquipAttributeSlot::has_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Equip_EquipAttributeSlot::set_has_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Equip_EquipAttributeSlot::clear_has_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Equip_EquipAttributeSlot::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline float Equip_EquipAttributeSlot::value() const {
  // @@protoc_insertion_point(field_get:sg.Equip.EquipAttributeSlot.value)
  return value_;
}
inline void Equip_EquipAttributeSlot::set_value(float value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:sg.Equip.EquipAttributeSlot.value)
}

// required int32 refine_times = 5;
inline bool Equip_EquipAttributeSlot::has_refine_times() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Equip_EquipAttributeSlot::set_has_refine_times() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Equip_EquipAttributeSlot::clear_has_refine_times() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Equip_EquipAttributeSlot::clear_refine_times() {
  refine_times_ = 0;
  clear_has_refine_times();
}
inline ::google::protobuf::int32 Equip_EquipAttributeSlot::refine_times() const {
  // @@protoc_insertion_point(field_get:sg.Equip.EquipAttributeSlot.refine_times)
  return refine_times_;
}
inline void Equip_EquipAttributeSlot::set_refine_times(::google::protobuf::int32 value) {
  set_has_refine_times();
  refine_times_ = value;
  // @@protoc_insertion_point(field_set:sg.Equip.EquipAttributeSlot.refine_times)
}

// optional bool big_success = 6;
inline bool Equip_EquipAttributeSlot::has_big_success() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Equip_EquipAttributeSlot::set_has_big_success() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Equip_EquipAttributeSlot::clear_has_big_success() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Equip_EquipAttributeSlot::clear_big_success() {
  big_success_ = false;
  clear_has_big_success();
}
inline bool Equip_EquipAttributeSlot::big_success() const {
  // @@protoc_insertion_point(field_get:sg.Equip.EquipAttributeSlot.big_success)
  return big_success_;
}
inline void Equip_EquipAttributeSlot::set_big_success(bool value) {
  set_has_big_success();
  big_success_ = value;
  // @@protoc_insertion_point(field_set:sg.Equip.EquipAttributeSlot.big_success)
}

// -------------------------------------------------------------------

// Equip

// required int32 id = 1;
inline bool Equip::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Equip::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Equip::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Equip::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Equip::id() const {
  // @@protoc_insertion_point(field_get:sg.Equip.id)
  return id_;
}
inline void Equip::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:sg.Equip.id)
}

// required int32 typeid = 2;
inline bool Equip::has_typeid_() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Equip::set_has_typeid_() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Equip::clear_has_typeid_() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Equip::clear_typeid_() {
  typeid__ = 0;
  clear_has_typeid_();
}
inline ::google::protobuf::int32 Equip::typeid_() const {
  // @@protoc_insertion_point(field_get:sg.Equip.typeid)
  return typeid__;
}
inline void Equip::set_typeid_(::google::protobuf::int32 value) {
  set_has_typeid_();
  typeid__ = value;
  // @@protoc_insertion_point(field_set:sg.Equip.typeid)
}

// required int32 quality = 3;
inline bool Equip::has_quality() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Equip::set_has_quality() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Equip::clear_has_quality() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Equip::clear_quality() {
  quality_ = 0;
  clear_has_quality();
}
inline ::google::protobuf::int32 Equip::quality() const {
  // @@protoc_insertion_point(field_get:sg.Equip.quality)
  return quality_;
}
inline void Equip::set_quality(::google::protobuf::int32 value) {
  set_has_quality();
  quality_ = value;
  // @@protoc_insertion_point(field_set:sg.Equip.quality)
}

// required int32 state = 4;
inline bool Equip::has_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Equip::set_has_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Equip::clear_has_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Equip::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 Equip::state() const {
  // @@protoc_insertion_point(field_get:sg.Equip.state)
  return state_;
}
inline void Equip::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:sg.Equip.state)
}

// required int32 belong_to = 5;
inline bool Equip::has_belong_to() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Equip::set_has_belong_to() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Equip::clear_has_belong_to() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Equip::clear_belong_to() {
  belong_to_ = 0;
  clear_has_belong_to();
}
inline ::google::protobuf::int32 Equip::belong_to() const {
  // @@protoc_insertion_point(field_get:sg.Equip.belong_to)
  return belong_to_;
}
inline void Equip::set_belong_to(::google::protobuf::int32 value) {
  set_has_belong_to();
  belong_to_ = value;
  // @@protoc_insertion_point(field_set:sg.Equip.belong_to)
}

// repeated .sg.pb_pair_int_float attribute = 6;
inline int Equip::attribute_size() const {
  return attribute_.size();
}
inline void Equip::clear_attribute() {
  attribute_.Clear();
}
inline ::sg::pb_pair_int_float* Equip::mutable_attribute(int index) {
  // @@protoc_insertion_point(field_mutable:sg.Equip.attribute)
  return attribute_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_float >*
Equip::mutable_attribute() {
  // @@protoc_insertion_point(field_mutable_list:sg.Equip.attribute)
  return &attribute_;
}
inline const ::sg::pb_pair_int_float& Equip::attribute(int index) const {
  // @@protoc_insertion_point(field_get:sg.Equip.attribute)
  return attribute_.Get(index);
}
inline ::sg::pb_pair_int_float* Equip::add_attribute() {
  // @@protoc_insertion_point(field_add:sg.Equip.attribute)
  return attribute_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_float >&
Equip::attribute() const {
  // @@protoc_insertion_point(field_list:sg.Equip.attribute)
  return attribute_;
}

// repeated .sg.Equip.SpecialAttribute special_attr = 7;
inline int Equip::special_attr_size() const {
  return special_attr_.size();
}
inline void Equip::clear_special_attr() {
  special_attr_.Clear();
}
inline ::sg::Equip_SpecialAttribute* Equip::mutable_special_attr(int index) {
  // @@protoc_insertion_point(field_mutable:sg.Equip.special_attr)
  return special_attr_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::Equip_SpecialAttribute >*
Equip::mutable_special_attr() {
  // @@protoc_insertion_point(field_mutable_list:sg.Equip.special_attr)
  return &special_attr_;
}
inline const ::sg::Equip_SpecialAttribute& Equip::special_attr(int index) const {
  // @@protoc_insertion_point(field_get:sg.Equip.special_attr)
  return special_attr_.Get(index);
}
inline ::sg::Equip_SpecialAttribute* Equip::add_special_attr() {
  // @@protoc_insertion_point(field_add:sg.Equip.special_attr)
  return special_attr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::Equip_SpecialAttribute >&
Equip::special_attr() const {
  // @@protoc_insertion_point(field_list:sg.Equip.special_attr)
  return special_attr_;
}

// repeated .sg.Equip.EquipAttributeSlot attr_slots = 8;
inline int Equip::attr_slots_size() const {
  return attr_slots_.size();
}
inline void Equip::clear_attr_slots() {
  attr_slots_.Clear();
}
inline ::sg::Equip_EquipAttributeSlot* Equip::mutable_attr_slots(int index) {
  // @@protoc_insertion_point(field_mutable:sg.Equip.attr_slots)
  return attr_slots_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::Equip_EquipAttributeSlot >*
Equip::mutable_attr_slots() {
  // @@protoc_insertion_point(field_mutable_list:sg.Equip.attr_slots)
  return &attr_slots_;
}
inline const ::sg::Equip_EquipAttributeSlot& Equip::attr_slots(int index) const {
  // @@protoc_insertion_point(field_get:sg.Equip.attr_slots)
  return attr_slots_.Get(index);
}
inline ::sg::Equip_EquipAttributeSlot* Equip::add_attr_slots() {
  // @@protoc_insertion_point(field_add:sg.Equip.attr_slots)
  return attr_slots_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::Equip_EquipAttributeSlot >&
Equip::attr_slots() const {
  // @@protoc_insertion_point(field_list:sg.Equip.attr_slots)
  return attr_slots_;
}

// optional int32 quality_refine_times = 9;
inline bool Equip::has_quality_refine_times() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Equip::set_has_quality_refine_times() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Equip::clear_has_quality_refine_times() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Equip::clear_quality_refine_times() {
  quality_refine_times_ = 0;
  clear_has_quality_refine_times();
}
inline ::google::protobuf::int32 Equip::quality_refine_times() const {
  // @@protoc_insertion_point(field_get:sg.Equip.quality_refine_times)
  return quality_refine_times_;
}
inline void Equip::set_quality_refine_times(::google::protobuf::int32 value) {
  set_has_quality_refine_times();
  quality_refine_times_ = value;
  // @@protoc_insertion_point(field_set:sg.Equip.quality_refine_times)
}

// optional int64 skill = 10;
inline bool Equip::has_skill() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Equip::set_has_skill() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Equip::clear_has_skill() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Equip::clear_skill() {
  skill_ = GOOGLE_LONGLONG(0);
  clear_has_skill();
}
inline ::google::protobuf::int64 Equip::skill() const {
  // @@protoc_insertion_point(field_get:sg.Equip.skill)
  return skill_;
}
inline void Equip::set_skill(::google::protobuf::int64 value) {
  set_has_skill();
  skill_ = value;
  // @@protoc_insertion_point(field_set:sg.Equip.skill)
}

// -------------------------------------------------------------------

// SailorSkill

// required int32 slotid = 1;
inline bool SailorSkill::has_slotid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SailorSkill::set_has_slotid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SailorSkill::clear_has_slotid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SailorSkill::clear_slotid() {
  slotid_ = 0;
  clear_has_slotid();
}
inline ::google::protobuf::int32 SailorSkill::slotid() const {
  // @@protoc_insertion_point(field_get:sg.SailorSkill.slotid)
  return slotid_;
}
inline void SailorSkill::set_slotid(::google::protobuf::int32 value) {
  set_has_slotid();
  slotid_ = value;
  // @@protoc_insertion_point(field_set:sg.SailorSkill.slotid)
}

// required int32 type = 2;
inline bool SailorSkill::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SailorSkill::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SailorSkill::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SailorSkill::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 SailorSkill::type() const {
  // @@protoc_insertion_point(field_get:sg.SailorSkill.type)
  return type_;
}
inline void SailorSkill::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:sg.SailorSkill.type)
}

// required int32 state = 3;
inline bool SailorSkill::has_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SailorSkill::set_has_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SailorSkill::clear_has_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SailorSkill::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 SailorSkill::state() const {
  // @@protoc_insertion_point(field_get:sg.SailorSkill.state)
  return state_;
}
inline void SailorSkill::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:sg.SailorSkill.state)
}

// required uint64 skillid = 4;
inline bool SailorSkill::has_skillid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SailorSkill::set_has_skillid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SailorSkill::clear_has_skillid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SailorSkill::clear_skillid() {
  skillid_ = GOOGLE_ULONGLONG(0);
  clear_has_skillid();
}
inline ::google::protobuf::uint64 SailorSkill::skillid() const {
  // @@protoc_insertion_point(field_get:sg.SailorSkill.skillid)
  return skillid_;
}
inline void SailorSkill::set_skillid(::google::protobuf::uint64 value) {
  set_has_skillid();
  skillid_ = value;
  // @@protoc_insertion_point(field_set:sg.SailorSkill.skillid)
}

// required int32 level = 5;
inline bool SailorSkill::has_level() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SailorSkill::set_has_level() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SailorSkill::clear_has_level() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SailorSkill::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 SailorSkill::level() const {
  // @@protoc_insertion_point(field_get:sg.SailorSkill.level)
  return level_;
}
inline void SailorSkill::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:sg.SailorSkill.level)
}

// -------------------------------------------------------------------

// SailorFarmSkill

// required uint64 id = 1;
inline bool SailorFarmSkill::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SailorFarmSkill::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SailorFarmSkill::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SailorFarmSkill::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 SailorFarmSkill::id() const {
  // @@protoc_insertion_point(field_get:sg.SailorFarmSkill.id)
  return id_;
}
inline void SailorFarmSkill::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:sg.SailorFarmSkill.id)
}

// required int32 level = 2;
inline bool SailorFarmSkill::has_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SailorFarmSkill::set_has_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SailorFarmSkill::clear_has_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SailorFarmSkill::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 SailorFarmSkill::level() const {
  // @@protoc_insertion_point(field_get:sg.SailorFarmSkill.level)
  return level_;
}
inline void SailorFarmSkill::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:sg.SailorFarmSkill.level)
}

// required int32 exp = 3;
inline bool SailorFarmSkill::has_exp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SailorFarmSkill::set_has_exp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SailorFarmSkill::clear_has_exp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SailorFarmSkill::clear_exp() {
  exp_ = 0;
  clear_has_exp();
}
inline ::google::protobuf::int32 SailorFarmSkill::exp() const {
  // @@protoc_insertion_point(field_get:sg.SailorFarmSkill.exp)
  return exp_;
}
inline void SailorFarmSkill::set_exp(::google::protobuf::int32 value) {
  set_has_exp();
  exp_ = value;
  // @@protoc_insertion_point(field_set:sg.SailorFarmSkill.exp)
}

// -------------------------------------------------------------------

// SailorTalent

// required uint64 id = 1;
inline bool SailorTalent::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SailorTalent::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SailorTalent::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SailorTalent::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 SailorTalent::id() const {
  // @@protoc_insertion_point(field_get:sg.SailorTalent.id)
  return id_;
}
inline void SailorTalent::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:sg.SailorTalent.id)
}

// required int32 level = 2;
inline bool SailorTalent::has_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SailorTalent::set_has_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SailorTalent::clear_has_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SailorTalent::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 SailorTalent::level() const {
  // @@protoc_insertion_point(field_get:sg.SailorTalent.level)
  return level_;
}
inline void SailorTalent::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:sg.SailorTalent.level)
}

// -------------------------------------------------------------------

// Sailor

// required int32 id = 1;
inline bool Sailor::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Sailor::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Sailor::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Sailor::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Sailor::id() const {
  // @@protoc_insertion_point(field_get:sg.Sailor.id)
  return id_;
}
inline void Sailor::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:sg.Sailor.id)
}

// required int32 typeid = 2;
inline bool Sailor::has_typeid_() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Sailor::set_has_typeid_() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Sailor::clear_has_typeid_() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Sailor::clear_typeid_() {
  typeid__ = 0;
  clear_has_typeid_();
}
inline ::google::protobuf::int32 Sailor::typeid_() const {
  // @@protoc_insertion_point(field_get:sg.Sailor.typeid)
  return typeid__;
}
inline void Sailor::set_typeid_(::google::protobuf::int32 value) {
  set_has_typeid_();
  typeid__ = value;
  // @@protoc_insertion_point(field_set:sg.Sailor.typeid)
}

// required .sg.SAILOR_STATE state = 3;
inline bool Sailor::has_state() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Sailor::set_has_state() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Sailor::clear_has_state() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Sailor::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::sg::SAILOR_STATE Sailor::state() const {
  // @@protoc_insertion_point(field_get:sg.Sailor.state)
  return static_cast< ::sg::SAILOR_STATE >(state_);
}
inline void Sailor::set_state(::sg::SAILOR_STATE value) {
  assert(::sg::SAILOR_STATE_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:sg.Sailor.state)
}

// required uint64 place = 4;
inline bool Sailor::has_place() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Sailor::set_has_place() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Sailor::clear_has_place() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Sailor::clear_place() {
  place_ = GOOGLE_ULONGLONG(0);
  clear_has_place();
}
inline ::google::protobuf::uint64 Sailor::place() const {
  // @@protoc_insertion_point(field_get:sg.Sailor.place)
  return place_;
}
inline void Sailor::set_place(::google::protobuf::uint64 value) {
  set_has_place();
  place_ = value;
  // @@protoc_insertion_point(field_set:sg.Sailor.place)
}

// required int32 facility_id = 5;
inline bool Sailor::has_facility_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Sailor::set_has_facility_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Sailor::clear_has_facility_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Sailor::clear_facility_id() {
  facility_id_ = 0;
  clear_has_facility_id();
}
inline ::google::protobuf::int32 Sailor::facility_id() const {
  // @@protoc_insertion_point(field_get:sg.Sailor.facility_id)
  return facility_id_;
}
inline void Sailor::set_facility_id(::google::protobuf::int32 value) {
  set_has_facility_id();
  facility_id_ = value;
  // @@protoc_insertion_point(field_set:sg.Sailor.facility_id)
}

// required int32 level = 6;
inline bool Sailor::has_level() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Sailor::set_has_level() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Sailor::clear_has_level() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Sailor::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 Sailor::level() const {
  // @@protoc_insertion_point(field_get:sg.Sailor.level)
  return level_;
}
inline void Sailor::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:sg.Sailor.level)
}

// required int32 star = 7;
inline bool Sailor::has_star() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Sailor::set_has_star() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Sailor::clear_has_star() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Sailor::clear_star() {
  star_ = 0;
  clear_has_star();
}
inline ::google::protobuf::int32 Sailor::star() const {
  // @@protoc_insertion_point(field_get:sg.Sailor.star)
  return star_;
}
inline void Sailor::set_star(::google::protobuf::int32 value) {
  set_has_star();
  star_ = value;
  // @@protoc_insertion_point(field_set:sg.Sailor.star)
}

// required int32 phase = 8;
inline bool Sailor::has_phase() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Sailor::set_has_phase() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Sailor::clear_has_phase() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Sailor::clear_phase() {
  phase_ = 0;
  clear_has_phase();
}
inline ::google::protobuf::int32 Sailor::phase() const {
  // @@protoc_insertion_point(field_get:sg.Sailor.phase)
  return phase_;
}
inline void Sailor::set_phase(::google::protobuf::int32 value) {
  set_has_phase();
  phase_ = value;
  // @@protoc_insertion_point(field_set:sg.Sailor.phase)
}

// required int32 hp_lost = 9;
inline bool Sailor::has_hp_lost() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Sailor::set_has_hp_lost() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Sailor::clear_has_hp_lost() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Sailor::clear_hp_lost() {
  hp_lost_ = 0;
  clear_has_hp_lost();
}
inline ::google::protobuf::int32 Sailor::hp_lost() const {
  // @@protoc_insertion_point(field_get:sg.Sailor.hp_lost)
  return hp_lost_;
}
inline void Sailor::set_hp_lost(::google::protobuf::int32 value) {
  set_has_hp_lost();
  hp_lost_ = value;
  // @@protoc_insertion_point(field_set:sg.Sailor.hp_lost)
}

// required float vim = 10;
inline bool Sailor::has_vim() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Sailor::set_has_vim() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Sailor::clear_has_vim() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Sailor::clear_vim() {
  vim_ = 0;
  clear_has_vim();
}
inline float Sailor::vim() const {
  // @@protoc_insertion_point(field_get:sg.Sailor.vim)
  return vim_;
}
inline void Sailor::set_vim(float value) {
  set_has_vim();
  vim_ = value;
  // @@protoc_insertion_point(field_set:sg.Sailor.vim)
}

// required int32 exp = 11;
inline bool Sailor::has_exp() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Sailor::set_has_exp() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Sailor::clear_has_exp() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Sailor::clear_exp() {
  exp_ = 0;
  clear_has_exp();
}
inline ::google::protobuf::int32 Sailor::exp() const {
  // @@protoc_insertion_point(field_get:sg.Sailor.exp)
  return exp_;
}
inline void Sailor::set_exp(::google::protobuf::int32 value) {
  set_has_exp();
  exp_ = value;
  // @@protoc_insertion_point(field_set:sg.Sailor.exp)
}

// optional int32 orderid = 13;
inline bool Sailor::has_orderid() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Sailor::set_has_orderid() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Sailor::clear_has_orderid() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Sailor::clear_orderid() {
  orderid_ = 0;
  clear_has_orderid();
}
inline ::google::protobuf::int32 Sailor::orderid() const {
  // @@protoc_insertion_point(field_get:sg.Sailor.orderid)
  return orderid_;
}
inline void Sailor::set_orderid(::google::protobuf::int32 value) {
  set_has_orderid();
  orderid_ = value;
  // @@protoc_insertion_point(field_set:sg.Sailor.orderid)
}

// optional sfixed64 last_rest_time = 14;
inline bool Sailor::has_last_rest_time() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Sailor::set_has_last_rest_time() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Sailor::clear_has_last_rest_time() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Sailor::clear_last_rest_time() {
  last_rest_time_ = GOOGLE_LONGLONG(0);
  clear_has_last_rest_time();
}
inline ::google::protobuf::int64 Sailor::last_rest_time() const {
  // @@protoc_insertion_point(field_get:sg.Sailor.last_rest_time)
  return last_rest_time_;
}
inline void Sailor::set_last_rest_time(::google::protobuf::int64 value) {
  set_has_last_rest_time();
  last_rest_time_ = value;
  // @@protoc_insertion_point(field_set:sg.Sailor.last_rest_time)
}

// optional int32 job = 15;
inline bool Sailor::has_job() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Sailor::set_has_job() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Sailor::clear_has_job() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Sailor::clear_job() {
  job_ = 0;
  clear_has_job();
}
inline ::google::protobuf::int32 Sailor::job() const {
  // @@protoc_insertion_point(field_get:sg.Sailor.job)
  return job_;
}
inline void Sailor::set_job(::google::protobuf::int32 value) {
  set_has_job();
  job_ = value;
  // @@protoc_insertion_point(field_set:sg.Sailor.job)
}

// repeated .sg.pb_pair_int_float attribute = 16;
inline int Sailor::attribute_size() const {
  return attribute_.size();
}
inline void Sailor::clear_attribute() {
  attribute_.Clear();
}
inline ::sg::pb_pair_int_float* Sailor::mutable_attribute(int index) {
  // @@protoc_insertion_point(field_mutable:sg.Sailor.attribute)
  return attribute_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_float >*
Sailor::mutable_attribute() {
  // @@protoc_insertion_point(field_mutable_list:sg.Sailor.attribute)
  return &attribute_;
}
inline const ::sg::pb_pair_int_float& Sailor::attribute(int index) const {
  // @@protoc_insertion_point(field_get:sg.Sailor.attribute)
  return attribute_.Get(index);
}
inline ::sg::pb_pair_int_float* Sailor::add_attribute() {
  // @@protoc_insertion_point(field_add:sg.Sailor.attribute)
  return attribute_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_float >&
Sailor::attribute() const {
  // @@protoc_insertion_point(field_list:sg.Sailor.attribute)
  return attribute_;
}

// repeated .sg.pb_pair_int_float aptitude = 17;
inline int Sailor::aptitude_size() const {
  return aptitude_.size();
}
inline void Sailor::clear_aptitude() {
  aptitude_.Clear();
}
inline ::sg::pb_pair_int_float* Sailor::mutable_aptitude(int index) {
  // @@protoc_insertion_point(field_mutable:sg.Sailor.aptitude)
  return aptitude_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_float >*
Sailor::mutable_aptitude() {
  // @@protoc_insertion_point(field_mutable_list:sg.Sailor.aptitude)
  return &aptitude_;
}
inline const ::sg::pb_pair_int_float& Sailor::aptitude(int index) const {
  // @@protoc_insertion_point(field_get:sg.Sailor.aptitude)
  return aptitude_.Get(index);
}
inline ::sg::pb_pair_int_float* Sailor::add_aptitude() {
  // @@protoc_insertion_point(field_add:sg.Sailor.aptitude)
  return aptitude_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_float >&
Sailor::aptitude() const {
  // @@protoc_insertion_point(field_list:sg.Sailor.aptitude)
  return aptitude_;
}

// repeated .sg.Equip equip = 18;
inline int Sailor::equip_size() const {
  return equip_.size();
}
inline void Sailor::clear_equip() {
  equip_.Clear();
}
inline ::sg::Equip* Sailor::mutable_equip(int index) {
  // @@protoc_insertion_point(field_mutable:sg.Sailor.equip)
  return equip_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::Equip >*
Sailor::mutable_equip() {
  // @@protoc_insertion_point(field_mutable_list:sg.Sailor.equip)
  return &equip_;
}
inline const ::sg::Equip& Sailor::equip(int index) const {
  // @@protoc_insertion_point(field_get:sg.Sailor.equip)
  return equip_.Get(index);
}
inline ::sg::Equip* Sailor::add_equip() {
  // @@protoc_insertion_point(field_add:sg.Sailor.equip)
  return equip_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::Equip >&
Sailor::equip() const {
  // @@protoc_insertion_point(field_list:sg.Sailor.equip)
  return equip_;
}

// repeated .sg.SailorSkill skills = 19;
inline int Sailor::skills_size() const {
  return skills_.size();
}
inline void Sailor::clear_skills() {
  skills_.Clear();
}
inline ::sg::SailorSkill* Sailor::mutable_skills(int index) {
  // @@protoc_insertion_point(field_mutable:sg.Sailor.skills)
  return skills_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::SailorSkill >*
Sailor::mutable_skills() {
  // @@protoc_insertion_point(field_mutable_list:sg.Sailor.skills)
  return &skills_;
}
inline const ::sg::SailorSkill& Sailor::skills(int index) const {
  // @@protoc_insertion_point(field_get:sg.Sailor.skills)
  return skills_.Get(index);
}
inline ::sg::SailorSkill* Sailor::add_skills() {
  // @@protoc_insertion_point(field_add:sg.Sailor.skills)
  return skills_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::SailorSkill >&
Sailor::skills() const {
  // @@protoc_insertion_point(field_list:sg.Sailor.skills)
  return skills_;
}

// repeated .sg.SailorFarmSkill farm_skills = 20;
inline int Sailor::farm_skills_size() const {
  return farm_skills_.size();
}
inline void Sailor::clear_farm_skills() {
  farm_skills_.Clear();
}
inline ::sg::SailorFarmSkill* Sailor::mutable_farm_skills(int index) {
  // @@protoc_insertion_point(field_mutable:sg.Sailor.farm_skills)
  return farm_skills_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::SailorFarmSkill >*
Sailor::mutable_farm_skills() {
  // @@protoc_insertion_point(field_mutable_list:sg.Sailor.farm_skills)
  return &farm_skills_;
}
inline const ::sg::SailorFarmSkill& Sailor::farm_skills(int index) const {
  // @@protoc_insertion_point(field_get:sg.Sailor.farm_skills)
  return farm_skills_.Get(index);
}
inline ::sg::SailorFarmSkill* Sailor::add_farm_skills() {
  // @@protoc_insertion_point(field_add:sg.Sailor.farm_skills)
  return farm_skills_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::SailorFarmSkill >&
Sailor::farm_skills() const {
  // @@protoc_insertion_point(field_list:sg.Sailor.farm_skills)
  return farm_skills_;
}

// optional .sg.SailorTalent talent = 21;
inline bool Sailor::has_talent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Sailor::set_has_talent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Sailor::clear_has_talent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Sailor::clear_talent() {
  if (talent_ != NULL) talent_->Clear();
  clear_has_talent();
}
inline const ::sg::SailorTalent& Sailor::_internal_talent() const {
  return *talent_;
}
inline const ::sg::SailorTalent& Sailor::talent() const {
  const ::sg::SailorTalent* p = talent_;
  // @@protoc_insertion_point(field_get:sg.Sailor.talent)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::SailorTalent*>(
      &::sg::_SailorTalent_default_instance_);
}
inline ::sg::SailorTalent* Sailor::release_talent() {
  // @@protoc_insertion_point(field_release:sg.Sailor.talent)
  clear_has_talent();
  ::sg::SailorTalent* temp = talent_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  talent_ = NULL;
  return temp;
}
inline ::sg::SailorTalent* Sailor::unsafe_arena_release_talent() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.Sailor.talent)
  clear_has_talent();
  ::sg::SailorTalent* temp = talent_;
  talent_ = NULL;
  return temp;
}
inline ::sg::SailorTalent* Sailor::mutable_talent() {
  set_has_talent();
  if (talent_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::SailorTalent>(GetArenaNoVirtual());
    talent_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.Sailor.talent)
  return talent_;
}
inline void Sailor::set_allocated_talent(::sg::SailorTalent* talent) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete talent_;
  }
  if (talent) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(talent);
    if (message_arena != submessage_arena) {
      talent = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, talent, submessage_arena);
    }
    set_has_talent();
  } else {
    clear_has_talent();
  }
  talent_ = talent;
  // @@protoc_insertion_point(field_set_allocated:sg.Sailor.talent)
}

// optional int32 practice = 22;
inline bool Sailor::has_practice() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Sailor::set_has_practice() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Sailor::clear_has_practice() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Sailor::clear_practice() {
  practice_ = 0;
  clear_has_practice();
}
inline ::google::protobuf::int32 Sailor::practice() const {
  // @@protoc_insertion_point(field_get:sg.Sailor.practice)
  return practice_;
}
inline void Sailor::set_practice(::google::protobuf::int32 value) {
  set_has_practice();
  practice_ = value;
  // @@protoc_insertion_point(field_set:sg.Sailor.practice)
}

// optional int32 region = 23;
inline bool Sailor::has_region() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Sailor::set_has_region() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Sailor::clear_has_region() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Sailor::clear_region() {
  region_ = 0;
  clear_has_region();
}
inline ::google::protobuf::int32 Sailor::region() const {
  // @@protoc_insertion_point(field_get:sg.Sailor.region)
  return region_;
}
inline void Sailor::set_region(::google::protobuf::int32 value) {
  set_has_region();
  region_ = value;
  // @@protoc_insertion_point(field_set:sg.Sailor.region)
}

// optional float hunger = 24;
inline bool Sailor::has_hunger() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Sailor::set_has_hunger() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Sailor::clear_has_hunger() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Sailor::clear_hunger() {
  hunger_ = 0;
  clear_has_hunger();
}
inline float Sailor::hunger() const {
  // @@protoc_insertion_point(field_get:sg.Sailor.hunger)
  return hunger_;
}
inline void Sailor::set_hunger(float value) {
  set_has_hunger();
  hunger_ = value;
  // @@protoc_insertion_point(field_set:sg.Sailor.hunger)
}

// -------------------------------------------------------------------

// NPC

// required int32 id = 1;
inline bool NPC::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NPC::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NPC::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NPC::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 NPC::id() const {
  // @@protoc_insertion_point(field_get:sg.NPC.id)
  return id_;
}
inline void NPC::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:sg.NPC.id)
}

// required int32 state = 2;
inline bool NPC::has_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NPC::set_has_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NPC::clear_has_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NPC::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 NPC::state() const {
  // @@protoc_insertion_point(field_get:sg.NPC.state)
  return state_;
}
inline void NPC::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:sg.NPC.state)
}

// required .sg.Locale locale = 3;
inline bool NPC::has_locale() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NPC::set_has_locale() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NPC::clear_has_locale() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NPC::clear_locale() {
  if (locale_ != NULL) locale_->Clear();
  clear_has_locale();
}
inline const ::sg::Locale& NPC::_internal_locale() const {
  return *locale_;
}
inline const ::sg::Locale& NPC::locale() const {
  const ::sg::Locale* p = locale_;
  // @@protoc_insertion_point(field_get:sg.NPC.locale)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::Locale*>(
      &::sg::_Locale_default_instance_);
}
inline ::sg::Locale* NPC::release_locale() {
  // @@protoc_insertion_point(field_release:sg.NPC.locale)
  clear_has_locale();
  ::sg::Locale* temp = locale_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  locale_ = NULL;
  return temp;
}
inline ::sg::Locale* NPC::unsafe_arena_release_locale() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.NPC.locale)
  clear_has_locale();
  ::sg::Locale* temp = locale_;
  locale_ = NULL;
  return temp;
}
inline ::sg::Locale* NPC::mutable_locale() {
  set_has_locale();
  if (locale_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::Locale>(GetArenaNoVirtual());
    locale_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.NPC.locale)
  return locale_;
}
inline void NPC::set_allocated_locale(::sg::Locale* locale) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete locale_;
  }
  if (locale) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(locale);
    if (message_arena != submessage_arena) {
      locale = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, locale, submessage_arena);
    }
    set_has_locale();
  } else {
    clear_has_locale();
  }
  locale_ = locale;
  // @@protoc_insertion_point(field_set_allocated:sg.NPC.locale)
}

// -------------------------------------------------------------------

// Item

// required int32 typeid = 1;
inline bool Item::has_typeid_() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Item::set_has_typeid_() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Item::clear_has_typeid_() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Item::clear_typeid_() {
  typeid__ = 0;
  clear_has_typeid_();
}
inline ::google::protobuf::int32 Item::typeid_() const {
  // @@protoc_insertion_point(field_get:sg.Item.typeid)
  return typeid__;
}
inline void Item::set_typeid_(::google::protobuf::int32 value) {
  set_has_typeid_();
  typeid__ = value;
  // @@protoc_insertion_point(field_set:sg.Item.typeid)
}

// required int64 num = 2;
inline bool Item::has_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Item::set_has_num() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Item::clear_has_num() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Item::clear_num() {
  num_ = GOOGLE_LONGLONG(0);
  clear_has_num();
}
inline ::google::protobuf::int64 Item::num() const {
  // @@protoc_insertion_point(field_get:sg.Item.num)
  return num_;
}
inline void Item::set_num(::google::protobuf::int64 value) {
  set_has_num();
  num_ = value;
  // @@protoc_insertion_point(field_set:sg.Item.num)
}

// -------------------------------------------------------------------

// Facility_SpecialData

// required int32 property_type = 1;
inline bool Facility_SpecialData::has_property_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Facility_SpecialData::set_has_property_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Facility_SpecialData::clear_has_property_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Facility_SpecialData::clear_property_type() {
  property_type_ = 0;
  clear_has_property_type();
}
inline ::google::protobuf::int32 Facility_SpecialData::property_type() const {
  // @@protoc_insertion_point(field_get:sg.Facility.SpecialData.property_type)
  return property_type_;
}
inline void Facility_SpecialData::set_property_type(::google::protobuf::int32 value) {
  set_has_property_type();
  property_type_ = value;
  // @@protoc_insertion_point(field_set:sg.Facility.SpecialData.property_type)
}

// required int32 count_times = 2;
inline bool Facility_SpecialData::has_count_times() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Facility_SpecialData::set_has_count_times() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Facility_SpecialData::clear_has_count_times() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Facility_SpecialData::clear_count_times() {
  count_times_ = 0;
  clear_has_count_times();
}
inline ::google::protobuf::int32 Facility_SpecialData::count_times() const {
  // @@protoc_insertion_point(field_get:sg.Facility.SpecialData.count_times)
  return count_times_;
}
inline void Facility_SpecialData::set_count_times(::google::protobuf::int32 value) {
  set_has_count_times();
  count_times_ = value;
  // @@protoc_insertion_point(field_set:sg.Facility.SpecialData.count_times)
}

// repeated .sg.Item contain = 3;
inline int Facility_SpecialData::contain_size() const {
  return contain_.size();
}
inline void Facility_SpecialData::clear_contain() {
  contain_.Clear();
}
inline ::sg::Item* Facility_SpecialData::mutable_contain(int index) {
  // @@protoc_insertion_point(field_mutable:sg.Facility.SpecialData.contain)
  return contain_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::Item >*
Facility_SpecialData::mutable_contain() {
  // @@protoc_insertion_point(field_mutable_list:sg.Facility.SpecialData.contain)
  return &contain_;
}
inline const ::sg::Item& Facility_SpecialData::contain(int index) const {
  // @@protoc_insertion_point(field_get:sg.Facility.SpecialData.contain)
  return contain_.Get(index);
}
inline ::sg::Item* Facility_SpecialData::add_contain() {
  // @@protoc_insertion_point(field_add:sg.Facility.SpecialData.contain)
  return contain_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::Item >&
Facility_SpecialData::contain() const {
  // @@protoc_insertion_point(field_list:sg.Facility.SpecialData.contain)
  return contain_;
}

// optional sfixed64 timestamp = 4;
inline bool Facility_SpecialData::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Facility_SpecialData::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Facility_SpecialData::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Facility_SpecialData::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 Facility_SpecialData::timestamp() const {
  // @@protoc_insertion_point(field_get:sg.Facility.SpecialData.timestamp)
  return timestamp_;
}
inline void Facility_SpecialData::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:sg.Facility.SpecialData.timestamp)
}

// -------------------------------------------------------------------

// Facility_OrderSlot

// required int32 orderid = 1;
inline bool Facility_OrderSlot::has_orderid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Facility_OrderSlot::set_has_orderid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Facility_OrderSlot::clear_has_orderid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Facility_OrderSlot::clear_orderid() {
  orderid_ = 0;
  clear_has_orderid();
}
inline ::google::protobuf::int32 Facility_OrderSlot::orderid() const {
  // @@protoc_insertion_point(field_get:sg.Facility.OrderSlot.orderid)
  return orderid_;
}
inline void Facility_OrderSlot::set_orderid(::google::protobuf::int32 value) {
  set_has_orderid();
  orderid_ = value;
  // @@protoc_insertion_point(field_set:sg.Facility.OrderSlot.orderid)
}

// required int32 state = 2;
inline bool Facility_OrderSlot::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Facility_OrderSlot::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Facility_OrderSlot::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Facility_OrderSlot::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 Facility_OrderSlot::state() const {
  // @@protoc_insertion_point(field_get:sg.Facility.OrderSlot.state)
  return state_;
}
inline void Facility_OrderSlot::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:sg.Facility.OrderSlot.state)
}

// required int32 index = 3;
inline bool Facility_OrderSlot::has_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Facility_OrderSlot::set_has_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Facility_OrderSlot::clear_has_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Facility_OrderSlot::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 Facility_OrderSlot::index() const {
  // @@protoc_insertion_point(field_get:sg.Facility.OrderSlot.index)
  return index_;
}
inline void Facility_OrderSlot::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:sg.Facility.OrderSlot.index)
}

// -------------------------------------------------------------------

// Facility

// required int32 id = 1;
inline bool Facility::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Facility::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Facility::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Facility::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Facility::id() const {
  // @@protoc_insertion_point(field_get:sg.Facility.id)
  return id_;
}
inline void Facility::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:sg.Facility.id)
}

// required int32 typeid = 2;
inline bool Facility::has_typeid_() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Facility::set_has_typeid_() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Facility::clear_has_typeid_() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Facility::clear_typeid_() {
  typeid__ = 0;
  clear_has_typeid_();
}
inline ::google::protobuf::int32 Facility::typeid_() const {
  // @@protoc_insertion_point(field_get:sg.Facility.typeid)
  return typeid__;
}
inline void Facility::set_typeid_(::google::protobuf::int32 value) {
  set_has_typeid_();
  typeid__ = value;
  // @@protoc_insertion_point(field_set:sg.Facility.typeid)
}

// required int32 style = 3;
inline bool Facility::has_style() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Facility::set_has_style() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Facility::clear_has_style() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Facility::clear_style() {
  style_ = 0;
  clear_has_style();
}
inline ::google::protobuf::int32 Facility::style() const {
  // @@protoc_insertion_point(field_get:sg.Facility.style)
  return style_;
}
inline void Facility::set_style(::google::protobuf::int32 value) {
  set_has_style();
  style_ = value;
  // @@protoc_insertion_point(field_set:sg.Facility.style)
}

// repeated .sg.Facility.OrderSlot order_list = 4;
inline int Facility::order_list_size() const {
  return order_list_.size();
}
inline void Facility::clear_order_list() {
  order_list_.Clear();
}
inline ::sg::Facility_OrderSlot* Facility::mutable_order_list(int index) {
  // @@protoc_insertion_point(field_mutable:sg.Facility.order_list)
  return order_list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::Facility_OrderSlot >*
Facility::mutable_order_list() {
  // @@protoc_insertion_point(field_mutable_list:sg.Facility.order_list)
  return &order_list_;
}
inline const ::sg::Facility_OrderSlot& Facility::order_list(int index) const {
  // @@protoc_insertion_point(field_get:sg.Facility.order_list)
  return order_list_.Get(index);
}
inline ::sg::Facility_OrderSlot* Facility::add_order_list() {
  // @@protoc_insertion_point(field_add:sg.Facility.order_list)
  return order_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::Facility_OrderSlot >&
Facility::order_list() const {
  // @@protoc_insertion_point(field_list:sg.Facility.order_list)
  return order_list_;
}

// optional int32 roomid = 5;
inline bool Facility::has_roomid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Facility::set_has_roomid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Facility::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Facility::clear_roomid() {
  roomid_ = 0;
  clear_has_roomid();
}
inline ::google::protobuf::int32 Facility::roomid() const {
  // @@protoc_insertion_point(field_get:sg.Facility.roomid)
  return roomid_;
}
inline void Facility::set_roomid(::google::protobuf::int32 value) {
  set_has_roomid();
  roomid_ = value;
  // @@protoc_insertion_point(field_set:sg.Facility.roomid)
}

// repeated int32 worker_list = 6;
inline int Facility::worker_list_size() const {
  return worker_list_.size();
}
inline void Facility::clear_worker_list() {
  worker_list_.Clear();
}
inline ::google::protobuf::int32 Facility::worker_list(int index) const {
  // @@protoc_insertion_point(field_get:sg.Facility.worker_list)
  return worker_list_.Get(index);
}
inline void Facility::set_worker_list(int index, ::google::protobuf::int32 value) {
  worker_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:sg.Facility.worker_list)
}
inline void Facility::add_worker_list(::google::protobuf::int32 value) {
  worker_list_.Add(value);
  // @@protoc_insertion_point(field_add:sg.Facility.worker_list)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Facility::worker_list() const {
  // @@protoc_insertion_point(field_list:sg.Facility.worker_list)
  return worker_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Facility::mutable_worker_list() {
  // @@protoc_insertion_point(field_mutable_list:sg.Facility.worker_list)
  return &worker_list_;
}

// optional int32 pos_x = 7;
inline bool Facility::has_pos_x() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Facility::set_has_pos_x() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Facility::clear_has_pos_x() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Facility::clear_pos_x() {
  pos_x_ = 0;
  clear_has_pos_x();
}
inline ::google::protobuf::int32 Facility::pos_x() const {
  // @@protoc_insertion_point(field_get:sg.Facility.pos_x)
  return pos_x_;
}
inline void Facility::set_pos_x(::google::protobuf::int32 value) {
  set_has_pos_x();
  pos_x_ = value;
  // @@protoc_insertion_point(field_set:sg.Facility.pos_x)
}

// optional int32 pos_y = 8;
inline bool Facility::has_pos_y() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Facility::set_has_pos_y() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Facility::clear_has_pos_y() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Facility::clear_pos_y() {
  pos_y_ = 0;
  clear_has_pos_y();
}
inline ::google::protobuf::int32 Facility::pos_y() const {
  // @@protoc_insertion_point(field_get:sg.Facility.pos_y)
  return pos_y_;
}
inline void Facility::set_pos_y(::google::protobuf::int32 value) {
  set_has_pos_y();
  pos_y_ = value;
  // @@protoc_insertion_point(field_set:sg.Facility.pos_y)
}

// optional int32 level = 9;
inline bool Facility::has_level() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Facility::set_has_level() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Facility::clear_has_level() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Facility::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 Facility::level() const {
  // @@protoc_insertion_point(field_get:sg.Facility.level)
  return level_;
}
inline void Facility::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:sg.Facility.level)
}

// optional int32 region = 10;
inline bool Facility::has_region() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Facility::set_has_region() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Facility::clear_has_region() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Facility::clear_region() {
  region_ = 0;
  clear_has_region();
}
inline ::google::protobuf::int32 Facility::region() const {
  // @@protoc_insertion_point(field_get:sg.Facility.region)
  return region_;
}
inline void Facility::set_region(::google::protobuf::int32 value) {
  set_has_region();
  region_ = value;
  // @@protoc_insertion_point(field_set:sg.Facility.region)
}

// repeated .sg.Facility.SpecialData special_data = 11;
inline int Facility::special_data_size() const {
  return special_data_.size();
}
inline void Facility::clear_special_data() {
  special_data_.Clear();
}
inline ::sg::Facility_SpecialData* Facility::mutable_special_data(int index) {
  // @@protoc_insertion_point(field_mutable:sg.Facility.special_data)
  return special_data_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::Facility_SpecialData >*
Facility::mutable_special_data() {
  // @@protoc_insertion_point(field_mutable_list:sg.Facility.special_data)
  return &special_data_;
}
inline const ::sg::Facility_SpecialData& Facility::special_data(int index) const {
  // @@protoc_insertion_point(field_get:sg.Facility.special_data)
  return special_data_.Get(index);
}
inline ::sg::Facility_SpecialData* Facility::add_special_data() {
  // @@protoc_insertion_point(field_add:sg.Facility.special_data)
  return special_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::Facility_SpecialData >&
Facility::special_data() const {
  // @@protoc_insertion_point(field_list:sg.Facility.special_data)
  return special_data_;
}

// optional int32 remain_food = 12;
inline bool Facility::has_remain_food() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Facility::set_has_remain_food() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Facility::clear_has_remain_food() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Facility::clear_remain_food() {
  remain_food_ = 0;
  clear_has_remain_food();
}
inline ::google::protobuf::int32 Facility::remain_food() const {
  // @@protoc_insertion_point(field_get:sg.Facility.remain_food)
  return remain_food_;
}
inline void Facility::set_remain_food(::google::protobuf::int32 value) {
  set_has_remain_food();
  remain_food_ = value;
  // @@protoc_insertion_point(field_set:sg.Facility.remain_food)
}

// optional sfixed64 level_up_starttime = 13;
inline bool Facility::has_level_up_starttime() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Facility::set_has_level_up_starttime() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Facility::clear_has_level_up_starttime() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Facility::clear_level_up_starttime() {
  level_up_starttime_ = GOOGLE_LONGLONG(0);
  clear_has_level_up_starttime();
}
inline ::google::protobuf::int64 Facility::level_up_starttime() const {
  // @@protoc_insertion_point(field_get:sg.Facility.level_up_starttime)
  return level_up_starttime_;
}
inline void Facility::set_level_up_starttime(::google::protobuf::int64 value) {
  set_has_level_up_starttime();
  level_up_starttime_ = value;
  // @@protoc_insertion_point(field_set:sg.Facility.level_up_starttime)
}

// -------------------------------------------------------------------

// Reward

// repeated .sg.Item items = 1;
inline int Reward::items_size() const {
  return items_.size();
}
inline void Reward::clear_items() {
  items_.Clear();
}
inline ::sg::Item* Reward::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:sg.Reward.items)
  return items_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::Item >*
Reward::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:sg.Reward.items)
  return &items_;
}
inline const ::sg::Item& Reward::items(int index) const {
  // @@protoc_insertion_point(field_get:sg.Reward.items)
  return items_.Get(index);
}
inline ::sg::Item* Reward::add_items() {
  // @@protoc_insertion_point(field_add:sg.Reward.items)
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::Item >&
Reward::items() const {
  // @@protoc_insertion_point(field_list:sg.Reward.items)
  return items_;
}

// repeated .sg.Sailor sailors = 2;
inline int Reward::sailors_size() const {
  return sailors_.size();
}
inline void Reward::clear_sailors() {
  sailors_.Clear();
}
inline ::sg::Sailor* Reward::mutable_sailors(int index) {
  // @@protoc_insertion_point(field_mutable:sg.Reward.sailors)
  return sailors_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::Sailor >*
Reward::mutable_sailors() {
  // @@protoc_insertion_point(field_mutable_list:sg.Reward.sailors)
  return &sailors_;
}
inline const ::sg::Sailor& Reward::sailors(int index) const {
  // @@protoc_insertion_point(field_get:sg.Reward.sailors)
  return sailors_.Get(index);
}
inline ::sg::Sailor* Reward::add_sailors() {
  // @@protoc_insertion_point(field_add:sg.Reward.sailors)
  return sailors_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::Sailor >&
Reward::sailors() const {
  // @@protoc_insertion_point(field_list:sg.Reward.sailors)
  return sailors_;
}

// repeated .sg.Facility facilitys = 3;
inline int Reward::facilitys_size() const {
  return facilitys_.size();
}
inline void Reward::clear_facilitys() {
  facilitys_.Clear();
}
inline ::sg::Facility* Reward::mutable_facilitys(int index) {
  // @@protoc_insertion_point(field_mutable:sg.Reward.facilitys)
  return facilitys_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::Facility >*
Reward::mutable_facilitys() {
  // @@protoc_insertion_point(field_mutable_list:sg.Reward.facilitys)
  return &facilitys_;
}
inline const ::sg::Facility& Reward::facilitys(int index) const {
  // @@protoc_insertion_point(field_get:sg.Reward.facilitys)
  return facilitys_.Get(index);
}
inline ::sg::Facility* Reward::add_facilitys() {
  // @@protoc_insertion_point(field_add:sg.Reward.facilitys)
  return facilitys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::Facility >&
Reward::facilitys() const {
  // @@protoc_insertion_point(field_list:sg.Reward.facilitys)
  return facilitys_;
}

// repeated int32 models = 4;
inline int Reward::models_size() const {
  return models_.size();
}
inline void Reward::clear_models() {
  models_.Clear();
}
inline ::google::protobuf::int32 Reward::models(int index) const {
  // @@protoc_insertion_point(field_get:sg.Reward.models)
  return models_.Get(index);
}
inline void Reward::set_models(int index, ::google::protobuf::int32 value) {
  models_.Set(index, value);
  // @@protoc_insertion_point(field_set:sg.Reward.models)
}
inline void Reward::add_models(::google::protobuf::int32 value) {
  models_.Add(value);
  // @@protoc_insertion_point(field_add:sg.Reward.models)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Reward::models() const {
  // @@protoc_insertion_point(field_list:sg.Reward.models)
  return models_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Reward::mutable_models() {
  // @@protoc_insertion_point(field_mutable_list:sg.Reward.models)
  return &models_;
}

// repeated int32 formulas = 5;
inline int Reward::formulas_size() const {
  return formulas_.size();
}
inline void Reward::clear_formulas() {
  formulas_.Clear();
}
inline ::google::protobuf::int32 Reward::formulas(int index) const {
  // @@protoc_insertion_point(field_get:sg.Reward.formulas)
  return formulas_.Get(index);
}
inline void Reward::set_formulas(int index, ::google::protobuf::int32 value) {
  formulas_.Set(index, value);
  // @@protoc_insertion_point(field_set:sg.Reward.formulas)
}
inline void Reward::add_formulas(::google::protobuf::int32 value) {
  formulas_.Add(value);
  // @@protoc_insertion_point(field_add:sg.Reward.formulas)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Reward::formulas() const {
  // @@protoc_insertion_point(field_list:sg.Reward.formulas)
  return formulas_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Reward::mutable_formulas() {
  // @@protoc_insertion_point(field_mutable_list:sg.Reward.formulas)
  return &formulas_;
}

// repeated int32 maps = 6;
inline int Reward::maps_size() const {
  return maps_.size();
}
inline void Reward::clear_maps() {
  maps_.Clear();
}
inline ::google::protobuf::int32 Reward::maps(int index) const {
  // @@protoc_insertion_point(field_get:sg.Reward.maps)
  return maps_.Get(index);
}
inline void Reward::set_maps(int index, ::google::protobuf::int32 value) {
  maps_.Set(index, value);
  // @@protoc_insertion_point(field_set:sg.Reward.maps)
}
inline void Reward::add_maps(::google::protobuf::int32 value) {
  maps_.Add(value);
  // @@protoc_insertion_point(field_add:sg.Reward.maps)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Reward::maps() const {
  // @@protoc_insertion_point(field_list:sg.Reward.maps)
  return maps_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Reward::mutable_maps() {
  // @@protoc_insertion_point(field_mutable_list:sg.Reward.maps)
  return &maps_;
}

// repeated int32 month_cards = 7;
inline int Reward::month_cards_size() const {
  return month_cards_.size();
}
inline void Reward::clear_month_cards() {
  month_cards_.Clear();
}
inline ::google::protobuf::int32 Reward::month_cards(int index) const {
  // @@protoc_insertion_point(field_get:sg.Reward.month_cards)
  return month_cards_.Get(index);
}
inline void Reward::set_month_cards(int index, ::google::protobuf::int32 value) {
  month_cards_.Set(index, value);
  // @@protoc_insertion_point(field_set:sg.Reward.month_cards)
}
inline void Reward::add_month_cards(::google::protobuf::int32 value) {
  month_cards_.Add(value);
  // @@protoc_insertion_point(field_add:sg.Reward.month_cards)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Reward::month_cards() const {
  // @@protoc_insertion_point(field_list:sg.Reward.month_cards)
  return month_cards_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Reward::mutable_month_cards() {
  // @@protoc_insertion_point(field_mutable_list:sg.Reward.month_cards)
  return &month_cards_;
}

// repeated .sg.Equip equips = 8;
inline int Reward::equips_size() const {
  return equips_.size();
}
inline void Reward::clear_equips() {
  equips_.Clear();
}
inline ::sg::Equip* Reward::mutable_equips(int index) {
  // @@protoc_insertion_point(field_mutable:sg.Reward.equips)
  return equips_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::Equip >*
Reward::mutable_equips() {
  // @@protoc_insertion_point(field_mutable_list:sg.Reward.equips)
  return &equips_;
}
inline const ::sg::Equip& Reward::equips(int index) const {
  // @@protoc_insertion_point(field_get:sg.Reward.equips)
  return equips_.Get(index);
}
inline ::sg::Equip* Reward::add_equips() {
  // @@protoc_insertion_point(field_add:sg.Reward.equips)
  return equips_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::Equip >&
Reward::equips() const {
  // @@protoc_insertion_point(field_list:sg.Reward.equips)
  return equips_;
}

// optional int32 exp = 9;
inline bool Reward::has_exp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Reward::set_has_exp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Reward::clear_has_exp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Reward::clear_exp() {
  exp_ = 0;
  clear_has_exp();
}
inline ::google::protobuf::int32 Reward::exp() const {
  // @@protoc_insertion_point(field_get:sg.Reward.exp)
  return exp_;
}
inline void Reward::set_exp(::google::protobuf::int32 value) {
  set_has_exp();
  exp_ = value;
  // @@protoc_insertion_point(field_set:sg.Reward.exp)
}

// repeated .sg.pb_pair_int_int sailor_add_exp = 10;
inline int Reward::sailor_add_exp_size() const {
  return sailor_add_exp_.size();
}
inline void Reward::clear_sailor_add_exp() {
  sailor_add_exp_.Clear();
}
inline ::sg::pb_pair_int_int* Reward::mutable_sailor_add_exp(int index) {
  // @@protoc_insertion_point(field_mutable:sg.Reward.sailor_add_exp)
  return sailor_add_exp_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int >*
Reward::mutable_sailor_add_exp() {
  // @@protoc_insertion_point(field_mutable_list:sg.Reward.sailor_add_exp)
  return &sailor_add_exp_;
}
inline const ::sg::pb_pair_int_int& Reward::sailor_add_exp(int index) const {
  // @@protoc_insertion_point(field_get:sg.Reward.sailor_add_exp)
  return sailor_add_exp_.Get(index);
}
inline ::sg::pb_pair_int_int* Reward::add_sailor_add_exp() {
  // @@protoc_insertion_point(field_add:sg.Reward.sailor_add_exp)
  return sailor_add_exp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::pb_pair_int_int >&
Reward::sailor_add_exp() const {
  // @@protoc_insertion_point(field_list:sg.Reward.sailor_add_exp)
  return sailor_add_exp_;
}

// repeated int32 treasure_ticket = 11;
inline int Reward::treasure_ticket_size() const {
  return treasure_ticket_.size();
}
inline void Reward::clear_treasure_ticket() {
  treasure_ticket_.Clear();
}
inline ::google::protobuf::int32 Reward::treasure_ticket(int index) const {
  // @@protoc_insertion_point(field_get:sg.Reward.treasure_ticket)
  return treasure_ticket_.Get(index);
}
inline void Reward::set_treasure_ticket(int index, ::google::protobuf::int32 value) {
  treasure_ticket_.Set(index, value);
  // @@protoc_insertion_point(field_set:sg.Reward.treasure_ticket)
}
inline void Reward::add_treasure_ticket(::google::protobuf::int32 value) {
  treasure_ticket_.Add(value);
  // @@protoc_insertion_point(field_add:sg.Reward.treasure_ticket)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Reward::treasure_ticket() const {
  // @@protoc_insertion_point(field_list:sg.Reward.treasure_ticket)
  return treasure_ticket_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Reward::mutable_treasure_ticket() {
  // @@protoc_insertion_point(field_mutable_list:sg.Reward.treasure_ticket)
  return &treasure_ticket_;
}

// repeated int32 grow_gift = 12;
inline int Reward::grow_gift_size() const {
  return grow_gift_.size();
}
inline void Reward::clear_grow_gift() {
  grow_gift_.Clear();
}
inline ::google::protobuf::int32 Reward::grow_gift(int index) const {
  // @@protoc_insertion_point(field_get:sg.Reward.grow_gift)
  return grow_gift_.Get(index);
}
inline void Reward::set_grow_gift(int index, ::google::protobuf::int32 value) {
  grow_gift_.Set(index, value);
  // @@protoc_insertion_point(field_set:sg.Reward.grow_gift)
}
inline void Reward::add_grow_gift(::google::protobuf::int32 value) {
  grow_gift_.Add(value);
  // @@protoc_insertion_point(field_add:sg.Reward.grow_gift)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Reward::grow_gift() const {
  // @@protoc_insertion_point(field_list:sg.Reward.grow_gift)
  return grow_gift_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Reward::mutable_grow_gift() {
  // @@protoc_insertion_point(field_mutable_list:sg.Reward.grow_gift)
  return &grow_gift_;
}

// -------------------------------------------------------------------

// RegionState

// optional int32 comfort_grade = 1;
inline bool RegionState::has_comfort_grade() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegionState::set_has_comfort_grade() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegionState::clear_has_comfort_grade() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegionState::clear_comfort_grade() {
  comfort_grade_ = 0;
  clear_has_comfort_grade();
}
inline ::google::protobuf::int32 RegionState::comfort_grade() const {
  // @@protoc_insertion_point(field_get:sg.RegionState.comfort_grade)
  return comfort_grade_;
}
inline void RegionState::set_comfort_grade(::google::protobuf::int32 value) {
  set_has_comfort_grade();
  comfort_grade_ = value;
  // @@protoc_insertion_point(field_set:sg.RegionState.comfort_grade)
}

// optional int32 item_capacity = 2;
inline bool RegionState::has_item_capacity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegionState::set_has_item_capacity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegionState::clear_has_item_capacity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegionState::clear_item_capacity() {
  item_capacity_ = 0;
  clear_has_item_capacity();
}
inline ::google::protobuf::int32 RegionState::item_capacity() const {
  // @@protoc_insertion_point(field_get:sg.RegionState.item_capacity)
  return item_capacity_;
}
inline void RegionState::set_item_capacity(::google::protobuf::int32 value) {
  set_has_item_capacity();
  item_capacity_ = value;
  // @@protoc_insertion_point(field_set:sg.RegionState.item_capacity)
}

// optional int32 equip_capacity = 3;
inline bool RegionState::has_equip_capacity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegionState::set_has_equip_capacity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegionState::clear_has_equip_capacity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegionState::clear_equip_capacity() {
  equip_capacity_ = 0;
  clear_has_equip_capacity();
}
inline ::google::protobuf::int32 RegionState::equip_capacity() const {
  // @@protoc_insertion_point(field_get:sg.RegionState.equip_capacity)
  return equip_capacity_;
}
inline void RegionState::set_equip_capacity(::google::protobuf::int32 value) {
  set_has_equip_capacity();
  equip_capacity_ = value;
  // @@protoc_insertion_point(field_set:sg.RegionState.equip_capacity)
}

// optional int32 facility_capacity = 4;
inline bool RegionState::has_facility_capacity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RegionState::set_has_facility_capacity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RegionState::clear_has_facility_capacity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RegionState::clear_facility_capacity() {
  facility_capacity_ = 0;
  clear_has_facility_capacity();
}
inline ::google::protobuf::int32 RegionState::facility_capacity() const {
  // @@protoc_insertion_point(field_get:sg.RegionState.facility_capacity)
  return facility_capacity_;
}
inline void RegionState::set_facility_capacity(::google::protobuf::int32 value) {
  set_has_facility_capacity();
  facility_capacity_ = value;
  // @@protoc_insertion_point(field_set:sg.RegionState.facility_capacity)
}

// optional int32 food_capacity = 5;
inline bool RegionState::has_food_capacity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RegionState::set_has_food_capacity() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RegionState::clear_has_food_capacity() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RegionState::clear_food_capacity() {
  food_capacity_ = 0;
  clear_has_food_capacity();
}
inline ::google::protobuf::int32 RegionState::food_capacity() const {
  // @@protoc_insertion_point(field_get:sg.RegionState.food_capacity)
  return food_capacity_;
}
inline void RegionState::set_food_capacity(::google::protobuf::int32 value) {
  set_has_food_capacity();
  food_capacity_ = value;
  // @@protoc_insertion_point(field_set:sg.RegionState.food_capacity)
}

// optional int32 resource_capacity = 6;
inline bool RegionState::has_resource_capacity() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RegionState::set_has_resource_capacity() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RegionState::clear_has_resource_capacity() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RegionState::clear_resource_capacity() {
  resource_capacity_ = 0;
  clear_has_resource_capacity();
}
inline ::google::protobuf::int32 RegionState::resource_capacity() const {
  // @@protoc_insertion_point(field_get:sg.RegionState.resource_capacity)
  return resource_capacity_;
}
inline void RegionState::set_resource_capacity(::google::protobuf::int32 value) {
  set_has_resource_capacity();
  resource_capacity_ = value;
  // @@protoc_insertion_point(field_set:sg.RegionState.resource_capacity)
}

// optional float resource_product_add = 7;
inline bool RegionState::has_resource_product_add() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RegionState::set_has_resource_product_add() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RegionState::clear_has_resource_product_add() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RegionState::clear_resource_product_add() {
  resource_product_add_ = 0;
  clear_has_resource_product_add();
}
inline float RegionState::resource_product_add() const {
  // @@protoc_insertion_point(field_get:sg.RegionState.resource_product_add)
  return resource_product_add_;
}
inline void RegionState::set_resource_product_add(float value) {
  set_has_resource_product_add();
  resource_product_add_ = value;
  // @@protoc_insertion_point(field_set:sg.RegionState.resource_product_add)
}

// optional int32 food_resource_capacity = 8;
inline bool RegionState::has_food_resource_capacity() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RegionState::set_has_food_resource_capacity() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RegionState::clear_has_food_resource_capacity() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RegionState::clear_food_resource_capacity() {
  food_resource_capacity_ = 0;
  clear_has_food_resource_capacity();
}
inline ::google::protobuf::int32 RegionState::food_resource_capacity() const {
  // @@protoc_insertion_point(field_get:sg.RegionState.food_resource_capacity)
  return food_resource_capacity_;
}
inline void RegionState::set_food_resource_capacity(::google::protobuf::int32 value) {
  set_has_food_resource_capacity();
  food_resource_capacity_ = value;
  // @@protoc_insertion_point(field_set:sg.RegionState.food_resource_capacity)
}

// optional int32 wood_resource_capacity = 9;
inline bool RegionState::has_wood_resource_capacity() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RegionState::set_has_wood_resource_capacity() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RegionState::clear_has_wood_resource_capacity() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RegionState::clear_wood_resource_capacity() {
  wood_resource_capacity_ = 0;
  clear_has_wood_resource_capacity();
}
inline ::google::protobuf::int32 RegionState::wood_resource_capacity() const {
  // @@protoc_insertion_point(field_get:sg.RegionState.wood_resource_capacity)
  return wood_resource_capacity_;
}
inline void RegionState::set_wood_resource_capacity(::google::protobuf::int32 value) {
  set_has_wood_resource_capacity();
  wood_resource_capacity_ = value;
  // @@protoc_insertion_point(field_set:sg.RegionState.wood_resource_capacity)
}

// optional int32 iron_resource_capacity = 10;
inline bool RegionState::has_iron_resource_capacity() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RegionState::set_has_iron_resource_capacity() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RegionState::clear_has_iron_resource_capacity() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RegionState::clear_iron_resource_capacity() {
  iron_resource_capacity_ = 0;
  clear_has_iron_resource_capacity();
}
inline ::google::protobuf::int32 RegionState::iron_resource_capacity() const {
  // @@protoc_insertion_point(field_get:sg.RegionState.iron_resource_capacity)
  return iron_resource_capacity_;
}
inline void RegionState::set_iron_resource_capacity(::google::protobuf::int32 value) {
  set_has_iron_resource_capacity();
  iron_resource_capacity_ = value;
  // @@protoc_insertion_point(field_set:sg.RegionState.iron_resource_capacity)
}

// optional int32 machine_capacity = 11;
inline bool RegionState::has_machine_capacity() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RegionState::set_has_machine_capacity() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RegionState::clear_has_machine_capacity() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RegionState::clear_machine_capacity() {
  machine_capacity_ = 0;
  clear_has_machine_capacity();
}
inline ::google::protobuf::int32 RegionState::machine_capacity() const {
  // @@protoc_insertion_point(field_get:sg.RegionState.machine_capacity)
  return machine_capacity_;
}
inline void RegionState::set_machine_capacity(::google::protobuf::int32 value) {
  set_has_machine_capacity();
  machine_capacity_ = value;
  // @@protoc_insertion_point(field_set:sg.RegionState.machine_capacity)
}

// -------------------------------------------------------------------

// SpecialEventNotify

// required int64 id = 1;
inline bool SpecialEventNotify::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SpecialEventNotify::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SpecialEventNotify::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SpecialEventNotify::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::int64 SpecialEventNotify::id() const {
  // @@protoc_insertion_point(field_get:sg.SpecialEventNotify.id)
  return id_;
}
inline void SpecialEventNotify::set_id(::google::protobuf::int64 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:sg.SpecialEventNotify.id)
}

// optional .sg.Reward reward = 2;
inline bool SpecialEventNotify::has_reward() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SpecialEventNotify::set_has_reward() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SpecialEventNotify::clear_has_reward() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SpecialEventNotify::clear_reward() {
  if (reward_ != NULL) reward_->Clear();
  clear_has_reward();
}
inline const ::sg::Reward& SpecialEventNotify::_internal_reward() const {
  return *reward_;
}
inline const ::sg::Reward& SpecialEventNotify::reward() const {
  const ::sg::Reward* p = reward_;
  // @@protoc_insertion_point(field_get:sg.SpecialEventNotify.reward)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::Reward*>(
      &::sg::_Reward_default_instance_);
}
inline ::sg::Reward* SpecialEventNotify::release_reward() {
  // @@protoc_insertion_point(field_release:sg.SpecialEventNotify.reward)
  clear_has_reward();
  ::sg::Reward* temp = reward_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  reward_ = NULL;
  return temp;
}
inline ::sg::Reward* SpecialEventNotify::unsafe_arena_release_reward() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.SpecialEventNotify.reward)
  clear_has_reward();
  ::sg::Reward* temp = reward_;
  reward_ = NULL;
  return temp;
}
inline ::sg::Reward* SpecialEventNotify::mutable_reward() {
  set_has_reward();
  if (reward_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::Reward>(GetArenaNoVirtual());
    reward_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.SpecialEventNotify.reward)
  return reward_;
}
inline void SpecialEventNotify::set_allocated_reward(::sg::Reward* reward) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reward_;
  }
  if (reward) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(reward);
    if (message_arena != submessage_arena) {
      reward = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, reward, submessage_arena);
    }
    set_has_reward();
  } else {
    clear_has_reward();
  }
  reward_ = reward;
  // @@protoc_insertion_point(field_set_allocated:sg.SpecialEventNotify.reward)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace sg

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::sg::GAME_GOODS_TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::GAME_GOODS_TYPE>() {
  return ::sg::GAME_GOODS_TYPE_descriptor();
}
template <> struct is_proto_enum< ::sg::ROOM_TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::ROOM_TYPE>() {
  return ::sg::ROOM_TYPE_descriptor();
}
template <> struct is_proto_enum< ::sg::SAILOR_STATE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::SAILOR_STATE>() {
  return ::sg::SAILOR_STATE_descriptor();
}
template <> struct is_proto_enum< ::sg::SAILOR_SKILL_TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::SAILOR_SKILL_TYPE>() {
  return ::sg::SAILOR_SKILL_TYPE_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_BaseStruct_2eproto
