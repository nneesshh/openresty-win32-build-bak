// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Multiplayer.proto

#ifndef PROTOBUF_INCLUDED_Multiplayer_2eproto
#define PROTOBUF_INCLUDED_Multiplayer_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "BaseStruct.pb.h"
#include "PVE.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_Multiplayer_2eproto 

namespace protobuf_Multiplayer_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[26];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_Multiplayer_2eproto
namespace sg {
class BattleOverNotify;
class BattleOverNotifyDefaultTypeInternal;
extern BattleOverNotifyDefaultTypeInternal _BattleOverNotify_default_instance_;
class BattleReadyNotify;
class BattleReadyNotifyDefaultTypeInternal;
extern BattleReadyNotifyDefaultTypeInternal _BattleReadyNotify_default_instance_;
class BattleStartNotify;
class BattleStartNotifyDefaultTypeInternal;
extern BattleStartNotifyDefaultTypeInternal _BattleStartNotify_default_instance_;
class FrameAddNotify;
class FrameAddNotifyDefaultTypeInternal;
extern FrameAddNotifyDefaultTypeInternal _FrameAddNotify_default_instance_;
class FrameData;
class FrameDataDefaultTypeInternal;
extern FrameDataDefaultTypeInternal _FrameData_default_instance_;
class MultiplayerBattleField;
class MultiplayerBattleFieldDefaultTypeInternal;
extern MultiplayerBattleFieldDefaultTypeInternal _MultiplayerBattleField_default_instance_;
class MultiplayerBattleField_Member;
class MultiplayerBattleField_MemberDefaultTypeInternal;
extern MultiplayerBattleField_MemberDefaultTypeInternal _MultiplayerBattleField_Member_default_instance_;
class MultiplayerBattleService;
class MultiplayerBattleServiceDefaultTypeInternal;
extern MultiplayerBattleServiceDefaultTypeInternal _MultiplayerBattleService_default_instance_;
class MultiplayerBattleService_MultiplayerBattleRequest;
class MultiplayerBattleService_MultiplayerBattleRequestDefaultTypeInternal;
extern MultiplayerBattleService_MultiplayerBattleRequestDefaultTypeInternal _MultiplayerBattleService_MultiplayerBattleRequest_default_instance_;
class MultiplayerBattleService_MultiplayerBattleResponse;
class MultiplayerBattleService_MultiplayerBattleResponseDefaultTypeInternal;
extern MultiplayerBattleService_MultiplayerBattleResponseDefaultTypeInternal _MultiplayerBattleService_MultiplayerBattleResponse_default_instance_;
class MultiplayerRoom;
class MultiplayerRoomDefaultTypeInternal;
extern MultiplayerRoomDefaultTypeInternal _MultiplayerRoom_default_instance_;
class MultiplayerRoom_Chat;
class MultiplayerRoom_ChatDefaultTypeInternal;
extern MultiplayerRoom_ChatDefaultTypeInternal _MultiplayerRoom_Chat_default_instance_;
class MultiplayerRoom_Member;
class MultiplayerRoom_MemberDefaultTypeInternal;
extern MultiplayerRoom_MemberDefaultTypeInternal _MultiplayerRoom_Member_default_instance_;
class MultiplayerTeamService;
class MultiplayerTeamServiceDefaultTypeInternal;
extern MultiplayerTeamServiceDefaultTypeInternal _MultiplayerTeamService_default_instance_;
class MultiplayerTeamService_MultiplayerTeamRequest;
class MultiplayerTeamService_MultiplayerTeamRequestDefaultTypeInternal;
extern MultiplayerTeamService_MultiplayerTeamRequestDefaultTypeInternal _MultiplayerTeamService_MultiplayerTeamRequest_default_instance_;
class MultiplayerTeamService_MultiplayerTeamResponse;
class MultiplayerTeamService_MultiplayerTeamResponseDefaultTypeInternal;
extern MultiplayerTeamService_MultiplayerTeamResponseDefaultTypeInternal _MultiplayerTeamService_MultiplayerTeamResponse_default_instance_;
class UserAddNotify;
class UserAddNotifyDefaultTypeInternal;
extern UserAddNotifyDefaultTypeInternal _UserAddNotify_default_instance_;
class UserChangeOwnerNotify;
class UserChangeOwnerNotifyDefaultTypeInternal;
extern UserChangeOwnerNotifyDefaultTypeInternal _UserChangeOwnerNotify_default_instance_;
class UserChangeSailorNotify;
class UserChangeSailorNotifyDefaultTypeInternal;
extern UserChangeSailorNotifyDefaultTypeInternal _UserChangeSailorNotify_default_instance_;
class UserChangeSeatNotify;
class UserChangeSeatNotifyDefaultTypeInternal;
extern UserChangeSeatNotifyDefaultTypeInternal _UserChangeSeatNotify_default_instance_;
class UserChangeWorkNotify;
class UserChangeWorkNotifyDefaultTypeInternal;
extern UserChangeWorkNotifyDefaultTypeInternal _UserChangeWorkNotify_default_instance_;
class UserDeleteRoomNotify;
class UserDeleteRoomNotifyDefaultTypeInternal;
extern UserDeleteRoomNotifyDefaultTypeInternal _UserDeleteRoomNotify_default_instance_;
class UserLeaveNotify;
class UserLeaveNotifyDefaultTypeInternal;
extern UserLeaveNotifyDefaultTypeInternal _UserLeaveNotify_default_instance_;
class UserReadyNotify;
class UserReadyNotifyDefaultTypeInternal;
extern UserReadyNotifyDefaultTypeInternal _UserReadyNotify_default_instance_;
class UserRenameNotify;
class UserRenameNotifyDefaultTypeInternal;
extern UserRenameNotifyDefaultTypeInternal _UserRenameNotify_default_instance_;
class UserTalkNotify;
class UserTalkNotifyDefaultTypeInternal;
extern UserTalkNotifyDefaultTypeInternal _UserTalkNotify_default_instance_;
}  // namespace sg
namespace google {
namespace protobuf {
template<> ::sg::BattleOverNotify* Arena::CreateMaybeMessage<::sg::BattleOverNotify>(Arena*);
template<> ::sg::BattleReadyNotify* Arena::CreateMaybeMessage<::sg::BattleReadyNotify>(Arena*);
template<> ::sg::BattleStartNotify* Arena::CreateMaybeMessage<::sg::BattleStartNotify>(Arena*);
template<> ::sg::FrameAddNotify* Arena::CreateMaybeMessage<::sg::FrameAddNotify>(Arena*);
template<> ::sg::FrameData* Arena::CreateMaybeMessage<::sg::FrameData>(Arena*);
template<> ::sg::MultiplayerBattleField* Arena::CreateMaybeMessage<::sg::MultiplayerBattleField>(Arena*);
template<> ::sg::MultiplayerBattleField_Member* Arena::CreateMaybeMessage<::sg::MultiplayerBattleField_Member>(Arena*);
template<> ::sg::MultiplayerBattleService* Arena::CreateMaybeMessage<::sg::MultiplayerBattleService>(Arena*);
template<> ::sg::MultiplayerBattleService_MultiplayerBattleRequest* Arena::CreateMaybeMessage<::sg::MultiplayerBattleService_MultiplayerBattleRequest>(Arena*);
template<> ::sg::MultiplayerBattleService_MultiplayerBattleResponse* Arena::CreateMaybeMessage<::sg::MultiplayerBattleService_MultiplayerBattleResponse>(Arena*);
template<> ::sg::MultiplayerRoom* Arena::CreateMaybeMessage<::sg::MultiplayerRoom>(Arena*);
template<> ::sg::MultiplayerRoom_Chat* Arena::CreateMaybeMessage<::sg::MultiplayerRoom_Chat>(Arena*);
template<> ::sg::MultiplayerRoom_Member* Arena::CreateMaybeMessage<::sg::MultiplayerRoom_Member>(Arena*);
template<> ::sg::MultiplayerTeamService* Arena::CreateMaybeMessage<::sg::MultiplayerTeamService>(Arena*);
template<> ::sg::MultiplayerTeamService_MultiplayerTeamRequest* Arena::CreateMaybeMessage<::sg::MultiplayerTeamService_MultiplayerTeamRequest>(Arena*);
template<> ::sg::MultiplayerTeamService_MultiplayerTeamResponse* Arena::CreateMaybeMessage<::sg::MultiplayerTeamService_MultiplayerTeamResponse>(Arena*);
template<> ::sg::UserAddNotify* Arena::CreateMaybeMessage<::sg::UserAddNotify>(Arena*);
template<> ::sg::UserChangeOwnerNotify* Arena::CreateMaybeMessage<::sg::UserChangeOwnerNotify>(Arena*);
template<> ::sg::UserChangeSailorNotify* Arena::CreateMaybeMessage<::sg::UserChangeSailorNotify>(Arena*);
template<> ::sg::UserChangeSeatNotify* Arena::CreateMaybeMessage<::sg::UserChangeSeatNotify>(Arena*);
template<> ::sg::UserChangeWorkNotify* Arena::CreateMaybeMessage<::sg::UserChangeWorkNotify>(Arena*);
template<> ::sg::UserDeleteRoomNotify* Arena::CreateMaybeMessage<::sg::UserDeleteRoomNotify>(Arena*);
template<> ::sg::UserLeaveNotify* Arena::CreateMaybeMessage<::sg::UserLeaveNotify>(Arena*);
template<> ::sg::UserReadyNotify* Arena::CreateMaybeMessage<::sg::UserReadyNotify>(Arena*);
template<> ::sg::UserRenameNotify* Arena::CreateMaybeMessage<::sg::UserRenameNotify>(Arena*);
template<> ::sg::UserTalkNotify* Arena::CreateMaybeMessage<::sg::UserTalkNotify>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace sg {

enum MultiplayerTeamService_CMD {
  MultiplayerTeamService_CMD_QUERY_LIST = 1,
  MultiplayerTeamService_CMD_QUERY_SELF = 2,
  MultiplayerTeamService_CMD_CREATE_ROOM = 3,
  MultiplayerTeamService_CMD_ADD_ROOM = 4,
  MultiplayerTeamService_CMD_LEAVE_ROOM = 5,
  MultiplayerTeamService_CMD_DELETE_ROOM = 6,
  MultiplayerTeamService_CMD_CHANGE_SEAT = 7,
  MultiplayerTeamService_CMD_CHANGE_OWNER = 8,
  MultiplayerTeamService_CMD_SET_WORK = 9,
  MultiplayerTeamService_CMD_RENAME_ROOM = 10,
  MultiplayerTeamService_CMD_READY = 11,
  MultiplayerTeamService_CMD_TALK = 12
};
bool MultiplayerTeamService_CMD_IsValid(int value);
const MultiplayerTeamService_CMD MultiplayerTeamService_CMD_CMD_MIN = MultiplayerTeamService_CMD_QUERY_LIST;
const MultiplayerTeamService_CMD MultiplayerTeamService_CMD_CMD_MAX = MultiplayerTeamService_CMD_TALK;
const int MultiplayerTeamService_CMD_CMD_ARRAYSIZE = MultiplayerTeamService_CMD_CMD_MAX + 1;

const ::google::protobuf::EnumDescriptor* MultiplayerTeamService_CMD_descriptor();
inline const ::std::string& MultiplayerTeamService_CMD_Name(MultiplayerTeamService_CMD value) {
  return ::google::protobuf::internal::NameOfEnum(
    MultiplayerTeamService_CMD_descriptor(), value);
}
inline bool MultiplayerTeamService_CMD_Parse(
    const ::std::string& name, MultiplayerTeamService_CMD* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MultiplayerTeamService_CMD>(
    MultiplayerTeamService_CMD_descriptor(), name, value);
}
enum MultiplayerBattleService_CMD {
  MultiplayerBattleService_CMD_READY = 1,
  MultiplayerBattleService_CMD_CHANGE_SAILOR = 2,
  MultiplayerBattleService_CMD_OPERATE = 3,
  MultiplayerBattleService_CMD_OVER = 4
};
bool MultiplayerBattleService_CMD_IsValid(int value);
const MultiplayerBattleService_CMD MultiplayerBattleService_CMD_CMD_MIN = MultiplayerBattleService_CMD_READY;
const MultiplayerBattleService_CMD MultiplayerBattleService_CMD_CMD_MAX = MultiplayerBattleService_CMD_OVER;
const int MultiplayerBattleService_CMD_CMD_ARRAYSIZE = MultiplayerBattleService_CMD_CMD_MAX + 1;

const ::google::protobuf::EnumDescriptor* MultiplayerBattleService_CMD_descriptor();
inline const ::std::string& MultiplayerBattleService_CMD_Name(MultiplayerBattleService_CMD value) {
  return ::google::protobuf::internal::NameOfEnum(
    MultiplayerBattleService_CMD_descriptor(), value);
}
inline bool MultiplayerBattleService_CMD_Parse(
    const ::std::string& name, MultiplayerBattleService_CMD* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MultiplayerBattleService_CMD>(
    MultiplayerBattleService_CMD_descriptor(), name, value);
}
// ===================================================================

class FrameData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.FrameData) */ {
 public:
  FrameData();
  virtual ~FrameData();

  FrameData(const FrameData& from);

  inline FrameData& operator=(const FrameData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FrameData(FrameData&& from) noexcept
    : FrameData() {
    *this = ::std::move(from);
  }

  inline FrameData& operator=(FrameData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const FrameData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FrameData* internal_default_instance() {
    return reinterpret_cast<const FrameData*>(
               &_FrameData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void UnsafeArenaSwap(FrameData* other);
  void Swap(FrameData* other);
  friend void swap(FrameData& a, FrameData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FrameData* New() const final {
    return CreateMaybeMessage<FrameData>(NULL);
  }

  FrameData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FrameData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FrameData& from);
  void MergeFrom(const FrameData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FrameData* other);
  protected:
  explicit FrameData(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes data = 3;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 3;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_data();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_data(
      ::std::string* data);

  // optional int32 frame = 1;
  bool has_frame() const;
  void clear_frame();
  static const int kFrameFieldNumber = 1;
  ::google::protobuf::int32 frame() const;
  void set_frame(::google::protobuf::int32 value);

  // optional int32 source = 2;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 2;
  ::google::protobuf::int32 source() const;
  void set_source(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.FrameData)
 private:
  void set_has_frame();
  void clear_has_frame();
  void set_has_source();
  void clear_has_source();
  void set_has_data();
  void clear_has_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::int32 frame_;
  ::google::protobuf::int32 source_;
  friend struct ::protobuf_Multiplayer_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MultiplayerRoom_Member : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.MultiplayerRoom.Member) */ {
 public:
  MultiplayerRoom_Member();
  virtual ~MultiplayerRoom_Member();

  MultiplayerRoom_Member(const MultiplayerRoom_Member& from);

  inline MultiplayerRoom_Member& operator=(const MultiplayerRoom_Member& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MultiplayerRoom_Member(MultiplayerRoom_Member&& from) noexcept
    : MultiplayerRoom_Member() {
    *this = ::std::move(from);
  }

  inline MultiplayerRoom_Member& operator=(MultiplayerRoom_Member&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const MultiplayerRoom_Member& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MultiplayerRoom_Member* internal_default_instance() {
    return reinterpret_cast<const MultiplayerRoom_Member*>(
               &_MultiplayerRoom_Member_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void UnsafeArenaSwap(MultiplayerRoom_Member* other);
  void Swap(MultiplayerRoom_Member* other);
  friend void swap(MultiplayerRoom_Member& a, MultiplayerRoom_Member& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MultiplayerRoom_Member* New() const final {
    return CreateMaybeMessage<MultiplayerRoom_Member>(NULL);
  }

  MultiplayerRoom_Member* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MultiplayerRoom_Member>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MultiplayerRoom_Member& from);
  void MergeFrom(const MultiplayerRoom_Member& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiplayerRoom_Member* other);
  protected:
  explicit MultiplayerRoom_Member(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sg.Sailor sailors = 6;
  int sailors_size() const;
  void clear_sailors();
  static const int kSailorsFieldNumber = 6;
  ::sg::Sailor* mutable_sailors(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::Sailor >*
      mutable_sailors();
  const ::sg::Sailor& sailors(int index) const;
  ::sg::Sailor* add_sailors();
  const ::google::protobuf::RepeatedPtrField< ::sg::Sailor >&
      sailors() const;

  // optional .sg.UserInfo user = 4;
  bool has_user() const;
  void clear_user();
  static const int kUserFieldNumber = 4;
  private:
  const ::sg::UserInfo& _internal_user() const;
  public:
  const ::sg::UserInfo& user() const;
  ::sg::UserInfo* release_user();
  ::sg::UserInfo* mutable_user();
  void set_allocated_user(::sg::UserInfo* user);
  void unsafe_arena_set_allocated_user(
      ::sg::UserInfo* user);
  ::sg::UserInfo* unsafe_arena_release_user();

  // required int32 index = 1;
  bool has_index() const;
  void clear_index();
  static const int kIndexFieldNumber = 1;
  ::google::protobuf::int32 index() const;
  void set_index(::google::protobuf::int32 value);

  // required int32 status = 3;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 3;
  ::google::protobuf::int32 status() const;
  void set_status(::google::protobuf::int32 value);

  // optional int32 state = 5;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 5;
  ::google::protobuf::int32 state() const;
  void set_state(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.MultiplayerRoom.Member)
 private:
  void set_has_index();
  void clear_has_index();
  void set_has_status();
  void clear_has_status();
  void set_has_user();
  void clear_has_user();
  void set_has_state();
  void clear_has_state();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::Sailor > sailors_;
  ::sg::UserInfo* user_;
  ::google::protobuf::int32 index_;
  ::google::protobuf::int32 status_;
  ::google::protobuf::int32 state_;
  friend struct ::protobuf_Multiplayer_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MultiplayerRoom_Chat : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.MultiplayerRoom.Chat) */ {
 public:
  MultiplayerRoom_Chat();
  virtual ~MultiplayerRoom_Chat();

  MultiplayerRoom_Chat(const MultiplayerRoom_Chat& from);

  inline MultiplayerRoom_Chat& operator=(const MultiplayerRoom_Chat& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MultiplayerRoom_Chat(MultiplayerRoom_Chat&& from) noexcept
    : MultiplayerRoom_Chat() {
    *this = ::std::move(from);
  }

  inline MultiplayerRoom_Chat& operator=(MultiplayerRoom_Chat&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const MultiplayerRoom_Chat& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MultiplayerRoom_Chat* internal_default_instance() {
    return reinterpret_cast<const MultiplayerRoom_Chat*>(
               &_MultiplayerRoom_Chat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void UnsafeArenaSwap(MultiplayerRoom_Chat* other);
  void Swap(MultiplayerRoom_Chat* other);
  friend void swap(MultiplayerRoom_Chat& a, MultiplayerRoom_Chat& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MultiplayerRoom_Chat* New() const final {
    return CreateMaybeMessage<MultiplayerRoom_Chat>(NULL);
  }

  MultiplayerRoom_Chat* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MultiplayerRoom_Chat>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MultiplayerRoom_Chat& from);
  void MergeFrom(const MultiplayerRoom_Chat& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiplayerRoom_Chat* other);
  protected:
  explicit MultiplayerRoom_Chat(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes data = 3;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 3;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_data();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_data(
      ::std::string* data);

  // required sfixed64 timestamp = 2;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // required int32 index = 1;
  bool has_index() const;
  void clear_index();
  static const int kIndexFieldNumber = 1;
  ::google::protobuf::int32 index() const;
  void set_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.MultiplayerRoom.Chat)
 private:
  void set_has_index();
  void clear_has_index();
  void set_has_timestamp();
  void clear_has_timestamp();
  void set_has_data();
  void clear_has_data();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::int64 timestamp_;
  ::google::protobuf::int32 index_;
  friend struct ::protobuf_Multiplayer_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MultiplayerRoom : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.MultiplayerRoom) */ {
 public:
  MultiplayerRoom();
  virtual ~MultiplayerRoom();

  MultiplayerRoom(const MultiplayerRoom& from);

  inline MultiplayerRoom& operator=(const MultiplayerRoom& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MultiplayerRoom(MultiplayerRoom&& from) noexcept
    : MultiplayerRoom() {
    *this = ::std::move(from);
  }

  inline MultiplayerRoom& operator=(MultiplayerRoom&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const MultiplayerRoom& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MultiplayerRoom* internal_default_instance() {
    return reinterpret_cast<const MultiplayerRoom*>(
               &_MultiplayerRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void UnsafeArenaSwap(MultiplayerRoom* other);
  void Swap(MultiplayerRoom* other);
  friend void swap(MultiplayerRoom& a, MultiplayerRoom& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MultiplayerRoom* New() const final {
    return CreateMaybeMessage<MultiplayerRoom>(NULL);
  }

  MultiplayerRoom* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MultiplayerRoom>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MultiplayerRoom& from);
  void MergeFrom(const MultiplayerRoom& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiplayerRoom* other);
  protected:
  explicit MultiplayerRoom(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MultiplayerRoom_Member Member;
  typedef MultiplayerRoom_Chat Chat;

  // accessors -------------------------------------------------------

  // repeated .sg.MultiplayerRoom.Member members = 4;
  int members_size() const;
  void clear_members();
  static const int kMembersFieldNumber = 4;
  ::sg::MultiplayerRoom_Member* mutable_members(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::MultiplayerRoom_Member >*
      mutable_members();
  const ::sg::MultiplayerRoom_Member& members(int index) const;
  ::sg::MultiplayerRoom_Member* add_members();
  const ::google::protobuf::RepeatedPtrField< ::sg::MultiplayerRoom_Member >&
      members() const;

  // repeated .sg.MultiplayerRoom.Chat chat_list = 8;
  int chat_list_size() const;
  void clear_chat_list();
  static const int kChatListFieldNumber = 8;
  ::sg::MultiplayerRoom_Chat* mutable_chat_list(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::MultiplayerRoom_Chat >*
      mutable_chat_list();
  const ::sg::MultiplayerRoom_Chat& chat_list(int index) const;
  ::sg::MultiplayerRoom_Chat* add_chat_list();
  const ::google::protobuf::RepeatedPtrField< ::sg::MultiplayerRoom_Chat >&
      chat_list() const;

  // required bytes name = 3;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const void* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_name();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      ::std::string* name);

  // required bytes work = 7;
  bool has_work() const;
  void clear_work();
  static const int kWorkFieldNumber = 7;
  const ::std::string& work() const;
  void set_work(const ::std::string& value);
  #if LANG_CXX11
  void set_work(::std::string&& value);
  #endif
  void set_work(const char* value);
  void set_work(const void* value, size_t size);
  ::std::string* mutable_work();
  ::std::string* release_work();
  void set_allocated_work(::std::string* work);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_work();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_work(
      ::std::string* work);

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // required int32 state = 2;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 2;
  ::google::protobuf::int32 state() const;
  void set_state(::google::protobuf::int32 value);

  // optional int32 target = 5;
  bool has_target() const;
  void clear_target();
  static const int kTargetFieldNumber = 5;
  ::google::protobuf::int32 target() const;
  void set_target(::google::protobuf::int32 value);

  // optional int32 type = 6;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 6;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.MultiplayerRoom)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_state();
  void clear_has_state();
  void set_has_name();
  void clear_has_name();
  void set_has_target();
  void clear_has_target();
  void set_has_type();
  void clear_has_type();
  void set_has_work();
  void clear_has_work();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::MultiplayerRoom_Member > members_;
  ::google::protobuf::RepeatedPtrField< ::sg::MultiplayerRoom_Chat > chat_list_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr work_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 state_;
  ::google::protobuf::int32 target_;
  ::google::protobuf::int32 type_;
  friend struct ::protobuf_Multiplayer_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MultiplayerBattleField_Member : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.MultiplayerBattleField.Member) */ {
 public:
  MultiplayerBattleField_Member();
  virtual ~MultiplayerBattleField_Member();

  MultiplayerBattleField_Member(const MultiplayerBattleField_Member& from);

  inline MultiplayerBattleField_Member& operator=(const MultiplayerBattleField_Member& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MultiplayerBattleField_Member(MultiplayerBattleField_Member&& from) noexcept
    : MultiplayerBattleField_Member() {
    *this = ::std::move(from);
  }

  inline MultiplayerBattleField_Member& operator=(MultiplayerBattleField_Member&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const MultiplayerBattleField_Member& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MultiplayerBattleField_Member* internal_default_instance() {
    return reinterpret_cast<const MultiplayerBattleField_Member*>(
               &_MultiplayerBattleField_Member_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void UnsafeArenaSwap(MultiplayerBattleField_Member* other);
  void Swap(MultiplayerBattleField_Member* other);
  friend void swap(MultiplayerBattleField_Member& a, MultiplayerBattleField_Member& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MultiplayerBattleField_Member* New() const final {
    return CreateMaybeMessage<MultiplayerBattleField_Member>(NULL);
  }

  MultiplayerBattleField_Member* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MultiplayerBattleField_Member>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MultiplayerBattleField_Member& from);
  void MergeFrom(const MultiplayerBattleField_Member& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiplayerBattleField_Member* other);
  protected:
  explicit MultiplayerBattleField_Member(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .sg.UserInfo user = 5;
  bool has_user() const;
  void clear_user();
  static const int kUserFieldNumber = 5;
  private:
  const ::sg::UserInfo& _internal_user() const;
  public:
  const ::sg::UserInfo& user() const;
  ::sg::UserInfo* release_user();
  ::sg::UserInfo* mutable_user();
  void set_allocated_user(::sg::UserInfo* user);
  void unsafe_arena_set_allocated_user(
      ::sg::UserInfo* user);
  ::sg::UserInfo* unsafe_arena_release_user();

  // optional .sg.UserTeamData data = 6;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 6;
  private:
  const ::sg::UserTeamData& _internal_data() const;
  public:
  const ::sg::UserTeamData& data() const;
  ::sg::UserTeamData* release_data();
  ::sg::UserTeamData* mutable_data();
  void set_allocated_data(::sg::UserTeamData* data);
  void unsafe_arena_set_allocated_data(
      ::sg::UserTeamData* data);
  ::sg::UserTeamData* unsafe_arena_release_data();

  // required int32 index = 1;
  bool has_index() const;
  void clear_index();
  static const int kIndexFieldNumber = 1;
  ::google::protobuf::int32 index() const;
  void set_index(::google::protobuf::int32 value);

  // required int32 status = 3;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 3;
  ::google::protobuf::int32 status() const;
  void set_status(::google::protobuf::int32 value);

  // required int32 state = 4;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 4;
  ::google::protobuf::int32 state() const;
  void set_state(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.MultiplayerBattleField.Member)
 private:
  void set_has_index();
  void clear_has_index();
  void set_has_status();
  void clear_has_status();
  void set_has_state();
  void clear_has_state();
  void set_has_user();
  void clear_has_user();
  void set_has_data();
  void clear_has_data();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::sg::UserInfo* user_;
  ::sg::UserTeamData* data_;
  ::google::protobuf::int32 index_;
  ::google::protobuf::int32 status_;
  ::google::protobuf::int32 state_;
  friend struct ::protobuf_Multiplayer_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MultiplayerBattleField : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.MultiplayerBattleField) */ {
 public:
  MultiplayerBattleField();
  virtual ~MultiplayerBattleField();

  MultiplayerBattleField(const MultiplayerBattleField& from);

  inline MultiplayerBattleField& operator=(const MultiplayerBattleField& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MultiplayerBattleField(MultiplayerBattleField&& from) noexcept
    : MultiplayerBattleField() {
    *this = ::std::move(from);
  }

  inline MultiplayerBattleField& operator=(MultiplayerBattleField&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const MultiplayerBattleField& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MultiplayerBattleField* internal_default_instance() {
    return reinterpret_cast<const MultiplayerBattleField*>(
               &_MultiplayerBattleField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void UnsafeArenaSwap(MultiplayerBattleField* other);
  void Swap(MultiplayerBattleField* other);
  friend void swap(MultiplayerBattleField& a, MultiplayerBattleField& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MultiplayerBattleField* New() const final {
    return CreateMaybeMessage<MultiplayerBattleField>(NULL);
  }

  MultiplayerBattleField* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MultiplayerBattleField>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MultiplayerBattleField& from);
  void MergeFrom(const MultiplayerBattleField& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiplayerBattleField* other);
  protected:
  explicit MultiplayerBattleField(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MultiplayerBattleField_Member Member;

  // accessors -------------------------------------------------------

  // repeated .sg.MultiplayerBattleField.Member members = 6;
  int members_size() const;
  void clear_members();
  static const int kMembersFieldNumber = 6;
  ::sg::MultiplayerBattleField_Member* mutable_members(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::MultiplayerBattleField_Member >*
      mutable_members();
  const ::sg::MultiplayerBattleField_Member& members(int index) const;
  ::sg::MultiplayerBattleField_Member* add_members();
  const ::google::protobuf::RepeatedPtrField< ::sg::MultiplayerBattleField_Member >&
      members() const;

  // repeated .sg.FrameData data = 7;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 7;
  ::sg::FrameData* mutable_data(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::FrameData >*
      mutable_data();
  const ::sg::FrameData& data(int index) const;
  ::sg::FrameData* add_data();
  const ::google::protobuf::RepeatedPtrField< ::sg::FrameData >&
      data() const;

  // required bytes name = 3;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const void* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_name();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      ::std::string* name);

  // required bytes work = 8;
  bool has_work() const;
  void clear_work();
  static const int kWorkFieldNumber = 8;
  const ::std::string& work() const;
  void set_work(const ::std::string& value);
  #if LANG_CXX11
  void set_work(::std::string&& value);
  #endif
  void set_work(const char* value);
  void set_work(const void* value, size_t size);
  ::std::string* mutable_work();
  ::std::string* release_work();
  void set_allocated_work(::std::string* work);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_work();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_work(
      ::std::string* work);

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // required int32 state = 2;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 2;
  ::google::protobuf::int32 state() const;
  void set_state(::google::protobuf::int32 value);

  // required int32 frame = 4;
  bool has_frame() const;
  void clear_frame();
  static const int kFrameFieldNumber = 4;
  ::google::protobuf::int32 frame() const;
  void set_frame(::google::protobuf::int32 value);

  // required int32 rand_seed = 5;
  bool has_rand_seed() const;
  void clear_rand_seed();
  static const int kRandSeedFieldNumber = 5;
  ::google::protobuf::int32 rand_seed() const;
  void set_rand_seed(::google::protobuf::int32 value);

  // optional int32 target = 9;
  bool has_target() const;
  void clear_target();
  static const int kTargetFieldNumber = 9;
  ::google::protobuf::int32 target() const;
  void set_target(::google::protobuf::int32 value);

  // optional int32 type = 10;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 10;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.MultiplayerBattleField)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_state();
  void clear_has_state();
  void set_has_name();
  void clear_has_name();
  void set_has_frame();
  void clear_has_frame();
  void set_has_rand_seed();
  void clear_has_rand_seed();
  void set_has_work();
  void clear_has_work();
  void set_has_target();
  void clear_has_target();
  void set_has_type();
  void clear_has_type();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::MultiplayerBattleField_Member > members_;
  ::google::protobuf::RepeatedPtrField< ::sg::FrameData > data_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr work_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 state_;
  ::google::protobuf::int32 frame_;
  ::google::protobuf::int32 rand_seed_;
  ::google::protobuf::int32 target_;
  ::google::protobuf::int32 type_;
  friend struct ::protobuf_Multiplayer_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MultiplayerTeamService_MultiplayerTeamRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.MultiplayerTeamService.MultiplayerTeamRequest) */ {
 public:
  MultiplayerTeamService_MultiplayerTeamRequest();
  virtual ~MultiplayerTeamService_MultiplayerTeamRequest();

  MultiplayerTeamService_MultiplayerTeamRequest(const MultiplayerTeamService_MultiplayerTeamRequest& from);

  inline MultiplayerTeamService_MultiplayerTeamRequest& operator=(const MultiplayerTeamService_MultiplayerTeamRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MultiplayerTeamService_MultiplayerTeamRequest(MultiplayerTeamService_MultiplayerTeamRequest&& from) noexcept
    : MultiplayerTeamService_MultiplayerTeamRequest() {
    *this = ::std::move(from);
  }

  inline MultiplayerTeamService_MultiplayerTeamRequest& operator=(MultiplayerTeamService_MultiplayerTeamRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const MultiplayerTeamService_MultiplayerTeamRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MultiplayerTeamService_MultiplayerTeamRequest* internal_default_instance() {
    return reinterpret_cast<const MultiplayerTeamService_MultiplayerTeamRequest*>(
               &_MultiplayerTeamService_MultiplayerTeamRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void UnsafeArenaSwap(MultiplayerTeamService_MultiplayerTeamRequest* other);
  void Swap(MultiplayerTeamService_MultiplayerTeamRequest* other);
  friend void swap(MultiplayerTeamService_MultiplayerTeamRequest& a, MultiplayerTeamService_MultiplayerTeamRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MultiplayerTeamService_MultiplayerTeamRequest* New() const final {
    return CreateMaybeMessage<MultiplayerTeamService_MultiplayerTeamRequest>(NULL);
  }

  MultiplayerTeamService_MultiplayerTeamRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MultiplayerTeamService_MultiplayerTeamRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MultiplayerTeamService_MultiplayerTeamRequest& from);
  void MergeFrom(const MultiplayerTeamService_MultiplayerTeamRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiplayerTeamService_MultiplayerTeamRequest* other);
  protected:
  explicit MultiplayerTeamService_MultiplayerTeamRequest(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes work = 4;
  bool has_work() const;
  void clear_work();
  static const int kWorkFieldNumber = 4;
  const ::std::string& work() const;
  void set_work(const ::std::string& value);
  #if LANG_CXX11
  void set_work(::std::string&& value);
  #endif
  void set_work(const char* value);
  void set_work(const void* value, size_t size);
  ::std::string* mutable_work();
  ::std::string* release_work();
  void set_allocated_work(::std::string* work);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_work();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_work(
      ::std::string* work);

  // optional bytes name = 6;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 6;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const void* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_name();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      ::std::string* name);

  // optional bytes talk_data = 8;
  bool has_talk_data() const;
  void clear_talk_data();
  static const int kTalkDataFieldNumber = 8;
  const ::std::string& talk_data() const;
  void set_talk_data(const ::std::string& value);
  #if LANG_CXX11
  void set_talk_data(::std::string&& value);
  #endif
  void set_talk_data(const char* value);
  void set_talk_data(const void* value, size_t size);
  ::std::string* mutable_talk_data();
  ::std::string* release_talk_data();
  void set_allocated_talk_data(::std::string* talk_data);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_talk_data();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_talk_data(
      ::std::string* talk_data);

  // optional int32 target_id = 2;
  bool has_target_id() const;
  void clear_target_id();
  static const int kTargetIdFieldNumber = 2;
  ::google::protobuf::int32 target_id() const;
  void set_target_id(::google::protobuf::int32 value);

  // optional int32 seat = 3;
  bool has_seat() const;
  void clear_seat();
  static const int kSeatFieldNumber = 3;
  ::google::protobuf::int32 seat() const;
  void set_seat(::google::protobuf::int32 value);

  // optional int32 type = 5;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 5;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // optional int32 new_owner = 7;
  bool has_new_owner() const;
  void clear_new_owner();
  static const int kNewOwnerFieldNumber = 7;
  ::google::protobuf::int32 new_owner() const;
  void set_new_owner(::google::protobuf::int32 value);

  // required .sg.MultiplayerTeamService.CMD cmd = 1;
  bool has_cmd() const;
  void clear_cmd();
  static const int kCmdFieldNumber = 1;
  ::sg::MultiplayerTeamService_CMD cmd() const;
  void set_cmd(::sg::MultiplayerTeamService_CMD value);

  // @@protoc_insertion_point(class_scope:sg.MultiplayerTeamService.MultiplayerTeamRequest)
 private:
  void set_has_cmd();
  void clear_has_cmd();
  void set_has_target_id();
  void clear_has_target_id();
  void set_has_seat();
  void clear_has_seat();
  void set_has_work();
  void clear_has_work();
  void set_has_type();
  void clear_has_type();
  void set_has_name();
  void clear_has_name();
  void set_has_new_owner();
  void clear_has_new_owner();
  void set_has_talk_data();
  void clear_has_talk_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr work_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr talk_data_;
  ::google::protobuf::int32 target_id_;
  ::google::protobuf::int32 seat_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 new_owner_;
  int cmd_;
  friend struct ::protobuf_Multiplayer_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MultiplayerTeamService_MultiplayerTeamResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.MultiplayerTeamService.MultiplayerTeamResponse) */ {
 public:
  MultiplayerTeamService_MultiplayerTeamResponse();
  virtual ~MultiplayerTeamService_MultiplayerTeamResponse();

  MultiplayerTeamService_MultiplayerTeamResponse(const MultiplayerTeamService_MultiplayerTeamResponse& from);

  inline MultiplayerTeamService_MultiplayerTeamResponse& operator=(const MultiplayerTeamService_MultiplayerTeamResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MultiplayerTeamService_MultiplayerTeamResponse(MultiplayerTeamService_MultiplayerTeamResponse&& from) noexcept
    : MultiplayerTeamService_MultiplayerTeamResponse() {
    *this = ::std::move(from);
  }

  inline MultiplayerTeamService_MultiplayerTeamResponse& operator=(MultiplayerTeamService_MultiplayerTeamResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const MultiplayerTeamService_MultiplayerTeamResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MultiplayerTeamService_MultiplayerTeamResponse* internal_default_instance() {
    return reinterpret_cast<const MultiplayerTeamService_MultiplayerTeamResponse*>(
               &_MultiplayerTeamService_MultiplayerTeamResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void UnsafeArenaSwap(MultiplayerTeamService_MultiplayerTeamResponse* other);
  void Swap(MultiplayerTeamService_MultiplayerTeamResponse* other);
  friend void swap(MultiplayerTeamService_MultiplayerTeamResponse& a, MultiplayerTeamService_MultiplayerTeamResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MultiplayerTeamService_MultiplayerTeamResponse* New() const final {
    return CreateMaybeMessage<MultiplayerTeamService_MultiplayerTeamResponse>(NULL);
  }

  MultiplayerTeamService_MultiplayerTeamResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MultiplayerTeamService_MultiplayerTeamResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MultiplayerTeamService_MultiplayerTeamResponse& from);
  void MergeFrom(const MultiplayerTeamService_MultiplayerTeamResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiplayerTeamService_MultiplayerTeamResponse* other);
  protected:
  explicit MultiplayerTeamService_MultiplayerTeamResponse(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sg.MultiplayerRoom room_list = 3;
  int room_list_size() const;
  void clear_room_list();
  static const int kRoomListFieldNumber = 3;
  ::sg::MultiplayerRoom* mutable_room_list(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::MultiplayerRoom >*
      mutable_room_list();
  const ::sg::MultiplayerRoom& room_list(int index) const;
  ::sg::MultiplayerRoom* add_room_list();
  const ::google::protobuf::RepeatedPtrField< ::sg::MultiplayerRoom >&
      room_list() const;

  // optional .sg.MultiplayerRoom my_room = 2;
  bool has_my_room() const;
  void clear_my_room();
  static const int kMyRoomFieldNumber = 2;
  private:
  const ::sg::MultiplayerRoom& _internal_my_room() const;
  public:
  const ::sg::MultiplayerRoom& my_room() const;
  ::sg::MultiplayerRoom* release_my_room();
  ::sg::MultiplayerRoom* mutable_my_room();
  void set_allocated_my_room(::sg::MultiplayerRoom* my_room);
  void unsafe_arena_set_allocated_my_room(
      ::sg::MultiplayerRoom* my_room);
  ::sg::MultiplayerRoom* unsafe_arena_release_my_room();

  // required int32 result = 1;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::google::protobuf::int32 result() const;
  void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.MultiplayerTeamService.MultiplayerTeamResponse)
 private:
  void set_has_result();
  void clear_has_result();
  void set_has_my_room();
  void clear_has_my_room();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::MultiplayerRoom > room_list_;
  ::sg::MultiplayerRoom* my_room_;
  ::google::protobuf::int32 result_;
  friend struct ::protobuf_Multiplayer_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MultiplayerTeamService : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.MultiplayerTeamService) */ {
 public:
  MultiplayerTeamService();
  virtual ~MultiplayerTeamService();

  MultiplayerTeamService(const MultiplayerTeamService& from);

  inline MultiplayerTeamService& operator=(const MultiplayerTeamService& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MultiplayerTeamService(MultiplayerTeamService&& from) noexcept
    : MultiplayerTeamService() {
    *this = ::std::move(from);
  }

  inline MultiplayerTeamService& operator=(MultiplayerTeamService&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const MultiplayerTeamService& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MultiplayerTeamService* internal_default_instance() {
    return reinterpret_cast<const MultiplayerTeamService*>(
               &_MultiplayerTeamService_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void UnsafeArenaSwap(MultiplayerTeamService* other);
  void Swap(MultiplayerTeamService* other);
  friend void swap(MultiplayerTeamService& a, MultiplayerTeamService& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MultiplayerTeamService* New() const final {
    return CreateMaybeMessage<MultiplayerTeamService>(NULL);
  }

  MultiplayerTeamService* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MultiplayerTeamService>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MultiplayerTeamService& from);
  void MergeFrom(const MultiplayerTeamService& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiplayerTeamService* other);
  protected:
  explicit MultiplayerTeamService(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MultiplayerTeamService_MultiplayerTeamRequest MultiplayerTeamRequest;
  typedef MultiplayerTeamService_MultiplayerTeamResponse MultiplayerTeamResponse;

  typedef MultiplayerTeamService_CMD CMD;
  static const CMD QUERY_LIST =
    MultiplayerTeamService_CMD_QUERY_LIST;
  static const CMD QUERY_SELF =
    MultiplayerTeamService_CMD_QUERY_SELF;
  static const CMD CREATE_ROOM =
    MultiplayerTeamService_CMD_CREATE_ROOM;
  static const CMD ADD_ROOM =
    MultiplayerTeamService_CMD_ADD_ROOM;
  static const CMD LEAVE_ROOM =
    MultiplayerTeamService_CMD_LEAVE_ROOM;
  static const CMD DELETE_ROOM =
    MultiplayerTeamService_CMD_DELETE_ROOM;
  static const CMD CHANGE_SEAT =
    MultiplayerTeamService_CMD_CHANGE_SEAT;
  static const CMD CHANGE_OWNER =
    MultiplayerTeamService_CMD_CHANGE_OWNER;
  static const CMD SET_WORK =
    MultiplayerTeamService_CMD_SET_WORK;
  static const CMD RENAME_ROOM =
    MultiplayerTeamService_CMD_RENAME_ROOM;
  static const CMD READY =
    MultiplayerTeamService_CMD_READY;
  static const CMD TALK =
    MultiplayerTeamService_CMD_TALK;
  static inline bool CMD_IsValid(int value) {
    return MultiplayerTeamService_CMD_IsValid(value);
  }
  static const CMD CMD_MIN =
    MultiplayerTeamService_CMD_CMD_MIN;
  static const CMD CMD_MAX =
    MultiplayerTeamService_CMD_CMD_MAX;
  static const int CMD_ARRAYSIZE =
    MultiplayerTeamService_CMD_CMD_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CMD_descriptor() {
    return MultiplayerTeamService_CMD_descriptor();
  }
  static inline const ::std::string& CMD_Name(CMD value) {
    return MultiplayerTeamService_CMD_Name(value);
  }
  static inline bool CMD_Parse(const ::std::string& name,
      CMD* value) {
    return MultiplayerTeamService_CMD_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .sg.MultiplayerTeamService.MultiplayerTeamRequest req = 1;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 1;
  private:
  const ::sg::MultiplayerTeamService_MultiplayerTeamRequest& _internal_req() const;
  public:
  const ::sg::MultiplayerTeamService_MultiplayerTeamRequest& req() const;
  ::sg::MultiplayerTeamService_MultiplayerTeamRequest* release_req();
  ::sg::MultiplayerTeamService_MultiplayerTeamRequest* mutable_req();
  void set_allocated_req(::sg::MultiplayerTeamService_MultiplayerTeamRequest* req);
  void unsafe_arena_set_allocated_req(
      ::sg::MultiplayerTeamService_MultiplayerTeamRequest* req);
  ::sg::MultiplayerTeamService_MultiplayerTeamRequest* unsafe_arena_release_req();

  // optional .sg.MultiplayerTeamService.MultiplayerTeamResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  private:
  const ::sg::MultiplayerTeamService_MultiplayerTeamResponse& _internal_resp() const;
  public:
  const ::sg::MultiplayerTeamService_MultiplayerTeamResponse& resp() const;
  ::sg::MultiplayerTeamService_MultiplayerTeamResponse* release_resp();
  ::sg::MultiplayerTeamService_MultiplayerTeamResponse* mutable_resp();
  void set_allocated_resp(::sg::MultiplayerTeamService_MultiplayerTeamResponse* resp);
  void unsafe_arena_set_allocated_resp(
      ::sg::MultiplayerTeamService_MultiplayerTeamResponse* resp);
  ::sg::MultiplayerTeamService_MultiplayerTeamResponse* unsafe_arena_release_resp();

  // @@protoc_insertion_point(class_scope:sg.MultiplayerTeamService)
 private:
  void set_has_req();
  void clear_has_req();
  void set_has_resp();
  void clear_has_resp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::sg::MultiplayerTeamService_MultiplayerTeamRequest* req_;
  ::sg::MultiplayerTeamService_MultiplayerTeamResponse* resp_;
  friend struct ::protobuf_Multiplayer_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserTalkNotify : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.UserTalkNotify) */ {
 public:
  UserTalkNotify();
  virtual ~UserTalkNotify();

  UserTalkNotify(const UserTalkNotify& from);

  inline UserTalkNotify& operator=(const UserTalkNotify& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserTalkNotify(UserTalkNotify&& from) noexcept
    : UserTalkNotify() {
    *this = ::std::move(from);
  }

  inline UserTalkNotify& operator=(UserTalkNotify&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserTalkNotify& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserTalkNotify* internal_default_instance() {
    return reinterpret_cast<const UserTalkNotify*>(
               &_UserTalkNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void UnsafeArenaSwap(UserTalkNotify* other);
  void Swap(UserTalkNotify* other);
  friend void swap(UserTalkNotify& a, UserTalkNotify& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserTalkNotify* New() const final {
    return CreateMaybeMessage<UserTalkNotify>(NULL);
  }

  UserTalkNotify* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserTalkNotify>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserTalkNotify& from);
  void MergeFrom(const UserTalkNotify& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserTalkNotify* other);
  protected:
  explicit UserTalkNotify(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes data = 3;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 3;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_data();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_data(
      ::std::string* data);

  // required sfixed64 timestamp = 2;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // required int32 index = 1;
  bool has_index() const;
  void clear_index();
  static const int kIndexFieldNumber = 1;
  ::google::protobuf::int32 index() const;
  void set_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.UserTalkNotify)
 private:
  void set_has_index();
  void clear_has_index();
  void set_has_timestamp();
  void clear_has_timestamp();
  void set_has_data();
  void clear_has_data();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::int64 timestamp_;
  ::google::protobuf::int32 index_;
  friend struct ::protobuf_Multiplayer_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserAddNotify : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.UserAddNotify) */ {
 public:
  UserAddNotify();
  virtual ~UserAddNotify();

  UserAddNotify(const UserAddNotify& from);

  inline UserAddNotify& operator=(const UserAddNotify& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserAddNotify(UserAddNotify&& from) noexcept
    : UserAddNotify() {
    *this = ::std::move(from);
  }

  inline UserAddNotify& operator=(UserAddNotify&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserAddNotify& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserAddNotify* internal_default_instance() {
    return reinterpret_cast<const UserAddNotify*>(
               &_UserAddNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void UnsafeArenaSwap(UserAddNotify* other);
  void Swap(UserAddNotify* other);
  friend void swap(UserAddNotify& a, UserAddNotify& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserAddNotify* New() const final {
    return CreateMaybeMessage<UserAddNotify>(NULL);
  }

  UserAddNotify* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserAddNotify>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserAddNotify& from);
  void MergeFrom(const UserAddNotify& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserAddNotify* other);
  protected:
  explicit UserAddNotify(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .sg.MultiplayerRoom room_data = 1;
  bool has_room_data() const;
  void clear_room_data();
  static const int kRoomDataFieldNumber = 1;
  private:
  const ::sg::MultiplayerRoom& _internal_room_data() const;
  public:
  const ::sg::MultiplayerRoom& room_data() const;
  ::sg::MultiplayerRoom* release_room_data();
  ::sg::MultiplayerRoom* mutable_room_data();
  void set_allocated_room_data(::sg::MultiplayerRoom* room_data);
  void unsafe_arena_set_allocated_room_data(
      ::sg::MultiplayerRoom* room_data);
  ::sg::MultiplayerRoom* unsafe_arena_release_room_data();

  // @@protoc_insertion_point(class_scope:sg.UserAddNotify)
 private:
  void set_has_room_data();
  void clear_has_room_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::sg::MultiplayerRoom* room_data_;
  friend struct ::protobuf_Multiplayer_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserChangeSeatNotify : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.UserChangeSeatNotify) */ {
 public:
  UserChangeSeatNotify();
  virtual ~UserChangeSeatNotify();

  UserChangeSeatNotify(const UserChangeSeatNotify& from);

  inline UserChangeSeatNotify& operator=(const UserChangeSeatNotify& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserChangeSeatNotify(UserChangeSeatNotify&& from) noexcept
    : UserChangeSeatNotify() {
    *this = ::std::move(from);
  }

  inline UserChangeSeatNotify& operator=(UserChangeSeatNotify&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserChangeSeatNotify& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserChangeSeatNotify* internal_default_instance() {
    return reinterpret_cast<const UserChangeSeatNotify*>(
               &_UserChangeSeatNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void UnsafeArenaSwap(UserChangeSeatNotify* other);
  void Swap(UserChangeSeatNotify* other);
  friend void swap(UserChangeSeatNotify& a, UserChangeSeatNotify& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserChangeSeatNotify* New() const final {
    return CreateMaybeMessage<UserChangeSeatNotify>(NULL);
  }

  UserChangeSeatNotify* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserChangeSeatNotify>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserChangeSeatNotify& from);
  void MergeFrom(const UserChangeSeatNotify& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserChangeSeatNotify* other);
  protected:
  explicit UserChangeSeatNotify(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .sg.MultiplayerRoom room_data = 1;
  bool has_room_data() const;
  void clear_room_data();
  static const int kRoomDataFieldNumber = 1;
  private:
  const ::sg::MultiplayerRoom& _internal_room_data() const;
  public:
  const ::sg::MultiplayerRoom& room_data() const;
  ::sg::MultiplayerRoom* release_room_data();
  ::sg::MultiplayerRoom* mutable_room_data();
  void set_allocated_room_data(::sg::MultiplayerRoom* room_data);
  void unsafe_arena_set_allocated_room_data(
      ::sg::MultiplayerRoom* room_data);
  ::sg::MultiplayerRoom* unsafe_arena_release_room_data();

  // @@protoc_insertion_point(class_scope:sg.UserChangeSeatNotify)
 private:
  void set_has_room_data();
  void clear_has_room_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::sg::MultiplayerRoom* room_data_;
  friend struct ::protobuf_Multiplayer_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserDeleteRoomNotify : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.UserDeleteRoomNotify) */ {
 public:
  UserDeleteRoomNotify();
  virtual ~UserDeleteRoomNotify();

  UserDeleteRoomNotify(const UserDeleteRoomNotify& from);

  inline UserDeleteRoomNotify& operator=(const UserDeleteRoomNotify& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserDeleteRoomNotify(UserDeleteRoomNotify&& from) noexcept
    : UserDeleteRoomNotify() {
    *this = ::std::move(from);
  }

  inline UserDeleteRoomNotify& operator=(UserDeleteRoomNotify&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserDeleteRoomNotify& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserDeleteRoomNotify* internal_default_instance() {
    return reinterpret_cast<const UserDeleteRoomNotify*>(
               &_UserDeleteRoomNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void UnsafeArenaSwap(UserDeleteRoomNotify* other);
  void Swap(UserDeleteRoomNotify* other);
  friend void swap(UserDeleteRoomNotify& a, UserDeleteRoomNotify& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserDeleteRoomNotify* New() const final {
    return CreateMaybeMessage<UserDeleteRoomNotify>(NULL);
  }

  UserDeleteRoomNotify* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserDeleteRoomNotify>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserDeleteRoomNotify& from);
  void MergeFrom(const UserDeleteRoomNotify& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserDeleteRoomNotify* other);
  protected:
  explicit UserDeleteRoomNotify(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .sg.MultiplayerRoom room_data = 1;
  bool has_room_data() const;
  void clear_room_data();
  static const int kRoomDataFieldNumber = 1;
  private:
  const ::sg::MultiplayerRoom& _internal_room_data() const;
  public:
  const ::sg::MultiplayerRoom& room_data() const;
  ::sg::MultiplayerRoom* release_room_data();
  ::sg::MultiplayerRoom* mutable_room_data();
  void set_allocated_room_data(::sg::MultiplayerRoom* room_data);
  void unsafe_arena_set_allocated_room_data(
      ::sg::MultiplayerRoom* room_data);
  ::sg::MultiplayerRoom* unsafe_arena_release_room_data();

  // @@protoc_insertion_point(class_scope:sg.UserDeleteRoomNotify)
 private:
  void set_has_room_data();
  void clear_has_room_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::sg::MultiplayerRoom* room_data_;
  friend struct ::protobuf_Multiplayer_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserChangeOwnerNotify : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.UserChangeOwnerNotify) */ {
 public:
  UserChangeOwnerNotify();
  virtual ~UserChangeOwnerNotify();

  UserChangeOwnerNotify(const UserChangeOwnerNotify& from);

  inline UserChangeOwnerNotify& operator=(const UserChangeOwnerNotify& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserChangeOwnerNotify(UserChangeOwnerNotify&& from) noexcept
    : UserChangeOwnerNotify() {
    *this = ::std::move(from);
  }

  inline UserChangeOwnerNotify& operator=(UserChangeOwnerNotify&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserChangeOwnerNotify& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserChangeOwnerNotify* internal_default_instance() {
    return reinterpret_cast<const UserChangeOwnerNotify*>(
               &_UserChangeOwnerNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void UnsafeArenaSwap(UserChangeOwnerNotify* other);
  void Swap(UserChangeOwnerNotify* other);
  friend void swap(UserChangeOwnerNotify& a, UserChangeOwnerNotify& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserChangeOwnerNotify* New() const final {
    return CreateMaybeMessage<UserChangeOwnerNotify>(NULL);
  }

  UserChangeOwnerNotify* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserChangeOwnerNotify>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserChangeOwnerNotify& from);
  void MergeFrom(const UserChangeOwnerNotify& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserChangeOwnerNotify* other);
  protected:
  explicit UserChangeOwnerNotify(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .sg.MultiplayerRoom room_data = 1;
  bool has_room_data() const;
  void clear_room_data();
  static const int kRoomDataFieldNumber = 1;
  private:
  const ::sg::MultiplayerRoom& _internal_room_data() const;
  public:
  const ::sg::MultiplayerRoom& room_data() const;
  ::sg::MultiplayerRoom* release_room_data();
  ::sg::MultiplayerRoom* mutable_room_data();
  void set_allocated_room_data(::sg::MultiplayerRoom* room_data);
  void unsafe_arena_set_allocated_room_data(
      ::sg::MultiplayerRoom* room_data);
  ::sg::MultiplayerRoom* unsafe_arena_release_room_data();

  // @@protoc_insertion_point(class_scope:sg.UserChangeOwnerNotify)
 private:
  void set_has_room_data();
  void clear_has_room_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::sg::MultiplayerRoom* room_data_;
  friend struct ::protobuf_Multiplayer_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserChangeWorkNotify : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.UserChangeWorkNotify) */ {
 public:
  UserChangeWorkNotify();
  virtual ~UserChangeWorkNotify();

  UserChangeWorkNotify(const UserChangeWorkNotify& from);

  inline UserChangeWorkNotify& operator=(const UserChangeWorkNotify& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserChangeWorkNotify(UserChangeWorkNotify&& from) noexcept
    : UserChangeWorkNotify() {
    *this = ::std::move(from);
  }

  inline UserChangeWorkNotify& operator=(UserChangeWorkNotify&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserChangeWorkNotify& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserChangeWorkNotify* internal_default_instance() {
    return reinterpret_cast<const UserChangeWorkNotify*>(
               &_UserChangeWorkNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void UnsafeArenaSwap(UserChangeWorkNotify* other);
  void Swap(UserChangeWorkNotify* other);
  friend void swap(UserChangeWorkNotify& a, UserChangeWorkNotify& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserChangeWorkNotify* New() const final {
    return CreateMaybeMessage<UserChangeWorkNotify>(NULL);
  }

  UserChangeWorkNotify* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserChangeWorkNotify>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserChangeWorkNotify& from);
  void MergeFrom(const UserChangeWorkNotify& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserChangeWorkNotify* other);
  protected:
  explicit UserChangeWorkNotify(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .sg.MultiplayerRoom room_data = 1;
  bool has_room_data() const;
  void clear_room_data();
  static const int kRoomDataFieldNumber = 1;
  private:
  const ::sg::MultiplayerRoom& _internal_room_data() const;
  public:
  const ::sg::MultiplayerRoom& room_data() const;
  ::sg::MultiplayerRoom* release_room_data();
  ::sg::MultiplayerRoom* mutable_room_data();
  void set_allocated_room_data(::sg::MultiplayerRoom* room_data);
  void unsafe_arena_set_allocated_room_data(
      ::sg::MultiplayerRoom* room_data);
  ::sg::MultiplayerRoom* unsafe_arena_release_room_data();

  // @@protoc_insertion_point(class_scope:sg.UserChangeWorkNotify)
 private:
  void set_has_room_data();
  void clear_has_room_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::sg::MultiplayerRoom* room_data_;
  friend struct ::protobuf_Multiplayer_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserLeaveNotify : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.UserLeaveNotify) */ {
 public:
  UserLeaveNotify();
  virtual ~UserLeaveNotify();

  UserLeaveNotify(const UserLeaveNotify& from);

  inline UserLeaveNotify& operator=(const UserLeaveNotify& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserLeaveNotify(UserLeaveNotify&& from) noexcept
    : UserLeaveNotify() {
    *this = ::std::move(from);
  }

  inline UserLeaveNotify& operator=(UserLeaveNotify&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserLeaveNotify& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserLeaveNotify* internal_default_instance() {
    return reinterpret_cast<const UserLeaveNotify*>(
               &_UserLeaveNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void UnsafeArenaSwap(UserLeaveNotify* other);
  void Swap(UserLeaveNotify* other);
  friend void swap(UserLeaveNotify& a, UserLeaveNotify& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserLeaveNotify* New() const final {
    return CreateMaybeMessage<UserLeaveNotify>(NULL);
  }

  UserLeaveNotify* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserLeaveNotify>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserLeaveNotify& from);
  void MergeFrom(const UserLeaveNotify& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserLeaveNotify* other);
  protected:
  explicit UserLeaveNotify(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .sg.MultiplayerRoom room_data = 1;
  bool has_room_data() const;
  void clear_room_data();
  static const int kRoomDataFieldNumber = 1;
  private:
  const ::sg::MultiplayerRoom& _internal_room_data() const;
  public:
  const ::sg::MultiplayerRoom& room_data() const;
  ::sg::MultiplayerRoom* release_room_data();
  ::sg::MultiplayerRoom* mutable_room_data();
  void set_allocated_room_data(::sg::MultiplayerRoom* room_data);
  void unsafe_arena_set_allocated_room_data(
      ::sg::MultiplayerRoom* room_data);
  ::sg::MultiplayerRoom* unsafe_arena_release_room_data();

  // @@protoc_insertion_point(class_scope:sg.UserLeaveNotify)
 private:
  void set_has_room_data();
  void clear_has_room_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::sg::MultiplayerRoom* room_data_;
  friend struct ::protobuf_Multiplayer_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserRenameNotify : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.UserRenameNotify) */ {
 public:
  UserRenameNotify();
  virtual ~UserRenameNotify();

  UserRenameNotify(const UserRenameNotify& from);

  inline UserRenameNotify& operator=(const UserRenameNotify& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserRenameNotify(UserRenameNotify&& from) noexcept
    : UserRenameNotify() {
    *this = ::std::move(from);
  }

  inline UserRenameNotify& operator=(UserRenameNotify&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserRenameNotify& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserRenameNotify* internal_default_instance() {
    return reinterpret_cast<const UserRenameNotify*>(
               &_UserRenameNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void UnsafeArenaSwap(UserRenameNotify* other);
  void Swap(UserRenameNotify* other);
  friend void swap(UserRenameNotify& a, UserRenameNotify& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserRenameNotify* New() const final {
    return CreateMaybeMessage<UserRenameNotify>(NULL);
  }

  UserRenameNotify* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserRenameNotify>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserRenameNotify& from);
  void MergeFrom(const UserRenameNotify& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserRenameNotify* other);
  protected:
  explicit UserRenameNotify(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .sg.MultiplayerRoom room_data = 1;
  bool has_room_data() const;
  void clear_room_data();
  static const int kRoomDataFieldNumber = 1;
  private:
  const ::sg::MultiplayerRoom& _internal_room_data() const;
  public:
  const ::sg::MultiplayerRoom& room_data() const;
  ::sg::MultiplayerRoom* release_room_data();
  ::sg::MultiplayerRoom* mutable_room_data();
  void set_allocated_room_data(::sg::MultiplayerRoom* room_data);
  void unsafe_arena_set_allocated_room_data(
      ::sg::MultiplayerRoom* room_data);
  ::sg::MultiplayerRoom* unsafe_arena_release_room_data();

  // @@protoc_insertion_point(class_scope:sg.UserRenameNotify)
 private:
  void set_has_room_data();
  void clear_has_room_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::sg::MultiplayerRoom* room_data_;
  friend struct ::protobuf_Multiplayer_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BattleReadyNotify : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.BattleReadyNotify) */ {
 public:
  BattleReadyNotify();
  virtual ~BattleReadyNotify();

  BattleReadyNotify(const BattleReadyNotify& from);

  inline BattleReadyNotify& operator=(const BattleReadyNotify& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BattleReadyNotify(BattleReadyNotify&& from) noexcept
    : BattleReadyNotify() {
    *this = ::std::move(from);
  }

  inline BattleReadyNotify& operator=(BattleReadyNotify&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const BattleReadyNotify& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BattleReadyNotify* internal_default_instance() {
    return reinterpret_cast<const BattleReadyNotify*>(
               &_BattleReadyNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void UnsafeArenaSwap(BattleReadyNotify* other);
  void Swap(BattleReadyNotify* other);
  friend void swap(BattleReadyNotify& a, BattleReadyNotify& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BattleReadyNotify* New() const final {
    return CreateMaybeMessage<BattleReadyNotify>(NULL);
  }

  BattleReadyNotify* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BattleReadyNotify>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BattleReadyNotify& from);
  void MergeFrom(const BattleReadyNotify& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BattleReadyNotify* other);
  protected:
  explicit BattleReadyNotify(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .sg.MultiplayerRoom room_data = 1;
  bool has_room_data() const;
  void clear_room_data();
  static const int kRoomDataFieldNumber = 1;
  private:
  const ::sg::MultiplayerRoom& _internal_room_data() const;
  public:
  const ::sg::MultiplayerRoom& room_data() const;
  ::sg::MultiplayerRoom* release_room_data();
  ::sg::MultiplayerRoom* mutable_room_data();
  void set_allocated_room_data(::sg::MultiplayerRoom* room_data);
  void unsafe_arena_set_allocated_room_data(
      ::sg::MultiplayerRoom* room_data);
  ::sg::MultiplayerRoom* unsafe_arena_release_room_data();

  // @@protoc_insertion_point(class_scope:sg.BattleReadyNotify)
 private:
  void set_has_room_data();
  void clear_has_room_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::sg::MultiplayerRoom* room_data_;
  friend struct ::protobuf_Multiplayer_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MultiplayerBattleService_MultiplayerBattleRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.MultiplayerBattleService.MultiplayerBattleRequest) */ {
 public:
  MultiplayerBattleService_MultiplayerBattleRequest();
  virtual ~MultiplayerBattleService_MultiplayerBattleRequest();

  MultiplayerBattleService_MultiplayerBattleRequest(const MultiplayerBattleService_MultiplayerBattleRequest& from);

  inline MultiplayerBattleService_MultiplayerBattleRequest& operator=(const MultiplayerBattleService_MultiplayerBattleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MultiplayerBattleService_MultiplayerBattleRequest(MultiplayerBattleService_MultiplayerBattleRequest&& from) noexcept
    : MultiplayerBattleService_MultiplayerBattleRequest() {
    *this = ::std::move(from);
  }

  inline MultiplayerBattleService_MultiplayerBattleRequest& operator=(MultiplayerBattleService_MultiplayerBattleRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const MultiplayerBattleService_MultiplayerBattleRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MultiplayerBattleService_MultiplayerBattleRequest* internal_default_instance() {
    return reinterpret_cast<const MultiplayerBattleService_MultiplayerBattleRequest*>(
               &_MultiplayerBattleService_MultiplayerBattleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void UnsafeArenaSwap(MultiplayerBattleService_MultiplayerBattleRequest* other);
  void Swap(MultiplayerBattleService_MultiplayerBattleRequest* other);
  friend void swap(MultiplayerBattleService_MultiplayerBattleRequest& a, MultiplayerBattleService_MultiplayerBattleRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MultiplayerBattleService_MultiplayerBattleRequest* New() const final {
    return CreateMaybeMessage<MultiplayerBattleService_MultiplayerBattleRequest>(NULL);
  }

  MultiplayerBattleService_MultiplayerBattleRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MultiplayerBattleService_MultiplayerBattleRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MultiplayerBattleService_MultiplayerBattleRequest& from);
  void MergeFrom(const MultiplayerBattleService_MultiplayerBattleRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiplayerBattleService_MultiplayerBattleRequest* other);
  protected:
  explicit MultiplayerBattleService_MultiplayerBattleRequest(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 sailors = 4;
  int sailors_size() const;
  void clear_sailors();
  static const int kSailorsFieldNumber = 4;
  ::google::protobuf::int32 sailors(int index) const;
  void set_sailors(int index, ::google::protobuf::int32 value);
  void add_sailors(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      sailors() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_sailors();

  // repeated .sg.FrameData operation_list = 5;
  int operation_list_size() const;
  void clear_operation_list();
  static const int kOperationListFieldNumber = 5;
  ::sg::FrameData* mutable_operation_list(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::FrameData >*
      mutable_operation_list();
  const ::sg::FrameData& operation_list(int index) const;
  ::sg::FrameData* add_operation_list();
  const ::google::protobuf::RepeatedPtrField< ::sg::FrameData >&
      operation_list() const;

  // optional uint64 target_id = 3;
  bool has_target_id() const;
  void clear_target_id();
  static const int kTargetIdFieldNumber = 3;
  ::google::protobuf::uint64 target_id() const;
  void set_target_id(::google::protobuf::uint64 value);

  // optional int32 result = 6;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 6;
  ::google::protobuf::int32 result() const;
  void set_result(::google::protobuf::int32 value);

  // required .sg.MultiplayerBattleService.CMD cmd = 1;
  bool has_cmd() const;
  void clear_cmd();
  static const int kCmdFieldNumber = 1;
  ::sg::MultiplayerBattleService_CMD cmd() const;
  void set_cmd(::sg::MultiplayerBattleService_CMD value);

  // @@protoc_insertion_point(class_scope:sg.MultiplayerBattleService.MultiplayerBattleRequest)
 private:
  void set_has_cmd();
  void clear_has_cmd();
  void set_has_target_id();
  void clear_has_target_id();
  void set_has_result();
  void clear_has_result();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > sailors_;
  ::google::protobuf::RepeatedPtrField< ::sg::FrameData > operation_list_;
  ::google::protobuf::uint64 target_id_;
  ::google::protobuf::int32 result_;
  int cmd_;
  friend struct ::protobuf_Multiplayer_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MultiplayerBattleService_MultiplayerBattleResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.MultiplayerBattleService.MultiplayerBattleResponse) */ {
 public:
  MultiplayerBattleService_MultiplayerBattleResponse();
  virtual ~MultiplayerBattleService_MultiplayerBattleResponse();

  MultiplayerBattleService_MultiplayerBattleResponse(const MultiplayerBattleService_MultiplayerBattleResponse& from);

  inline MultiplayerBattleService_MultiplayerBattleResponse& operator=(const MultiplayerBattleService_MultiplayerBattleResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MultiplayerBattleService_MultiplayerBattleResponse(MultiplayerBattleService_MultiplayerBattleResponse&& from) noexcept
    : MultiplayerBattleService_MultiplayerBattleResponse() {
    *this = ::std::move(from);
  }

  inline MultiplayerBattleService_MultiplayerBattleResponse& operator=(MultiplayerBattleService_MultiplayerBattleResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const MultiplayerBattleService_MultiplayerBattleResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MultiplayerBattleService_MultiplayerBattleResponse* internal_default_instance() {
    return reinterpret_cast<const MultiplayerBattleService_MultiplayerBattleResponse*>(
               &_MultiplayerBattleService_MultiplayerBattleResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void UnsafeArenaSwap(MultiplayerBattleService_MultiplayerBattleResponse* other);
  void Swap(MultiplayerBattleService_MultiplayerBattleResponse* other);
  friend void swap(MultiplayerBattleService_MultiplayerBattleResponse& a, MultiplayerBattleService_MultiplayerBattleResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MultiplayerBattleService_MultiplayerBattleResponse* New() const final {
    return CreateMaybeMessage<MultiplayerBattleService_MultiplayerBattleResponse>(NULL);
  }

  MultiplayerBattleService_MultiplayerBattleResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MultiplayerBattleService_MultiplayerBattleResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MultiplayerBattleService_MultiplayerBattleResponse& from);
  void MergeFrom(const MultiplayerBattleService_MultiplayerBattleResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiplayerBattleService_MultiplayerBattleResponse* other);
  protected:
  explicit MultiplayerBattleService_MultiplayerBattleResponse(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::google::protobuf::int32 result() const;
  void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.MultiplayerBattleService.MultiplayerBattleResponse)
 private:
  void set_has_result();
  void clear_has_result();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 result_;
  friend struct ::protobuf_Multiplayer_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MultiplayerBattleService : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.MultiplayerBattleService) */ {
 public:
  MultiplayerBattleService();
  virtual ~MultiplayerBattleService();

  MultiplayerBattleService(const MultiplayerBattleService& from);

  inline MultiplayerBattleService& operator=(const MultiplayerBattleService& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MultiplayerBattleService(MultiplayerBattleService&& from) noexcept
    : MultiplayerBattleService() {
    *this = ::std::move(from);
  }

  inline MultiplayerBattleService& operator=(MultiplayerBattleService&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const MultiplayerBattleService& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MultiplayerBattleService* internal_default_instance() {
    return reinterpret_cast<const MultiplayerBattleService*>(
               &_MultiplayerBattleService_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void UnsafeArenaSwap(MultiplayerBattleService* other);
  void Swap(MultiplayerBattleService* other);
  friend void swap(MultiplayerBattleService& a, MultiplayerBattleService& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MultiplayerBattleService* New() const final {
    return CreateMaybeMessage<MultiplayerBattleService>(NULL);
  }

  MultiplayerBattleService* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MultiplayerBattleService>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MultiplayerBattleService& from);
  void MergeFrom(const MultiplayerBattleService& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiplayerBattleService* other);
  protected:
  explicit MultiplayerBattleService(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MultiplayerBattleService_MultiplayerBattleRequest MultiplayerBattleRequest;
  typedef MultiplayerBattleService_MultiplayerBattleResponse MultiplayerBattleResponse;

  typedef MultiplayerBattleService_CMD CMD;
  static const CMD READY =
    MultiplayerBattleService_CMD_READY;
  static const CMD CHANGE_SAILOR =
    MultiplayerBattleService_CMD_CHANGE_SAILOR;
  static const CMD OPERATE =
    MultiplayerBattleService_CMD_OPERATE;
  static const CMD OVER =
    MultiplayerBattleService_CMD_OVER;
  static inline bool CMD_IsValid(int value) {
    return MultiplayerBattleService_CMD_IsValid(value);
  }
  static const CMD CMD_MIN =
    MultiplayerBattleService_CMD_CMD_MIN;
  static const CMD CMD_MAX =
    MultiplayerBattleService_CMD_CMD_MAX;
  static const int CMD_ARRAYSIZE =
    MultiplayerBattleService_CMD_CMD_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CMD_descriptor() {
    return MultiplayerBattleService_CMD_descriptor();
  }
  static inline const ::std::string& CMD_Name(CMD value) {
    return MultiplayerBattleService_CMD_Name(value);
  }
  static inline bool CMD_Parse(const ::std::string& name,
      CMD* value) {
    return MultiplayerBattleService_CMD_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .sg.MultiplayerBattleService.MultiplayerBattleRequest req = 1;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 1;
  private:
  const ::sg::MultiplayerBattleService_MultiplayerBattleRequest& _internal_req() const;
  public:
  const ::sg::MultiplayerBattleService_MultiplayerBattleRequest& req() const;
  ::sg::MultiplayerBattleService_MultiplayerBattleRequest* release_req();
  ::sg::MultiplayerBattleService_MultiplayerBattleRequest* mutable_req();
  void set_allocated_req(::sg::MultiplayerBattleService_MultiplayerBattleRequest* req);
  void unsafe_arena_set_allocated_req(
      ::sg::MultiplayerBattleService_MultiplayerBattleRequest* req);
  ::sg::MultiplayerBattleService_MultiplayerBattleRequest* unsafe_arena_release_req();

  // optional .sg.MultiplayerBattleService.MultiplayerBattleResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  private:
  const ::sg::MultiplayerBattleService_MultiplayerBattleResponse& _internal_resp() const;
  public:
  const ::sg::MultiplayerBattleService_MultiplayerBattleResponse& resp() const;
  ::sg::MultiplayerBattleService_MultiplayerBattleResponse* release_resp();
  ::sg::MultiplayerBattleService_MultiplayerBattleResponse* mutable_resp();
  void set_allocated_resp(::sg::MultiplayerBattleService_MultiplayerBattleResponse* resp);
  void unsafe_arena_set_allocated_resp(
      ::sg::MultiplayerBattleService_MultiplayerBattleResponse* resp);
  ::sg::MultiplayerBattleService_MultiplayerBattleResponse* unsafe_arena_release_resp();

  // @@protoc_insertion_point(class_scope:sg.MultiplayerBattleService)
 private:
  void set_has_req();
  void clear_has_req();
  void set_has_resp();
  void clear_has_resp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::sg::MultiplayerBattleService_MultiplayerBattleRequest* req_;
  ::sg::MultiplayerBattleService_MultiplayerBattleResponse* resp_;
  friend struct ::protobuf_Multiplayer_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FrameAddNotify : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.FrameAddNotify) */ {
 public:
  FrameAddNotify();
  virtual ~FrameAddNotify();

  FrameAddNotify(const FrameAddNotify& from);

  inline FrameAddNotify& operator=(const FrameAddNotify& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FrameAddNotify(FrameAddNotify&& from) noexcept
    : FrameAddNotify() {
    *this = ::std::move(from);
  }

  inline FrameAddNotify& operator=(FrameAddNotify&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const FrameAddNotify& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FrameAddNotify* internal_default_instance() {
    return reinterpret_cast<const FrameAddNotify*>(
               &_FrameAddNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void UnsafeArenaSwap(FrameAddNotify* other);
  void Swap(FrameAddNotify* other);
  friend void swap(FrameAddNotify& a, FrameAddNotify& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FrameAddNotify* New() const final {
    return CreateMaybeMessage<FrameAddNotify>(NULL);
  }

  FrameAddNotify* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FrameAddNotify>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FrameAddNotify& from);
  void MergeFrom(const FrameAddNotify& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FrameAddNotify* other);
  protected:
  explicit FrameAddNotify(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sg.FrameData data = 2;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  ::sg::FrameData* mutable_data(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::FrameData >*
      mutable_data();
  const ::sg::FrameData& data(int index) const;
  ::sg::FrameData* add_data();
  const ::google::protobuf::RepeatedPtrField< ::sg::FrameData >&
      data() const;

  // required int32 frame = 1;
  bool has_frame() const;
  void clear_frame();
  static const int kFrameFieldNumber = 1;
  ::google::protobuf::int32 frame() const;
  void set_frame(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.FrameAddNotify)
 private:
  void set_has_frame();
  void clear_has_frame();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::FrameData > data_;
  ::google::protobuf::int32 frame_;
  friend struct ::protobuf_Multiplayer_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserReadyNotify : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.UserReadyNotify) */ {
 public:
  UserReadyNotify();
  virtual ~UserReadyNotify();

  UserReadyNotify(const UserReadyNotify& from);

  inline UserReadyNotify& operator=(const UserReadyNotify& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserReadyNotify(UserReadyNotify&& from) noexcept
    : UserReadyNotify() {
    *this = ::std::move(from);
  }

  inline UserReadyNotify& operator=(UserReadyNotify&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserReadyNotify& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserReadyNotify* internal_default_instance() {
    return reinterpret_cast<const UserReadyNotify*>(
               &_UserReadyNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void UnsafeArenaSwap(UserReadyNotify* other);
  void Swap(UserReadyNotify* other);
  friend void swap(UserReadyNotify& a, UserReadyNotify& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserReadyNotify* New() const final {
    return CreateMaybeMessage<UserReadyNotify>(NULL);
  }

  UserReadyNotify* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserReadyNotify>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserReadyNotify& from);
  void MergeFrom(const UserReadyNotify& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserReadyNotify* other);
  protected:
  explicit UserReadyNotify(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 member_index = 1;
  bool has_member_index() const;
  void clear_member_index();
  static const int kMemberIndexFieldNumber = 1;
  ::google::protobuf::int32 member_index() const;
  void set_member_index(::google::protobuf::int32 value);

  // required bool ready = 2;
  bool has_ready() const;
  void clear_ready();
  static const int kReadyFieldNumber = 2;
  bool ready() const;
  void set_ready(bool value);

  // @@protoc_insertion_point(class_scope:sg.UserReadyNotify)
 private:
  void set_has_member_index();
  void clear_has_member_index();
  void set_has_ready();
  void clear_has_ready();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 member_index_;
  bool ready_;
  friend struct ::protobuf_Multiplayer_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserChangeSailorNotify : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.UserChangeSailorNotify) */ {
 public:
  UserChangeSailorNotify();
  virtual ~UserChangeSailorNotify();

  UserChangeSailorNotify(const UserChangeSailorNotify& from);

  inline UserChangeSailorNotify& operator=(const UserChangeSailorNotify& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserChangeSailorNotify(UserChangeSailorNotify&& from) noexcept
    : UserChangeSailorNotify() {
    *this = ::std::move(from);
  }

  inline UserChangeSailorNotify& operator=(UserChangeSailorNotify&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserChangeSailorNotify& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserChangeSailorNotify* internal_default_instance() {
    return reinterpret_cast<const UserChangeSailorNotify*>(
               &_UserChangeSailorNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void UnsafeArenaSwap(UserChangeSailorNotify* other);
  void Swap(UserChangeSailorNotify* other);
  friend void swap(UserChangeSailorNotify& a, UserChangeSailorNotify& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserChangeSailorNotify* New() const final {
    return CreateMaybeMessage<UserChangeSailorNotify>(NULL);
  }

  UserChangeSailorNotify* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserChangeSailorNotify>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserChangeSailorNotify& from);
  void MergeFrom(const UserChangeSailorNotify& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserChangeSailorNotify* other);
  protected:
  explicit UserChangeSailorNotify(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sg.Sailor use_sailor = 2;
  int use_sailor_size() const;
  void clear_use_sailor();
  static const int kUseSailorFieldNumber = 2;
  ::sg::Sailor* mutable_use_sailor(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::Sailor >*
      mutable_use_sailor();
  const ::sg::Sailor& use_sailor(int index) const;
  ::sg::Sailor* add_use_sailor();
  const ::google::protobuf::RepeatedPtrField< ::sg::Sailor >&
      use_sailor() const;

  // required int32 member_index = 1;
  bool has_member_index() const;
  void clear_member_index();
  static const int kMemberIndexFieldNumber = 1;
  ::google::protobuf::int32 member_index() const;
  void set_member_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.UserChangeSailorNotify)
 private:
  void set_has_member_index();
  void clear_has_member_index();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::Sailor > use_sailor_;
  ::google::protobuf::int32 member_index_;
  friend struct ::protobuf_Multiplayer_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BattleStartNotify : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.BattleStartNotify) */ {
 public:
  BattleStartNotify();
  virtual ~BattleStartNotify();

  BattleStartNotify(const BattleStartNotify& from);

  inline BattleStartNotify& operator=(const BattleStartNotify& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BattleStartNotify(BattleStartNotify&& from) noexcept
    : BattleStartNotify() {
    *this = ::std::move(from);
  }

  inline BattleStartNotify& operator=(BattleStartNotify&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const BattleStartNotify& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BattleStartNotify* internal_default_instance() {
    return reinterpret_cast<const BattleStartNotify*>(
               &_BattleStartNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void UnsafeArenaSwap(BattleStartNotify* other);
  void Swap(BattleStartNotify* other);
  friend void swap(BattleStartNotify& a, BattleStartNotify& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BattleStartNotify* New() const final {
    return CreateMaybeMessage<BattleStartNotify>(NULL);
  }

  BattleStartNotify* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BattleStartNotify>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BattleStartNotify& from);
  void MergeFrom(const BattleStartNotify& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BattleStartNotify* other);
  protected:
  explicit BattleStartNotify(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .sg.MultiplayerBattleField battle_data = 1;
  bool has_battle_data() const;
  void clear_battle_data();
  static const int kBattleDataFieldNumber = 1;
  private:
  const ::sg::MultiplayerBattleField& _internal_battle_data() const;
  public:
  const ::sg::MultiplayerBattleField& battle_data() const;
  ::sg::MultiplayerBattleField* release_battle_data();
  ::sg::MultiplayerBattleField* mutable_battle_data();
  void set_allocated_battle_data(::sg::MultiplayerBattleField* battle_data);
  void unsafe_arena_set_allocated_battle_data(
      ::sg::MultiplayerBattleField* battle_data);
  ::sg::MultiplayerBattleField* unsafe_arena_release_battle_data();

  // optional .sg.DungeonContent content = 2;
  bool has_content() const;
  void clear_content();
  static const int kContentFieldNumber = 2;
  private:
  const ::sg::DungeonContent& _internal_content() const;
  public:
  const ::sg::DungeonContent& content() const;
  ::sg::DungeonContent* release_content();
  ::sg::DungeonContent* mutable_content();
  void set_allocated_content(::sg::DungeonContent* content);
  void unsafe_arena_set_allocated_content(
      ::sg::DungeonContent* content);
  ::sg::DungeonContent* unsafe_arena_release_content();

  // optional .sg.UserDungeonInformation user_info = 3;
  bool has_user_info() const;
  void clear_user_info();
  static const int kUserInfoFieldNumber = 3;
  private:
  const ::sg::UserDungeonInformation& _internal_user_info() const;
  public:
  const ::sg::UserDungeonInformation& user_info() const;
  ::sg::UserDungeonInformation* release_user_info();
  ::sg::UserDungeonInformation* mutable_user_info();
  void set_allocated_user_info(::sg::UserDungeonInformation* user_info);
  void unsafe_arena_set_allocated_user_info(
      ::sg::UserDungeonInformation* user_info);
  ::sg::UserDungeonInformation* unsafe_arena_release_user_info();

  // optional int32 cost_vitality = 4;
  bool has_cost_vitality() const;
  void clear_cost_vitality();
  static const int kCostVitalityFieldNumber = 4;
  ::google::protobuf::int32 cost_vitality() const;
  void set_cost_vitality(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.BattleStartNotify)
 private:
  void set_has_battle_data();
  void clear_has_battle_data();
  void set_has_content();
  void clear_has_content();
  void set_has_user_info();
  void clear_has_user_info();
  void set_has_cost_vitality();
  void clear_has_cost_vitality();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::sg::MultiplayerBattleField* battle_data_;
  ::sg::DungeonContent* content_;
  ::sg::UserDungeonInformation* user_info_;
  ::google::protobuf::int32 cost_vitality_;
  friend struct ::protobuf_Multiplayer_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BattleOverNotify : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.BattleOverNotify) */ {
 public:
  BattleOverNotify();
  virtual ~BattleOverNotify();

  BattleOverNotify(const BattleOverNotify& from);

  inline BattleOverNotify& operator=(const BattleOverNotify& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BattleOverNotify(BattleOverNotify&& from) noexcept
    : BattleOverNotify() {
    *this = ::std::move(from);
  }

  inline BattleOverNotify& operator=(BattleOverNotify&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const BattleOverNotify& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BattleOverNotify* internal_default_instance() {
    return reinterpret_cast<const BattleOverNotify*>(
               &_BattleOverNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void UnsafeArenaSwap(BattleOverNotify* other);
  void Swap(BattleOverNotify* other);
  friend void swap(BattleOverNotify& a, BattleOverNotify& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BattleOverNotify* New() const final {
    return CreateMaybeMessage<BattleOverNotify>(NULL);
  }

  BattleOverNotify* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BattleOverNotify>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BattleOverNotify& from);
  void MergeFrom(const BattleOverNotify& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BattleOverNotify* other);
  protected:
  explicit BattleOverNotify(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .sg.Reward reward = 2;
  bool has_reward() const;
  void clear_reward();
  static const int kRewardFieldNumber = 2;
  private:
  const ::sg::Reward& _internal_reward() const;
  public:
  const ::sg::Reward& reward() const;
  ::sg::Reward* release_reward();
  ::sg::Reward* mutable_reward();
  void set_allocated_reward(::sg::Reward* reward);
  void unsafe_arena_set_allocated_reward(
      ::sg::Reward* reward);
  ::sg::Reward* unsafe_arena_release_reward();

  // required int32 result = 1;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::google::protobuf::int32 result() const;
  void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.BattleOverNotify)
 private:
  void set_has_result();
  void clear_has_result();
  void set_has_reward();
  void clear_has_reward();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::sg::Reward* reward_;
  ::google::protobuf::int32 result_;
  friend struct ::protobuf_Multiplayer_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// FrameData

// optional int32 frame = 1;
inline bool FrameData::has_frame() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FrameData::set_has_frame() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FrameData::clear_has_frame() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FrameData::clear_frame() {
  frame_ = 0;
  clear_has_frame();
}
inline ::google::protobuf::int32 FrameData::frame() const {
  // @@protoc_insertion_point(field_get:sg.FrameData.frame)
  return frame_;
}
inline void FrameData::set_frame(::google::protobuf::int32 value) {
  set_has_frame();
  frame_ = value;
  // @@protoc_insertion_point(field_set:sg.FrameData.frame)
}

// optional int32 source = 2;
inline bool FrameData::has_source() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FrameData::set_has_source() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FrameData::clear_has_source() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FrameData::clear_source() {
  source_ = 0;
  clear_has_source();
}
inline ::google::protobuf::int32 FrameData::source() const {
  // @@protoc_insertion_point(field_get:sg.FrameData.source)
  return source_;
}
inline void FrameData::set_source(::google::protobuf::int32 value) {
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:sg.FrameData.source)
}

// optional bytes data = 3;
inline bool FrameData::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FrameData::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FrameData::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FrameData::clear_data() {
  data_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_data();
}
inline const ::std::string& FrameData::data() const {
  // @@protoc_insertion_point(field_get:sg.FrameData.data)
  return data_.Get();
}
inline void FrameData::set_data(const ::std::string& value) {
  set_has_data();
  data_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:sg.FrameData.data)
}
#if LANG_CXX11
inline void FrameData::set_data(::std::string&& value) {
  set_has_data();
  data_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:sg.FrameData.data)
}
#endif
inline void FrameData::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_data();
  data_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:sg.FrameData.data)
}
inline void FrameData::set_data(const void* value,
    size_t size) {
  set_has_data();
  data_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:sg.FrameData.data)
}
inline ::std::string* FrameData::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:sg.FrameData.data)
  return data_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* FrameData::release_data() {
  // @@protoc_insertion_point(field_release:sg.FrameData.data)
  if (!has_data()) {
    return NULL;
  }
  clear_has_data();
  return data_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void FrameData::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:sg.FrameData.data)
}
inline ::std::string* FrameData::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.FrameData.data)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_data();
  return data_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void FrameData::unsafe_arena_set_allocated_data(
    ::std::string* data) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      data, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sg.FrameData.data)
}

// -------------------------------------------------------------------

// MultiplayerRoom_Member

// required int32 index = 1;
inline bool MultiplayerRoom_Member::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MultiplayerRoom_Member::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MultiplayerRoom_Member::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MultiplayerRoom_Member::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 MultiplayerRoom_Member::index() const {
  // @@protoc_insertion_point(field_get:sg.MultiplayerRoom.Member.index)
  return index_;
}
inline void MultiplayerRoom_Member::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:sg.MultiplayerRoom.Member.index)
}

// required int32 status = 3;
inline bool MultiplayerRoom_Member::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MultiplayerRoom_Member::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MultiplayerRoom_Member::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MultiplayerRoom_Member::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 MultiplayerRoom_Member::status() const {
  // @@protoc_insertion_point(field_get:sg.MultiplayerRoom.Member.status)
  return status_;
}
inline void MultiplayerRoom_Member::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:sg.MultiplayerRoom.Member.status)
}

// optional .sg.UserInfo user = 4;
inline bool MultiplayerRoom_Member::has_user() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MultiplayerRoom_Member::set_has_user() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MultiplayerRoom_Member::clear_has_user() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::sg::UserInfo& MultiplayerRoom_Member::_internal_user() const {
  return *user_;
}
inline const ::sg::UserInfo& MultiplayerRoom_Member::user() const {
  const ::sg::UserInfo* p = user_;
  // @@protoc_insertion_point(field_get:sg.MultiplayerRoom.Member.user)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::UserInfo*>(
      &::sg::_UserInfo_default_instance_);
}
inline ::sg::UserInfo* MultiplayerRoom_Member::release_user() {
  // @@protoc_insertion_point(field_release:sg.MultiplayerRoom.Member.user)
  clear_has_user();
  ::sg::UserInfo* temp = user_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  user_ = NULL;
  return temp;
}
inline ::sg::UserInfo* MultiplayerRoom_Member::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.MultiplayerRoom.Member.user)
  clear_has_user();
  ::sg::UserInfo* temp = user_;
  user_ = NULL;
  return temp;
}
inline ::sg::UserInfo* MultiplayerRoom_Member::mutable_user() {
  set_has_user();
  if (user_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::UserInfo>(GetArenaNoVirtual());
    user_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.MultiplayerRoom.Member.user)
  return user_;
}
inline void MultiplayerRoom_Member::set_allocated_user(::sg::UserInfo* user) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(user_);
  }
  if (user) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(user)->GetArena();
    if (message_arena != submessage_arena) {
      user = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    set_has_user();
  } else {
    clear_has_user();
  }
  user_ = user;
  // @@protoc_insertion_point(field_set_allocated:sg.MultiplayerRoom.Member.user)
}

// optional int32 state = 5;
inline bool MultiplayerRoom_Member::has_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MultiplayerRoom_Member::set_has_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MultiplayerRoom_Member::clear_has_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MultiplayerRoom_Member::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 MultiplayerRoom_Member::state() const {
  // @@protoc_insertion_point(field_get:sg.MultiplayerRoom.Member.state)
  return state_;
}
inline void MultiplayerRoom_Member::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:sg.MultiplayerRoom.Member.state)
}

// repeated .sg.Sailor sailors = 6;
inline int MultiplayerRoom_Member::sailors_size() const {
  return sailors_.size();
}
inline ::sg::Sailor* MultiplayerRoom_Member::mutable_sailors(int index) {
  // @@protoc_insertion_point(field_mutable:sg.MultiplayerRoom.Member.sailors)
  return sailors_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::Sailor >*
MultiplayerRoom_Member::mutable_sailors() {
  // @@protoc_insertion_point(field_mutable_list:sg.MultiplayerRoom.Member.sailors)
  return &sailors_;
}
inline const ::sg::Sailor& MultiplayerRoom_Member::sailors(int index) const {
  // @@protoc_insertion_point(field_get:sg.MultiplayerRoom.Member.sailors)
  return sailors_.Get(index);
}
inline ::sg::Sailor* MultiplayerRoom_Member::add_sailors() {
  // @@protoc_insertion_point(field_add:sg.MultiplayerRoom.Member.sailors)
  return sailors_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::Sailor >&
MultiplayerRoom_Member::sailors() const {
  // @@protoc_insertion_point(field_list:sg.MultiplayerRoom.Member.sailors)
  return sailors_;
}

// -------------------------------------------------------------------

// MultiplayerRoom_Chat

// required int32 index = 1;
inline bool MultiplayerRoom_Chat::has_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MultiplayerRoom_Chat::set_has_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MultiplayerRoom_Chat::clear_has_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MultiplayerRoom_Chat::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 MultiplayerRoom_Chat::index() const {
  // @@protoc_insertion_point(field_get:sg.MultiplayerRoom.Chat.index)
  return index_;
}
inline void MultiplayerRoom_Chat::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:sg.MultiplayerRoom.Chat.index)
}

// required sfixed64 timestamp = 2;
inline bool MultiplayerRoom_Chat::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MultiplayerRoom_Chat::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MultiplayerRoom_Chat::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MultiplayerRoom_Chat::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 MultiplayerRoom_Chat::timestamp() const {
  // @@protoc_insertion_point(field_get:sg.MultiplayerRoom.Chat.timestamp)
  return timestamp_;
}
inline void MultiplayerRoom_Chat::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:sg.MultiplayerRoom.Chat.timestamp)
}

// required bytes data = 3;
inline bool MultiplayerRoom_Chat::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MultiplayerRoom_Chat::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MultiplayerRoom_Chat::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MultiplayerRoom_Chat::clear_data() {
  data_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_data();
}
inline const ::std::string& MultiplayerRoom_Chat::data() const {
  // @@protoc_insertion_point(field_get:sg.MultiplayerRoom.Chat.data)
  return data_.Get();
}
inline void MultiplayerRoom_Chat::set_data(const ::std::string& value) {
  set_has_data();
  data_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:sg.MultiplayerRoom.Chat.data)
}
#if LANG_CXX11
inline void MultiplayerRoom_Chat::set_data(::std::string&& value) {
  set_has_data();
  data_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:sg.MultiplayerRoom.Chat.data)
}
#endif
inline void MultiplayerRoom_Chat::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_data();
  data_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:sg.MultiplayerRoom.Chat.data)
}
inline void MultiplayerRoom_Chat::set_data(const void* value,
    size_t size) {
  set_has_data();
  data_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:sg.MultiplayerRoom.Chat.data)
}
inline ::std::string* MultiplayerRoom_Chat::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:sg.MultiplayerRoom.Chat.data)
  return data_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* MultiplayerRoom_Chat::release_data() {
  // @@protoc_insertion_point(field_release:sg.MultiplayerRoom.Chat.data)
  if (!has_data()) {
    return NULL;
  }
  clear_has_data();
  return data_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void MultiplayerRoom_Chat::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:sg.MultiplayerRoom.Chat.data)
}
inline ::std::string* MultiplayerRoom_Chat::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.MultiplayerRoom.Chat.data)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_data();
  return data_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void MultiplayerRoom_Chat::unsafe_arena_set_allocated_data(
    ::std::string* data) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      data, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sg.MultiplayerRoom.Chat.data)
}

// -------------------------------------------------------------------

// MultiplayerRoom

// required int32 id = 1;
inline bool MultiplayerRoom::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MultiplayerRoom::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MultiplayerRoom::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MultiplayerRoom::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 MultiplayerRoom::id() const {
  // @@protoc_insertion_point(field_get:sg.MultiplayerRoom.id)
  return id_;
}
inline void MultiplayerRoom::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:sg.MultiplayerRoom.id)
}

// required int32 state = 2;
inline bool MultiplayerRoom::has_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MultiplayerRoom::set_has_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MultiplayerRoom::clear_has_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MultiplayerRoom::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 MultiplayerRoom::state() const {
  // @@protoc_insertion_point(field_get:sg.MultiplayerRoom.state)
  return state_;
}
inline void MultiplayerRoom::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:sg.MultiplayerRoom.state)
}

// required bytes name = 3;
inline bool MultiplayerRoom::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MultiplayerRoom::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MultiplayerRoom::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MultiplayerRoom::clear_name() {
  name_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_name();
}
inline const ::std::string& MultiplayerRoom::name() const {
  // @@protoc_insertion_point(field_get:sg.MultiplayerRoom.name)
  return name_.Get();
}
inline void MultiplayerRoom::set_name(const ::std::string& value) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:sg.MultiplayerRoom.name)
}
#if LANG_CXX11
inline void MultiplayerRoom::set_name(::std::string&& value) {
  set_has_name();
  name_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:sg.MultiplayerRoom.name)
}
#endif
inline void MultiplayerRoom::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:sg.MultiplayerRoom.name)
}
inline void MultiplayerRoom::set_name(const void* value,
    size_t size) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:sg.MultiplayerRoom.name)
}
inline ::std::string* MultiplayerRoom::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:sg.MultiplayerRoom.name)
  return name_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* MultiplayerRoom::release_name() {
  // @@protoc_insertion_point(field_release:sg.MultiplayerRoom.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void MultiplayerRoom::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:sg.MultiplayerRoom.name)
}
inline ::std::string* MultiplayerRoom::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.MultiplayerRoom.name)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_name();
  return name_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void MultiplayerRoom::unsafe_arena_set_allocated_name(
    ::std::string* name) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      name, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sg.MultiplayerRoom.name)
}

// repeated .sg.MultiplayerRoom.Member members = 4;
inline int MultiplayerRoom::members_size() const {
  return members_.size();
}
inline void MultiplayerRoom::clear_members() {
  members_.Clear();
}
inline ::sg::MultiplayerRoom_Member* MultiplayerRoom::mutable_members(int index) {
  // @@protoc_insertion_point(field_mutable:sg.MultiplayerRoom.members)
  return members_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::MultiplayerRoom_Member >*
MultiplayerRoom::mutable_members() {
  // @@protoc_insertion_point(field_mutable_list:sg.MultiplayerRoom.members)
  return &members_;
}
inline const ::sg::MultiplayerRoom_Member& MultiplayerRoom::members(int index) const {
  // @@protoc_insertion_point(field_get:sg.MultiplayerRoom.members)
  return members_.Get(index);
}
inline ::sg::MultiplayerRoom_Member* MultiplayerRoom::add_members() {
  // @@protoc_insertion_point(field_add:sg.MultiplayerRoom.members)
  return members_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::MultiplayerRoom_Member >&
MultiplayerRoom::members() const {
  // @@protoc_insertion_point(field_list:sg.MultiplayerRoom.members)
  return members_;
}

// optional int32 target = 5;
inline bool MultiplayerRoom::has_target() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MultiplayerRoom::set_has_target() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MultiplayerRoom::clear_has_target() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MultiplayerRoom::clear_target() {
  target_ = 0;
  clear_has_target();
}
inline ::google::protobuf::int32 MultiplayerRoom::target() const {
  // @@protoc_insertion_point(field_get:sg.MultiplayerRoom.target)
  return target_;
}
inline void MultiplayerRoom::set_target(::google::protobuf::int32 value) {
  set_has_target();
  target_ = value;
  // @@protoc_insertion_point(field_set:sg.MultiplayerRoom.target)
}

// optional int32 type = 6;
inline bool MultiplayerRoom::has_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MultiplayerRoom::set_has_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MultiplayerRoom::clear_has_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MultiplayerRoom::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 MultiplayerRoom::type() const {
  // @@protoc_insertion_point(field_get:sg.MultiplayerRoom.type)
  return type_;
}
inline void MultiplayerRoom::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:sg.MultiplayerRoom.type)
}

// required bytes work = 7;
inline bool MultiplayerRoom::has_work() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MultiplayerRoom::set_has_work() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MultiplayerRoom::clear_has_work() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MultiplayerRoom::clear_work() {
  work_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_work();
}
inline const ::std::string& MultiplayerRoom::work() const {
  // @@protoc_insertion_point(field_get:sg.MultiplayerRoom.work)
  return work_.Get();
}
inline void MultiplayerRoom::set_work(const ::std::string& value) {
  set_has_work();
  work_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:sg.MultiplayerRoom.work)
}
#if LANG_CXX11
inline void MultiplayerRoom::set_work(::std::string&& value) {
  set_has_work();
  work_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:sg.MultiplayerRoom.work)
}
#endif
inline void MultiplayerRoom::set_work(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_work();
  work_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:sg.MultiplayerRoom.work)
}
inline void MultiplayerRoom::set_work(const void* value,
    size_t size) {
  set_has_work();
  work_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:sg.MultiplayerRoom.work)
}
inline ::std::string* MultiplayerRoom::mutable_work() {
  set_has_work();
  // @@protoc_insertion_point(field_mutable:sg.MultiplayerRoom.work)
  return work_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* MultiplayerRoom::release_work() {
  // @@protoc_insertion_point(field_release:sg.MultiplayerRoom.work)
  if (!has_work()) {
    return NULL;
  }
  clear_has_work();
  return work_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void MultiplayerRoom::set_allocated_work(::std::string* work) {
  if (work != NULL) {
    set_has_work();
  } else {
    clear_has_work();
  }
  work_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), work,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:sg.MultiplayerRoom.work)
}
inline ::std::string* MultiplayerRoom::unsafe_arena_release_work() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.MultiplayerRoom.work)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_work();
  return work_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void MultiplayerRoom::unsafe_arena_set_allocated_work(
    ::std::string* work) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (work != NULL) {
    set_has_work();
  } else {
    clear_has_work();
  }
  work_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      work, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sg.MultiplayerRoom.work)
}

// repeated .sg.MultiplayerRoom.Chat chat_list = 8;
inline int MultiplayerRoom::chat_list_size() const {
  return chat_list_.size();
}
inline void MultiplayerRoom::clear_chat_list() {
  chat_list_.Clear();
}
inline ::sg::MultiplayerRoom_Chat* MultiplayerRoom::mutable_chat_list(int index) {
  // @@protoc_insertion_point(field_mutable:sg.MultiplayerRoom.chat_list)
  return chat_list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::MultiplayerRoom_Chat >*
MultiplayerRoom::mutable_chat_list() {
  // @@protoc_insertion_point(field_mutable_list:sg.MultiplayerRoom.chat_list)
  return &chat_list_;
}
inline const ::sg::MultiplayerRoom_Chat& MultiplayerRoom::chat_list(int index) const {
  // @@protoc_insertion_point(field_get:sg.MultiplayerRoom.chat_list)
  return chat_list_.Get(index);
}
inline ::sg::MultiplayerRoom_Chat* MultiplayerRoom::add_chat_list() {
  // @@protoc_insertion_point(field_add:sg.MultiplayerRoom.chat_list)
  return chat_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::MultiplayerRoom_Chat >&
MultiplayerRoom::chat_list() const {
  // @@protoc_insertion_point(field_list:sg.MultiplayerRoom.chat_list)
  return chat_list_;
}

// -------------------------------------------------------------------

// MultiplayerBattleField_Member

// required int32 index = 1;
inline bool MultiplayerBattleField_Member::has_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MultiplayerBattleField_Member::set_has_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MultiplayerBattleField_Member::clear_has_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MultiplayerBattleField_Member::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 MultiplayerBattleField_Member::index() const {
  // @@protoc_insertion_point(field_get:sg.MultiplayerBattleField.Member.index)
  return index_;
}
inline void MultiplayerBattleField_Member::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:sg.MultiplayerBattleField.Member.index)
}

// required int32 status = 3;
inline bool MultiplayerBattleField_Member::has_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MultiplayerBattleField_Member::set_has_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MultiplayerBattleField_Member::clear_has_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MultiplayerBattleField_Member::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 MultiplayerBattleField_Member::status() const {
  // @@protoc_insertion_point(field_get:sg.MultiplayerBattleField.Member.status)
  return status_;
}
inline void MultiplayerBattleField_Member::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:sg.MultiplayerBattleField.Member.status)
}

// required int32 state = 4;
inline bool MultiplayerBattleField_Member::has_state() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MultiplayerBattleField_Member::set_has_state() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MultiplayerBattleField_Member::clear_has_state() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MultiplayerBattleField_Member::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 MultiplayerBattleField_Member::state() const {
  // @@protoc_insertion_point(field_get:sg.MultiplayerBattleField.Member.state)
  return state_;
}
inline void MultiplayerBattleField_Member::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:sg.MultiplayerBattleField.Member.state)
}

// optional .sg.UserInfo user = 5;
inline bool MultiplayerBattleField_Member::has_user() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MultiplayerBattleField_Member::set_has_user() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MultiplayerBattleField_Member::clear_has_user() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::sg::UserInfo& MultiplayerBattleField_Member::_internal_user() const {
  return *user_;
}
inline const ::sg::UserInfo& MultiplayerBattleField_Member::user() const {
  const ::sg::UserInfo* p = user_;
  // @@protoc_insertion_point(field_get:sg.MultiplayerBattleField.Member.user)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::UserInfo*>(
      &::sg::_UserInfo_default_instance_);
}
inline ::sg::UserInfo* MultiplayerBattleField_Member::release_user() {
  // @@protoc_insertion_point(field_release:sg.MultiplayerBattleField.Member.user)
  clear_has_user();
  ::sg::UserInfo* temp = user_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  user_ = NULL;
  return temp;
}
inline ::sg::UserInfo* MultiplayerBattleField_Member::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.MultiplayerBattleField.Member.user)
  clear_has_user();
  ::sg::UserInfo* temp = user_;
  user_ = NULL;
  return temp;
}
inline ::sg::UserInfo* MultiplayerBattleField_Member::mutable_user() {
  set_has_user();
  if (user_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::UserInfo>(GetArenaNoVirtual());
    user_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.MultiplayerBattleField.Member.user)
  return user_;
}
inline void MultiplayerBattleField_Member::set_allocated_user(::sg::UserInfo* user) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(user_);
  }
  if (user) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(user)->GetArena();
    if (message_arena != submessage_arena) {
      user = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    set_has_user();
  } else {
    clear_has_user();
  }
  user_ = user;
  // @@protoc_insertion_point(field_set_allocated:sg.MultiplayerBattleField.Member.user)
}

// optional .sg.UserTeamData data = 6;
inline bool MultiplayerBattleField_Member::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MultiplayerBattleField_Member::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MultiplayerBattleField_Member::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::sg::UserTeamData& MultiplayerBattleField_Member::_internal_data() const {
  return *data_;
}
inline const ::sg::UserTeamData& MultiplayerBattleField_Member::data() const {
  const ::sg::UserTeamData* p = data_;
  // @@protoc_insertion_point(field_get:sg.MultiplayerBattleField.Member.data)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::UserTeamData*>(
      &::sg::_UserTeamData_default_instance_);
}
inline ::sg::UserTeamData* MultiplayerBattleField_Member::release_data() {
  // @@protoc_insertion_point(field_release:sg.MultiplayerBattleField.Member.data)
  clear_has_data();
  ::sg::UserTeamData* temp = data_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  data_ = NULL;
  return temp;
}
inline ::sg::UserTeamData* MultiplayerBattleField_Member::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.MultiplayerBattleField.Member.data)
  clear_has_data();
  ::sg::UserTeamData* temp = data_;
  data_ = NULL;
  return temp;
}
inline ::sg::UserTeamData* MultiplayerBattleField_Member::mutable_data() {
  set_has_data();
  if (data_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::UserTeamData>(GetArenaNoVirtual());
    data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.MultiplayerBattleField.Member.data)
  return data_;
}
inline void MultiplayerBattleField_Member::set_allocated_data(::sg::UserTeamData* data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(data_);
  }
  if (data) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(data)->GetArena();
    if (message_arena != submessage_arena) {
      data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    set_has_data();
  } else {
    clear_has_data();
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:sg.MultiplayerBattleField.Member.data)
}

// -------------------------------------------------------------------

// MultiplayerBattleField

// required int32 id = 1;
inline bool MultiplayerBattleField::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MultiplayerBattleField::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MultiplayerBattleField::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MultiplayerBattleField::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 MultiplayerBattleField::id() const {
  // @@protoc_insertion_point(field_get:sg.MultiplayerBattleField.id)
  return id_;
}
inline void MultiplayerBattleField::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:sg.MultiplayerBattleField.id)
}

// required int32 state = 2;
inline bool MultiplayerBattleField::has_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MultiplayerBattleField::set_has_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MultiplayerBattleField::clear_has_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MultiplayerBattleField::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 MultiplayerBattleField::state() const {
  // @@protoc_insertion_point(field_get:sg.MultiplayerBattleField.state)
  return state_;
}
inline void MultiplayerBattleField::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:sg.MultiplayerBattleField.state)
}

// required bytes name = 3;
inline bool MultiplayerBattleField::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MultiplayerBattleField::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MultiplayerBattleField::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MultiplayerBattleField::clear_name() {
  name_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_name();
}
inline const ::std::string& MultiplayerBattleField::name() const {
  // @@protoc_insertion_point(field_get:sg.MultiplayerBattleField.name)
  return name_.Get();
}
inline void MultiplayerBattleField::set_name(const ::std::string& value) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:sg.MultiplayerBattleField.name)
}
#if LANG_CXX11
inline void MultiplayerBattleField::set_name(::std::string&& value) {
  set_has_name();
  name_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:sg.MultiplayerBattleField.name)
}
#endif
inline void MultiplayerBattleField::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:sg.MultiplayerBattleField.name)
}
inline void MultiplayerBattleField::set_name(const void* value,
    size_t size) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:sg.MultiplayerBattleField.name)
}
inline ::std::string* MultiplayerBattleField::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:sg.MultiplayerBattleField.name)
  return name_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* MultiplayerBattleField::release_name() {
  // @@protoc_insertion_point(field_release:sg.MultiplayerBattleField.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void MultiplayerBattleField::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:sg.MultiplayerBattleField.name)
}
inline ::std::string* MultiplayerBattleField::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.MultiplayerBattleField.name)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_name();
  return name_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void MultiplayerBattleField::unsafe_arena_set_allocated_name(
    ::std::string* name) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      name, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sg.MultiplayerBattleField.name)
}

// required int32 frame = 4;
inline bool MultiplayerBattleField::has_frame() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MultiplayerBattleField::set_has_frame() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MultiplayerBattleField::clear_has_frame() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MultiplayerBattleField::clear_frame() {
  frame_ = 0;
  clear_has_frame();
}
inline ::google::protobuf::int32 MultiplayerBattleField::frame() const {
  // @@protoc_insertion_point(field_get:sg.MultiplayerBattleField.frame)
  return frame_;
}
inline void MultiplayerBattleField::set_frame(::google::protobuf::int32 value) {
  set_has_frame();
  frame_ = value;
  // @@protoc_insertion_point(field_set:sg.MultiplayerBattleField.frame)
}

// required int32 rand_seed = 5;
inline bool MultiplayerBattleField::has_rand_seed() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MultiplayerBattleField::set_has_rand_seed() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MultiplayerBattleField::clear_has_rand_seed() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MultiplayerBattleField::clear_rand_seed() {
  rand_seed_ = 0;
  clear_has_rand_seed();
}
inline ::google::protobuf::int32 MultiplayerBattleField::rand_seed() const {
  // @@protoc_insertion_point(field_get:sg.MultiplayerBattleField.rand_seed)
  return rand_seed_;
}
inline void MultiplayerBattleField::set_rand_seed(::google::protobuf::int32 value) {
  set_has_rand_seed();
  rand_seed_ = value;
  // @@protoc_insertion_point(field_set:sg.MultiplayerBattleField.rand_seed)
}

// repeated .sg.MultiplayerBattleField.Member members = 6;
inline int MultiplayerBattleField::members_size() const {
  return members_.size();
}
inline void MultiplayerBattleField::clear_members() {
  members_.Clear();
}
inline ::sg::MultiplayerBattleField_Member* MultiplayerBattleField::mutable_members(int index) {
  // @@protoc_insertion_point(field_mutable:sg.MultiplayerBattleField.members)
  return members_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::MultiplayerBattleField_Member >*
MultiplayerBattleField::mutable_members() {
  // @@protoc_insertion_point(field_mutable_list:sg.MultiplayerBattleField.members)
  return &members_;
}
inline const ::sg::MultiplayerBattleField_Member& MultiplayerBattleField::members(int index) const {
  // @@protoc_insertion_point(field_get:sg.MultiplayerBattleField.members)
  return members_.Get(index);
}
inline ::sg::MultiplayerBattleField_Member* MultiplayerBattleField::add_members() {
  // @@protoc_insertion_point(field_add:sg.MultiplayerBattleField.members)
  return members_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::MultiplayerBattleField_Member >&
MultiplayerBattleField::members() const {
  // @@protoc_insertion_point(field_list:sg.MultiplayerBattleField.members)
  return members_;
}

// repeated .sg.FrameData data = 7;
inline int MultiplayerBattleField::data_size() const {
  return data_.size();
}
inline void MultiplayerBattleField::clear_data() {
  data_.Clear();
}
inline ::sg::FrameData* MultiplayerBattleField::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:sg.MultiplayerBattleField.data)
  return data_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::FrameData >*
MultiplayerBattleField::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:sg.MultiplayerBattleField.data)
  return &data_;
}
inline const ::sg::FrameData& MultiplayerBattleField::data(int index) const {
  // @@protoc_insertion_point(field_get:sg.MultiplayerBattleField.data)
  return data_.Get(index);
}
inline ::sg::FrameData* MultiplayerBattleField::add_data() {
  // @@protoc_insertion_point(field_add:sg.MultiplayerBattleField.data)
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::FrameData >&
MultiplayerBattleField::data() const {
  // @@protoc_insertion_point(field_list:sg.MultiplayerBattleField.data)
  return data_;
}

// required bytes work = 8;
inline bool MultiplayerBattleField::has_work() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MultiplayerBattleField::set_has_work() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MultiplayerBattleField::clear_has_work() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MultiplayerBattleField::clear_work() {
  work_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_work();
}
inline const ::std::string& MultiplayerBattleField::work() const {
  // @@protoc_insertion_point(field_get:sg.MultiplayerBattleField.work)
  return work_.Get();
}
inline void MultiplayerBattleField::set_work(const ::std::string& value) {
  set_has_work();
  work_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:sg.MultiplayerBattleField.work)
}
#if LANG_CXX11
inline void MultiplayerBattleField::set_work(::std::string&& value) {
  set_has_work();
  work_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:sg.MultiplayerBattleField.work)
}
#endif
inline void MultiplayerBattleField::set_work(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_work();
  work_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:sg.MultiplayerBattleField.work)
}
inline void MultiplayerBattleField::set_work(const void* value,
    size_t size) {
  set_has_work();
  work_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:sg.MultiplayerBattleField.work)
}
inline ::std::string* MultiplayerBattleField::mutable_work() {
  set_has_work();
  // @@protoc_insertion_point(field_mutable:sg.MultiplayerBattleField.work)
  return work_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* MultiplayerBattleField::release_work() {
  // @@protoc_insertion_point(field_release:sg.MultiplayerBattleField.work)
  if (!has_work()) {
    return NULL;
  }
  clear_has_work();
  return work_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void MultiplayerBattleField::set_allocated_work(::std::string* work) {
  if (work != NULL) {
    set_has_work();
  } else {
    clear_has_work();
  }
  work_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), work,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:sg.MultiplayerBattleField.work)
}
inline ::std::string* MultiplayerBattleField::unsafe_arena_release_work() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.MultiplayerBattleField.work)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_work();
  return work_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void MultiplayerBattleField::unsafe_arena_set_allocated_work(
    ::std::string* work) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (work != NULL) {
    set_has_work();
  } else {
    clear_has_work();
  }
  work_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      work, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sg.MultiplayerBattleField.work)
}

// optional int32 target = 9;
inline bool MultiplayerBattleField::has_target() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MultiplayerBattleField::set_has_target() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MultiplayerBattleField::clear_has_target() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MultiplayerBattleField::clear_target() {
  target_ = 0;
  clear_has_target();
}
inline ::google::protobuf::int32 MultiplayerBattleField::target() const {
  // @@protoc_insertion_point(field_get:sg.MultiplayerBattleField.target)
  return target_;
}
inline void MultiplayerBattleField::set_target(::google::protobuf::int32 value) {
  set_has_target();
  target_ = value;
  // @@protoc_insertion_point(field_set:sg.MultiplayerBattleField.target)
}

// optional int32 type = 10;
inline bool MultiplayerBattleField::has_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MultiplayerBattleField::set_has_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MultiplayerBattleField::clear_has_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MultiplayerBattleField::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 MultiplayerBattleField::type() const {
  // @@protoc_insertion_point(field_get:sg.MultiplayerBattleField.type)
  return type_;
}
inline void MultiplayerBattleField::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:sg.MultiplayerBattleField.type)
}

// -------------------------------------------------------------------

// MultiplayerTeamService_MultiplayerTeamRequest

// required .sg.MultiplayerTeamService.CMD cmd = 1;
inline bool MultiplayerTeamService_MultiplayerTeamRequest::has_cmd() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MultiplayerTeamService_MultiplayerTeamRequest::set_has_cmd() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MultiplayerTeamService_MultiplayerTeamRequest::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MultiplayerTeamService_MultiplayerTeamRequest::clear_cmd() {
  cmd_ = 1;
  clear_has_cmd();
}
inline ::sg::MultiplayerTeamService_CMD MultiplayerTeamService_MultiplayerTeamRequest::cmd() const {
  // @@protoc_insertion_point(field_get:sg.MultiplayerTeamService.MultiplayerTeamRequest.cmd)
  return static_cast< ::sg::MultiplayerTeamService_CMD >(cmd_);
}
inline void MultiplayerTeamService_MultiplayerTeamRequest::set_cmd(::sg::MultiplayerTeamService_CMD value) {
  assert(::sg::MultiplayerTeamService_CMD_IsValid(value));
  set_has_cmd();
  cmd_ = value;
  // @@protoc_insertion_point(field_set:sg.MultiplayerTeamService.MultiplayerTeamRequest.cmd)
}

// optional int32 target_id = 2;
inline bool MultiplayerTeamService_MultiplayerTeamRequest::has_target_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MultiplayerTeamService_MultiplayerTeamRequest::set_has_target_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MultiplayerTeamService_MultiplayerTeamRequest::clear_has_target_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MultiplayerTeamService_MultiplayerTeamRequest::clear_target_id() {
  target_id_ = 0;
  clear_has_target_id();
}
inline ::google::protobuf::int32 MultiplayerTeamService_MultiplayerTeamRequest::target_id() const {
  // @@protoc_insertion_point(field_get:sg.MultiplayerTeamService.MultiplayerTeamRequest.target_id)
  return target_id_;
}
inline void MultiplayerTeamService_MultiplayerTeamRequest::set_target_id(::google::protobuf::int32 value) {
  set_has_target_id();
  target_id_ = value;
  // @@protoc_insertion_point(field_set:sg.MultiplayerTeamService.MultiplayerTeamRequest.target_id)
}

// optional int32 seat = 3;
inline bool MultiplayerTeamService_MultiplayerTeamRequest::has_seat() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MultiplayerTeamService_MultiplayerTeamRequest::set_has_seat() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MultiplayerTeamService_MultiplayerTeamRequest::clear_has_seat() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MultiplayerTeamService_MultiplayerTeamRequest::clear_seat() {
  seat_ = 0;
  clear_has_seat();
}
inline ::google::protobuf::int32 MultiplayerTeamService_MultiplayerTeamRequest::seat() const {
  // @@protoc_insertion_point(field_get:sg.MultiplayerTeamService.MultiplayerTeamRequest.seat)
  return seat_;
}
inline void MultiplayerTeamService_MultiplayerTeamRequest::set_seat(::google::protobuf::int32 value) {
  set_has_seat();
  seat_ = value;
  // @@protoc_insertion_point(field_set:sg.MultiplayerTeamService.MultiplayerTeamRequest.seat)
}

// optional bytes work = 4;
inline bool MultiplayerTeamService_MultiplayerTeamRequest::has_work() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MultiplayerTeamService_MultiplayerTeamRequest::set_has_work() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MultiplayerTeamService_MultiplayerTeamRequest::clear_has_work() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MultiplayerTeamService_MultiplayerTeamRequest::clear_work() {
  work_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_work();
}
inline const ::std::string& MultiplayerTeamService_MultiplayerTeamRequest::work() const {
  // @@protoc_insertion_point(field_get:sg.MultiplayerTeamService.MultiplayerTeamRequest.work)
  return work_.Get();
}
inline void MultiplayerTeamService_MultiplayerTeamRequest::set_work(const ::std::string& value) {
  set_has_work();
  work_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:sg.MultiplayerTeamService.MultiplayerTeamRequest.work)
}
#if LANG_CXX11
inline void MultiplayerTeamService_MultiplayerTeamRequest::set_work(::std::string&& value) {
  set_has_work();
  work_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:sg.MultiplayerTeamService.MultiplayerTeamRequest.work)
}
#endif
inline void MultiplayerTeamService_MultiplayerTeamRequest::set_work(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_work();
  work_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:sg.MultiplayerTeamService.MultiplayerTeamRequest.work)
}
inline void MultiplayerTeamService_MultiplayerTeamRequest::set_work(const void* value,
    size_t size) {
  set_has_work();
  work_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:sg.MultiplayerTeamService.MultiplayerTeamRequest.work)
}
inline ::std::string* MultiplayerTeamService_MultiplayerTeamRequest::mutable_work() {
  set_has_work();
  // @@protoc_insertion_point(field_mutable:sg.MultiplayerTeamService.MultiplayerTeamRequest.work)
  return work_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* MultiplayerTeamService_MultiplayerTeamRequest::release_work() {
  // @@protoc_insertion_point(field_release:sg.MultiplayerTeamService.MultiplayerTeamRequest.work)
  if (!has_work()) {
    return NULL;
  }
  clear_has_work();
  return work_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void MultiplayerTeamService_MultiplayerTeamRequest::set_allocated_work(::std::string* work) {
  if (work != NULL) {
    set_has_work();
  } else {
    clear_has_work();
  }
  work_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), work,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:sg.MultiplayerTeamService.MultiplayerTeamRequest.work)
}
inline ::std::string* MultiplayerTeamService_MultiplayerTeamRequest::unsafe_arena_release_work() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.MultiplayerTeamService.MultiplayerTeamRequest.work)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_work();
  return work_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void MultiplayerTeamService_MultiplayerTeamRequest::unsafe_arena_set_allocated_work(
    ::std::string* work) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (work != NULL) {
    set_has_work();
  } else {
    clear_has_work();
  }
  work_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      work, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sg.MultiplayerTeamService.MultiplayerTeamRequest.work)
}

// optional int32 type = 5;
inline bool MultiplayerTeamService_MultiplayerTeamRequest::has_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MultiplayerTeamService_MultiplayerTeamRequest::set_has_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MultiplayerTeamService_MultiplayerTeamRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MultiplayerTeamService_MultiplayerTeamRequest::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 MultiplayerTeamService_MultiplayerTeamRequest::type() const {
  // @@protoc_insertion_point(field_get:sg.MultiplayerTeamService.MultiplayerTeamRequest.type)
  return type_;
}
inline void MultiplayerTeamService_MultiplayerTeamRequest::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:sg.MultiplayerTeamService.MultiplayerTeamRequest.type)
}

// optional bytes name = 6;
inline bool MultiplayerTeamService_MultiplayerTeamRequest::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MultiplayerTeamService_MultiplayerTeamRequest::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MultiplayerTeamService_MultiplayerTeamRequest::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MultiplayerTeamService_MultiplayerTeamRequest::clear_name() {
  name_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_name();
}
inline const ::std::string& MultiplayerTeamService_MultiplayerTeamRequest::name() const {
  // @@protoc_insertion_point(field_get:sg.MultiplayerTeamService.MultiplayerTeamRequest.name)
  return name_.Get();
}
inline void MultiplayerTeamService_MultiplayerTeamRequest::set_name(const ::std::string& value) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:sg.MultiplayerTeamService.MultiplayerTeamRequest.name)
}
#if LANG_CXX11
inline void MultiplayerTeamService_MultiplayerTeamRequest::set_name(::std::string&& value) {
  set_has_name();
  name_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:sg.MultiplayerTeamService.MultiplayerTeamRequest.name)
}
#endif
inline void MultiplayerTeamService_MultiplayerTeamRequest::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:sg.MultiplayerTeamService.MultiplayerTeamRequest.name)
}
inline void MultiplayerTeamService_MultiplayerTeamRequest::set_name(const void* value,
    size_t size) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:sg.MultiplayerTeamService.MultiplayerTeamRequest.name)
}
inline ::std::string* MultiplayerTeamService_MultiplayerTeamRequest::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:sg.MultiplayerTeamService.MultiplayerTeamRequest.name)
  return name_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* MultiplayerTeamService_MultiplayerTeamRequest::release_name() {
  // @@protoc_insertion_point(field_release:sg.MultiplayerTeamService.MultiplayerTeamRequest.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void MultiplayerTeamService_MultiplayerTeamRequest::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:sg.MultiplayerTeamService.MultiplayerTeamRequest.name)
}
inline ::std::string* MultiplayerTeamService_MultiplayerTeamRequest::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.MultiplayerTeamService.MultiplayerTeamRequest.name)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_name();
  return name_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void MultiplayerTeamService_MultiplayerTeamRequest::unsafe_arena_set_allocated_name(
    ::std::string* name) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      name, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sg.MultiplayerTeamService.MultiplayerTeamRequest.name)
}

// optional int32 new_owner = 7;
inline bool MultiplayerTeamService_MultiplayerTeamRequest::has_new_owner() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MultiplayerTeamService_MultiplayerTeamRequest::set_has_new_owner() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MultiplayerTeamService_MultiplayerTeamRequest::clear_has_new_owner() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MultiplayerTeamService_MultiplayerTeamRequest::clear_new_owner() {
  new_owner_ = 0;
  clear_has_new_owner();
}
inline ::google::protobuf::int32 MultiplayerTeamService_MultiplayerTeamRequest::new_owner() const {
  // @@protoc_insertion_point(field_get:sg.MultiplayerTeamService.MultiplayerTeamRequest.new_owner)
  return new_owner_;
}
inline void MultiplayerTeamService_MultiplayerTeamRequest::set_new_owner(::google::protobuf::int32 value) {
  set_has_new_owner();
  new_owner_ = value;
  // @@protoc_insertion_point(field_set:sg.MultiplayerTeamService.MultiplayerTeamRequest.new_owner)
}

// optional bytes talk_data = 8;
inline bool MultiplayerTeamService_MultiplayerTeamRequest::has_talk_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MultiplayerTeamService_MultiplayerTeamRequest::set_has_talk_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MultiplayerTeamService_MultiplayerTeamRequest::clear_has_talk_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MultiplayerTeamService_MultiplayerTeamRequest::clear_talk_data() {
  talk_data_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_talk_data();
}
inline const ::std::string& MultiplayerTeamService_MultiplayerTeamRequest::talk_data() const {
  // @@protoc_insertion_point(field_get:sg.MultiplayerTeamService.MultiplayerTeamRequest.talk_data)
  return talk_data_.Get();
}
inline void MultiplayerTeamService_MultiplayerTeamRequest::set_talk_data(const ::std::string& value) {
  set_has_talk_data();
  talk_data_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:sg.MultiplayerTeamService.MultiplayerTeamRequest.talk_data)
}
#if LANG_CXX11
inline void MultiplayerTeamService_MultiplayerTeamRequest::set_talk_data(::std::string&& value) {
  set_has_talk_data();
  talk_data_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:sg.MultiplayerTeamService.MultiplayerTeamRequest.talk_data)
}
#endif
inline void MultiplayerTeamService_MultiplayerTeamRequest::set_talk_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_talk_data();
  talk_data_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:sg.MultiplayerTeamService.MultiplayerTeamRequest.talk_data)
}
inline void MultiplayerTeamService_MultiplayerTeamRequest::set_talk_data(const void* value,
    size_t size) {
  set_has_talk_data();
  talk_data_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:sg.MultiplayerTeamService.MultiplayerTeamRequest.talk_data)
}
inline ::std::string* MultiplayerTeamService_MultiplayerTeamRequest::mutable_talk_data() {
  set_has_talk_data();
  // @@protoc_insertion_point(field_mutable:sg.MultiplayerTeamService.MultiplayerTeamRequest.talk_data)
  return talk_data_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* MultiplayerTeamService_MultiplayerTeamRequest::release_talk_data() {
  // @@protoc_insertion_point(field_release:sg.MultiplayerTeamService.MultiplayerTeamRequest.talk_data)
  if (!has_talk_data()) {
    return NULL;
  }
  clear_has_talk_data();
  return talk_data_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void MultiplayerTeamService_MultiplayerTeamRequest::set_allocated_talk_data(::std::string* talk_data) {
  if (talk_data != NULL) {
    set_has_talk_data();
  } else {
    clear_has_talk_data();
  }
  talk_data_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), talk_data,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:sg.MultiplayerTeamService.MultiplayerTeamRequest.talk_data)
}
inline ::std::string* MultiplayerTeamService_MultiplayerTeamRequest::unsafe_arena_release_talk_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.MultiplayerTeamService.MultiplayerTeamRequest.talk_data)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_talk_data();
  return talk_data_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void MultiplayerTeamService_MultiplayerTeamRequest::unsafe_arena_set_allocated_talk_data(
    ::std::string* talk_data) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (talk_data != NULL) {
    set_has_talk_data();
  } else {
    clear_has_talk_data();
  }
  talk_data_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      talk_data, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sg.MultiplayerTeamService.MultiplayerTeamRequest.talk_data)
}

// -------------------------------------------------------------------

// MultiplayerTeamService_MultiplayerTeamResponse

// required int32 result = 1;
inline bool MultiplayerTeamService_MultiplayerTeamResponse::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MultiplayerTeamService_MultiplayerTeamResponse::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MultiplayerTeamService_MultiplayerTeamResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MultiplayerTeamService_MultiplayerTeamResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 MultiplayerTeamService_MultiplayerTeamResponse::result() const {
  // @@protoc_insertion_point(field_get:sg.MultiplayerTeamService.MultiplayerTeamResponse.result)
  return result_;
}
inline void MultiplayerTeamService_MultiplayerTeamResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:sg.MultiplayerTeamService.MultiplayerTeamResponse.result)
}

// optional .sg.MultiplayerRoom my_room = 2;
inline bool MultiplayerTeamService_MultiplayerTeamResponse::has_my_room() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MultiplayerTeamService_MultiplayerTeamResponse::set_has_my_room() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MultiplayerTeamService_MultiplayerTeamResponse::clear_has_my_room() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MultiplayerTeamService_MultiplayerTeamResponse::clear_my_room() {
  if (my_room_ != NULL) my_room_->Clear();
  clear_has_my_room();
}
inline const ::sg::MultiplayerRoom& MultiplayerTeamService_MultiplayerTeamResponse::_internal_my_room() const {
  return *my_room_;
}
inline const ::sg::MultiplayerRoom& MultiplayerTeamService_MultiplayerTeamResponse::my_room() const {
  const ::sg::MultiplayerRoom* p = my_room_;
  // @@protoc_insertion_point(field_get:sg.MultiplayerTeamService.MultiplayerTeamResponse.my_room)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::MultiplayerRoom*>(
      &::sg::_MultiplayerRoom_default_instance_);
}
inline ::sg::MultiplayerRoom* MultiplayerTeamService_MultiplayerTeamResponse::release_my_room() {
  // @@protoc_insertion_point(field_release:sg.MultiplayerTeamService.MultiplayerTeamResponse.my_room)
  clear_has_my_room();
  ::sg::MultiplayerRoom* temp = my_room_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  my_room_ = NULL;
  return temp;
}
inline ::sg::MultiplayerRoom* MultiplayerTeamService_MultiplayerTeamResponse::unsafe_arena_release_my_room() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.MultiplayerTeamService.MultiplayerTeamResponse.my_room)
  clear_has_my_room();
  ::sg::MultiplayerRoom* temp = my_room_;
  my_room_ = NULL;
  return temp;
}
inline ::sg::MultiplayerRoom* MultiplayerTeamService_MultiplayerTeamResponse::mutable_my_room() {
  set_has_my_room();
  if (my_room_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::MultiplayerRoom>(GetArenaNoVirtual());
    my_room_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.MultiplayerTeamService.MultiplayerTeamResponse.my_room)
  return my_room_;
}
inline void MultiplayerTeamService_MultiplayerTeamResponse::set_allocated_my_room(::sg::MultiplayerRoom* my_room) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete my_room_;
  }
  if (my_room) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(my_room);
    if (message_arena != submessage_arena) {
      my_room = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, my_room, submessage_arena);
    }
    set_has_my_room();
  } else {
    clear_has_my_room();
  }
  my_room_ = my_room;
  // @@protoc_insertion_point(field_set_allocated:sg.MultiplayerTeamService.MultiplayerTeamResponse.my_room)
}

// repeated .sg.MultiplayerRoom room_list = 3;
inline int MultiplayerTeamService_MultiplayerTeamResponse::room_list_size() const {
  return room_list_.size();
}
inline void MultiplayerTeamService_MultiplayerTeamResponse::clear_room_list() {
  room_list_.Clear();
}
inline ::sg::MultiplayerRoom* MultiplayerTeamService_MultiplayerTeamResponse::mutable_room_list(int index) {
  // @@protoc_insertion_point(field_mutable:sg.MultiplayerTeamService.MultiplayerTeamResponse.room_list)
  return room_list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::MultiplayerRoom >*
MultiplayerTeamService_MultiplayerTeamResponse::mutable_room_list() {
  // @@protoc_insertion_point(field_mutable_list:sg.MultiplayerTeamService.MultiplayerTeamResponse.room_list)
  return &room_list_;
}
inline const ::sg::MultiplayerRoom& MultiplayerTeamService_MultiplayerTeamResponse::room_list(int index) const {
  // @@protoc_insertion_point(field_get:sg.MultiplayerTeamService.MultiplayerTeamResponse.room_list)
  return room_list_.Get(index);
}
inline ::sg::MultiplayerRoom* MultiplayerTeamService_MultiplayerTeamResponse::add_room_list() {
  // @@protoc_insertion_point(field_add:sg.MultiplayerTeamService.MultiplayerTeamResponse.room_list)
  return room_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::MultiplayerRoom >&
MultiplayerTeamService_MultiplayerTeamResponse::room_list() const {
  // @@protoc_insertion_point(field_list:sg.MultiplayerTeamService.MultiplayerTeamResponse.room_list)
  return room_list_;
}

// -------------------------------------------------------------------

// MultiplayerTeamService

// optional .sg.MultiplayerTeamService.MultiplayerTeamRequest req = 1;
inline bool MultiplayerTeamService::has_req() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MultiplayerTeamService::set_has_req() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MultiplayerTeamService::clear_has_req() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MultiplayerTeamService::clear_req() {
  if (req_ != NULL) req_->Clear();
  clear_has_req();
}
inline const ::sg::MultiplayerTeamService_MultiplayerTeamRequest& MultiplayerTeamService::_internal_req() const {
  return *req_;
}
inline const ::sg::MultiplayerTeamService_MultiplayerTeamRequest& MultiplayerTeamService::req() const {
  const ::sg::MultiplayerTeamService_MultiplayerTeamRequest* p = req_;
  // @@protoc_insertion_point(field_get:sg.MultiplayerTeamService.req)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::MultiplayerTeamService_MultiplayerTeamRequest*>(
      &::sg::_MultiplayerTeamService_MultiplayerTeamRequest_default_instance_);
}
inline ::sg::MultiplayerTeamService_MultiplayerTeamRequest* MultiplayerTeamService::release_req() {
  // @@protoc_insertion_point(field_release:sg.MultiplayerTeamService.req)
  clear_has_req();
  ::sg::MultiplayerTeamService_MultiplayerTeamRequest* temp = req_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  req_ = NULL;
  return temp;
}
inline ::sg::MultiplayerTeamService_MultiplayerTeamRequest* MultiplayerTeamService::unsafe_arena_release_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.MultiplayerTeamService.req)
  clear_has_req();
  ::sg::MultiplayerTeamService_MultiplayerTeamRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline ::sg::MultiplayerTeamService_MultiplayerTeamRequest* MultiplayerTeamService::mutable_req() {
  set_has_req();
  if (req_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::MultiplayerTeamService_MultiplayerTeamRequest>(GetArenaNoVirtual());
    req_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.MultiplayerTeamService.req)
  return req_;
}
inline void MultiplayerTeamService::set_allocated_req(::sg::MultiplayerTeamService_MultiplayerTeamRequest* req) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete req_;
  }
  if (req) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(req);
    if (message_arena != submessage_arena) {
      req = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, req, submessage_arena);
    }
    set_has_req();
  } else {
    clear_has_req();
  }
  req_ = req;
  // @@protoc_insertion_point(field_set_allocated:sg.MultiplayerTeamService.req)
}

// optional .sg.MultiplayerTeamService.MultiplayerTeamResponse resp = 2;
inline bool MultiplayerTeamService::has_resp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MultiplayerTeamService::set_has_resp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MultiplayerTeamService::clear_has_resp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MultiplayerTeamService::clear_resp() {
  if (resp_ != NULL) resp_->Clear();
  clear_has_resp();
}
inline const ::sg::MultiplayerTeamService_MultiplayerTeamResponse& MultiplayerTeamService::_internal_resp() const {
  return *resp_;
}
inline const ::sg::MultiplayerTeamService_MultiplayerTeamResponse& MultiplayerTeamService::resp() const {
  const ::sg::MultiplayerTeamService_MultiplayerTeamResponse* p = resp_;
  // @@protoc_insertion_point(field_get:sg.MultiplayerTeamService.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::MultiplayerTeamService_MultiplayerTeamResponse*>(
      &::sg::_MultiplayerTeamService_MultiplayerTeamResponse_default_instance_);
}
inline ::sg::MultiplayerTeamService_MultiplayerTeamResponse* MultiplayerTeamService::release_resp() {
  // @@protoc_insertion_point(field_release:sg.MultiplayerTeamService.resp)
  clear_has_resp();
  ::sg::MultiplayerTeamService_MultiplayerTeamResponse* temp = resp_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  resp_ = NULL;
  return temp;
}
inline ::sg::MultiplayerTeamService_MultiplayerTeamResponse* MultiplayerTeamService::unsafe_arena_release_resp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.MultiplayerTeamService.resp)
  clear_has_resp();
  ::sg::MultiplayerTeamService_MultiplayerTeamResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline ::sg::MultiplayerTeamService_MultiplayerTeamResponse* MultiplayerTeamService::mutable_resp() {
  set_has_resp();
  if (resp_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::MultiplayerTeamService_MultiplayerTeamResponse>(GetArenaNoVirtual());
    resp_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.MultiplayerTeamService.resp)
  return resp_;
}
inline void MultiplayerTeamService::set_allocated_resp(::sg::MultiplayerTeamService_MultiplayerTeamResponse* resp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete resp_;
  }
  if (resp) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(resp);
    if (message_arena != submessage_arena) {
      resp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, resp, submessage_arena);
    }
    set_has_resp();
  } else {
    clear_has_resp();
  }
  resp_ = resp;
  // @@protoc_insertion_point(field_set_allocated:sg.MultiplayerTeamService.resp)
}

// -------------------------------------------------------------------

// UserTalkNotify

// required int32 index = 1;
inline bool UserTalkNotify::has_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserTalkNotify::set_has_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserTalkNotify::clear_has_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserTalkNotify::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 UserTalkNotify::index() const {
  // @@protoc_insertion_point(field_get:sg.UserTalkNotify.index)
  return index_;
}
inline void UserTalkNotify::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:sg.UserTalkNotify.index)
}

// required sfixed64 timestamp = 2;
inline bool UserTalkNotify::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserTalkNotify::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserTalkNotify::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserTalkNotify::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 UserTalkNotify::timestamp() const {
  // @@protoc_insertion_point(field_get:sg.UserTalkNotify.timestamp)
  return timestamp_;
}
inline void UserTalkNotify::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:sg.UserTalkNotify.timestamp)
}

// required bytes data = 3;
inline bool UserTalkNotify::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserTalkNotify::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserTalkNotify::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserTalkNotify::clear_data() {
  data_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_data();
}
inline const ::std::string& UserTalkNotify::data() const {
  // @@protoc_insertion_point(field_get:sg.UserTalkNotify.data)
  return data_.Get();
}
inline void UserTalkNotify::set_data(const ::std::string& value) {
  set_has_data();
  data_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:sg.UserTalkNotify.data)
}
#if LANG_CXX11
inline void UserTalkNotify::set_data(::std::string&& value) {
  set_has_data();
  data_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:sg.UserTalkNotify.data)
}
#endif
inline void UserTalkNotify::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_data();
  data_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:sg.UserTalkNotify.data)
}
inline void UserTalkNotify::set_data(const void* value,
    size_t size) {
  set_has_data();
  data_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:sg.UserTalkNotify.data)
}
inline ::std::string* UserTalkNotify::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:sg.UserTalkNotify.data)
  return data_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* UserTalkNotify::release_data() {
  // @@protoc_insertion_point(field_release:sg.UserTalkNotify.data)
  if (!has_data()) {
    return NULL;
  }
  clear_has_data();
  return data_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void UserTalkNotify::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:sg.UserTalkNotify.data)
}
inline ::std::string* UserTalkNotify::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.UserTalkNotify.data)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_data();
  return data_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void UserTalkNotify::unsafe_arena_set_allocated_data(
    ::std::string* data) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      data, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sg.UserTalkNotify.data)
}

// -------------------------------------------------------------------

// UserAddNotify

// optional .sg.MultiplayerRoom room_data = 1;
inline bool UserAddNotify::has_room_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserAddNotify::set_has_room_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserAddNotify::clear_has_room_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserAddNotify::clear_room_data() {
  if (room_data_ != NULL) room_data_->Clear();
  clear_has_room_data();
}
inline const ::sg::MultiplayerRoom& UserAddNotify::_internal_room_data() const {
  return *room_data_;
}
inline const ::sg::MultiplayerRoom& UserAddNotify::room_data() const {
  const ::sg::MultiplayerRoom* p = room_data_;
  // @@protoc_insertion_point(field_get:sg.UserAddNotify.room_data)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::MultiplayerRoom*>(
      &::sg::_MultiplayerRoom_default_instance_);
}
inline ::sg::MultiplayerRoom* UserAddNotify::release_room_data() {
  // @@protoc_insertion_point(field_release:sg.UserAddNotify.room_data)
  clear_has_room_data();
  ::sg::MultiplayerRoom* temp = room_data_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  room_data_ = NULL;
  return temp;
}
inline ::sg::MultiplayerRoom* UserAddNotify::unsafe_arena_release_room_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.UserAddNotify.room_data)
  clear_has_room_data();
  ::sg::MultiplayerRoom* temp = room_data_;
  room_data_ = NULL;
  return temp;
}
inline ::sg::MultiplayerRoom* UserAddNotify::mutable_room_data() {
  set_has_room_data();
  if (room_data_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::MultiplayerRoom>(GetArenaNoVirtual());
    room_data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.UserAddNotify.room_data)
  return room_data_;
}
inline void UserAddNotify::set_allocated_room_data(::sg::MultiplayerRoom* room_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete room_data_;
  }
  if (room_data) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(room_data);
    if (message_arena != submessage_arena) {
      room_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, room_data, submessage_arena);
    }
    set_has_room_data();
  } else {
    clear_has_room_data();
  }
  room_data_ = room_data;
  // @@protoc_insertion_point(field_set_allocated:sg.UserAddNotify.room_data)
}

// -------------------------------------------------------------------

// UserChangeSeatNotify

// optional .sg.MultiplayerRoom room_data = 1;
inline bool UserChangeSeatNotify::has_room_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserChangeSeatNotify::set_has_room_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserChangeSeatNotify::clear_has_room_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserChangeSeatNotify::clear_room_data() {
  if (room_data_ != NULL) room_data_->Clear();
  clear_has_room_data();
}
inline const ::sg::MultiplayerRoom& UserChangeSeatNotify::_internal_room_data() const {
  return *room_data_;
}
inline const ::sg::MultiplayerRoom& UserChangeSeatNotify::room_data() const {
  const ::sg::MultiplayerRoom* p = room_data_;
  // @@protoc_insertion_point(field_get:sg.UserChangeSeatNotify.room_data)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::MultiplayerRoom*>(
      &::sg::_MultiplayerRoom_default_instance_);
}
inline ::sg::MultiplayerRoom* UserChangeSeatNotify::release_room_data() {
  // @@protoc_insertion_point(field_release:sg.UserChangeSeatNotify.room_data)
  clear_has_room_data();
  ::sg::MultiplayerRoom* temp = room_data_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  room_data_ = NULL;
  return temp;
}
inline ::sg::MultiplayerRoom* UserChangeSeatNotify::unsafe_arena_release_room_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.UserChangeSeatNotify.room_data)
  clear_has_room_data();
  ::sg::MultiplayerRoom* temp = room_data_;
  room_data_ = NULL;
  return temp;
}
inline ::sg::MultiplayerRoom* UserChangeSeatNotify::mutable_room_data() {
  set_has_room_data();
  if (room_data_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::MultiplayerRoom>(GetArenaNoVirtual());
    room_data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.UserChangeSeatNotify.room_data)
  return room_data_;
}
inline void UserChangeSeatNotify::set_allocated_room_data(::sg::MultiplayerRoom* room_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete room_data_;
  }
  if (room_data) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(room_data);
    if (message_arena != submessage_arena) {
      room_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, room_data, submessage_arena);
    }
    set_has_room_data();
  } else {
    clear_has_room_data();
  }
  room_data_ = room_data;
  // @@protoc_insertion_point(field_set_allocated:sg.UserChangeSeatNotify.room_data)
}

// -------------------------------------------------------------------

// UserDeleteRoomNotify

// optional .sg.MultiplayerRoom room_data = 1;
inline bool UserDeleteRoomNotify::has_room_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserDeleteRoomNotify::set_has_room_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserDeleteRoomNotify::clear_has_room_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserDeleteRoomNotify::clear_room_data() {
  if (room_data_ != NULL) room_data_->Clear();
  clear_has_room_data();
}
inline const ::sg::MultiplayerRoom& UserDeleteRoomNotify::_internal_room_data() const {
  return *room_data_;
}
inline const ::sg::MultiplayerRoom& UserDeleteRoomNotify::room_data() const {
  const ::sg::MultiplayerRoom* p = room_data_;
  // @@protoc_insertion_point(field_get:sg.UserDeleteRoomNotify.room_data)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::MultiplayerRoom*>(
      &::sg::_MultiplayerRoom_default_instance_);
}
inline ::sg::MultiplayerRoom* UserDeleteRoomNotify::release_room_data() {
  // @@protoc_insertion_point(field_release:sg.UserDeleteRoomNotify.room_data)
  clear_has_room_data();
  ::sg::MultiplayerRoom* temp = room_data_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  room_data_ = NULL;
  return temp;
}
inline ::sg::MultiplayerRoom* UserDeleteRoomNotify::unsafe_arena_release_room_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.UserDeleteRoomNotify.room_data)
  clear_has_room_data();
  ::sg::MultiplayerRoom* temp = room_data_;
  room_data_ = NULL;
  return temp;
}
inline ::sg::MultiplayerRoom* UserDeleteRoomNotify::mutable_room_data() {
  set_has_room_data();
  if (room_data_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::MultiplayerRoom>(GetArenaNoVirtual());
    room_data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.UserDeleteRoomNotify.room_data)
  return room_data_;
}
inline void UserDeleteRoomNotify::set_allocated_room_data(::sg::MultiplayerRoom* room_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete room_data_;
  }
  if (room_data) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(room_data);
    if (message_arena != submessage_arena) {
      room_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, room_data, submessage_arena);
    }
    set_has_room_data();
  } else {
    clear_has_room_data();
  }
  room_data_ = room_data;
  // @@protoc_insertion_point(field_set_allocated:sg.UserDeleteRoomNotify.room_data)
}

// -------------------------------------------------------------------

// UserChangeOwnerNotify

// optional .sg.MultiplayerRoom room_data = 1;
inline bool UserChangeOwnerNotify::has_room_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserChangeOwnerNotify::set_has_room_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserChangeOwnerNotify::clear_has_room_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserChangeOwnerNotify::clear_room_data() {
  if (room_data_ != NULL) room_data_->Clear();
  clear_has_room_data();
}
inline const ::sg::MultiplayerRoom& UserChangeOwnerNotify::_internal_room_data() const {
  return *room_data_;
}
inline const ::sg::MultiplayerRoom& UserChangeOwnerNotify::room_data() const {
  const ::sg::MultiplayerRoom* p = room_data_;
  // @@protoc_insertion_point(field_get:sg.UserChangeOwnerNotify.room_data)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::MultiplayerRoom*>(
      &::sg::_MultiplayerRoom_default_instance_);
}
inline ::sg::MultiplayerRoom* UserChangeOwnerNotify::release_room_data() {
  // @@protoc_insertion_point(field_release:sg.UserChangeOwnerNotify.room_data)
  clear_has_room_data();
  ::sg::MultiplayerRoom* temp = room_data_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  room_data_ = NULL;
  return temp;
}
inline ::sg::MultiplayerRoom* UserChangeOwnerNotify::unsafe_arena_release_room_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.UserChangeOwnerNotify.room_data)
  clear_has_room_data();
  ::sg::MultiplayerRoom* temp = room_data_;
  room_data_ = NULL;
  return temp;
}
inline ::sg::MultiplayerRoom* UserChangeOwnerNotify::mutable_room_data() {
  set_has_room_data();
  if (room_data_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::MultiplayerRoom>(GetArenaNoVirtual());
    room_data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.UserChangeOwnerNotify.room_data)
  return room_data_;
}
inline void UserChangeOwnerNotify::set_allocated_room_data(::sg::MultiplayerRoom* room_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete room_data_;
  }
  if (room_data) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(room_data);
    if (message_arena != submessage_arena) {
      room_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, room_data, submessage_arena);
    }
    set_has_room_data();
  } else {
    clear_has_room_data();
  }
  room_data_ = room_data;
  // @@protoc_insertion_point(field_set_allocated:sg.UserChangeOwnerNotify.room_data)
}

// -------------------------------------------------------------------

// UserChangeWorkNotify

// optional .sg.MultiplayerRoom room_data = 1;
inline bool UserChangeWorkNotify::has_room_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserChangeWorkNotify::set_has_room_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserChangeWorkNotify::clear_has_room_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserChangeWorkNotify::clear_room_data() {
  if (room_data_ != NULL) room_data_->Clear();
  clear_has_room_data();
}
inline const ::sg::MultiplayerRoom& UserChangeWorkNotify::_internal_room_data() const {
  return *room_data_;
}
inline const ::sg::MultiplayerRoom& UserChangeWorkNotify::room_data() const {
  const ::sg::MultiplayerRoom* p = room_data_;
  // @@protoc_insertion_point(field_get:sg.UserChangeWorkNotify.room_data)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::MultiplayerRoom*>(
      &::sg::_MultiplayerRoom_default_instance_);
}
inline ::sg::MultiplayerRoom* UserChangeWorkNotify::release_room_data() {
  // @@protoc_insertion_point(field_release:sg.UserChangeWorkNotify.room_data)
  clear_has_room_data();
  ::sg::MultiplayerRoom* temp = room_data_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  room_data_ = NULL;
  return temp;
}
inline ::sg::MultiplayerRoom* UserChangeWorkNotify::unsafe_arena_release_room_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.UserChangeWorkNotify.room_data)
  clear_has_room_data();
  ::sg::MultiplayerRoom* temp = room_data_;
  room_data_ = NULL;
  return temp;
}
inline ::sg::MultiplayerRoom* UserChangeWorkNotify::mutable_room_data() {
  set_has_room_data();
  if (room_data_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::MultiplayerRoom>(GetArenaNoVirtual());
    room_data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.UserChangeWorkNotify.room_data)
  return room_data_;
}
inline void UserChangeWorkNotify::set_allocated_room_data(::sg::MultiplayerRoom* room_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete room_data_;
  }
  if (room_data) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(room_data);
    if (message_arena != submessage_arena) {
      room_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, room_data, submessage_arena);
    }
    set_has_room_data();
  } else {
    clear_has_room_data();
  }
  room_data_ = room_data;
  // @@protoc_insertion_point(field_set_allocated:sg.UserChangeWorkNotify.room_data)
}

// -------------------------------------------------------------------

// UserLeaveNotify

// optional .sg.MultiplayerRoom room_data = 1;
inline bool UserLeaveNotify::has_room_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserLeaveNotify::set_has_room_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserLeaveNotify::clear_has_room_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserLeaveNotify::clear_room_data() {
  if (room_data_ != NULL) room_data_->Clear();
  clear_has_room_data();
}
inline const ::sg::MultiplayerRoom& UserLeaveNotify::_internal_room_data() const {
  return *room_data_;
}
inline const ::sg::MultiplayerRoom& UserLeaveNotify::room_data() const {
  const ::sg::MultiplayerRoom* p = room_data_;
  // @@protoc_insertion_point(field_get:sg.UserLeaveNotify.room_data)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::MultiplayerRoom*>(
      &::sg::_MultiplayerRoom_default_instance_);
}
inline ::sg::MultiplayerRoom* UserLeaveNotify::release_room_data() {
  // @@protoc_insertion_point(field_release:sg.UserLeaveNotify.room_data)
  clear_has_room_data();
  ::sg::MultiplayerRoom* temp = room_data_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  room_data_ = NULL;
  return temp;
}
inline ::sg::MultiplayerRoom* UserLeaveNotify::unsafe_arena_release_room_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.UserLeaveNotify.room_data)
  clear_has_room_data();
  ::sg::MultiplayerRoom* temp = room_data_;
  room_data_ = NULL;
  return temp;
}
inline ::sg::MultiplayerRoom* UserLeaveNotify::mutable_room_data() {
  set_has_room_data();
  if (room_data_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::MultiplayerRoom>(GetArenaNoVirtual());
    room_data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.UserLeaveNotify.room_data)
  return room_data_;
}
inline void UserLeaveNotify::set_allocated_room_data(::sg::MultiplayerRoom* room_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete room_data_;
  }
  if (room_data) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(room_data);
    if (message_arena != submessage_arena) {
      room_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, room_data, submessage_arena);
    }
    set_has_room_data();
  } else {
    clear_has_room_data();
  }
  room_data_ = room_data;
  // @@protoc_insertion_point(field_set_allocated:sg.UserLeaveNotify.room_data)
}

// -------------------------------------------------------------------

// UserRenameNotify

// optional .sg.MultiplayerRoom room_data = 1;
inline bool UserRenameNotify::has_room_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserRenameNotify::set_has_room_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserRenameNotify::clear_has_room_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserRenameNotify::clear_room_data() {
  if (room_data_ != NULL) room_data_->Clear();
  clear_has_room_data();
}
inline const ::sg::MultiplayerRoom& UserRenameNotify::_internal_room_data() const {
  return *room_data_;
}
inline const ::sg::MultiplayerRoom& UserRenameNotify::room_data() const {
  const ::sg::MultiplayerRoom* p = room_data_;
  // @@protoc_insertion_point(field_get:sg.UserRenameNotify.room_data)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::MultiplayerRoom*>(
      &::sg::_MultiplayerRoom_default_instance_);
}
inline ::sg::MultiplayerRoom* UserRenameNotify::release_room_data() {
  // @@protoc_insertion_point(field_release:sg.UserRenameNotify.room_data)
  clear_has_room_data();
  ::sg::MultiplayerRoom* temp = room_data_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  room_data_ = NULL;
  return temp;
}
inline ::sg::MultiplayerRoom* UserRenameNotify::unsafe_arena_release_room_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.UserRenameNotify.room_data)
  clear_has_room_data();
  ::sg::MultiplayerRoom* temp = room_data_;
  room_data_ = NULL;
  return temp;
}
inline ::sg::MultiplayerRoom* UserRenameNotify::mutable_room_data() {
  set_has_room_data();
  if (room_data_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::MultiplayerRoom>(GetArenaNoVirtual());
    room_data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.UserRenameNotify.room_data)
  return room_data_;
}
inline void UserRenameNotify::set_allocated_room_data(::sg::MultiplayerRoom* room_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete room_data_;
  }
  if (room_data) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(room_data);
    if (message_arena != submessage_arena) {
      room_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, room_data, submessage_arena);
    }
    set_has_room_data();
  } else {
    clear_has_room_data();
  }
  room_data_ = room_data;
  // @@protoc_insertion_point(field_set_allocated:sg.UserRenameNotify.room_data)
}

// -------------------------------------------------------------------

// BattleReadyNotify

// optional .sg.MultiplayerRoom room_data = 1;
inline bool BattleReadyNotify::has_room_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleReadyNotify::set_has_room_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleReadyNotify::clear_has_room_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleReadyNotify::clear_room_data() {
  if (room_data_ != NULL) room_data_->Clear();
  clear_has_room_data();
}
inline const ::sg::MultiplayerRoom& BattleReadyNotify::_internal_room_data() const {
  return *room_data_;
}
inline const ::sg::MultiplayerRoom& BattleReadyNotify::room_data() const {
  const ::sg::MultiplayerRoom* p = room_data_;
  // @@protoc_insertion_point(field_get:sg.BattleReadyNotify.room_data)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::MultiplayerRoom*>(
      &::sg::_MultiplayerRoom_default_instance_);
}
inline ::sg::MultiplayerRoom* BattleReadyNotify::release_room_data() {
  // @@protoc_insertion_point(field_release:sg.BattleReadyNotify.room_data)
  clear_has_room_data();
  ::sg::MultiplayerRoom* temp = room_data_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  room_data_ = NULL;
  return temp;
}
inline ::sg::MultiplayerRoom* BattleReadyNotify::unsafe_arena_release_room_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.BattleReadyNotify.room_data)
  clear_has_room_data();
  ::sg::MultiplayerRoom* temp = room_data_;
  room_data_ = NULL;
  return temp;
}
inline ::sg::MultiplayerRoom* BattleReadyNotify::mutable_room_data() {
  set_has_room_data();
  if (room_data_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::MultiplayerRoom>(GetArenaNoVirtual());
    room_data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.BattleReadyNotify.room_data)
  return room_data_;
}
inline void BattleReadyNotify::set_allocated_room_data(::sg::MultiplayerRoom* room_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete room_data_;
  }
  if (room_data) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(room_data);
    if (message_arena != submessage_arena) {
      room_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, room_data, submessage_arena);
    }
    set_has_room_data();
  } else {
    clear_has_room_data();
  }
  room_data_ = room_data;
  // @@protoc_insertion_point(field_set_allocated:sg.BattleReadyNotify.room_data)
}

// -------------------------------------------------------------------

// MultiplayerBattleService_MultiplayerBattleRequest

// required .sg.MultiplayerBattleService.CMD cmd = 1;
inline bool MultiplayerBattleService_MultiplayerBattleRequest::has_cmd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MultiplayerBattleService_MultiplayerBattleRequest::set_has_cmd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MultiplayerBattleService_MultiplayerBattleRequest::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MultiplayerBattleService_MultiplayerBattleRequest::clear_cmd() {
  cmd_ = 1;
  clear_has_cmd();
}
inline ::sg::MultiplayerBattleService_CMD MultiplayerBattleService_MultiplayerBattleRequest::cmd() const {
  // @@protoc_insertion_point(field_get:sg.MultiplayerBattleService.MultiplayerBattleRequest.cmd)
  return static_cast< ::sg::MultiplayerBattleService_CMD >(cmd_);
}
inline void MultiplayerBattleService_MultiplayerBattleRequest::set_cmd(::sg::MultiplayerBattleService_CMD value) {
  assert(::sg::MultiplayerBattleService_CMD_IsValid(value));
  set_has_cmd();
  cmd_ = value;
  // @@protoc_insertion_point(field_set:sg.MultiplayerBattleService.MultiplayerBattleRequest.cmd)
}

// optional uint64 target_id = 3;
inline bool MultiplayerBattleService_MultiplayerBattleRequest::has_target_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MultiplayerBattleService_MultiplayerBattleRequest::set_has_target_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MultiplayerBattleService_MultiplayerBattleRequest::clear_has_target_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MultiplayerBattleService_MultiplayerBattleRequest::clear_target_id() {
  target_id_ = GOOGLE_ULONGLONG(0);
  clear_has_target_id();
}
inline ::google::protobuf::uint64 MultiplayerBattleService_MultiplayerBattleRequest::target_id() const {
  // @@protoc_insertion_point(field_get:sg.MultiplayerBattleService.MultiplayerBattleRequest.target_id)
  return target_id_;
}
inline void MultiplayerBattleService_MultiplayerBattleRequest::set_target_id(::google::protobuf::uint64 value) {
  set_has_target_id();
  target_id_ = value;
  // @@protoc_insertion_point(field_set:sg.MultiplayerBattleService.MultiplayerBattleRequest.target_id)
}

// repeated int32 sailors = 4;
inline int MultiplayerBattleService_MultiplayerBattleRequest::sailors_size() const {
  return sailors_.size();
}
inline void MultiplayerBattleService_MultiplayerBattleRequest::clear_sailors() {
  sailors_.Clear();
}
inline ::google::protobuf::int32 MultiplayerBattleService_MultiplayerBattleRequest::sailors(int index) const {
  // @@protoc_insertion_point(field_get:sg.MultiplayerBattleService.MultiplayerBattleRequest.sailors)
  return sailors_.Get(index);
}
inline void MultiplayerBattleService_MultiplayerBattleRequest::set_sailors(int index, ::google::protobuf::int32 value) {
  sailors_.Set(index, value);
  // @@protoc_insertion_point(field_set:sg.MultiplayerBattleService.MultiplayerBattleRequest.sailors)
}
inline void MultiplayerBattleService_MultiplayerBattleRequest::add_sailors(::google::protobuf::int32 value) {
  sailors_.Add(value);
  // @@protoc_insertion_point(field_add:sg.MultiplayerBattleService.MultiplayerBattleRequest.sailors)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
MultiplayerBattleService_MultiplayerBattleRequest::sailors() const {
  // @@protoc_insertion_point(field_list:sg.MultiplayerBattleService.MultiplayerBattleRequest.sailors)
  return sailors_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
MultiplayerBattleService_MultiplayerBattleRequest::mutable_sailors() {
  // @@protoc_insertion_point(field_mutable_list:sg.MultiplayerBattleService.MultiplayerBattleRequest.sailors)
  return &sailors_;
}

// repeated .sg.FrameData operation_list = 5;
inline int MultiplayerBattleService_MultiplayerBattleRequest::operation_list_size() const {
  return operation_list_.size();
}
inline void MultiplayerBattleService_MultiplayerBattleRequest::clear_operation_list() {
  operation_list_.Clear();
}
inline ::sg::FrameData* MultiplayerBattleService_MultiplayerBattleRequest::mutable_operation_list(int index) {
  // @@protoc_insertion_point(field_mutable:sg.MultiplayerBattleService.MultiplayerBattleRequest.operation_list)
  return operation_list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::FrameData >*
MultiplayerBattleService_MultiplayerBattleRequest::mutable_operation_list() {
  // @@protoc_insertion_point(field_mutable_list:sg.MultiplayerBattleService.MultiplayerBattleRequest.operation_list)
  return &operation_list_;
}
inline const ::sg::FrameData& MultiplayerBattleService_MultiplayerBattleRequest::operation_list(int index) const {
  // @@protoc_insertion_point(field_get:sg.MultiplayerBattleService.MultiplayerBattleRequest.operation_list)
  return operation_list_.Get(index);
}
inline ::sg::FrameData* MultiplayerBattleService_MultiplayerBattleRequest::add_operation_list() {
  // @@protoc_insertion_point(field_add:sg.MultiplayerBattleService.MultiplayerBattleRequest.operation_list)
  return operation_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::FrameData >&
MultiplayerBattleService_MultiplayerBattleRequest::operation_list() const {
  // @@protoc_insertion_point(field_list:sg.MultiplayerBattleService.MultiplayerBattleRequest.operation_list)
  return operation_list_;
}

// optional int32 result = 6;
inline bool MultiplayerBattleService_MultiplayerBattleRequest::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MultiplayerBattleService_MultiplayerBattleRequest::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MultiplayerBattleService_MultiplayerBattleRequest::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MultiplayerBattleService_MultiplayerBattleRequest::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 MultiplayerBattleService_MultiplayerBattleRequest::result() const {
  // @@protoc_insertion_point(field_get:sg.MultiplayerBattleService.MultiplayerBattleRequest.result)
  return result_;
}
inline void MultiplayerBattleService_MultiplayerBattleRequest::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:sg.MultiplayerBattleService.MultiplayerBattleRequest.result)
}

// -------------------------------------------------------------------

// MultiplayerBattleService_MultiplayerBattleResponse

// required int32 result = 1;
inline bool MultiplayerBattleService_MultiplayerBattleResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MultiplayerBattleService_MultiplayerBattleResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MultiplayerBattleService_MultiplayerBattleResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MultiplayerBattleService_MultiplayerBattleResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 MultiplayerBattleService_MultiplayerBattleResponse::result() const {
  // @@protoc_insertion_point(field_get:sg.MultiplayerBattleService.MultiplayerBattleResponse.result)
  return result_;
}
inline void MultiplayerBattleService_MultiplayerBattleResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:sg.MultiplayerBattleService.MultiplayerBattleResponse.result)
}

// -------------------------------------------------------------------

// MultiplayerBattleService

// optional .sg.MultiplayerBattleService.MultiplayerBattleRequest req = 1;
inline bool MultiplayerBattleService::has_req() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MultiplayerBattleService::set_has_req() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MultiplayerBattleService::clear_has_req() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MultiplayerBattleService::clear_req() {
  if (req_ != NULL) req_->Clear();
  clear_has_req();
}
inline const ::sg::MultiplayerBattleService_MultiplayerBattleRequest& MultiplayerBattleService::_internal_req() const {
  return *req_;
}
inline const ::sg::MultiplayerBattleService_MultiplayerBattleRequest& MultiplayerBattleService::req() const {
  const ::sg::MultiplayerBattleService_MultiplayerBattleRequest* p = req_;
  // @@protoc_insertion_point(field_get:sg.MultiplayerBattleService.req)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::MultiplayerBattleService_MultiplayerBattleRequest*>(
      &::sg::_MultiplayerBattleService_MultiplayerBattleRequest_default_instance_);
}
inline ::sg::MultiplayerBattleService_MultiplayerBattleRequest* MultiplayerBattleService::release_req() {
  // @@protoc_insertion_point(field_release:sg.MultiplayerBattleService.req)
  clear_has_req();
  ::sg::MultiplayerBattleService_MultiplayerBattleRequest* temp = req_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  req_ = NULL;
  return temp;
}
inline ::sg::MultiplayerBattleService_MultiplayerBattleRequest* MultiplayerBattleService::unsafe_arena_release_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.MultiplayerBattleService.req)
  clear_has_req();
  ::sg::MultiplayerBattleService_MultiplayerBattleRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline ::sg::MultiplayerBattleService_MultiplayerBattleRequest* MultiplayerBattleService::mutable_req() {
  set_has_req();
  if (req_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::MultiplayerBattleService_MultiplayerBattleRequest>(GetArenaNoVirtual());
    req_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.MultiplayerBattleService.req)
  return req_;
}
inline void MultiplayerBattleService::set_allocated_req(::sg::MultiplayerBattleService_MultiplayerBattleRequest* req) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete req_;
  }
  if (req) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(req);
    if (message_arena != submessage_arena) {
      req = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, req, submessage_arena);
    }
    set_has_req();
  } else {
    clear_has_req();
  }
  req_ = req;
  // @@protoc_insertion_point(field_set_allocated:sg.MultiplayerBattleService.req)
}

// optional .sg.MultiplayerBattleService.MultiplayerBattleResponse resp = 2;
inline bool MultiplayerBattleService::has_resp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MultiplayerBattleService::set_has_resp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MultiplayerBattleService::clear_has_resp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MultiplayerBattleService::clear_resp() {
  if (resp_ != NULL) resp_->Clear();
  clear_has_resp();
}
inline const ::sg::MultiplayerBattleService_MultiplayerBattleResponse& MultiplayerBattleService::_internal_resp() const {
  return *resp_;
}
inline const ::sg::MultiplayerBattleService_MultiplayerBattleResponse& MultiplayerBattleService::resp() const {
  const ::sg::MultiplayerBattleService_MultiplayerBattleResponse* p = resp_;
  // @@protoc_insertion_point(field_get:sg.MultiplayerBattleService.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::MultiplayerBattleService_MultiplayerBattleResponse*>(
      &::sg::_MultiplayerBattleService_MultiplayerBattleResponse_default_instance_);
}
inline ::sg::MultiplayerBattleService_MultiplayerBattleResponse* MultiplayerBattleService::release_resp() {
  // @@protoc_insertion_point(field_release:sg.MultiplayerBattleService.resp)
  clear_has_resp();
  ::sg::MultiplayerBattleService_MultiplayerBattleResponse* temp = resp_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  resp_ = NULL;
  return temp;
}
inline ::sg::MultiplayerBattleService_MultiplayerBattleResponse* MultiplayerBattleService::unsafe_arena_release_resp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.MultiplayerBattleService.resp)
  clear_has_resp();
  ::sg::MultiplayerBattleService_MultiplayerBattleResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline ::sg::MultiplayerBattleService_MultiplayerBattleResponse* MultiplayerBattleService::mutable_resp() {
  set_has_resp();
  if (resp_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::MultiplayerBattleService_MultiplayerBattleResponse>(GetArenaNoVirtual());
    resp_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.MultiplayerBattleService.resp)
  return resp_;
}
inline void MultiplayerBattleService::set_allocated_resp(::sg::MultiplayerBattleService_MultiplayerBattleResponse* resp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete resp_;
  }
  if (resp) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(resp);
    if (message_arena != submessage_arena) {
      resp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, resp, submessage_arena);
    }
    set_has_resp();
  } else {
    clear_has_resp();
  }
  resp_ = resp;
  // @@protoc_insertion_point(field_set_allocated:sg.MultiplayerBattleService.resp)
}

// -------------------------------------------------------------------

// FrameAddNotify

// required int32 frame = 1;
inline bool FrameAddNotify::has_frame() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FrameAddNotify::set_has_frame() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FrameAddNotify::clear_has_frame() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FrameAddNotify::clear_frame() {
  frame_ = 0;
  clear_has_frame();
}
inline ::google::protobuf::int32 FrameAddNotify::frame() const {
  // @@protoc_insertion_point(field_get:sg.FrameAddNotify.frame)
  return frame_;
}
inline void FrameAddNotify::set_frame(::google::protobuf::int32 value) {
  set_has_frame();
  frame_ = value;
  // @@protoc_insertion_point(field_set:sg.FrameAddNotify.frame)
}

// repeated .sg.FrameData data = 2;
inline int FrameAddNotify::data_size() const {
  return data_.size();
}
inline void FrameAddNotify::clear_data() {
  data_.Clear();
}
inline ::sg::FrameData* FrameAddNotify::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:sg.FrameAddNotify.data)
  return data_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::FrameData >*
FrameAddNotify::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:sg.FrameAddNotify.data)
  return &data_;
}
inline const ::sg::FrameData& FrameAddNotify::data(int index) const {
  // @@protoc_insertion_point(field_get:sg.FrameAddNotify.data)
  return data_.Get(index);
}
inline ::sg::FrameData* FrameAddNotify::add_data() {
  // @@protoc_insertion_point(field_add:sg.FrameAddNotify.data)
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::FrameData >&
FrameAddNotify::data() const {
  // @@protoc_insertion_point(field_list:sg.FrameAddNotify.data)
  return data_;
}

// -------------------------------------------------------------------

// UserReadyNotify

// required int32 member_index = 1;
inline bool UserReadyNotify::has_member_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserReadyNotify::set_has_member_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserReadyNotify::clear_has_member_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserReadyNotify::clear_member_index() {
  member_index_ = 0;
  clear_has_member_index();
}
inline ::google::protobuf::int32 UserReadyNotify::member_index() const {
  // @@protoc_insertion_point(field_get:sg.UserReadyNotify.member_index)
  return member_index_;
}
inline void UserReadyNotify::set_member_index(::google::protobuf::int32 value) {
  set_has_member_index();
  member_index_ = value;
  // @@protoc_insertion_point(field_set:sg.UserReadyNotify.member_index)
}

// required bool ready = 2;
inline bool UserReadyNotify::has_ready() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserReadyNotify::set_has_ready() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserReadyNotify::clear_has_ready() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserReadyNotify::clear_ready() {
  ready_ = false;
  clear_has_ready();
}
inline bool UserReadyNotify::ready() const {
  // @@protoc_insertion_point(field_get:sg.UserReadyNotify.ready)
  return ready_;
}
inline void UserReadyNotify::set_ready(bool value) {
  set_has_ready();
  ready_ = value;
  // @@protoc_insertion_point(field_set:sg.UserReadyNotify.ready)
}

// -------------------------------------------------------------------

// UserChangeSailorNotify

// required int32 member_index = 1;
inline bool UserChangeSailorNotify::has_member_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserChangeSailorNotify::set_has_member_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserChangeSailorNotify::clear_has_member_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserChangeSailorNotify::clear_member_index() {
  member_index_ = 0;
  clear_has_member_index();
}
inline ::google::protobuf::int32 UserChangeSailorNotify::member_index() const {
  // @@protoc_insertion_point(field_get:sg.UserChangeSailorNotify.member_index)
  return member_index_;
}
inline void UserChangeSailorNotify::set_member_index(::google::protobuf::int32 value) {
  set_has_member_index();
  member_index_ = value;
  // @@protoc_insertion_point(field_set:sg.UserChangeSailorNotify.member_index)
}

// repeated .sg.Sailor use_sailor = 2;
inline int UserChangeSailorNotify::use_sailor_size() const {
  return use_sailor_.size();
}
inline ::sg::Sailor* UserChangeSailorNotify::mutable_use_sailor(int index) {
  // @@protoc_insertion_point(field_mutable:sg.UserChangeSailorNotify.use_sailor)
  return use_sailor_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::Sailor >*
UserChangeSailorNotify::mutable_use_sailor() {
  // @@protoc_insertion_point(field_mutable_list:sg.UserChangeSailorNotify.use_sailor)
  return &use_sailor_;
}
inline const ::sg::Sailor& UserChangeSailorNotify::use_sailor(int index) const {
  // @@protoc_insertion_point(field_get:sg.UserChangeSailorNotify.use_sailor)
  return use_sailor_.Get(index);
}
inline ::sg::Sailor* UserChangeSailorNotify::add_use_sailor() {
  // @@protoc_insertion_point(field_add:sg.UserChangeSailorNotify.use_sailor)
  return use_sailor_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::Sailor >&
UserChangeSailorNotify::use_sailor() const {
  // @@protoc_insertion_point(field_list:sg.UserChangeSailorNotify.use_sailor)
  return use_sailor_;
}

// -------------------------------------------------------------------

// BattleStartNotify

// required .sg.MultiplayerBattleField battle_data = 1;
inline bool BattleStartNotify::has_battle_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleStartNotify::set_has_battle_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleStartNotify::clear_has_battle_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleStartNotify::clear_battle_data() {
  if (battle_data_ != NULL) battle_data_->Clear();
  clear_has_battle_data();
}
inline const ::sg::MultiplayerBattleField& BattleStartNotify::_internal_battle_data() const {
  return *battle_data_;
}
inline const ::sg::MultiplayerBattleField& BattleStartNotify::battle_data() const {
  const ::sg::MultiplayerBattleField* p = battle_data_;
  // @@protoc_insertion_point(field_get:sg.BattleStartNotify.battle_data)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::MultiplayerBattleField*>(
      &::sg::_MultiplayerBattleField_default_instance_);
}
inline ::sg::MultiplayerBattleField* BattleStartNotify::release_battle_data() {
  // @@protoc_insertion_point(field_release:sg.BattleStartNotify.battle_data)
  clear_has_battle_data();
  ::sg::MultiplayerBattleField* temp = battle_data_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  battle_data_ = NULL;
  return temp;
}
inline ::sg::MultiplayerBattleField* BattleStartNotify::unsafe_arena_release_battle_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.BattleStartNotify.battle_data)
  clear_has_battle_data();
  ::sg::MultiplayerBattleField* temp = battle_data_;
  battle_data_ = NULL;
  return temp;
}
inline ::sg::MultiplayerBattleField* BattleStartNotify::mutable_battle_data() {
  set_has_battle_data();
  if (battle_data_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::MultiplayerBattleField>(GetArenaNoVirtual());
    battle_data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.BattleStartNotify.battle_data)
  return battle_data_;
}
inline void BattleStartNotify::set_allocated_battle_data(::sg::MultiplayerBattleField* battle_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete battle_data_;
  }
  if (battle_data) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(battle_data);
    if (message_arena != submessage_arena) {
      battle_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, battle_data, submessage_arena);
    }
    set_has_battle_data();
  } else {
    clear_has_battle_data();
  }
  battle_data_ = battle_data;
  // @@protoc_insertion_point(field_set_allocated:sg.BattleStartNotify.battle_data)
}

// optional .sg.DungeonContent content = 2;
inline bool BattleStartNotify::has_content() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleStartNotify::set_has_content() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleStartNotify::clear_has_content() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::sg::DungeonContent& BattleStartNotify::_internal_content() const {
  return *content_;
}
inline const ::sg::DungeonContent& BattleStartNotify::content() const {
  const ::sg::DungeonContent* p = content_;
  // @@protoc_insertion_point(field_get:sg.BattleStartNotify.content)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::DungeonContent*>(
      &::sg::_DungeonContent_default_instance_);
}
inline ::sg::DungeonContent* BattleStartNotify::release_content() {
  // @@protoc_insertion_point(field_release:sg.BattleStartNotify.content)
  clear_has_content();
  ::sg::DungeonContent* temp = content_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  content_ = NULL;
  return temp;
}
inline ::sg::DungeonContent* BattleStartNotify::unsafe_arena_release_content() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.BattleStartNotify.content)
  clear_has_content();
  ::sg::DungeonContent* temp = content_;
  content_ = NULL;
  return temp;
}
inline ::sg::DungeonContent* BattleStartNotify::mutable_content() {
  set_has_content();
  if (content_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::DungeonContent>(GetArenaNoVirtual());
    content_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.BattleStartNotify.content)
  return content_;
}
inline void BattleStartNotify::set_allocated_content(::sg::DungeonContent* content) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(content_);
  }
  if (content) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(content)->GetArena();
    if (message_arena != submessage_arena) {
      content = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, content, submessage_arena);
    }
    set_has_content();
  } else {
    clear_has_content();
  }
  content_ = content;
  // @@protoc_insertion_point(field_set_allocated:sg.BattleStartNotify.content)
}

// optional .sg.UserDungeonInformation user_info = 3;
inline bool BattleStartNotify::has_user_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BattleStartNotify::set_has_user_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BattleStartNotify::clear_has_user_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::sg::UserDungeonInformation& BattleStartNotify::_internal_user_info() const {
  return *user_info_;
}
inline const ::sg::UserDungeonInformation& BattleStartNotify::user_info() const {
  const ::sg::UserDungeonInformation* p = user_info_;
  // @@protoc_insertion_point(field_get:sg.BattleStartNotify.user_info)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::UserDungeonInformation*>(
      &::sg::_UserDungeonInformation_default_instance_);
}
inline ::sg::UserDungeonInformation* BattleStartNotify::release_user_info() {
  // @@protoc_insertion_point(field_release:sg.BattleStartNotify.user_info)
  clear_has_user_info();
  ::sg::UserDungeonInformation* temp = user_info_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  user_info_ = NULL;
  return temp;
}
inline ::sg::UserDungeonInformation* BattleStartNotify::unsafe_arena_release_user_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.BattleStartNotify.user_info)
  clear_has_user_info();
  ::sg::UserDungeonInformation* temp = user_info_;
  user_info_ = NULL;
  return temp;
}
inline ::sg::UserDungeonInformation* BattleStartNotify::mutable_user_info() {
  set_has_user_info();
  if (user_info_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::UserDungeonInformation>(GetArenaNoVirtual());
    user_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.BattleStartNotify.user_info)
  return user_info_;
}
inline void BattleStartNotify::set_allocated_user_info(::sg::UserDungeonInformation* user_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(user_info_);
  }
  if (user_info) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(user_info)->GetArena();
    if (message_arena != submessage_arena) {
      user_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user_info, submessage_arena);
    }
    set_has_user_info();
  } else {
    clear_has_user_info();
  }
  user_info_ = user_info;
  // @@protoc_insertion_point(field_set_allocated:sg.BattleStartNotify.user_info)
}

// optional int32 cost_vitality = 4;
inline bool BattleStartNotify::has_cost_vitality() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BattleStartNotify::set_has_cost_vitality() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BattleStartNotify::clear_has_cost_vitality() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BattleStartNotify::clear_cost_vitality() {
  cost_vitality_ = 0;
  clear_has_cost_vitality();
}
inline ::google::protobuf::int32 BattleStartNotify::cost_vitality() const {
  // @@protoc_insertion_point(field_get:sg.BattleStartNotify.cost_vitality)
  return cost_vitality_;
}
inline void BattleStartNotify::set_cost_vitality(::google::protobuf::int32 value) {
  set_has_cost_vitality();
  cost_vitality_ = value;
  // @@protoc_insertion_point(field_set:sg.BattleStartNotify.cost_vitality)
}

// -------------------------------------------------------------------

// BattleOverNotify

// required int32 result = 1;
inline bool BattleOverNotify::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleOverNotify::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleOverNotify::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BattleOverNotify::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 BattleOverNotify::result() const {
  // @@protoc_insertion_point(field_get:sg.BattleOverNotify.result)
  return result_;
}
inline void BattleOverNotify::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:sg.BattleOverNotify.result)
}

// optional .sg.Reward reward = 2;
inline bool BattleOverNotify::has_reward() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleOverNotify::set_has_reward() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleOverNotify::clear_has_reward() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::sg::Reward& BattleOverNotify::_internal_reward() const {
  return *reward_;
}
inline const ::sg::Reward& BattleOverNotify::reward() const {
  const ::sg::Reward* p = reward_;
  // @@protoc_insertion_point(field_get:sg.BattleOverNotify.reward)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::Reward*>(
      &::sg::_Reward_default_instance_);
}
inline ::sg::Reward* BattleOverNotify::release_reward() {
  // @@protoc_insertion_point(field_release:sg.BattleOverNotify.reward)
  clear_has_reward();
  ::sg::Reward* temp = reward_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  reward_ = NULL;
  return temp;
}
inline ::sg::Reward* BattleOverNotify::unsafe_arena_release_reward() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.BattleOverNotify.reward)
  clear_has_reward();
  ::sg::Reward* temp = reward_;
  reward_ = NULL;
  return temp;
}
inline ::sg::Reward* BattleOverNotify::mutable_reward() {
  set_has_reward();
  if (reward_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::Reward>(GetArenaNoVirtual());
    reward_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.BattleOverNotify.reward)
  return reward_;
}
inline void BattleOverNotify::set_allocated_reward(::sg::Reward* reward) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(reward_);
  }
  if (reward) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(reward)->GetArena();
    if (message_arena != submessage_arena) {
      reward = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, reward, submessage_arena);
    }
    set_has_reward();
  } else {
    clear_has_reward();
  }
  reward_ = reward;
  // @@protoc_insertion_point(field_set_allocated:sg.BattleOverNotify.reward)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace sg

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::sg::MultiplayerTeamService_CMD> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::MultiplayerTeamService_CMD>() {
  return ::sg::MultiplayerTeamService_CMD_descriptor();
}
template <> struct is_proto_enum< ::sg::MultiplayerBattleService_CMD> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::MultiplayerBattleService_CMD>() {
  return ::sg::MultiplayerBattleService_CMD_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_Multiplayer_2eproto
