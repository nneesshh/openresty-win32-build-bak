// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: UserHunt.proto

#ifndef PROTOBUF_INCLUDED_UserHunt_2eproto
#define PROTOBUF_INCLUDED_UserHunt_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "Mail.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_UserHunt_2eproto 

namespace protobuf_UserHunt_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[10];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_UserHunt_2eproto
namespace sg {
class HuntGroundInfo;
class HuntGroundInfoDefaultTypeInternal;
extern HuntGroundInfoDefaultTypeInternal _HuntGroundInfo_default_instance_;
class HuntGroundStateNotify;
class HuntGroundStateNotifyDefaultTypeInternal;
extern HuntGroundStateNotifyDefaultTypeInternal _HuntGroundStateNotify_default_instance_;
class HuntPrey;
class HuntPreyDefaultTypeInternal;
extern HuntPreyDefaultTypeInternal _HuntPrey_default_instance_;
class HuntPreyDrop;
class HuntPreyDropDefaultTypeInternal;
extern HuntPreyDropDefaultTypeInternal _HuntPreyDrop_default_instance_;
class HuntPreyDropList;
class HuntPreyDropListDefaultTypeInternal;
extern HuntPreyDropListDefaultTypeInternal _HuntPreyDropList_default_instance_;
class HuntPreyList;
class HuntPreyListDefaultTypeInternal;
extern HuntPreyListDefaultTypeInternal _HuntPreyList_default_instance_;
class HuntPreyStateNotify;
class HuntPreyStateNotifyDefaultTypeInternal;
extern HuntPreyStateNotifyDefaultTypeInternal _HuntPreyStateNotify_default_instance_;
class UserHuntService;
class UserHuntServiceDefaultTypeInternal;
extern UserHuntServiceDefaultTypeInternal _UserHuntService_default_instance_;
class UserHuntService_HuntRequest;
class UserHuntService_HuntRequestDefaultTypeInternal;
extern UserHuntService_HuntRequestDefaultTypeInternal _UserHuntService_HuntRequest_default_instance_;
class UserHuntService_HuntResponse;
class UserHuntService_HuntResponseDefaultTypeInternal;
extern UserHuntService_HuntResponseDefaultTypeInternal _UserHuntService_HuntResponse_default_instance_;
}  // namespace sg
namespace google {
namespace protobuf {
template<> ::sg::HuntGroundInfo* Arena::CreateMaybeMessage<::sg::HuntGroundInfo>(Arena*);
template<> ::sg::HuntGroundStateNotify* Arena::CreateMaybeMessage<::sg::HuntGroundStateNotify>(Arena*);
template<> ::sg::HuntPrey* Arena::CreateMaybeMessage<::sg::HuntPrey>(Arena*);
template<> ::sg::HuntPreyDrop* Arena::CreateMaybeMessage<::sg::HuntPreyDrop>(Arena*);
template<> ::sg::HuntPreyDropList* Arena::CreateMaybeMessage<::sg::HuntPreyDropList>(Arena*);
template<> ::sg::HuntPreyList* Arena::CreateMaybeMessage<::sg::HuntPreyList>(Arena*);
template<> ::sg::HuntPreyStateNotify* Arena::CreateMaybeMessage<::sg::HuntPreyStateNotify>(Arena*);
template<> ::sg::UserHuntService* Arena::CreateMaybeMessage<::sg::UserHuntService>(Arena*);
template<> ::sg::UserHuntService_HuntRequest* Arena::CreateMaybeMessage<::sg::UserHuntService_HuntRequest>(Arena*);
template<> ::sg::UserHuntService_HuntResponse* Arena::CreateMaybeMessage<::sg::UserHuntService_HuntResponse>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace sg {

enum HuntPrey_PREY_STATE {
  HuntPrey_PREY_STATE_TO_DELETE = -1,
  HuntPrey_PREY_STATE_IDLE = 0,
  HuntPrey_PREY_STATE_CAPTURED = 1,
  HuntPrey_PREY_STATE_ESCAPED = 2,
  HuntPrey_PREY_STATE_STRUGGLE = 3,
  HuntPrey_PREY_STATE_FIGHT = 4,
  HuntPrey_PREY_STATE_RETREAT = 5
};
bool HuntPrey_PREY_STATE_IsValid(int value);
const HuntPrey_PREY_STATE HuntPrey_PREY_STATE_PREY_STATE_MIN = HuntPrey_PREY_STATE_TO_DELETE;
const HuntPrey_PREY_STATE HuntPrey_PREY_STATE_PREY_STATE_MAX = HuntPrey_PREY_STATE_RETREAT;
const int HuntPrey_PREY_STATE_PREY_STATE_ARRAYSIZE = HuntPrey_PREY_STATE_PREY_STATE_MAX + 1;

const ::google::protobuf::EnumDescriptor* HuntPrey_PREY_STATE_descriptor();
inline const ::std::string& HuntPrey_PREY_STATE_Name(HuntPrey_PREY_STATE value) {
  return ::google::protobuf::internal::NameOfEnum(
    HuntPrey_PREY_STATE_descriptor(), value);
}
inline bool HuntPrey_PREY_STATE_Parse(
    const ::std::string& name, HuntPrey_PREY_STATE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HuntPrey_PREY_STATE>(
    HuntPrey_PREY_STATE_descriptor(), name, value);
}
enum UserHuntService_HUNT_COMMAND {
  UserHuntService_HUNT_COMMAND_QUERY = 1,
  UserHuntService_HUNT_COMMAND_ENTER = 2,
  UserHuntService_HUNT_COMMAND_TRAP = 3,
  UserHuntService_HUNT_COMMAND_FISHING_NET = 4,
  UserHuntService_HUNT_COMMAND_FISHING_ROD = 5,
  UserHuntService_HUNT_COMMAND_FISHING_HARPOON = 6
};
bool UserHuntService_HUNT_COMMAND_IsValid(int value);
const UserHuntService_HUNT_COMMAND UserHuntService_HUNT_COMMAND_HUNT_COMMAND_MIN = UserHuntService_HUNT_COMMAND_QUERY;
const UserHuntService_HUNT_COMMAND UserHuntService_HUNT_COMMAND_HUNT_COMMAND_MAX = UserHuntService_HUNT_COMMAND_FISHING_HARPOON;
const int UserHuntService_HUNT_COMMAND_HUNT_COMMAND_ARRAYSIZE = UserHuntService_HUNT_COMMAND_HUNT_COMMAND_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserHuntService_HUNT_COMMAND_descriptor();
inline const ::std::string& UserHuntService_HUNT_COMMAND_Name(UserHuntService_HUNT_COMMAND value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserHuntService_HUNT_COMMAND_descriptor(), value);
}
inline bool UserHuntService_HUNT_COMMAND_Parse(
    const ::std::string& name, UserHuntService_HUNT_COMMAND* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserHuntService_HUNT_COMMAND>(
    UserHuntService_HUNT_COMMAND_descriptor(), name, value);
}
enum HUNT_GROUND_TYPE {
  HUNT_GROUND_TYPE_TRAP = 1,
  HUNT_GROUND_TYPE_FISHING = 2
};
bool HUNT_GROUND_TYPE_IsValid(int value);
const HUNT_GROUND_TYPE HUNT_GROUND_TYPE_MIN = HUNT_GROUND_TYPE_TRAP;
const HUNT_GROUND_TYPE HUNT_GROUND_TYPE_MAX = HUNT_GROUND_TYPE_FISHING;
const int HUNT_GROUND_TYPE_ARRAYSIZE = HUNT_GROUND_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* HUNT_GROUND_TYPE_descriptor();
inline const ::std::string& HUNT_GROUND_TYPE_Name(HUNT_GROUND_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    HUNT_GROUND_TYPE_descriptor(), value);
}
inline bool HUNT_GROUND_TYPE_Parse(
    const ::std::string& name, HUNT_GROUND_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HUNT_GROUND_TYPE>(
    HUNT_GROUND_TYPE_descriptor(), name, value);
}
enum HUNT_GROUND_STATE {
  HUNT_GROUND_STATE_DISABLE = 0,
  HUNT_GROUND_STATE_ENABLE_PART = 1,
  HUNT_GROUND_STATE_ENABLE_FULL = 2
};
bool HUNT_GROUND_STATE_IsValid(int value);
const HUNT_GROUND_STATE HUNT_GROUND_STATE_MIN = HUNT_GROUND_STATE_DISABLE;
const HUNT_GROUND_STATE HUNT_GROUND_STATE_MAX = HUNT_GROUND_STATE_ENABLE_FULL;
const int HUNT_GROUND_STATE_ARRAYSIZE = HUNT_GROUND_STATE_MAX + 1;

const ::google::protobuf::EnumDescriptor* HUNT_GROUND_STATE_descriptor();
inline const ::std::string& HUNT_GROUND_STATE_Name(HUNT_GROUND_STATE value) {
  return ::google::protobuf::internal::NameOfEnum(
    HUNT_GROUND_STATE_descriptor(), value);
}
inline bool HUNT_GROUND_STATE_Parse(
    const ::std::string& name, HUNT_GROUND_STATE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HUNT_GROUND_STATE>(
    HUNT_GROUND_STATE_descriptor(), name, value);
}
enum HUNT_PREY_TYPE {
  HUNT_PREY_TYPE_UNKNOWN = 0,
  HUNT_PREY_TYPE_BEAST = 1,
  HUNT_PREY_TYPE_FISH = 2
};
bool HUNT_PREY_TYPE_IsValid(int value);
const HUNT_PREY_TYPE HUNT_PREY_TYPE_MIN = HUNT_PREY_TYPE_UNKNOWN;
const HUNT_PREY_TYPE HUNT_PREY_TYPE_MAX = HUNT_PREY_TYPE_FISH;
const int HUNT_PREY_TYPE_ARRAYSIZE = HUNT_PREY_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* HUNT_PREY_TYPE_descriptor();
inline const ::std::string& HUNT_PREY_TYPE_Name(HUNT_PREY_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    HUNT_PREY_TYPE_descriptor(), value);
}
inline bool HUNT_PREY_TYPE_Parse(
    const ::std::string& name, HUNT_PREY_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HUNT_PREY_TYPE>(
    HUNT_PREY_TYPE_descriptor(), name, value);
}
// ===================================================================

class HuntGroundInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.HuntGroundInfo) */ {
 public:
  HuntGroundInfo();
  virtual ~HuntGroundInfo();

  HuntGroundInfo(const HuntGroundInfo& from);

  inline HuntGroundInfo& operator=(const HuntGroundInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HuntGroundInfo(HuntGroundInfo&& from) noexcept
    : HuntGroundInfo() {
    *this = ::std::move(from);
  }

  inline HuntGroundInfo& operator=(HuntGroundInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const HuntGroundInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HuntGroundInfo* internal_default_instance() {
    return reinterpret_cast<const HuntGroundInfo*>(
               &_HuntGroundInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void UnsafeArenaSwap(HuntGroundInfo* other);
  void Swap(HuntGroundInfo* other);
  friend void swap(HuntGroundInfo& a, HuntGroundInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HuntGroundInfo* New() const final {
    return CreateMaybeMessage<HuntGroundInfo>(NULL);
  }

  HuntGroundInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HuntGroundInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HuntGroundInfo& from);
  void MergeFrom(const HuntGroundInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HuntGroundInfo* other);
  protected:
  explicit HuntGroundInfo(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 groundid = 1;
  bool has_groundid() const;
  void clear_groundid();
  static const int kGroundidFieldNumber = 1;
  ::google::protobuf::uint64 groundid() const;
  void set_groundid(::google::protobuf::uint64 value);

  // optional .sg.HUNT_GROUND_STATE state = 2;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 2;
  ::sg::HUNT_GROUND_STATE state() const;
  void set_state(::sg::HUNT_GROUND_STATE value);

  // optional int32 hunt_num = 3;
  bool has_hunt_num() const;
  void clear_hunt_num();
  static const int kHuntNumFieldNumber = 3;
  ::google::protobuf::int32 hunt_num() const;
  void set_hunt_num(::google::protobuf::int32 value);

  // optional sfixed64 hunt_recover_starttime = 4;
  bool has_hunt_recover_starttime() const;
  void clear_hunt_recover_starttime();
  static const int kHuntRecoverStarttimeFieldNumber = 4;
  ::google::protobuf::int64 hunt_recover_starttime() const;
  void set_hunt_recover_starttime(::google::protobuf::int64 value);

  // optional int32 hunt_recover_cd_seconds = 5;
  bool has_hunt_recover_cd_seconds() const;
  void clear_hunt_recover_cd_seconds();
  static const int kHuntRecoverCdSecondsFieldNumber = 5;
  ::google::protobuf::int32 hunt_recover_cd_seconds() const;
  void set_hunt_recover_cd_seconds(::google::protobuf::int32 value);

  // optional float hunt_recover_add_ratio1 = 6;
  bool has_hunt_recover_add_ratio1() const;
  void clear_hunt_recover_add_ratio1();
  static const int kHuntRecoverAddRatio1FieldNumber = 6;
  float hunt_recover_add_ratio1() const;
  void set_hunt_recover_add_ratio1(float value);

  // optional float hunt_recover_add_ratio2 = 7;
  bool has_hunt_recover_add_ratio2() const;
  void clear_hunt_recover_add_ratio2();
  static const int kHuntRecoverAddRatio2FieldNumber = 7;
  float hunt_recover_add_ratio2() const;
  void set_hunt_recover_add_ratio2(float value);

  // optional float hunt_recover_add_ratio3 = 8;
  bool has_hunt_recover_add_ratio3() const;
  void clear_hunt_recover_add_ratio3();
  static const int kHuntRecoverAddRatio3FieldNumber = 8;
  float hunt_recover_add_ratio3() const;
  void set_hunt_recover_add_ratio3(float value);

  // optional int32 prey_hunt_num_max = 11;
  bool has_prey_hunt_num_max() const;
  void clear_prey_hunt_num_max();
  static const int kPreyHuntNumMaxFieldNumber = 11;
  ::google::protobuf::int32 prey_hunt_num_max() const;
  void set_prey_hunt_num_max(::google::protobuf::int32 value);

  // optional sfixed64 growtime = 12;
  bool has_growtime() const;
  void clear_growtime();
  static const int kGrowtimeFieldNumber = 12;
  ::google::protobuf::int64 growtime() const;
  void set_growtime(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:sg.HuntGroundInfo)
 private:
  void set_has_groundid();
  void clear_has_groundid();
  void set_has_state();
  void clear_has_state();
  void set_has_hunt_num();
  void clear_has_hunt_num();
  void set_has_hunt_recover_starttime();
  void clear_has_hunt_recover_starttime();
  void set_has_hunt_recover_cd_seconds();
  void clear_has_hunt_recover_cd_seconds();
  void set_has_hunt_recover_add_ratio1();
  void clear_has_hunt_recover_add_ratio1();
  void set_has_hunt_recover_add_ratio2();
  void clear_has_hunt_recover_add_ratio2();
  void set_has_hunt_recover_add_ratio3();
  void clear_has_hunt_recover_add_ratio3();
  void set_has_prey_hunt_num_max();
  void clear_has_prey_hunt_num_max();
  void set_has_growtime();
  void clear_has_growtime();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 groundid_;
  int state_;
  ::google::protobuf::int32 hunt_num_;
  ::google::protobuf::int64 hunt_recover_starttime_;
  ::google::protobuf::int32 hunt_recover_cd_seconds_;
  float hunt_recover_add_ratio1_;
  float hunt_recover_add_ratio2_;
  float hunt_recover_add_ratio3_;
  ::google::protobuf::int32 prey_hunt_num_max_;
  ::google::protobuf::int64 growtime_;
  friend struct ::protobuf_UserHunt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HuntPrey : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.HuntPrey) */ {
 public:
  HuntPrey();
  virtual ~HuntPrey();

  HuntPrey(const HuntPrey& from);

  inline HuntPrey& operator=(const HuntPrey& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HuntPrey(HuntPrey&& from) noexcept
    : HuntPrey() {
    *this = ::std::move(from);
  }

  inline HuntPrey& operator=(HuntPrey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const HuntPrey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HuntPrey* internal_default_instance() {
    return reinterpret_cast<const HuntPrey*>(
               &_HuntPrey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void UnsafeArenaSwap(HuntPrey* other);
  void Swap(HuntPrey* other);
  friend void swap(HuntPrey& a, HuntPrey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HuntPrey* New() const final {
    return CreateMaybeMessage<HuntPrey>(NULL);
  }

  HuntPrey* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HuntPrey>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HuntPrey& from);
  void MergeFrom(const HuntPrey& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HuntPrey* other);
  protected:
  explicit HuntPrey(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef HuntPrey_PREY_STATE PREY_STATE;
  static const PREY_STATE TO_DELETE =
    HuntPrey_PREY_STATE_TO_DELETE;
  static const PREY_STATE IDLE =
    HuntPrey_PREY_STATE_IDLE;
  static const PREY_STATE CAPTURED =
    HuntPrey_PREY_STATE_CAPTURED;
  static const PREY_STATE ESCAPED =
    HuntPrey_PREY_STATE_ESCAPED;
  static const PREY_STATE STRUGGLE =
    HuntPrey_PREY_STATE_STRUGGLE;
  static const PREY_STATE FIGHT =
    HuntPrey_PREY_STATE_FIGHT;
  static const PREY_STATE RETREAT =
    HuntPrey_PREY_STATE_RETREAT;
  static inline bool PREY_STATE_IsValid(int value) {
    return HuntPrey_PREY_STATE_IsValid(value);
  }
  static const PREY_STATE PREY_STATE_MIN =
    HuntPrey_PREY_STATE_PREY_STATE_MIN;
  static const PREY_STATE PREY_STATE_MAX =
    HuntPrey_PREY_STATE_PREY_STATE_MAX;
  static const int PREY_STATE_ARRAYSIZE =
    HuntPrey_PREY_STATE_PREY_STATE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PREY_STATE_descriptor() {
    return HuntPrey_PREY_STATE_descriptor();
  }
  static inline const ::std::string& PREY_STATE_Name(PREY_STATE value) {
    return HuntPrey_PREY_STATE_Name(value);
  }
  static inline bool PREY_STATE_Parse(const ::std::string& name,
      PREY_STATE* value) {
    return HuntPrey_PREY_STATE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int32 preyid = 1;
  bool has_preyid() const;
  void clear_preyid();
  static const int kPreyidFieldNumber = 1;
  ::google::protobuf::int32 preyid() const;
  void set_preyid(::google::protobuf::int32 value);

  // optional .sg.HUNT_PREY_TYPE prey_type = 2;
  bool has_prey_type() const;
  void clear_prey_type();
  static const int kPreyTypeFieldNumber = 2;
  ::sg::HUNT_PREY_TYPE prey_type() const;
  void set_prey_type(::sg::HUNT_PREY_TYPE value);

  // optional uint64 cfgid = 3;
  bool has_cfgid() const;
  void clear_cfgid();
  static const int kCfgidFieldNumber = 3;
  ::google::protobuf::uint64 cfgid() const;
  void set_cfgid(::google::protobuf::uint64 value);

  // optional int32 cfg_groupid = 4;
  bool has_cfg_groupid() const;
  void clear_cfg_groupid();
  static const int kCfgGroupidFieldNumber = 4;
  ::google::protobuf::int32 cfg_groupid() const;
  void set_cfg_groupid(::google::protobuf::int32 value);

  // optional int32 seconds = 6;
  bool has_seconds() const;
  void clear_seconds();
  static const int kSecondsFieldNumber = 6;
  ::google::protobuf::int32 seconds() const;
  void set_seconds(::google::protobuf::int32 value);

  // optional sfixed64 optime = 21;
  bool has_optime() const;
  void clear_optime();
  static const int kOptimeFieldNumber = 21;
  ::google::protobuf::int64 optime() const;
  void set_optime(::google::protobuf::int64 value);

  // optional .sg.HuntPrey.PREY_STATE state = 5;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 5;
  ::sg::HuntPrey_PREY_STATE state() const;
  void set_state(::sg::HuntPrey_PREY_STATE value);

  // @@protoc_insertion_point(class_scope:sg.HuntPrey)
 private:
  void set_has_preyid();
  void clear_has_preyid();
  void set_has_prey_type();
  void clear_has_prey_type();
  void set_has_cfgid();
  void clear_has_cfgid();
  void set_has_cfg_groupid();
  void clear_has_cfg_groupid();
  void set_has_state();
  void clear_has_state();
  void set_has_seconds();
  void clear_has_seconds();
  void set_has_optime();
  void clear_has_optime();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 preyid_;
  int prey_type_;
  ::google::protobuf::uint64 cfgid_;
  ::google::protobuf::int32 cfg_groupid_;
  ::google::protobuf::int32 seconds_;
  ::google::protobuf::int64 optime_;
  int state_;
  friend struct ::protobuf_UserHunt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HuntPreyList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.HuntPreyList) */ {
 public:
  HuntPreyList();
  virtual ~HuntPreyList();

  HuntPreyList(const HuntPreyList& from);

  inline HuntPreyList& operator=(const HuntPreyList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HuntPreyList(HuntPreyList&& from) noexcept
    : HuntPreyList() {
    *this = ::std::move(from);
  }

  inline HuntPreyList& operator=(HuntPreyList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const HuntPreyList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HuntPreyList* internal_default_instance() {
    return reinterpret_cast<const HuntPreyList*>(
               &_HuntPreyList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void UnsafeArenaSwap(HuntPreyList* other);
  void Swap(HuntPreyList* other);
  friend void swap(HuntPreyList& a, HuntPreyList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HuntPreyList* New() const final {
    return CreateMaybeMessage<HuntPreyList>(NULL);
  }

  HuntPreyList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HuntPreyList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HuntPreyList& from);
  void MergeFrom(const HuntPreyList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HuntPreyList* other);
  protected:
  explicit HuntPreyList(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sg.HuntPrey list = 1;
  int list_size() const;
  void clear_list();
  static const int kListFieldNumber = 1;
  ::sg::HuntPrey* mutable_list(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::HuntPrey >*
      mutable_list();
  const ::sg::HuntPrey& list(int index) const;
  ::sg::HuntPrey* add_list();
  const ::google::protobuf::RepeatedPtrField< ::sg::HuntPrey >&
      list() const;

  // @@protoc_insertion_point(class_scope:sg.HuntPreyList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::HuntPrey > list_;
  friend struct ::protobuf_UserHunt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HuntPreyDrop : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.HuntPreyDrop) */ {
 public:
  HuntPreyDrop();
  virtual ~HuntPreyDrop();

  HuntPreyDrop(const HuntPreyDrop& from);

  inline HuntPreyDrop& operator=(const HuntPreyDrop& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HuntPreyDrop(HuntPreyDrop&& from) noexcept
    : HuntPreyDrop() {
    *this = ::std::move(from);
  }

  inline HuntPreyDrop& operator=(HuntPreyDrop&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const HuntPreyDrop& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HuntPreyDrop* internal_default_instance() {
    return reinterpret_cast<const HuntPreyDrop*>(
               &_HuntPreyDrop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void UnsafeArenaSwap(HuntPreyDrop* other);
  void Swap(HuntPreyDrop* other);
  friend void swap(HuntPreyDrop& a, HuntPreyDrop& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HuntPreyDrop* New() const final {
    return CreateMaybeMessage<HuntPreyDrop>(NULL);
  }

  HuntPreyDrop* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HuntPreyDrop>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HuntPreyDrop& from);
  void MergeFrom(const HuntPreyDrop& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HuntPreyDrop* other);
  protected:
  explicit HuntPreyDrop(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .sg.ItemDropList drop_item_list = 2;
  bool has_drop_item_list() const;
  void clear_drop_item_list();
  static const int kDropItemListFieldNumber = 2;
  private:
  const ::sg::ItemDropList& _internal_drop_item_list() const;
  public:
  const ::sg::ItemDropList& drop_item_list() const;
  ::sg::ItemDropList* release_drop_item_list();
  ::sg::ItemDropList* mutable_drop_item_list();
  void set_allocated_drop_item_list(::sg::ItemDropList* drop_item_list);
  void unsafe_arena_set_allocated_drop_item_list(
      ::sg::ItemDropList* drop_item_list);
  ::sg::ItemDropList* unsafe_arena_release_drop_item_list();

  // optional int32 preyid = 1;
  bool has_preyid() const;
  void clear_preyid();
  static const int kPreyidFieldNumber = 1;
  ::google::protobuf::int32 preyid() const;
  void set_preyid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.HuntPreyDrop)
 private:
  void set_has_preyid();
  void clear_has_preyid();
  void set_has_drop_item_list();
  void clear_has_drop_item_list();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::sg::ItemDropList* drop_item_list_;
  ::google::protobuf::int32 preyid_;
  friend struct ::protobuf_UserHunt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HuntPreyDropList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.HuntPreyDropList) */ {
 public:
  HuntPreyDropList();
  virtual ~HuntPreyDropList();

  HuntPreyDropList(const HuntPreyDropList& from);

  inline HuntPreyDropList& operator=(const HuntPreyDropList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HuntPreyDropList(HuntPreyDropList&& from) noexcept
    : HuntPreyDropList() {
    *this = ::std::move(from);
  }

  inline HuntPreyDropList& operator=(HuntPreyDropList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const HuntPreyDropList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HuntPreyDropList* internal_default_instance() {
    return reinterpret_cast<const HuntPreyDropList*>(
               &_HuntPreyDropList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void UnsafeArenaSwap(HuntPreyDropList* other);
  void Swap(HuntPreyDropList* other);
  friend void swap(HuntPreyDropList& a, HuntPreyDropList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HuntPreyDropList* New() const final {
    return CreateMaybeMessage<HuntPreyDropList>(NULL);
  }

  HuntPreyDropList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HuntPreyDropList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HuntPreyDropList& from);
  void MergeFrom(const HuntPreyDropList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HuntPreyDropList* other);
  protected:
  explicit HuntPreyDropList(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sg.HuntPreyDrop list = 1;
  int list_size() const;
  void clear_list();
  static const int kListFieldNumber = 1;
  ::sg::HuntPreyDrop* mutable_list(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::HuntPreyDrop >*
      mutable_list();
  const ::sg::HuntPreyDrop& list(int index) const;
  ::sg::HuntPreyDrop* add_list();
  const ::google::protobuf::RepeatedPtrField< ::sg::HuntPreyDrop >&
      list() const;

  // @@protoc_insertion_point(class_scope:sg.HuntPreyDropList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::HuntPreyDrop > list_;
  friend struct ::protobuf_UserHunt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserHuntService_HuntRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.UserHuntService.HuntRequest) */ {
 public:
  UserHuntService_HuntRequest();
  virtual ~UserHuntService_HuntRequest();

  UserHuntService_HuntRequest(const UserHuntService_HuntRequest& from);

  inline UserHuntService_HuntRequest& operator=(const UserHuntService_HuntRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserHuntService_HuntRequest(UserHuntService_HuntRequest&& from) noexcept
    : UserHuntService_HuntRequest() {
    *this = ::std::move(from);
  }

  inline UserHuntService_HuntRequest& operator=(UserHuntService_HuntRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserHuntService_HuntRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserHuntService_HuntRequest* internal_default_instance() {
    return reinterpret_cast<const UserHuntService_HuntRequest*>(
               &_UserHuntService_HuntRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void UnsafeArenaSwap(UserHuntService_HuntRequest* other);
  void Swap(UserHuntService_HuntRequest* other);
  friend void swap(UserHuntService_HuntRequest& a, UserHuntService_HuntRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserHuntService_HuntRequest* New() const final {
    return CreateMaybeMessage<UserHuntService_HuntRequest>(NULL);
  }

  UserHuntService_HuntRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserHuntService_HuntRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserHuntService_HuntRequest& from);
  void MergeFrom(const UserHuntService_HuntRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserHuntService_HuntRequest* other);
  protected:
  explicit UserHuntService_HuntRequest(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 fishid_list = 6;
  int fishid_list_size() const;
  void clear_fishid_list();
  static const int kFishidListFieldNumber = 6;
  ::google::protobuf::int32 fishid_list(int index) const;
  void set_fishid_list(int index, ::google::protobuf::int32 value);
  void add_fishid_list(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      fishid_list() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_fishid_list();

  // optional uint64 hunt_groundid = 2;
  bool has_hunt_groundid() const;
  void clear_hunt_groundid();
  static const int kHuntGroundidFieldNumber = 2;
  ::google::protobuf::uint64 hunt_groundid() const;
  void set_hunt_groundid(::google::protobuf::uint64 value);

  // optional int32 trapid = 3;
  bool has_trapid() const;
  void clear_trapid();
  static const int kTrapidFieldNumber = 3;
  ::google::protobuf::int32 trapid() const;
  void set_trapid(::google::protobuf::int32 value);

  // optional int32 preyid = 4;
  bool has_preyid() const;
  void clear_preyid();
  static const int kPreyidFieldNumber = 4;
  ::google::protobuf::int32 preyid() const;
  void set_preyid(::google::protobuf::int32 value);

  // optional int32 toolid = 5;
  bool has_toolid() const;
  void clear_toolid();
  static const int kToolidFieldNumber = 5;
  ::google::protobuf::int32 toolid() const;
  void set_toolid(::google::protobuf::int32 value);

  // required .sg.UserHuntService.HUNT_COMMAND cmd = 1;
  bool has_cmd() const;
  void clear_cmd();
  static const int kCmdFieldNumber = 1;
  ::sg::UserHuntService_HUNT_COMMAND cmd() const;
  void set_cmd(::sg::UserHuntService_HUNT_COMMAND value);

  // @@protoc_insertion_point(class_scope:sg.UserHuntService.HuntRequest)
 private:
  void set_has_cmd();
  void clear_has_cmd();
  void set_has_hunt_groundid();
  void clear_has_hunt_groundid();
  void set_has_trapid();
  void clear_has_trapid();
  void set_has_preyid();
  void clear_has_preyid();
  void set_has_toolid();
  void clear_has_toolid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > fishid_list_;
  ::google::protobuf::uint64 hunt_groundid_;
  ::google::protobuf::int32 trapid_;
  ::google::protobuf::int32 preyid_;
  ::google::protobuf::int32 toolid_;
  int cmd_;
  friend struct ::protobuf_UserHunt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserHuntService_HuntResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.UserHuntService.HuntResponse) */ {
 public:
  UserHuntService_HuntResponse();
  virtual ~UserHuntService_HuntResponse();

  UserHuntService_HuntResponse(const UserHuntService_HuntResponse& from);

  inline UserHuntService_HuntResponse& operator=(const UserHuntService_HuntResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserHuntService_HuntResponse(UserHuntService_HuntResponse&& from) noexcept
    : UserHuntService_HuntResponse() {
    *this = ::std::move(from);
  }

  inline UserHuntService_HuntResponse& operator=(UserHuntService_HuntResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserHuntService_HuntResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserHuntService_HuntResponse* internal_default_instance() {
    return reinterpret_cast<const UserHuntService_HuntResponse*>(
               &_UserHuntService_HuntResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void UnsafeArenaSwap(UserHuntService_HuntResponse* other);
  void Swap(UserHuntService_HuntResponse* other);
  friend void swap(UserHuntService_HuntResponse& a, UserHuntService_HuntResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserHuntService_HuntResponse* New() const final {
    return CreateMaybeMessage<UserHuntService_HuntResponse>(NULL);
  }

  UserHuntService_HuntResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserHuntService_HuntResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserHuntService_HuntResponse& from);
  void MergeFrom(const UserHuntService_HuntResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserHuntService_HuntResponse* other);
  protected:
  explicit UserHuntService_HuntResponse(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .sg.HuntPreyList prey_list = 2;
  bool has_prey_list() const;
  void clear_prey_list();
  static const int kPreyListFieldNumber = 2;
  private:
  const ::sg::HuntPreyList& _internal_prey_list() const;
  public:
  const ::sg::HuntPreyList& prey_list() const;
  ::sg::HuntPreyList* release_prey_list();
  ::sg::HuntPreyList* mutable_prey_list();
  void set_allocated_prey_list(::sg::HuntPreyList* prey_list);
  void unsafe_arena_set_allocated_prey_list(
      ::sg::HuntPreyList* prey_list);
  ::sg::HuntPreyList* unsafe_arena_release_prey_list();

  // optional .sg.HuntGroundInfo ground_info = 3;
  bool has_ground_info() const;
  void clear_ground_info();
  static const int kGroundInfoFieldNumber = 3;
  private:
  const ::sg::HuntGroundInfo& _internal_ground_info() const;
  public:
  const ::sg::HuntGroundInfo& ground_info() const;
  ::sg::HuntGroundInfo* release_ground_info();
  ::sg::HuntGroundInfo* mutable_ground_info();
  void set_allocated_ground_info(::sg::HuntGroundInfo* ground_info);
  void unsafe_arena_set_allocated_ground_info(
      ::sg::HuntGroundInfo* ground_info);
  ::sg::HuntGroundInfo* unsafe_arena_release_ground_info();

  // optional .sg.HuntPreyDropList prey_drop_list = 4;
  bool has_prey_drop_list() const;
  void clear_prey_drop_list();
  static const int kPreyDropListFieldNumber = 4;
  private:
  const ::sg::HuntPreyDropList& _internal_prey_drop_list() const;
  public:
  const ::sg::HuntPreyDropList& prey_drop_list() const;
  ::sg::HuntPreyDropList* release_prey_drop_list();
  ::sg::HuntPreyDropList* mutable_prey_drop_list();
  void set_allocated_prey_drop_list(::sg::HuntPreyDropList* prey_drop_list);
  void unsafe_arena_set_allocated_prey_drop_list(
      ::sg::HuntPreyDropList* prey_drop_list);
  ::sg::HuntPreyDropList* unsafe_arena_release_prey_drop_list();

  // required int32 result = 1;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::google::protobuf::int32 result() const;
  void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.UserHuntService.HuntResponse)
 private:
  void set_has_result();
  void clear_has_result();
  void set_has_prey_list();
  void clear_has_prey_list();
  void set_has_ground_info();
  void clear_has_ground_info();
  void set_has_prey_drop_list();
  void clear_has_prey_drop_list();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::sg::HuntPreyList* prey_list_;
  ::sg::HuntGroundInfo* ground_info_;
  ::sg::HuntPreyDropList* prey_drop_list_;
  ::google::protobuf::int32 result_;
  friend struct ::protobuf_UserHunt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserHuntService : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.UserHuntService) */ {
 public:
  UserHuntService();
  virtual ~UserHuntService();

  UserHuntService(const UserHuntService& from);

  inline UserHuntService& operator=(const UserHuntService& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserHuntService(UserHuntService&& from) noexcept
    : UserHuntService() {
    *this = ::std::move(from);
  }

  inline UserHuntService& operator=(UserHuntService&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserHuntService& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserHuntService* internal_default_instance() {
    return reinterpret_cast<const UserHuntService*>(
               &_UserHuntService_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void UnsafeArenaSwap(UserHuntService* other);
  void Swap(UserHuntService* other);
  friend void swap(UserHuntService& a, UserHuntService& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserHuntService* New() const final {
    return CreateMaybeMessage<UserHuntService>(NULL);
  }

  UserHuntService* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserHuntService>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserHuntService& from);
  void MergeFrom(const UserHuntService& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserHuntService* other);
  protected:
  explicit UserHuntService(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UserHuntService_HuntRequest HuntRequest;
  typedef UserHuntService_HuntResponse HuntResponse;

  typedef UserHuntService_HUNT_COMMAND HUNT_COMMAND;
  static const HUNT_COMMAND QUERY =
    UserHuntService_HUNT_COMMAND_QUERY;
  static const HUNT_COMMAND ENTER =
    UserHuntService_HUNT_COMMAND_ENTER;
  static const HUNT_COMMAND TRAP =
    UserHuntService_HUNT_COMMAND_TRAP;
  static const HUNT_COMMAND FISHING_NET =
    UserHuntService_HUNT_COMMAND_FISHING_NET;
  static const HUNT_COMMAND FISHING_ROD =
    UserHuntService_HUNT_COMMAND_FISHING_ROD;
  static const HUNT_COMMAND FISHING_HARPOON =
    UserHuntService_HUNT_COMMAND_FISHING_HARPOON;
  static inline bool HUNT_COMMAND_IsValid(int value) {
    return UserHuntService_HUNT_COMMAND_IsValid(value);
  }
  static const HUNT_COMMAND HUNT_COMMAND_MIN =
    UserHuntService_HUNT_COMMAND_HUNT_COMMAND_MIN;
  static const HUNT_COMMAND HUNT_COMMAND_MAX =
    UserHuntService_HUNT_COMMAND_HUNT_COMMAND_MAX;
  static const int HUNT_COMMAND_ARRAYSIZE =
    UserHuntService_HUNT_COMMAND_HUNT_COMMAND_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  HUNT_COMMAND_descriptor() {
    return UserHuntService_HUNT_COMMAND_descriptor();
  }
  static inline const ::std::string& HUNT_COMMAND_Name(HUNT_COMMAND value) {
    return UserHuntService_HUNT_COMMAND_Name(value);
  }
  static inline bool HUNT_COMMAND_Parse(const ::std::string& name,
      HUNT_COMMAND* value) {
    return UserHuntService_HUNT_COMMAND_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .sg.UserHuntService.HuntRequest req = 1;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 1;
  private:
  const ::sg::UserHuntService_HuntRequest& _internal_req() const;
  public:
  const ::sg::UserHuntService_HuntRequest& req() const;
  ::sg::UserHuntService_HuntRequest* release_req();
  ::sg::UserHuntService_HuntRequest* mutable_req();
  void set_allocated_req(::sg::UserHuntService_HuntRequest* req);
  void unsafe_arena_set_allocated_req(
      ::sg::UserHuntService_HuntRequest* req);
  ::sg::UserHuntService_HuntRequest* unsafe_arena_release_req();

  // optional .sg.UserHuntService.HuntResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  private:
  const ::sg::UserHuntService_HuntResponse& _internal_resp() const;
  public:
  const ::sg::UserHuntService_HuntResponse& resp() const;
  ::sg::UserHuntService_HuntResponse* release_resp();
  ::sg::UserHuntService_HuntResponse* mutable_resp();
  void set_allocated_resp(::sg::UserHuntService_HuntResponse* resp);
  void unsafe_arena_set_allocated_resp(
      ::sg::UserHuntService_HuntResponse* resp);
  ::sg::UserHuntService_HuntResponse* unsafe_arena_release_resp();

  // @@protoc_insertion_point(class_scope:sg.UserHuntService)
 private:
  void set_has_req();
  void clear_has_req();
  void set_has_resp();
  void clear_has_resp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::sg::UserHuntService_HuntRequest* req_;
  ::sg::UserHuntService_HuntResponse* resp_;
  friend struct ::protobuf_UserHunt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HuntGroundStateNotify : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.HuntGroundStateNotify) */ {
 public:
  HuntGroundStateNotify();
  virtual ~HuntGroundStateNotify();

  HuntGroundStateNotify(const HuntGroundStateNotify& from);

  inline HuntGroundStateNotify& operator=(const HuntGroundStateNotify& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HuntGroundStateNotify(HuntGroundStateNotify&& from) noexcept
    : HuntGroundStateNotify() {
    *this = ::std::move(from);
  }

  inline HuntGroundStateNotify& operator=(HuntGroundStateNotify&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const HuntGroundStateNotify& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HuntGroundStateNotify* internal_default_instance() {
    return reinterpret_cast<const HuntGroundStateNotify*>(
               &_HuntGroundStateNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void UnsafeArenaSwap(HuntGroundStateNotify* other);
  void Swap(HuntGroundStateNotify* other);
  friend void swap(HuntGroundStateNotify& a, HuntGroundStateNotify& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HuntGroundStateNotify* New() const final {
    return CreateMaybeMessage<HuntGroundStateNotify>(NULL);
  }

  HuntGroundStateNotify* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HuntGroundStateNotify>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HuntGroundStateNotify& from);
  void MergeFrom(const HuntGroundStateNotify& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HuntGroundStateNotify* other);
  protected:
  explicit HuntGroundStateNotify(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .sg.HuntGroundInfo ground_info = 1;
  bool has_ground_info() const;
  void clear_ground_info();
  static const int kGroundInfoFieldNumber = 1;
  private:
  const ::sg::HuntGroundInfo& _internal_ground_info() const;
  public:
  const ::sg::HuntGroundInfo& ground_info() const;
  ::sg::HuntGroundInfo* release_ground_info();
  ::sg::HuntGroundInfo* mutable_ground_info();
  void set_allocated_ground_info(::sg::HuntGroundInfo* ground_info);
  void unsafe_arena_set_allocated_ground_info(
      ::sg::HuntGroundInfo* ground_info);
  ::sg::HuntGroundInfo* unsafe_arena_release_ground_info();

  // @@protoc_insertion_point(class_scope:sg.HuntGroundStateNotify)
 private:
  void set_has_ground_info();
  void clear_has_ground_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::sg::HuntGroundInfo* ground_info_;
  friend struct ::protobuf_UserHunt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HuntPreyStateNotify : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.HuntPreyStateNotify) */ {
 public:
  HuntPreyStateNotify();
  virtual ~HuntPreyStateNotify();

  HuntPreyStateNotify(const HuntPreyStateNotify& from);

  inline HuntPreyStateNotify& operator=(const HuntPreyStateNotify& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HuntPreyStateNotify(HuntPreyStateNotify&& from) noexcept
    : HuntPreyStateNotify() {
    *this = ::std::move(from);
  }

  inline HuntPreyStateNotify& operator=(HuntPreyStateNotify&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const HuntPreyStateNotify& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HuntPreyStateNotify* internal_default_instance() {
    return reinterpret_cast<const HuntPreyStateNotify*>(
               &_HuntPreyStateNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void UnsafeArenaSwap(HuntPreyStateNotify* other);
  void Swap(HuntPreyStateNotify* other);
  friend void swap(HuntPreyStateNotify& a, HuntPreyStateNotify& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HuntPreyStateNotify* New() const final {
    return CreateMaybeMessage<HuntPreyStateNotify>(NULL);
  }

  HuntPreyStateNotify* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HuntPreyStateNotify>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HuntPreyStateNotify& from);
  void MergeFrom(const HuntPreyStateNotify& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HuntPreyStateNotify* other);
  protected:
  explicit HuntPreyStateNotify(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .sg.HuntPreyList prey_list = 2;
  bool has_prey_list() const;
  void clear_prey_list();
  static const int kPreyListFieldNumber = 2;
  private:
  const ::sg::HuntPreyList& _internal_prey_list() const;
  public:
  const ::sg::HuntPreyList& prey_list() const;
  ::sg::HuntPreyList* release_prey_list();
  ::sg::HuntPreyList* mutable_prey_list();
  void set_allocated_prey_list(::sg::HuntPreyList* prey_list);
  void unsafe_arena_set_allocated_prey_list(
      ::sg::HuntPreyList* prey_list);
  ::sg::HuntPreyList* unsafe_arena_release_prey_list();

  // optional .sg.ItemDropList prey_drop_item_list = 11;
  bool has_prey_drop_item_list() const;
  void clear_prey_drop_item_list();
  static const int kPreyDropItemListFieldNumber = 11;
  private:
  const ::sg::ItemDropList& _internal_prey_drop_item_list() const;
  public:
  const ::sg::ItemDropList& prey_drop_item_list() const;
  ::sg::ItemDropList* release_prey_drop_item_list();
  ::sg::ItemDropList* mutable_prey_drop_item_list();
  void set_allocated_prey_drop_item_list(::sg::ItemDropList* prey_drop_item_list);
  void unsafe_arena_set_allocated_prey_drop_item_list(
      ::sg::ItemDropList* prey_drop_item_list);
  ::sg::ItemDropList* unsafe_arena_release_prey_drop_item_list();

  // required uint64 groundid = 1;
  bool has_groundid() const;
  void clear_groundid();
  static const int kGroundidFieldNumber = 1;
  ::google::protobuf::uint64 groundid() const;
  void set_groundid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:sg.HuntPreyStateNotify)
 private:
  void set_has_groundid();
  void clear_has_groundid();
  void set_has_prey_list();
  void clear_has_prey_list();
  void set_has_prey_drop_item_list();
  void clear_has_prey_drop_item_list();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::sg::HuntPreyList* prey_list_;
  ::sg::ItemDropList* prey_drop_item_list_;
  ::google::protobuf::uint64 groundid_;
  friend struct ::protobuf_UserHunt_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// HuntGroundInfo

// required uint64 groundid = 1;
inline bool HuntGroundInfo::has_groundid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HuntGroundInfo::set_has_groundid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HuntGroundInfo::clear_has_groundid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HuntGroundInfo::clear_groundid() {
  groundid_ = GOOGLE_ULONGLONG(0);
  clear_has_groundid();
}
inline ::google::protobuf::uint64 HuntGroundInfo::groundid() const {
  // @@protoc_insertion_point(field_get:sg.HuntGroundInfo.groundid)
  return groundid_;
}
inline void HuntGroundInfo::set_groundid(::google::protobuf::uint64 value) {
  set_has_groundid();
  groundid_ = value;
  // @@protoc_insertion_point(field_set:sg.HuntGroundInfo.groundid)
}

// optional .sg.HUNT_GROUND_STATE state = 2;
inline bool HuntGroundInfo::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HuntGroundInfo::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HuntGroundInfo::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HuntGroundInfo::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::sg::HUNT_GROUND_STATE HuntGroundInfo::state() const {
  // @@protoc_insertion_point(field_get:sg.HuntGroundInfo.state)
  return static_cast< ::sg::HUNT_GROUND_STATE >(state_);
}
inline void HuntGroundInfo::set_state(::sg::HUNT_GROUND_STATE value) {
  assert(::sg::HUNT_GROUND_STATE_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:sg.HuntGroundInfo.state)
}

// optional int32 hunt_num = 3;
inline bool HuntGroundInfo::has_hunt_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HuntGroundInfo::set_has_hunt_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HuntGroundInfo::clear_has_hunt_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HuntGroundInfo::clear_hunt_num() {
  hunt_num_ = 0;
  clear_has_hunt_num();
}
inline ::google::protobuf::int32 HuntGroundInfo::hunt_num() const {
  // @@protoc_insertion_point(field_get:sg.HuntGroundInfo.hunt_num)
  return hunt_num_;
}
inline void HuntGroundInfo::set_hunt_num(::google::protobuf::int32 value) {
  set_has_hunt_num();
  hunt_num_ = value;
  // @@protoc_insertion_point(field_set:sg.HuntGroundInfo.hunt_num)
}

// optional sfixed64 hunt_recover_starttime = 4;
inline bool HuntGroundInfo::has_hunt_recover_starttime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HuntGroundInfo::set_has_hunt_recover_starttime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HuntGroundInfo::clear_has_hunt_recover_starttime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HuntGroundInfo::clear_hunt_recover_starttime() {
  hunt_recover_starttime_ = GOOGLE_LONGLONG(0);
  clear_has_hunt_recover_starttime();
}
inline ::google::protobuf::int64 HuntGroundInfo::hunt_recover_starttime() const {
  // @@protoc_insertion_point(field_get:sg.HuntGroundInfo.hunt_recover_starttime)
  return hunt_recover_starttime_;
}
inline void HuntGroundInfo::set_hunt_recover_starttime(::google::protobuf::int64 value) {
  set_has_hunt_recover_starttime();
  hunt_recover_starttime_ = value;
  // @@protoc_insertion_point(field_set:sg.HuntGroundInfo.hunt_recover_starttime)
}

// optional int32 hunt_recover_cd_seconds = 5;
inline bool HuntGroundInfo::has_hunt_recover_cd_seconds() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HuntGroundInfo::set_has_hunt_recover_cd_seconds() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HuntGroundInfo::clear_has_hunt_recover_cd_seconds() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HuntGroundInfo::clear_hunt_recover_cd_seconds() {
  hunt_recover_cd_seconds_ = 0;
  clear_has_hunt_recover_cd_seconds();
}
inline ::google::protobuf::int32 HuntGroundInfo::hunt_recover_cd_seconds() const {
  // @@protoc_insertion_point(field_get:sg.HuntGroundInfo.hunt_recover_cd_seconds)
  return hunt_recover_cd_seconds_;
}
inline void HuntGroundInfo::set_hunt_recover_cd_seconds(::google::protobuf::int32 value) {
  set_has_hunt_recover_cd_seconds();
  hunt_recover_cd_seconds_ = value;
  // @@protoc_insertion_point(field_set:sg.HuntGroundInfo.hunt_recover_cd_seconds)
}

// optional float hunt_recover_add_ratio1 = 6;
inline bool HuntGroundInfo::has_hunt_recover_add_ratio1() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HuntGroundInfo::set_has_hunt_recover_add_ratio1() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HuntGroundInfo::clear_has_hunt_recover_add_ratio1() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HuntGroundInfo::clear_hunt_recover_add_ratio1() {
  hunt_recover_add_ratio1_ = 0;
  clear_has_hunt_recover_add_ratio1();
}
inline float HuntGroundInfo::hunt_recover_add_ratio1() const {
  // @@protoc_insertion_point(field_get:sg.HuntGroundInfo.hunt_recover_add_ratio1)
  return hunt_recover_add_ratio1_;
}
inline void HuntGroundInfo::set_hunt_recover_add_ratio1(float value) {
  set_has_hunt_recover_add_ratio1();
  hunt_recover_add_ratio1_ = value;
  // @@protoc_insertion_point(field_set:sg.HuntGroundInfo.hunt_recover_add_ratio1)
}

// optional float hunt_recover_add_ratio2 = 7;
inline bool HuntGroundInfo::has_hunt_recover_add_ratio2() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void HuntGroundInfo::set_has_hunt_recover_add_ratio2() {
  _has_bits_[0] |= 0x00000040u;
}
inline void HuntGroundInfo::clear_has_hunt_recover_add_ratio2() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void HuntGroundInfo::clear_hunt_recover_add_ratio2() {
  hunt_recover_add_ratio2_ = 0;
  clear_has_hunt_recover_add_ratio2();
}
inline float HuntGroundInfo::hunt_recover_add_ratio2() const {
  // @@protoc_insertion_point(field_get:sg.HuntGroundInfo.hunt_recover_add_ratio2)
  return hunt_recover_add_ratio2_;
}
inline void HuntGroundInfo::set_hunt_recover_add_ratio2(float value) {
  set_has_hunt_recover_add_ratio2();
  hunt_recover_add_ratio2_ = value;
  // @@protoc_insertion_point(field_set:sg.HuntGroundInfo.hunt_recover_add_ratio2)
}

// optional float hunt_recover_add_ratio3 = 8;
inline bool HuntGroundInfo::has_hunt_recover_add_ratio3() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void HuntGroundInfo::set_has_hunt_recover_add_ratio3() {
  _has_bits_[0] |= 0x00000080u;
}
inline void HuntGroundInfo::clear_has_hunt_recover_add_ratio3() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void HuntGroundInfo::clear_hunt_recover_add_ratio3() {
  hunt_recover_add_ratio3_ = 0;
  clear_has_hunt_recover_add_ratio3();
}
inline float HuntGroundInfo::hunt_recover_add_ratio3() const {
  // @@protoc_insertion_point(field_get:sg.HuntGroundInfo.hunt_recover_add_ratio3)
  return hunt_recover_add_ratio3_;
}
inline void HuntGroundInfo::set_hunt_recover_add_ratio3(float value) {
  set_has_hunt_recover_add_ratio3();
  hunt_recover_add_ratio3_ = value;
  // @@protoc_insertion_point(field_set:sg.HuntGroundInfo.hunt_recover_add_ratio3)
}

// optional int32 prey_hunt_num_max = 11;
inline bool HuntGroundInfo::has_prey_hunt_num_max() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void HuntGroundInfo::set_has_prey_hunt_num_max() {
  _has_bits_[0] |= 0x00000100u;
}
inline void HuntGroundInfo::clear_has_prey_hunt_num_max() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void HuntGroundInfo::clear_prey_hunt_num_max() {
  prey_hunt_num_max_ = 0;
  clear_has_prey_hunt_num_max();
}
inline ::google::protobuf::int32 HuntGroundInfo::prey_hunt_num_max() const {
  // @@protoc_insertion_point(field_get:sg.HuntGroundInfo.prey_hunt_num_max)
  return prey_hunt_num_max_;
}
inline void HuntGroundInfo::set_prey_hunt_num_max(::google::protobuf::int32 value) {
  set_has_prey_hunt_num_max();
  prey_hunt_num_max_ = value;
  // @@protoc_insertion_point(field_set:sg.HuntGroundInfo.prey_hunt_num_max)
}

// optional sfixed64 growtime = 12;
inline bool HuntGroundInfo::has_growtime() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void HuntGroundInfo::set_has_growtime() {
  _has_bits_[0] |= 0x00000200u;
}
inline void HuntGroundInfo::clear_has_growtime() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void HuntGroundInfo::clear_growtime() {
  growtime_ = GOOGLE_LONGLONG(0);
  clear_has_growtime();
}
inline ::google::protobuf::int64 HuntGroundInfo::growtime() const {
  // @@protoc_insertion_point(field_get:sg.HuntGroundInfo.growtime)
  return growtime_;
}
inline void HuntGroundInfo::set_growtime(::google::protobuf::int64 value) {
  set_has_growtime();
  growtime_ = value;
  // @@protoc_insertion_point(field_set:sg.HuntGroundInfo.growtime)
}

// -------------------------------------------------------------------

// HuntPrey

// required int32 preyid = 1;
inline bool HuntPrey::has_preyid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HuntPrey::set_has_preyid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HuntPrey::clear_has_preyid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HuntPrey::clear_preyid() {
  preyid_ = 0;
  clear_has_preyid();
}
inline ::google::protobuf::int32 HuntPrey::preyid() const {
  // @@protoc_insertion_point(field_get:sg.HuntPrey.preyid)
  return preyid_;
}
inline void HuntPrey::set_preyid(::google::protobuf::int32 value) {
  set_has_preyid();
  preyid_ = value;
  // @@protoc_insertion_point(field_set:sg.HuntPrey.preyid)
}

// optional .sg.HUNT_PREY_TYPE prey_type = 2;
inline bool HuntPrey::has_prey_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HuntPrey::set_has_prey_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HuntPrey::clear_has_prey_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HuntPrey::clear_prey_type() {
  prey_type_ = 0;
  clear_has_prey_type();
}
inline ::sg::HUNT_PREY_TYPE HuntPrey::prey_type() const {
  // @@protoc_insertion_point(field_get:sg.HuntPrey.prey_type)
  return static_cast< ::sg::HUNT_PREY_TYPE >(prey_type_);
}
inline void HuntPrey::set_prey_type(::sg::HUNT_PREY_TYPE value) {
  assert(::sg::HUNT_PREY_TYPE_IsValid(value));
  set_has_prey_type();
  prey_type_ = value;
  // @@protoc_insertion_point(field_set:sg.HuntPrey.prey_type)
}

// optional uint64 cfgid = 3;
inline bool HuntPrey::has_cfgid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HuntPrey::set_has_cfgid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HuntPrey::clear_has_cfgid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HuntPrey::clear_cfgid() {
  cfgid_ = GOOGLE_ULONGLONG(0);
  clear_has_cfgid();
}
inline ::google::protobuf::uint64 HuntPrey::cfgid() const {
  // @@protoc_insertion_point(field_get:sg.HuntPrey.cfgid)
  return cfgid_;
}
inline void HuntPrey::set_cfgid(::google::protobuf::uint64 value) {
  set_has_cfgid();
  cfgid_ = value;
  // @@protoc_insertion_point(field_set:sg.HuntPrey.cfgid)
}

// optional int32 cfg_groupid = 4;
inline bool HuntPrey::has_cfg_groupid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HuntPrey::set_has_cfg_groupid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HuntPrey::clear_has_cfg_groupid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HuntPrey::clear_cfg_groupid() {
  cfg_groupid_ = 0;
  clear_has_cfg_groupid();
}
inline ::google::protobuf::int32 HuntPrey::cfg_groupid() const {
  // @@protoc_insertion_point(field_get:sg.HuntPrey.cfg_groupid)
  return cfg_groupid_;
}
inline void HuntPrey::set_cfg_groupid(::google::protobuf::int32 value) {
  set_has_cfg_groupid();
  cfg_groupid_ = value;
  // @@protoc_insertion_point(field_set:sg.HuntPrey.cfg_groupid)
}

// optional .sg.HuntPrey.PREY_STATE state = 5;
inline bool HuntPrey::has_state() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void HuntPrey::set_has_state() {
  _has_bits_[0] |= 0x00000040u;
}
inline void HuntPrey::clear_has_state() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void HuntPrey::clear_state() {
  state_ = -1;
  clear_has_state();
}
inline ::sg::HuntPrey_PREY_STATE HuntPrey::state() const {
  // @@protoc_insertion_point(field_get:sg.HuntPrey.state)
  return static_cast< ::sg::HuntPrey_PREY_STATE >(state_);
}
inline void HuntPrey::set_state(::sg::HuntPrey_PREY_STATE value) {
  assert(::sg::HuntPrey_PREY_STATE_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:sg.HuntPrey.state)
}

// optional int32 seconds = 6;
inline bool HuntPrey::has_seconds() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HuntPrey::set_has_seconds() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HuntPrey::clear_has_seconds() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HuntPrey::clear_seconds() {
  seconds_ = 0;
  clear_has_seconds();
}
inline ::google::protobuf::int32 HuntPrey::seconds() const {
  // @@protoc_insertion_point(field_get:sg.HuntPrey.seconds)
  return seconds_;
}
inline void HuntPrey::set_seconds(::google::protobuf::int32 value) {
  set_has_seconds();
  seconds_ = value;
  // @@protoc_insertion_point(field_set:sg.HuntPrey.seconds)
}

// optional sfixed64 optime = 21;
inline bool HuntPrey::has_optime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HuntPrey::set_has_optime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HuntPrey::clear_has_optime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HuntPrey::clear_optime() {
  optime_ = GOOGLE_LONGLONG(0);
  clear_has_optime();
}
inline ::google::protobuf::int64 HuntPrey::optime() const {
  // @@protoc_insertion_point(field_get:sg.HuntPrey.optime)
  return optime_;
}
inline void HuntPrey::set_optime(::google::protobuf::int64 value) {
  set_has_optime();
  optime_ = value;
  // @@protoc_insertion_point(field_set:sg.HuntPrey.optime)
}

// -------------------------------------------------------------------

// HuntPreyList

// repeated .sg.HuntPrey list = 1;
inline int HuntPreyList::list_size() const {
  return list_.size();
}
inline void HuntPreyList::clear_list() {
  list_.Clear();
}
inline ::sg::HuntPrey* HuntPreyList::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:sg.HuntPreyList.list)
  return list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::HuntPrey >*
HuntPreyList::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:sg.HuntPreyList.list)
  return &list_;
}
inline const ::sg::HuntPrey& HuntPreyList::list(int index) const {
  // @@protoc_insertion_point(field_get:sg.HuntPreyList.list)
  return list_.Get(index);
}
inline ::sg::HuntPrey* HuntPreyList::add_list() {
  // @@protoc_insertion_point(field_add:sg.HuntPreyList.list)
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::HuntPrey >&
HuntPreyList::list() const {
  // @@protoc_insertion_point(field_list:sg.HuntPreyList.list)
  return list_;
}

// -------------------------------------------------------------------

// HuntPreyDrop

// optional int32 preyid = 1;
inline bool HuntPreyDrop::has_preyid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HuntPreyDrop::set_has_preyid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HuntPreyDrop::clear_has_preyid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HuntPreyDrop::clear_preyid() {
  preyid_ = 0;
  clear_has_preyid();
}
inline ::google::protobuf::int32 HuntPreyDrop::preyid() const {
  // @@protoc_insertion_point(field_get:sg.HuntPreyDrop.preyid)
  return preyid_;
}
inline void HuntPreyDrop::set_preyid(::google::protobuf::int32 value) {
  set_has_preyid();
  preyid_ = value;
  // @@protoc_insertion_point(field_set:sg.HuntPreyDrop.preyid)
}

// optional .sg.ItemDropList drop_item_list = 2;
inline bool HuntPreyDrop::has_drop_item_list() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HuntPreyDrop::set_has_drop_item_list() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HuntPreyDrop::clear_has_drop_item_list() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::sg::ItemDropList& HuntPreyDrop::_internal_drop_item_list() const {
  return *drop_item_list_;
}
inline const ::sg::ItemDropList& HuntPreyDrop::drop_item_list() const {
  const ::sg::ItemDropList* p = drop_item_list_;
  // @@protoc_insertion_point(field_get:sg.HuntPreyDrop.drop_item_list)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::ItemDropList*>(
      &::sg::_ItemDropList_default_instance_);
}
inline ::sg::ItemDropList* HuntPreyDrop::release_drop_item_list() {
  // @@protoc_insertion_point(field_release:sg.HuntPreyDrop.drop_item_list)
  clear_has_drop_item_list();
  ::sg::ItemDropList* temp = drop_item_list_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  drop_item_list_ = NULL;
  return temp;
}
inline ::sg::ItemDropList* HuntPreyDrop::unsafe_arena_release_drop_item_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.HuntPreyDrop.drop_item_list)
  clear_has_drop_item_list();
  ::sg::ItemDropList* temp = drop_item_list_;
  drop_item_list_ = NULL;
  return temp;
}
inline ::sg::ItemDropList* HuntPreyDrop::mutable_drop_item_list() {
  set_has_drop_item_list();
  if (drop_item_list_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::ItemDropList>(GetArenaNoVirtual());
    drop_item_list_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.HuntPreyDrop.drop_item_list)
  return drop_item_list_;
}
inline void HuntPreyDrop::set_allocated_drop_item_list(::sg::ItemDropList* drop_item_list) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(drop_item_list_);
  }
  if (drop_item_list) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(drop_item_list)->GetArena();
    if (message_arena != submessage_arena) {
      drop_item_list = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, drop_item_list, submessage_arena);
    }
    set_has_drop_item_list();
  } else {
    clear_has_drop_item_list();
  }
  drop_item_list_ = drop_item_list;
  // @@protoc_insertion_point(field_set_allocated:sg.HuntPreyDrop.drop_item_list)
}

// -------------------------------------------------------------------

// HuntPreyDropList

// repeated .sg.HuntPreyDrop list = 1;
inline int HuntPreyDropList::list_size() const {
  return list_.size();
}
inline void HuntPreyDropList::clear_list() {
  list_.Clear();
}
inline ::sg::HuntPreyDrop* HuntPreyDropList::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:sg.HuntPreyDropList.list)
  return list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::HuntPreyDrop >*
HuntPreyDropList::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:sg.HuntPreyDropList.list)
  return &list_;
}
inline const ::sg::HuntPreyDrop& HuntPreyDropList::list(int index) const {
  // @@protoc_insertion_point(field_get:sg.HuntPreyDropList.list)
  return list_.Get(index);
}
inline ::sg::HuntPreyDrop* HuntPreyDropList::add_list() {
  // @@protoc_insertion_point(field_add:sg.HuntPreyDropList.list)
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::HuntPreyDrop >&
HuntPreyDropList::list() const {
  // @@protoc_insertion_point(field_list:sg.HuntPreyDropList.list)
  return list_;
}

// -------------------------------------------------------------------

// UserHuntService_HuntRequest

// required .sg.UserHuntService.HUNT_COMMAND cmd = 1;
inline bool UserHuntService_HuntRequest::has_cmd() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserHuntService_HuntRequest::set_has_cmd() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserHuntService_HuntRequest::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserHuntService_HuntRequest::clear_cmd() {
  cmd_ = 1;
  clear_has_cmd();
}
inline ::sg::UserHuntService_HUNT_COMMAND UserHuntService_HuntRequest::cmd() const {
  // @@protoc_insertion_point(field_get:sg.UserHuntService.HuntRequest.cmd)
  return static_cast< ::sg::UserHuntService_HUNT_COMMAND >(cmd_);
}
inline void UserHuntService_HuntRequest::set_cmd(::sg::UserHuntService_HUNT_COMMAND value) {
  assert(::sg::UserHuntService_HUNT_COMMAND_IsValid(value));
  set_has_cmd();
  cmd_ = value;
  // @@protoc_insertion_point(field_set:sg.UserHuntService.HuntRequest.cmd)
}

// optional uint64 hunt_groundid = 2;
inline bool UserHuntService_HuntRequest::has_hunt_groundid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserHuntService_HuntRequest::set_has_hunt_groundid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserHuntService_HuntRequest::clear_has_hunt_groundid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserHuntService_HuntRequest::clear_hunt_groundid() {
  hunt_groundid_ = GOOGLE_ULONGLONG(0);
  clear_has_hunt_groundid();
}
inline ::google::protobuf::uint64 UserHuntService_HuntRequest::hunt_groundid() const {
  // @@protoc_insertion_point(field_get:sg.UserHuntService.HuntRequest.hunt_groundid)
  return hunt_groundid_;
}
inline void UserHuntService_HuntRequest::set_hunt_groundid(::google::protobuf::uint64 value) {
  set_has_hunt_groundid();
  hunt_groundid_ = value;
  // @@protoc_insertion_point(field_set:sg.UserHuntService.HuntRequest.hunt_groundid)
}

// optional int32 trapid = 3;
inline bool UserHuntService_HuntRequest::has_trapid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserHuntService_HuntRequest::set_has_trapid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserHuntService_HuntRequest::clear_has_trapid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserHuntService_HuntRequest::clear_trapid() {
  trapid_ = 0;
  clear_has_trapid();
}
inline ::google::protobuf::int32 UserHuntService_HuntRequest::trapid() const {
  // @@protoc_insertion_point(field_get:sg.UserHuntService.HuntRequest.trapid)
  return trapid_;
}
inline void UserHuntService_HuntRequest::set_trapid(::google::protobuf::int32 value) {
  set_has_trapid();
  trapid_ = value;
  // @@protoc_insertion_point(field_set:sg.UserHuntService.HuntRequest.trapid)
}

// optional int32 preyid = 4;
inline bool UserHuntService_HuntRequest::has_preyid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserHuntService_HuntRequest::set_has_preyid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserHuntService_HuntRequest::clear_has_preyid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserHuntService_HuntRequest::clear_preyid() {
  preyid_ = 0;
  clear_has_preyid();
}
inline ::google::protobuf::int32 UserHuntService_HuntRequest::preyid() const {
  // @@protoc_insertion_point(field_get:sg.UserHuntService.HuntRequest.preyid)
  return preyid_;
}
inline void UserHuntService_HuntRequest::set_preyid(::google::protobuf::int32 value) {
  set_has_preyid();
  preyid_ = value;
  // @@protoc_insertion_point(field_set:sg.UserHuntService.HuntRequest.preyid)
}

// optional int32 toolid = 5;
inline bool UserHuntService_HuntRequest::has_toolid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserHuntService_HuntRequest::set_has_toolid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserHuntService_HuntRequest::clear_has_toolid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserHuntService_HuntRequest::clear_toolid() {
  toolid_ = 0;
  clear_has_toolid();
}
inline ::google::protobuf::int32 UserHuntService_HuntRequest::toolid() const {
  // @@protoc_insertion_point(field_get:sg.UserHuntService.HuntRequest.toolid)
  return toolid_;
}
inline void UserHuntService_HuntRequest::set_toolid(::google::protobuf::int32 value) {
  set_has_toolid();
  toolid_ = value;
  // @@protoc_insertion_point(field_set:sg.UserHuntService.HuntRequest.toolid)
}

// repeated int32 fishid_list = 6;
inline int UserHuntService_HuntRequest::fishid_list_size() const {
  return fishid_list_.size();
}
inline void UserHuntService_HuntRequest::clear_fishid_list() {
  fishid_list_.Clear();
}
inline ::google::protobuf::int32 UserHuntService_HuntRequest::fishid_list(int index) const {
  // @@protoc_insertion_point(field_get:sg.UserHuntService.HuntRequest.fishid_list)
  return fishid_list_.Get(index);
}
inline void UserHuntService_HuntRequest::set_fishid_list(int index, ::google::protobuf::int32 value) {
  fishid_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:sg.UserHuntService.HuntRequest.fishid_list)
}
inline void UserHuntService_HuntRequest::add_fishid_list(::google::protobuf::int32 value) {
  fishid_list_.Add(value);
  // @@protoc_insertion_point(field_add:sg.UserHuntService.HuntRequest.fishid_list)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
UserHuntService_HuntRequest::fishid_list() const {
  // @@protoc_insertion_point(field_list:sg.UserHuntService.HuntRequest.fishid_list)
  return fishid_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
UserHuntService_HuntRequest::mutable_fishid_list() {
  // @@protoc_insertion_point(field_mutable_list:sg.UserHuntService.HuntRequest.fishid_list)
  return &fishid_list_;
}

// -------------------------------------------------------------------

// UserHuntService_HuntResponse

// required int32 result = 1;
inline bool UserHuntService_HuntResponse::has_result() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserHuntService_HuntResponse::set_has_result() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserHuntService_HuntResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserHuntService_HuntResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 UserHuntService_HuntResponse::result() const {
  // @@protoc_insertion_point(field_get:sg.UserHuntService.HuntResponse.result)
  return result_;
}
inline void UserHuntService_HuntResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:sg.UserHuntService.HuntResponse.result)
}

// optional .sg.HuntPreyList prey_list = 2;
inline bool UserHuntService_HuntResponse::has_prey_list() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserHuntService_HuntResponse::set_has_prey_list() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserHuntService_HuntResponse::clear_has_prey_list() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserHuntService_HuntResponse::clear_prey_list() {
  if (prey_list_ != NULL) prey_list_->Clear();
  clear_has_prey_list();
}
inline const ::sg::HuntPreyList& UserHuntService_HuntResponse::_internal_prey_list() const {
  return *prey_list_;
}
inline const ::sg::HuntPreyList& UserHuntService_HuntResponse::prey_list() const {
  const ::sg::HuntPreyList* p = prey_list_;
  // @@protoc_insertion_point(field_get:sg.UserHuntService.HuntResponse.prey_list)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::HuntPreyList*>(
      &::sg::_HuntPreyList_default_instance_);
}
inline ::sg::HuntPreyList* UserHuntService_HuntResponse::release_prey_list() {
  // @@protoc_insertion_point(field_release:sg.UserHuntService.HuntResponse.prey_list)
  clear_has_prey_list();
  ::sg::HuntPreyList* temp = prey_list_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  prey_list_ = NULL;
  return temp;
}
inline ::sg::HuntPreyList* UserHuntService_HuntResponse::unsafe_arena_release_prey_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.UserHuntService.HuntResponse.prey_list)
  clear_has_prey_list();
  ::sg::HuntPreyList* temp = prey_list_;
  prey_list_ = NULL;
  return temp;
}
inline ::sg::HuntPreyList* UserHuntService_HuntResponse::mutable_prey_list() {
  set_has_prey_list();
  if (prey_list_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::HuntPreyList>(GetArenaNoVirtual());
    prey_list_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.UserHuntService.HuntResponse.prey_list)
  return prey_list_;
}
inline void UserHuntService_HuntResponse::set_allocated_prey_list(::sg::HuntPreyList* prey_list) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete prey_list_;
  }
  if (prey_list) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(prey_list);
    if (message_arena != submessage_arena) {
      prey_list = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, prey_list, submessage_arena);
    }
    set_has_prey_list();
  } else {
    clear_has_prey_list();
  }
  prey_list_ = prey_list;
  // @@protoc_insertion_point(field_set_allocated:sg.UserHuntService.HuntResponse.prey_list)
}

// optional .sg.HuntGroundInfo ground_info = 3;
inline bool UserHuntService_HuntResponse::has_ground_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserHuntService_HuntResponse::set_has_ground_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserHuntService_HuntResponse::clear_has_ground_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserHuntService_HuntResponse::clear_ground_info() {
  if (ground_info_ != NULL) ground_info_->Clear();
  clear_has_ground_info();
}
inline const ::sg::HuntGroundInfo& UserHuntService_HuntResponse::_internal_ground_info() const {
  return *ground_info_;
}
inline const ::sg::HuntGroundInfo& UserHuntService_HuntResponse::ground_info() const {
  const ::sg::HuntGroundInfo* p = ground_info_;
  // @@protoc_insertion_point(field_get:sg.UserHuntService.HuntResponse.ground_info)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::HuntGroundInfo*>(
      &::sg::_HuntGroundInfo_default_instance_);
}
inline ::sg::HuntGroundInfo* UserHuntService_HuntResponse::release_ground_info() {
  // @@protoc_insertion_point(field_release:sg.UserHuntService.HuntResponse.ground_info)
  clear_has_ground_info();
  ::sg::HuntGroundInfo* temp = ground_info_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  ground_info_ = NULL;
  return temp;
}
inline ::sg::HuntGroundInfo* UserHuntService_HuntResponse::unsafe_arena_release_ground_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.UserHuntService.HuntResponse.ground_info)
  clear_has_ground_info();
  ::sg::HuntGroundInfo* temp = ground_info_;
  ground_info_ = NULL;
  return temp;
}
inline ::sg::HuntGroundInfo* UserHuntService_HuntResponse::mutable_ground_info() {
  set_has_ground_info();
  if (ground_info_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::HuntGroundInfo>(GetArenaNoVirtual());
    ground_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.UserHuntService.HuntResponse.ground_info)
  return ground_info_;
}
inline void UserHuntService_HuntResponse::set_allocated_ground_info(::sg::HuntGroundInfo* ground_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ground_info_;
  }
  if (ground_info) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(ground_info);
    if (message_arena != submessage_arena) {
      ground_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ground_info, submessage_arena);
    }
    set_has_ground_info();
  } else {
    clear_has_ground_info();
  }
  ground_info_ = ground_info;
  // @@protoc_insertion_point(field_set_allocated:sg.UserHuntService.HuntResponse.ground_info)
}

// optional .sg.HuntPreyDropList prey_drop_list = 4;
inline bool UserHuntService_HuntResponse::has_prey_drop_list() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserHuntService_HuntResponse::set_has_prey_drop_list() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserHuntService_HuntResponse::clear_has_prey_drop_list() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserHuntService_HuntResponse::clear_prey_drop_list() {
  if (prey_drop_list_ != NULL) prey_drop_list_->Clear();
  clear_has_prey_drop_list();
}
inline const ::sg::HuntPreyDropList& UserHuntService_HuntResponse::_internal_prey_drop_list() const {
  return *prey_drop_list_;
}
inline const ::sg::HuntPreyDropList& UserHuntService_HuntResponse::prey_drop_list() const {
  const ::sg::HuntPreyDropList* p = prey_drop_list_;
  // @@protoc_insertion_point(field_get:sg.UserHuntService.HuntResponse.prey_drop_list)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::HuntPreyDropList*>(
      &::sg::_HuntPreyDropList_default_instance_);
}
inline ::sg::HuntPreyDropList* UserHuntService_HuntResponse::release_prey_drop_list() {
  // @@protoc_insertion_point(field_release:sg.UserHuntService.HuntResponse.prey_drop_list)
  clear_has_prey_drop_list();
  ::sg::HuntPreyDropList* temp = prey_drop_list_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  prey_drop_list_ = NULL;
  return temp;
}
inline ::sg::HuntPreyDropList* UserHuntService_HuntResponse::unsafe_arena_release_prey_drop_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.UserHuntService.HuntResponse.prey_drop_list)
  clear_has_prey_drop_list();
  ::sg::HuntPreyDropList* temp = prey_drop_list_;
  prey_drop_list_ = NULL;
  return temp;
}
inline ::sg::HuntPreyDropList* UserHuntService_HuntResponse::mutable_prey_drop_list() {
  set_has_prey_drop_list();
  if (prey_drop_list_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::HuntPreyDropList>(GetArenaNoVirtual());
    prey_drop_list_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.UserHuntService.HuntResponse.prey_drop_list)
  return prey_drop_list_;
}
inline void UserHuntService_HuntResponse::set_allocated_prey_drop_list(::sg::HuntPreyDropList* prey_drop_list) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete prey_drop_list_;
  }
  if (prey_drop_list) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(prey_drop_list);
    if (message_arena != submessage_arena) {
      prey_drop_list = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, prey_drop_list, submessage_arena);
    }
    set_has_prey_drop_list();
  } else {
    clear_has_prey_drop_list();
  }
  prey_drop_list_ = prey_drop_list;
  // @@protoc_insertion_point(field_set_allocated:sg.UserHuntService.HuntResponse.prey_drop_list)
}

// -------------------------------------------------------------------

// UserHuntService

// optional .sg.UserHuntService.HuntRequest req = 1;
inline bool UserHuntService::has_req() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserHuntService::set_has_req() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserHuntService::clear_has_req() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserHuntService::clear_req() {
  if (req_ != NULL) req_->Clear();
  clear_has_req();
}
inline const ::sg::UserHuntService_HuntRequest& UserHuntService::_internal_req() const {
  return *req_;
}
inline const ::sg::UserHuntService_HuntRequest& UserHuntService::req() const {
  const ::sg::UserHuntService_HuntRequest* p = req_;
  // @@protoc_insertion_point(field_get:sg.UserHuntService.req)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::UserHuntService_HuntRequest*>(
      &::sg::_UserHuntService_HuntRequest_default_instance_);
}
inline ::sg::UserHuntService_HuntRequest* UserHuntService::release_req() {
  // @@protoc_insertion_point(field_release:sg.UserHuntService.req)
  clear_has_req();
  ::sg::UserHuntService_HuntRequest* temp = req_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  req_ = NULL;
  return temp;
}
inline ::sg::UserHuntService_HuntRequest* UserHuntService::unsafe_arena_release_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.UserHuntService.req)
  clear_has_req();
  ::sg::UserHuntService_HuntRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline ::sg::UserHuntService_HuntRequest* UserHuntService::mutable_req() {
  set_has_req();
  if (req_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::UserHuntService_HuntRequest>(GetArenaNoVirtual());
    req_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.UserHuntService.req)
  return req_;
}
inline void UserHuntService::set_allocated_req(::sg::UserHuntService_HuntRequest* req) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete req_;
  }
  if (req) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(req);
    if (message_arena != submessage_arena) {
      req = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, req, submessage_arena);
    }
    set_has_req();
  } else {
    clear_has_req();
  }
  req_ = req;
  // @@protoc_insertion_point(field_set_allocated:sg.UserHuntService.req)
}

// optional .sg.UserHuntService.HuntResponse resp = 2;
inline bool UserHuntService::has_resp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserHuntService::set_has_resp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserHuntService::clear_has_resp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserHuntService::clear_resp() {
  if (resp_ != NULL) resp_->Clear();
  clear_has_resp();
}
inline const ::sg::UserHuntService_HuntResponse& UserHuntService::_internal_resp() const {
  return *resp_;
}
inline const ::sg::UserHuntService_HuntResponse& UserHuntService::resp() const {
  const ::sg::UserHuntService_HuntResponse* p = resp_;
  // @@protoc_insertion_point(field_get:sg.UserHuntService.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::UserHuntService_HuntResponse*>(
      &::sg::_UserHuntService_HuntResponse_default_instance_);
}
inline ::sg::UserHuntService_HuntResponse* UserHuntService::release_resp() {
  // @@protoc_insertion_point(field_release:sg.UserHuntService.resp)
  clear_has_resp();
  ::sg::UserHuntService_HuntResponse* temp = resp_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  resp_ = NULL;
  return temp;
}
inline ::sg::UserHuntService_HuntResponse* UserHuntService::unsafe_arena_release_resp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.UserHuntService.resp)
  clear_has_resp();
  ::sg::UserHuntService_HuntResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline ::sg::UserHuntService_HuntResponse* UserHuntService::mutable_resp() {
  set_has_resp();
  if (resp_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::UserHuntService_HuntResponse>(GetArenaNoVirtual());
    resp_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.UserHuntService.resp)
  return resp_;
}
inline void UserHuntService::set_allocated_resp(::sg::UserHuntService_HuntResponse* resp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete resp_;
  }
  if (resp) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(resp);
    if (message_arena != submessage_arena) {
      resp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, resp, submessage_arena);
    }
    set_has_resp();
  } else {
    clear_has_resp();
  }
  resp_ = resp;
  // @@protoc_insertion_point(field_set_allocated:sg.UserHuntService.resp)
}

// -------------------------------------------------------------------

// HuntGroundStateNotify

// required .sg.HuntGroundInfo ground_info = 1;
inline bool HuntGroundStateNotify::has_ground_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HuntGroundStateNotify::set_has_ground_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HuntGroundStateNotify::clear_has_ground_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HuntGroundStateNotify::clear_ground_info() {
  if (ground_info_ != NULL) ground_info_->Clear();
  clear_has_ground_info();
}
inline const ::sg::HuntGroundInfo& HuntGroundStateNotify::_internal_ground_info() const {
  return *ground_info_;
}
inline const ::sg::HuntGroundInfo& HuntGroundStateNotify::ground_info() const {
  const ::sg::HuntGroundInfo* p = ground_info_;
  // @@protoc_insertion_point(field_get:sg.HuntGroundStateNotify.ground_info)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::HuntGroundInfo*>(
      &::sg::_HuntGroundInfo_default_instance_);
}
inline ::sg::HuntGroundInfo* HuntGroundStateNotify::release_ground_info() {
  // @@protoc_insertion_point(field_release:sg.HuntGroundStateNotify.ground_info)
  clear_has_ground_info();
  ::sg::HuntGroundInfo* temp = ground_info_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  ground_info_ = NULL;
  return temp;
}
inline ::sg::HuntGroundInfo* HuntGroundStateNotify::unsafe_arena_release_ground_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.HuntGroundStateNotify.ground_info)
  clear_has_ground_info();
  ::sg::HuntGroundInfo* temp = ground_info_;
  ground_info_ = NULL;
  return temp;
}
inline ::sg::HuntGroundInfo* HuntGroundStateNotify::mutable_ground_info() {
  set_has_ground_info();
  if (ground_info_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::HuntGroundInfo>(GetArenaNoVirtual());
    ground_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.HuntGroundStateNotify.ground_info)
  return ground_info_;
}
inline void HuntGroundStateNotify::set_allocated_ground_info(::sg::HuntGroundInfo* ground_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ground_info_;
  }
  if (ground_info) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(ground_info);
    if (message_arena != submessage_arena) {
      ground_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ground_info, submessage_arena);
    }
    set_has_ground_info();
  } else {
    clear_has_ground_info();
  }
  ground_info_ = ground_info;
  // @@protoc_insertion_point(field_set_allocated:sg.HuntGroundStateNotify.ground_info)
}

// -------------------------------------------------------------------

// HuntPreyStateNotify

// required uint64 groundid = 1;
inline bool HuntPreyStateNotify::has_groundid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HuntPreyStateNotify::set_has_groundid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HuntPreyStateNotify::clear_has_groundid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HuntPreyStateNotify::clear_groundid() {
  groundid_ = GOOGLE_ULONGLONG(0);
  clear_has_groundid();
}
inline ::google::protobuf::uint64 HuntPreyStateNotify::groundid() const {
  // @@protoc_insertion_point(field_get:sg.HuntPreyStateNotify.groundid)
  return groundid_;
}
inline void HuntPreyStateNotify::set_groundid(::google::protobuf::uint64 value) {
  set_has_groundid();
  groundid_ = value;
  // @@protoc_insertion_point(field_set:sg.HuntPreyStateNotify.groundid)
}

// required .sg.HuntPreyList prey_list = 2;
inline bool HuntPreyStateNotify::has_prey_list() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HuntPreyStateNotify::set_has_prey_list() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HuntPreyStateNotify::clear_has_prey_list() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HuntPreyStateNotify::clear_prey_list() {
  if (prey_list_ != NULL) prey_list_->Clear();
  clear_has_prey_list();
}
inline const ::sg::HuntPreyList& HuntPreyStateNotify::_internal_prey_list() const {
  return *prey_list_;
}
inline const ::sg::HuntPreyList& HuntPreyStateNotify::prey_list() const {
  const ::sg::HuntPreyList* p = prey_list_;
  // @@protoc_insertion_point(field_get:sg.HuntPreyStateNotify.prey_list)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::HuntPreyList*>(
      &::sg::_HuntPreyList_default_instance_);
}
inline ::sg::HuntPreyList* HuntPreyStateNotify::release_prey_list() {
  // @@protoc_insertion_point(field_release:sg.HuntPreyStateNotify.prey_list)
  clear_has_prey_list();
  ::sg::HuntPreyList* temp = prey_list_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  prey_list_ = NULL;
  return temp;
}
inline ::sg::HuntPreyList* HuntPreyStateNotify::unsafe_arena_release_prey_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.HuntPreyStateNotify.prey_list)
  clear_has_prey_list();
  ::sg::HuntPreyList* temp = prey_list_;
  prey_list_ = NULL;
  return temp;
}
inline ::sg::HuntPreyList* HuntPreyStateNotify::mutable_prey_list() {
  set_has_prey_list();
  if (prey_list_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::HuntPreyList>(GetArenaNoVirtual());
    prey_list_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.HuntPreyStateNotify.prey_list)
  return prey_list_;
}
inline void HuntPreyStateNotify::set_allocated_prey_list(::sg::HuntPreyList* prey_list) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete prey_list_;
  }
  if (prey_list) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(prey_list);
    if (message_arena != submessage_arena) {
      prey_list = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, prey_list, submessage_arena);
    }
    set_has_prey_list();
  } else {
    clear_has_prey_list();
  }
  prey_list_ = prey_list;
  // @@protoc_insertion_point(field_set_allocated:sg.HuntPreyStateNotify.prey_list)
}

// optional .sg.ItemDropList prey_drop_item_list = 11;
inline bool HuntPreyStateNotify::has_prey_drop_item_list() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HuntPreyStateNotify::set_has_prey_drop_item_list() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HuntPreyStateNotify::clear_has_prey_drop_item_list() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::sg::ItemDropList& HuntPreyStateNotify::_internal_prey_drop_item_list() const {
  return *prey_drop_item_list_;
}
inline const ::sg::ItemDropList& HuntPreyStateNotify::prey_drop_item_list() const {
  const ::sg::ItemDropList* p = prey_drop_item_list_;
  // @@protoc_insertion_point(field_get:sg.HuntPreyStateNotify.prey_drop_item_list)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::ItemDropList*>(
      &::sg::_ItemDropList_default_instance_);
}
inline ::sg::ItemDropList* HuntPreyStateNotify::release_prey_drop_item_list() {
  // @@protoc_insertion_point(field_release:sg.HuntPreyStateNotify.prey_drop_item_list)
  clear_has_prey_drop_item_list();
  ::sg::ItemDropList* temp = prey_drop_item_list_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  prey_drop_item_list_ = NULL;
  return temp;
}
inline ::sg::ItemDropList* HuntPreyStateNotify::unsafe_arena_release_prey_drop_item_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.HuntPreyStateNotify.prey_drop_item_list)
  clear_has_prey_drop_item_list();
  ::sg::ItemDropList* temp = prey_drop_item_list_;
  prey_drop_item_list_ = NULL;
  return temp;
}
inline ::sg::ItemDropList* HuntPreyStateNotify::mutable_prey_drop_item_list() {
  set_has_prey_drop_item_list();
  if (prey_drop_item_list_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::ItemDropList>(GetArenaNoVirtual());
    prey_drop_item_list_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.HuntPreyStateNotify.prey_drop_item_list)
  return prey_drop_item_list_;
}
inline void HuntPreyStateNotify::set_allocated_prey_drop_item_list(::sg::ItemDropList* prey_drop_item_list) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(prey_drop_item_list_);
  }
  if (prey_drop_item_list) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(prey_drop_item_list)->GetArena();
    if (message_arena != submessage_arena) {
      prey_drop_item_list = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, prey_drop_item_list, submessage_arena);
    }
    set_has_prey_drop_item_list();
  } else {
    clear_has_prey_drop_item_list();
  }
  prey_drop_item_list_ = prey_drop_item_list;
  // @@protoc_insertion_point(field_set_allocated:sg.HuntPreyStateNotify.prey_drop_item_list)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace sg

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::sg::HuntPrey_PREY_STATE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::HuntPrey_PREY_STATE>() {
  return ::sg::HuntPrey_PREY_STATE_descriptor();
}
template <> struct is_proto_enum< ::sg::UserHuntService_HUNT_COMMAND> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::UserHuntService_HUNT_COMMAND>() {
  return ::sg::UserHuntService_HUNT_COMMAND_descriptor();
}
template <> struct is_proto_enum< ::sg::HUNT_GROUND_TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::HUNT_GROUND_TYPE>() {
  return ::sg::HUNT_GROUND_TYPE_descriptor();
}
template <> struct is_proto_enum< ::sg::HUNT_GROUND_STATE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::HUNT_GROUND_STATE>() {
  return ::sg::HUNT_GROUND_STATE_descriptor();
}
template <> struct is_proto_enum< ::sg::HUNT_PREY_TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::HUNT_PREY_TYPE>() {
  return ::sg::HUNT_PREY_TYPE_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_UserHunt_2eproto
