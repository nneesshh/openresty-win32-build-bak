// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: UserTreasureMap.proto

#include "UserTreasureMap.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// This is a temporary google only hack
#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
#include "third_party/protobuf/version.h"
#endif
// @@protoc_insertion_point(includes)

namespace protobuf_BaseStruct_2eproto {
extern PROTOBUF_INTERNAL_EXPORT_protobuf_BaseStruct_2eproto ::google::protobuf::internal::SCCInfo<5> scc_info_Reward;
}  // namespace protobuf_BaseStruct_2eproto
namespace protobuf_UserTreasureMap_2eproto {
extern PROTOBUF_INTERNAL_EXPORT_protobuf_UserTreasureMap_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_TreasureHuntInfo;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_UserTreasureMap_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_UserTreasureMapService_TreasureMapRequest;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_UserTreasureMap_2eproto ::google::protobuf::internal::SCCInfo<2> scc_info_UserTreasureMapService_TreasureMapResponse;
}  // namespace protobuf_UserTreasureMap_2eproto
namespace sg {
class TreasureHuntInfoDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<TreasureHuntInfo>
      _instance;
} _TreasureHuntInfo_default_instance_;
class UserTreasureMapService_TreasureMapRequestDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<UserTreasureMapService_TreasureMapRequest>
      _instance;
} _UserTreasureMapService_TreasureMapRequest_default_instance_;
class UserTreasureMapService_TreasureMapResponseDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<UserTreasureMapService_TreasureMapResponse>
      _instance;
} _UserTreasureMapService_TreasureMapResponse_default_instance_;
class UserTreasureMapServiceDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<UserTreasureMapService>
      _instance;
} _UserTreasureMapService_default_instance_;
class TreasureMapStateNotifyDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<TreasureMapStateNotify>
      _instance;
} _TreasureMapStateNotify_default_instance_;
}  // namespace sg
namespace protobuf_UserTreasureMap_2eproto {
static void InitDefaultsTreasureHuntInfo() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::sg::_TreasureHuntInfo_default_instance_;
    new (ptr) ::sg::TreasureHuntInfo();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::sg::TreasureHuntInfo::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_TreasureHuntInfo =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsTreasureHuntInfo}, {}};

static void InitDefaultsUserTreasureMapService_TreasureMapRequest() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::sg::_UserTreasureMapService_TreasureMapRequest_default_instance_;
    new (ptr) ::sg::UserTreasureMapService_TreasureMapRequest();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::sg::UserTreasureMapService_TreasureMapRequest::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_UserTreasureMapService_TreasureMapRequest =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsUserTreasureMapService_TreasureMapRequest}, {}};

static void InitDefaultsUserTreasureMapService_TreasureMapResponse() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::sg::_UserTreasureMapService_TreasureMapResponse_default_instance_;
    new (ptr) ::sg::UserTreasureMapService_TreasureMapResponse();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::sg::UserTreasureMapService_TreasureMapResponse::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_UserTreasureMapService_TreasureMapResponse =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsUserTreasureMapService_TreasureMapResponse}, {
      &protobuf_UserTreasureMap_2eproto::scc_info_TreasureHuntInfo.base,
      &protobuf_BaseStruct_2eproto::scc_info_Reward.base,}};

static void InitDefaultsUserTreasureMapService() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::sg::_UserTreasureMapService_default_instance_;
    new (ptr) ::sg::UserTreasureMapService();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::sg::UserTreasureMapService::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_UserTreasureMapService =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsUserTreasureMapService}, {
      &protobuf_UserTreasureMap_2eproto::scc_info_UserTreasureMapService_TreasureMapRequest.base,
      &protobuf_UserTreasureMap_2eproto::scc_info_UserTreasureMapService_TreasureMapResponse.base,}};

static void InitDefaultsTreasureMapStateNotify() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::sg::_TreasureMapStateNotify_default_instance_;
    new (ptr) ::sg::TreasureMapStateNotify();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::sg::TreasureMapStateNotify::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_TreasureMapStateNotify =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsTreasureMapStateNotify}, {
      &protobuf_UserTreasureMap_2eproto::scc_info_TreasureHuntInfo.base,
      &protobuf_BaseStruct_2eproto::scc_info_Reward.base,}};

void InitDefaults() {
  ::google::protobuf::internal::InitSCC(&scc_info_TreasureHuntInfo.base);
  ::google::protobuf::internal::InitSCC(&scc_info_UserTreasureMapService_TreasureMapRequest.base);
  ::google::protobuf::internal::InitSCC(&scc_info_UserTreasureMapService_TreasureMapResponse.base);
  ::google::protobuf::internal::InitSCC(&scc_info_UserTreasureMapService.base);
  ::google::protobuf::internal::InitSCC(&scc_info_TreasureMapStateNotify.base);
}

::google::protobuf::Metadata file_level_metadata[5];
const ::google::protobuf::EnumDescriptor* file_level_enum_descriptors[6];

const ::google::protobuf::uint32 TableStruct::offsets[] GOOGLE_PROTOBUF_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sg::TreasureHuntInfo, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sg::TreasureHuntInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sg::TreasureHuntInfo, huntid_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sg::TreasureHuntInfo, toolid_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sg::TreasureHuntInfo, state_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sg::TreasureHuntInfo, areaid_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sg::TreasureHuntInfo, coord_x_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sg::TreasureHuntInfo, coord_y_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sg::TreasureHuntInfo, monster_group_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sg::TreasureHuntInfo, trap_type_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sg::TreasureHuntInfo, trap_lost_num_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sg::TreasureHuntInfo, optime_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sg::TreasureHuntInfo, left_num1_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sg::TreasureHuntInfo, left_num2_),
  0,
  1,
  2,
  3,
  4,
  5,
  7,
  8,
  9,
  11,
  10,
  6,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sg::UserTreasureMapService_TreasureMapRequest, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sg::UserTreasureMapService_TreasureMapRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sg::UserTreasureMapService_TreasureMapRequest, cmd_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sg::UserTreasureMapService_TreasureMapRequest, map_type_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sg::UserTreasureMapService_TreasureMapRequest, areaid_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sg::UserTreasureMapService_TreasureMapRequest, coord_x_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sg::UserTreasureMapService_TreasureMapRequest, coord_y_),
  4,
  0,
  1,
  2,
  3,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sg::UserTreasureMapService_TreasureMapResponse, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sg::UserTreasureMapService_TreasureMapResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sg::UserTreasureMapService_TreasureMapResponse, result_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sg::UserTreasureMapService_TreasureMapResponse, hunt_info_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sg::UserTreasureMapService_TreasureMapResponse, out_drop_),
  2,
  0,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sg::UserTreasureMapService, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sg::UserTreasureMapService, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sg::UserTreasureMapService, req_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sg::UserTreasureMapService, resp_),
  0,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sg::TreasureMapStateNotify, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sg::TreasureMapStateNotify, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sg::TreasureMapStateNotify, hunt_info_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sg::TreasureMapStateNotify, out_drop_),
  0,
  1,
};
static const ::google::protobuf::internal::MigrationSchema schemas[] GOOGLE_PROTOBUF_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 17, sizeof(::sg::TreasureHuntInfo)},
  { 29, 39, sizeof(::sg::UserTreasureMapService_TreasureMapRequest)},
  { 44, 52, sizeof(::sg::UserTreasureMapService_TreasureMapResponse)},
  { 55, 62, sizeof(::sg::UserTreasureMapService)},
  { 64, 71, sizeof(::sg::TreasureMapStateNotify)},
};

static ::google::protobuf::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::google::protobuf::Message*>(&::sg::_TreasureHuntInfo_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::sg::_UserTreasureMapService_TreasureMapRequest_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::sg::_UserTreasureMapService_TreasureMapResponse_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::sg::_UserTreasureMapService_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::sg::_TreasureMapStateNotify_default_instance_),
};

void protobuf_AssignDescriptors() {
  AddDescriptors();
  AssignDescriptors(
      "UserTreasureMap.proto", schemas, file_default_instances, TableStruct::offsets,
      file_level_metadata, file_level_enum_descriptors, NULL);
}

void protobuf_AssignDescriptorsOnce() {
  static ::google::protobuf::internal::once_flag once;
  ::google::protobuf::internal::call_once(once, protobuf_AssignDescriptors);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_PROTOBUF_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::internal::RegisterAllTypes(file_level_metadata, 5);
}

void AddDescriptorsImpl() {
  InitDefaults();
  static const char descriptor[] GOOGLE_PROTOBUF_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
      "\n\025UserTreasureMap.proto\022\002sg\032\020BaseStruct."
      "proto\"\233\002\n\020TreasureHuntInfo\022\016\n\006huntid\030\001 \002"
      "(\005\022\016\n\006toolid\030\002 \002(\005\022&\n\005state\030\003 \001(\0162\027.sg.T"
      "REASURE_HUNT_STATE\022\016\n\006areaid\030\004 \001(\005\022\017\n\007co"
      "ord_x\030\005 \001(\005\022\017\n\007coord_y\030\006 \001(\005\022\025\n\rmonster_"
      "group\030\013 \001(\005\022)\n\ttrap_type\030\025 \001(\0162\026.sg.TREA"
      "SURE_TRAP_TYPE\022\025\n\rtrap_lost_num\030\026 \001(\005\022\016\n"
      "\006optime\030\037 \001(\020\022\021\n\tleft_num1\030  \001(\005\022\021\n\tleft"
      "_num2\030! \001(\005\"\350\003\n\026UserTreasureMapService\022:"
      "\n\003req\030\001 \001(\0132-.sg.UserTreasureMapService."
      "TreasureMapRequest\022<\n\004resp\030\002 \001(\0132..sg.Us"
      "erTreasureMapService.TreasureMapResponse"
      "\032\245\001\n\022TreasureMapRequest\0224\n\003cmd\030\001 \002(\0162\'.s"
      "g.UserTreasureMapService.HUNT_COMMAND\022\'\n"
      "\010map_type\030\002 \001(\0162\025.sg.TREASURE_MAP_TYPE\022\016"
      "\n\006areaid\030\003 \001(\005\022\017\n\007coord_x\030\004 \001(\005\022\017\n\007coord"
      "_y\030\005 \001(\005\032l\n\023TreasureMapResponse\022\016\n\006resul"
      "t\030\001 \002(\005\022\'\n\thunt_info\030\002 \001(\0132\024.sg.Treasure"
      "HuntInfo\022\034\n\010out_drop\030\013 \001(\0132\n.sg.Reward\">"
      "\n\014HUNT_COMMAND\022\t\n\005QUERY\020\001\022\t\n\005START\020\002\022\014\n\010"
      "COMPLETE\020\003\022\n\n\006CANCEL\020\004\"_\n\026TreasureMapSta"
      "teNotify\022\'\n\thunt_info\030\001 \002(\0132\024.sg.Treasur"
      "eHuntInfo\022\034\n\010out_drop\030\013 \001(\0132\n.sg.Reward*"
      "l\n\021TREASURE_MAP_TYPE\022\035\n\031TREASURE_MAP_TYP"
      "E_UNKNOWN\020\000\022\035\n\031TREASURE_MAP_TYPE_COMPASS"
      "\020\001\022\031\n\025TREASURE_MAP_TYPE_MAP\020\002*\204\001\n\026TREASU"
      "RE_LOCATION_TYPE\022\"\n\036TREASURE_LOCATION_TY"
      "PE_UNKNOWN\020\000\022#\n\037TREASURE_LOCATION_TYPE_S"
      "EA_AREA\020\001\022!\n\035TREASURE_LOCATION_TYPE_HARB"
      "OR\020\002*\234\001\n\025TREASURE_TRIGGER_TYPE\022\036\n\032TREASU"
      "RE_TRIGGER_TYPE_NONE\020\000\022\037\n\033TREASURE_TRIGG"
      "ER_TYPE_FIGHT\020\001\022\"\n\036TREASURE_TRIGGER_TYPE"
      "_TREASURE\020\002\022\036\n\032TREASURE_TRIGGER_TYPE_TRA"
      "P\020\003*\370\001\n\023TREASURE_HUNT_STATE\022\034\n\030TREASURE_"
      "HUNT_STATE_IDLE\020\000\022\034\n\030TREASURE_HUNT_STATE"
      "_HUNT\020\001\022\035\n\031TREASURE_HUNT_STATE_FIGHT\020\002\022\037"
      "\n\033TREASURE_HUNT_STATE_HARVEST\020\003\022\037\n\033TREAS"
      "URE_HUNT_STATE_TRAPPED\020\004\022\"\n\036TREASURE_HUN"
      "T_STATE_FIGHT_OVER\020\005\022 \n\034TREASURE_HUNT_ST"
      "ATE_CANCELED\020\006*m\n\022TREASURE_TRAP_TYPE\022\033\n\027"
      "TREASURE_TRAP_TYPE_NONE\020\000\022\033\n\027TREASURE_TR"
      "AP_TYPE_REEF\020\001\022\035\n\031TREASURE_TRAP_TYPE_POI"
      "SON\020\002B\003\370\001\001"
  };
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
      descriptor, 1690);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "UserTreasureMap.proto", &protobuf_RegisterTypes);
  ::protobuf_BaseStruct_2eproto::AddDescriptors();
}

void AddDescriptors() {
  static ::google::protobuf::internal::once_flag once;
  ::google::protobuf::internal::call_once(once, AddDescriptorsImpl);
}
// Force AddDescriptors() to be called at dynamic initialization time.
struct StaticDescriptorInitializer {
  StaticDescriptorInitializer() {
    AddDescriptors();
  }
} static_descriptor_initializer;
}  // namespace protobuf_UserTreasureMap_2eproto
namespace sg {
const ::google::protobuf::EnumDescriptor* UserTreasureMapService_HUNT_COMMAND_descriptor() {
  protobuf_UserTreasureMap_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_UserTreasureMap_2eproto::file_level_enum_descriptors[0];
}
bool UserTreasureMapService_HUNT_COMMAND_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const UserTreasureMapService_HUNT_COMMAND UserTreasureMapService::QUERY;
const UserTreasureMapService_HUNT_COMMAND UserTreasureMapService::START;
const UserTreasureMapService_HUNT_COMMAND UserTreasureMapService::COMPLETE;
const UserTreasureMapService_HUNT_COMMAND UserTreasureMapService::CANCEL;
const UserTreasureMapService_HUNT_COMMAND UserTreasureMapService::HUNT_COMMAND_MIN;
const UserTreasureMapService_HUNT_COMMAND UserTreasureMapService::HUNT_COMMAND_MAX;
const int UserTreasureMapService::HUNT_COMMAND_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* TREASURE_MAP_TYPE_descriptor() {
  protobuf_UserTreasureMap_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_UserTreasureMap_2eproto::file_level_enum_descriptors[1];
}
bool TREASURE_MAP_TYPE_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* TREASURE_LOCATION_TYPE_descriptor() {
  protobuf_UserTreasureMap_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_UserTreasureMap_2eproto::file_level_enum_descriptors[2];
}
bool TREASURE_LOCATION_TYPE_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* TREASURE_TRIGGER_TYPE_descriptor() {
  protobuf_UserTreasureMap_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_UserTreasureMap_2eproto::file_level_enum_descriptors[3];
}
bool TREASURE_TRIGGER_TYPE_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* TREASURE_HUNT_STATE_descriptor() {
  protobuf_UserTreasureMap_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_UserTreasureMap_2eproto::file_level_enum_descriptors[4];
}
bool TREASURE_HUNT_STATE_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* TREASURE_TRAP_TYPE_descriptor() {
  protobuf_UserTreasureMap_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_UserTreasureMap_2eproto::file_level_enum_descriptors[5];
}
bool TREASURE_TRAP_TYPE_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

void TreasureHuntInfo::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TreasureHuntInfo::kHuntidFieldNumber;
const int TreasureHuntInfo::kToolidFieldNumber;
const int TreasureHuntInfo::kStateFieldNumber;
const int TreasureHuntInfo::kAreaidFieldNumber;
const int TreasureHuntInfo::kCoordXFieldNumber;
const int TreasureHuntInfo::kCoordYFieldNumber;
const int TreasureHuntInfo::kMonsterGroupFieldNumber;
const int TreasureHuntInfo::kTrapTypeFieldNumber;
const int TreasureHuntInfo::kTrapLostNumFieldNumber;
const int TreasureHuntInfo::kOptimeFieldNumber;
const int TreasureHuntInfo::kLeftNum1FieldNumber;
const int TreasureHuntInfo::kLeftNum2FieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TreasureHuntInfo::TreasureHuntInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_UserTreasureMap_2eproto::scc_info_TreasureHuntInfo.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:sg.TreasureHuntInfo)
}
TreasureHuntInfo::TreasureHuntInfo(::google::protobuf::Arena* arena)
  : ::google::protobuf::Message(),
  _internal_metadata_(arena) {
  ::google::protobuf::internal::InitSCC(&protobuf_UserTreasureMap_2eproto::scc_info_TreasureHuntInfo.base);
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:sg.TreasureHuntInfo)
}
TreasureHuntInfo::TreasureHuntInfo(const TreasureHuntInfo& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&huntid_, &from.huntid_,
    static_cast<size_t>(reinterpret_cast<char*>(&optime_) -
    reinterpret_cast<char*>(&huntid_)) + sizeof(optime_));
  // @@protoc_insertion_point(copy_constructor:sg.TreasureHuntInfo)
}

void TreasureHuntInfo::SharedCtor() {
  ::memset(&huntid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&optime_) -
      reinterpret_cast<char*>(&huntid_)) + sizeof(optime_));
}

TreasureHuntInfo::~TreasureHuntInfo() {
  // @@protoc_insertion_point(destructor:sg.TreasureHuntInfo)
  SharedDtor();
}

void TreasureHuntInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaNoVirtual() == NULL);
}

void TreasureHuntInfo::ArenaDtor(void* object) {
  TreasureHuntInfo* _this = reinterpret_cast< TreasureHuntInfo* >(object);
  (void)_this;
}
void TreasureHuntInfo::RegisterArenaDtor(::google::protobuf::Arena* arena) {
}
void TreasureHuntInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* TreasureHuntInfo::descriptor() {
  ::protobuf_UserTreasureMap_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_UserTreasureMap_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const TreasureHuntInfo& TreasureHuntInfo::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_UserTreasureMap_2eproto::scc_info_TreasureHuntInfo.base);
  return *internal_default_instance();
}


void TreasureHuntInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:sg.TreasureHuntInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 255u) {
    ::memset(&huntid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&monster_group_) -
        reinterpret_cast<char*>(&huntid_)) + sizeof(monster_group_));
  }
  if (cached_has_bits & 3840u) {
    ::memset(&trap_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&optime_) -
        reinterpret_cast<char*>(&trap_type_)) + sizeof(optime_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool TreasureHuntInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:sg.TreasureHuntInfo)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 huntid = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          set_has_huntid();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &huntid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required int32 toolid = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          set_has_toolid();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &toolid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .sg.TREASURE_HUNT_STATE state = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 24 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::sg::TREASURE_HUNT_STATE_IsValid(value)) {
            set_state(static_cast< ::sg::TREASURE_HUNT_STATE >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                3, static_cast< ::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 areaid = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u /* 32 & 0xFF */)) {
          set_has_areaid();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &areaid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 coord_x = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(40u /* 40 & 0xFF */)) {
          set_has_coord_x();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &coord_x_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 coord_y = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(48u /* 48 & 0xFF */)) {
          set_has_coord_y();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &coord_y_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 monster_group = 11;
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(88u /* 88 & 0xFF */)) {
          set_has_monster_group();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &monster_group_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .sg.TREASURE_TRAP_TYPE trap_type = 21;
      case 21: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(168u /* 168 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::sg::TREASURE_TRAP_TYPE_IsValid(value)) {
            set_trap_type(static_cast< ::sg::TREASURE_TRAP_TYPE >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                21, static_cast< ::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 trap_lost_num = 22;
      case 22: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(176u /* 176 & 0xFF */)) {
          set_has_trap_lost_num();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &trap_lost_num_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional sfixed64 optime = 31;
      case 31: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(249u /* 249 & 0xFF */)) {
          set_has_optime();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_SFIXED64>(
                 input, &optime_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 left_num1 = 32;
      case 32: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(0u /* 256 & 0xFF */)) {
          set_has_left_num1();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &left_num1_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 left_num2 = 33;
      case 33: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 264 & 0xFF */)) {
          set_has_left_num2();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &left_num2_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:sg.TreasureHuntInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:sg.TreasureHuntInfo)
  return false;
#undef DO_
}

void TreasureHuntInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:sg.TreasureHuntInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 huntid = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->huntid(), output);
  }

  // required int32 toolid = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->toolid(), output);
  }

  // optional .sg.TREASURE_HUNT_STATE state = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->state(), output);
  }

  // optional int32 areaid = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->areaid(), output);
  }

  // optional int32 coord_x = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->coord_x(), output);
  }

  // optional int32 coord_y = 6;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->coord_y(), output);
  }

  // optional int32 monster_group = 11;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(11, this->monster_group(), output);
  }

  // optional .sg.TREASURE_TRAP_TYPE trap_type = 21;
  if (cached_has_bits & 0x00000100u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      21, this->trap_type(), output);
  }

  // optional int32 trap_lost_num = 22;
  if (cached_has_bits & 0x00000200u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(22, this->trap_lost_num(), output);
  }

  // optional sfixed64 optime = 31;
  if (cached_has_bits & 0x00000800u) {
    ::google::protobuf::internal::WireFormatLite::WriteSFixed64(31, this->optime(), output);
  }

  // optional int32 left_num1 = 32;
  if (cached_has_bits & 0x00000400u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(32, this->left_num1(), output);
  }

  // optional int32 left_num2 = 33;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(33, this->left_num2(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:sg.TreasureHuntInfo)
}

::google::protobuf::uint8* TreasureHuntInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:sg.TreasureHuntInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 huntid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->huntid(), target);
  }

  // required int32 toolid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->toolid(), target);
  }

  // optional .sg.TREASURE_HUNT_STATE state = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->state(), target);
  }

  // optional int32 areaid = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->areaid(), target);
  }

  // optional int32 coord_x = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->coord_x(), target);
  }

  // optional int32 coord_y = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->coord_y(), target);
  }

  // optional int32 monster_group = 11;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(11, this->monster_group(), target);
  }

  // optional .sg.TREASURE_TRAP_TYPE trap_type = 21;
  if (cached_has_bits & 0x00000100u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      21, this->trap_type(), target);
  }

  // optional int32 trap_lost_num = 22;
  if (cached_has_bits & 0x00000200u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(22, this->trap_lost_num(), target);
  }

  // optional sfixed64 optime = 31;
  if (cached_has_bits & 0x00000800u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSFixed64ToArray(31, this->optime(), target);
  }

  // optional int32 left_num1 = 32;
  if (cached_has_bits & 0x00000400u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(32, this->left_num1(), target);
  }

  // optional int32 left_num2 = 33;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(33, this->left_num2(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sg.TreasureHuntInfo)
  return target;
}

size_t TreasureHuntInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:sg.TreasureHuntInfo)
  size_t total_size = 0;

  if (has_huntid()) {
    // required int32 huntid = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->huntid());
  }

  if (has_toolid()) {
    // required int32 toolid = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->toolid());
  }

  return total_size;
}
size_t TreasureHuntInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sg.TreasureHuntInfo)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required int32 huntid = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->huntid());

    // required int32 toolid = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->toolid());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_has_bits_[0 / 32] & 252u) {
    // optional .sg.TREASURE_HUNT_STATE state = 3;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->state());
    }

    // optional int32 areaid = 4;
    if (has_areaid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->areaid());
    }

    // optional int32 coord_x = 5;
    if (has_coord_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->coord_x());
    }

    // optional int32 coord_y = 6;
    if (has_coord_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->coord_y());
    }

    // optional int32 left_num2 = 33;
    if (has_left_num2()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->left_num2());
    }

    // optional int32 monster_group = 11;
    if (has_monster_group()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->monster_group());
    }

  }
  if (_has_bits_[8 / 32] & 3840u) {
    // optional .sg.TREASURE_TRAP_TYPE trap_type = 21;
    if (has_trap_type()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->trap_type());
    }

    // optional int32 trap_lost_num = 22;
    if (has_trap_lost_num()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->trap_lost_num());
    }

    // optional int32 left_num1 = 32;
    if (has_left_num1()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->left_num1());
    }

    // optional sfixed64 optime = 31;
    if (has_optime()) {
      total_size += 2 + 8;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TreasureHuntInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:sg.TreasureHuntInfo)
  GOOGLE_DCHECK_NE(&from, this);
  const TreasureHuntInfo* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const TreasureHuntInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:sg.TreasureHuntInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:sg.TreasureHuntInfo)
    MergeFrom(*source);
  }
}

void TreasureHuntInfo::MergeFrom(const TreasureHuntInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sg.TreasureHuntInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 255u) {
    if (cached_has_bits & 0x00000001u) {
      huntid_ = from.huntid_;
    }
    if (cached_has_bits & 0x00000002u) {
      toolid_ = from.toolid_;
    }
    if (cached_has_bits & 0x00000004u) {
      state_ = from.state_;
    }
    if (cached_has_bits & 0x00000008u) {
      areaid_ = from.areaid_;
    }
    if (cached_has_bits & 0x00000010u) {
      coord_x_ = from.coord_x_;
    }
    if (cached_has_bits & 0x00000020u) {
      coord_y_ = from.coord_y_;
    }
    if (cached_has_bits & 0x00000040u) {
      left_num2_ = from.left_num2_;
    }
    if (cached_has_bits & 0x00000080u) {
      monster_group_ = from.monster_group_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 3840u) {
    if (cached_has_bits & 0x00000100u) {
      trap_type_ = from.trap_type_;
    }
    if (cached_has_bits & 0x00000200u) {
      trap_lost_num_ = from.trap_lost_num_;
    }
    if (cached_has_bits & 0x00000400u) {
      left_num1_ = from.left_num1_;
    }
    if (cached_has_bits & 0x00000800u) {
      optime_ = from.optime_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TreasureHuntInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:sg.TreasureHuntInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TreasureHuntInfo::CopyFrom(const TreasureHuntInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sg.TreasureHuntInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TreasureHuntInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  return true;
}

void TreasureHuntInfo::Swap(TreasureHuntInfo* other) {
  if (other == this) return;
  if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
    InternalSwap(other);
  } else {
    TreasureHuntInfo* temp = New(GetArenaNoVirtual());
    temp->MergeFrom(*other);
    other->CopyFrom(*this);
    InternalSwap(temp);
    if (GetArenaNoVirtual() == NULL) {
      delete temp;
    }
  }
}
void TreasureHuntInfo::UnsafeArenaSwap(TreasureHuntInfo* other) {
  if (other == this) return;
  GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
  InternalSwap(other);
}
void TreasureHuntInfo::InternalSwap(TreasureHuntInfo* other) {
  using std::swap;
  swap(huntid_, other->huntid_);
  swap(toolid_, other->toolid_);
  swap(state_, other->state_);
  swap(areaid_, other->areaid_);
  swap(coord_x_, other->coord_x_);
  swap(coord_y_, other->coord_y_);
  swap(left_num2_, other->left_num2_);
  swap(monster_group_, other->monster_group_);
  swap(trap_type_, other->trap_type_);
  swap(trap_lost_num_, other->trap_lost_num_);
  swap(left_num1_, other->left_num1_);
  swap(optime_, other->optime_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata TreasureHuntInfo::GetMetadata() const {
  protobuf_UserTreasureMap_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_UserTreasureMap_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void UserTreasureMapService_TreasureMapRequest::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int UserTreasureMapService_TreasureMapRequest::kCmdFieldNumber;
const int UserTreasureMapService_TreasureMapRequest::kMapTypeFieldNumber;
const int UserTreasureMapService_TreasureMapRequest::kAreaidFieldNumber;
const int UserTreasureMapService_TreasureMapRequest::kCoordXFieldNumber;
const int UserTreasureMapService_TreasureMapRequest::kCoordYFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

UserTreasureMapService_TreasureMapRequest::UserTreasureMapService_TreasureMapRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_UserTreasureMap_2eproto::scc_info_UserTreasureMapService_TreasureMapRequest.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:sg.UserTreasureMapService.TreasureMapRequest)
}
UserTreasureMapService_TreasureMapRequest::UserTreasureMapService_TreasureMapRequest(::google::protobuf::Arena* arena)
  : ::google::protobuf::Message(),
  _internal_metadata_(arena) {
  ::google::protobuf::internal::InitSCC(&protobuf_UserTreasureMap_2eproto::scc_info_UserTreasureMapService_TreasureMapRequest.base);
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:sg.UserTreasureMapService.TreasureMapRequest)
}
UserTreasureMapService_TreasureMapRequest::UserTreasureMapService_TreasureMapRequest(const UserTreasureMapService_TreasureMapRequest& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&map_type_, &from.map_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&cmd_) -
    reinterpret_cast<char*>(&map_type_)) + sizeof(cmd_));
  // @@protoc_insertion_point(copy_constructor:sg.UserTreasureMapService.TreasureMapRequest)
}

void UserTreasureMapService_TreasureMapRequest::SharedCtor() {
  ::memset(&map_type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&coord_y_) -
      reinterpret_cast<char*>(&map_type_)) + sizeof(coord_y_));
  cmd_ = 1;
}

UserTreasureMapService_TreasureMapRequest::~UserTreasureMapService_TreasureMapRequest() {
  // @@protoc_insertion_point(destructor:sg.UserTreasureMapService.TreasureMapRequest)
  SharedDtor();
}

void UserTreasureMapService_TreasureMapRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaNoVirtual() == NULL);
}

void UserTreasureMapService_TreasureMapRequest::ArenaDtor(void* object) {
  UserTreasureMapService_TreasureMapRequest* _this = reinterpret_cast< UserTreasureMapService_TreasureMapRequest* >(object);
  (void)_this;
}
void UserTreasureMapService_TreasureMapRequest::RegisterArenaDtor(::google::protobuf::Arena* arena) {
}
void UserTreasureMapService_TreasureMapRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* UserTreasureMapService_TreasureMapRequest::descriptor() {
  ::protobuf_UserTreasureMap_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_UserTreasureMap_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const UserTreasureMapService_TreasureMapRequest& UserTreasureMapService_TreasureMapRequest::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_UserTreasureMap_2eproto::scc_info_UserTreasureMapService_TreasureMapRequest.base);
  return *internal_default_instance();
}


void UserTreasureMapService_TreasureMapRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:sg.UserTreasureMapService.TreasureMapRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 31u) {
    ::memset(&map_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&coord_y_) -
        reinterpret_cast<char*>(&map_type_)) + sizeof(coord_y_));
    cmd_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool UserTreasureMapService_TreasureMapRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:sg.UserTreasureMapService.TreasureMapRequest)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .sg.UserTreasureMapService.HUNT_COMMAND cmd = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::sg::UserTreasureMapService_HUNT_COMMAND_IsValid(value)) {
            set_cmd(static_cast< ::sg::UserTreasureMapService_HUNT_COMMAND >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast< ::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .sg.TREASURE_MAP_TYPE map_type = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::sg::TREASURE_MAP_TYPE_IsValid(value)) {
            set_map_type(static_cast< ::sg::TREASURE_MAP_TYPE >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                2, static_cast< ::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 areaid = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 24 & 0xFF */)) {
          set_has_areaid();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &areaid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 coord_x = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u /* 32 & 0xFF */)) {
          set_has_coord_x();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &coord_x_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 coord_y = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(40u /* 40 & 0xFF */)) {
          set_has_coord_y();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &coord_y_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:sg.UserTreasureMapService.TreasureMapRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:sg.UserTreasureMapService.TreasureMapRequest)
  return false;
#undef DO_
}

void UserTreasureMapService_TreasureMapRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:sg.UserTreasureMapService.TreasureMapRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .sg.UserTreasureMapService.HUNT_COMMAND cmd = 1;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->cmd(), output);
  }

  // optional .sg.TREASURE_MAP_TYPE map_type = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->map_type(), output);
  }

  // optional int32 areaid = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->areaid(), output);
  }

  // optional int32 coord_x = 4;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->coord_x(), output);
  }

  // optional int32 coord_y = 5;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->coord_y(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:sg.UserTreasureMapService.TreasureMapRequest)
}

::google::protobuf::uint8* UserTreasureMapService_TreasureMapRequest::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:sg.UserTreasureMapService.TreasureMapRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .sg.UserTreasureMapService.HUNT_COMMAND cmd = 1;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->cmd(), target);
  }

  // optional .sg.TREASURE_MAP_TYPE map_type = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->map_type(), target);
  }

  // optional int32 areaid = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->areaid(), target);
  }

  // optional int32 coord_x = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->coord_x(), target);
  }

  // optional int32 coord_y = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->coord_y(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sg.UserTreasureMapService.TreasureMapRequest)
  return target;
}

size_t UserTreasureMapService_TreasureMapRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sg.UserTreasureMapService.TreasureMapRequest)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .sg.UserTreasureMapService.HUNT_COMMAND cmd = 1;
  if (has_cmd()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->cmd());
  }
  if (_has_bits_[0 / 32] & 15u) {
    // optional .sg.TREASURE_MAP_TYPE map_type = 2;
    if (has_map_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->map_type());
    }

    // optional int32 areaid = 3;
    if (has_areaid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->areaid());
    }

    // optional int32 coord_x = 4;
    if (has_coord_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->coord_x());
    }

    // optional int32 coord_y = 5;
    if (has_coord_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->coord_y());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UserTreasureMapService_TreasureMapRequest::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:sg.UserTreasureMapService.TreasureMapRequest)
  GOOGLE_DCHECK_NE(&from, this);
  const UserTreasureMapService_TreasureMapRequest* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const UserTreasureMapService_TreasureMapRequest>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:sg.UserTreasureMapService.TreasureMapRequest)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:sg.UserTreasureMapService.TreasureMapRequest)
    MergeFrom(*source);
  }
}

void UserTreasureMapService_TreasureMapRequest::MergeFrom(const UserTreasureMapService_TreasureMapRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sg.UserTreasureMapService.TreasureMapRequest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 31u) {
    if (cached_has_bits & 0x00000001u) {
      map_type_ = from.map_type_;
    }
    if (cached_has_bits & 0x00000002u) {
      areaid_ = from.areaid_;
    }
    if (cached_has_bits & 0x00000004u) {
      coord_x_ = from.coord_x_;
    }
    if (cached_has_bits & 0x00000008u) {
      coord_y_ = from.coord_y_;
    }
    if (cached_has_bits & 0x00000010u) {
      cmd_ = from.cmd_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void UserTreasureMapService_TreasureMapRequest::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:sg.UserTreasureMapService.TreasureMapRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UserTreasureMapService_TreasureMapRequest::CopyFrom(const UserTreasureMapService_TreasureMapRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sg.UserTreasureMapService.TreasureMapRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserTreasureMapService_TreasureMapRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000010) != 0x00000010) return false;
  return true;
}

void UserTreasureMapService_TreasureMapRequest::Swap(UserTreasureMapService_TreasureMapRequest* other) {
  if (other == this) return;
  if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
    InternalSwap(other);
  } else {
    UserTreasureMapService_TreasureMapRequest* temp = New(GetArenaNoVirtual());
    temp->MergeFrom(*other);
    other->CopyFrom(*this);
    InternalSwap(temp);
    if (GetArenaNoVirtual() == NULL) {
      delete temp;
    }
  }
}
void UserTreasureMapService_TreasureMapRequest::UnsafeArenaSwap(UserTreasureMapService_TreasureMapRequest* other) {
  if (other == this) return;
  GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
  InternalSwap(other);
}
void UserTreasureMapService_TreasureMapRequest::InternalSwap(UserTreasureMapService_TreasureMapRequest* other) {
  using std::swap;
  swap(map_type_, other->map_type_);
  swap(areaid_, other->areaid_);
  swap(coord_x_, other->coord_x_);
  swap(coord_y_, other->coord_y_);
  swap(cmd_, other->cmd_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata UserTreasureMapService_TreasureMapRequest::GetMetadata() const {
  protobuf_UserTreasureMap_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_UserTreasureMap_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void UserTreasureMapService_TreasureMapResponse::InitAsDefaultInstance() {
  ::sg::_UserTreasureMapService_TreasureMapResponse_default_instance_._instance.get_mutable()->hunt_info_ = const_cast< ::sg::TreasureHuntInfo*>(
      ::sg::TreasureHuntInfo::internal_default_instance());
  ::sg::_UserTreasureMapService_TreasureMapResponse_default_instance_._instance.get_mutable()->out_drop_ = const_cast< ::sg::Reward*>(
      ::sg::Reward::internal_default_instance());
}
void UserTreasureMapService_TreasureMapResponse::unsafe_arena_set_allocated_hunt_info(
    ::sg::TreasureHuntInfo* hunt_info) {
  if (GetArenaNoVirtual() == NULL) {
    delete hunt_info_;
  }
  hunt_info_ = hunt_info;
  if (hunt_info) {
    set_has_hunt_info();
  } else {
    clear_has_hunt_info();
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sg.UserTreasureMapService.TreasureMapResponse.hunt_info)
}
void UserTreasureMapService_TreasureMapResponse::unsafe_arena_set_allocated_out_drop(
    ::sg::Reward* out_drop) {
  if (GetArenaNoVirtual() == NULL) {
    delete out_drop_;
  }
  out_drop_ = out_drop;
  if (out_drop) {
    set_has_out_drop();
  } else {
    clear_has_out_drop();
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sg.UserTreasureMapService.TreasureMapResponse.out_drop)
}
void UserTreasureMapService_TreasureMapResponse::clear_out_drop() {
  if (out_drop_ != NULL) out_drop_->Clear();
  clear_has_out_drop();
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int UserTreasureMapService_TreasureMapResponse::kResultFieldNumber;
const int UserTreasureMapService_TreasureMapResponse::kHuntInfoFieldNumber;
const int UserTreasureMapService_TreasureMapResponse::kOutDropFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

UserTreasureMapService_TreasureMapResponse::UserTreasureMapService_TreasureMapResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_UserTreasureMap_2eproto::scc_info_UserTreasureMapService_TreasureMapResponse.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:sg.UserTreasureMapService.TreasureMapResponse)
}
UserTreasureMapService_TreasureMapResponse::UserTreasureMapService_TreasureMapResponse(::google::protobuf::Arena* arena)
  : ::google::protobuf::Message(),
  _internal_metadata_(arena) {
  ::google::protobuf::internal::InitSCC(&protobuf_UserTreasureMap_2eproto::scc_info_UserTreasureMapService_TreasureMapResponse.base);
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:sg.UserTreasureMapService.TreasureMapResponse)
}
UserTreasureMapService_TreasureMapResponse::UserTreasureMapService_TreasureMapResponse(const UserTreasureMapService_TreasureMapResponse& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_hunt_info()) {
    hunt_info_ = new ::sg::TreasureHuntInfo(*from.hunt_info_);
  } else {
    hunt_info_ = NULL;
  }
  if (from.has_out_drop()) {
    out_drop_ = new ::sg::Reward(*from.out_drop_);
  } else {
    out_drop_ = NULL;
  }
  result_ = from.result_;
  // @@protoc_insertion_point(copy_constructor:sg.UserTreasureMapService.TreasureMapResponse)
}

void UserTreasureMapService_TreasureMapResponse::SharedCtor() {
  ::memset(&hunt_info_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&result_) -
      reinterpret_cast<char*>(&hunt_info_)) + sizeof(result_));
}

UserTreasureMapService_TreasureMapResponse::~UserTreasureMapService_TreasureMapResponse() {
  // @@protoc_insertion_point(destructor:sg.UserTreasureMapService.TreasureMapResponse)
  SharedDtor();
}

void UserTreasureMapService_TreasureMapResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaNoVirtual() == NULL);
  if (this != internal_default_instance()) delete hunt_info_;
  if (this != internal_default_instance()) delete out_drop_;
}

void UserTreasureMapService_TreasureMapResponse::ArenaDtor(void* object) {
  UserTreasureMapService_TreasureMapResponse* _this = reinterpret_cast< UserTreasureMapService_TreasureMapResponse* >(object);
  (void)_this;
}
void UserTreasureMapService_TreasureMapResponse::RegisterArenaDtor(::google::protobuf::Arena* arena) {
}
void UserTreasureMapService_TreasureMapResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* UserTreasureMapService_TreasureMapResponse::descriptor() {
  ::protobuf_UserTreasureMap_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_UserTreasureMap_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const UserTreasureMapService_TreasureMapResponse& UserTreasureMapService_TreasureMapResponse::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_UserTreasureMap_2eproto::scc_info_UserTreasureMapService_TreasureMapResponse.base);
  return *internal_default_instance();
}


void UserTreasureMapService_TreasureMapResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:sg.UserTreasureMapService.TreasureMapResponse)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(hunt_info_ != NULL);
      hunt_info_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(out_drop_ != NULL);
      out_drop_->Clear();
    }
  }
  result_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool UserTreasureMapService_TreasureMapResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:sg.UserTreasureMapService.TreasureMapResponse)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 result = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          set_has_result();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .sg.TreasureHuntInfo hunt_info = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_hunt_info()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .sg.Reward out_drop = 11;
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(90u /* 90 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_out_drop()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:sg.UserTreasureMapService.TreasureMapResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:sg.UserTreasureMapService.TreasureMapResponse)
  return false;
#undef DO_
}

void UserTreasureMapService_TreasureMapResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:sg.UserTreasureMapService.TreasureMapResponse)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 result = 1;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional .sg.TreasureHuntInfo hunt_info = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->_internal_hunt_info(), output);
  }

  // optional .sg.Reward out_drop = 11;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, this->_internal_out_drop(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:sg.UserTreasureMapService.TreasureMapResponse)
}

::google::protobuf::uint8* UserTreasureMapService_TreasureMapResponse::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:sg.UserTreasureMapService.TreasureMapResponse)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 result = 1;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->result(), target);
  }

  // optional .sg.TreasureHuntInfo hunt_info = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->_internal_hunt_info(), deterministic, target);
  }

  // optional .sg.Reward out_drop = 11;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        11, this->_internal_out_drop(), deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sg.UserTreasureMapService.TreasureMapResponse)
  return target;
}

size_t UserTreasureMapService_TreasureMapResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sg.UserTreasureMapService.TreasureMapResponse)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required int32 result = 1;
  if (has_result()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->result());
  }
  if (_has_bits_[0 / 32] & 3u) {
    // optional .sg.TreasureHuntInfo hunt_info = 2;
    if (has_hunt_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *hunt_info_);
    }

    // optional .sg.Reward out_drop = 11;
    if (has_out_drop()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *out_drop_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UserTreasureMapService_TreasureMapResponse::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:sg.UserTreasureMapService.TreasureMapResponse)
  GOOGLE_DCHECK_NE(&from, this);
  const UserTreasureMapService_TreasureMapResponse* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const UserTreasureMapService_TreasureMapResponse>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:sg.UserTreasureMapService.TreasureMapResponse)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:sg.UserTreasureMapService.TreasureMapResponse)
    MergeFrom(*source);
  }
}

void UserTreasureMapService_TreasureMapResponse::MergeFrom(const UserTreasureMapService_TreasureMapResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sg.UserTreasureMapService.TreasureMapResponse)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_hunt_info()->::sg::TreasureHuntInfo::MergeFrom(from.hunt_info());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_out_drop()->::sg::Reward::MergeFrom(from.out_drop());
    }
    if (cached_has_bits & 0x00000004u) {
      result_ = from.result_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void UserTreasureMapService_TreasureMapResponse::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:sg.UserTreasureMapService.TreasureMapResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UserTreasureMapService_TreasureMapResponse::CopyFrom(const UserTreasureMapService_TreasureMapResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sg.UserTreasureMapService.TreasureMapResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserTreasureMapService_TreasureMapResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000004) != 0x00000004) return false;
  if (has_hunt_info()) {
    if (!this->hunt_info_->IsInitialized()) return false;
  }
  if (has_out_drop()) {
    if (!this->out_drop_->IsInitialized()) return false;
  }
  return true;
}

void UserTreasureMapService_TreasureMapResponse::Swap(UserTreasureMapService_TreasureMapResponse* other) {
  if (other == this) return;
  if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
    InternalSwap(other);
  } else {
    UserTreasureMapService_TreasureMapResponse* temp = New(GetArenaNoVirtual());
    temp->MergeFrom(*other);
    other->CopyFrom(*this);
    InternalSwap(temp);
    if (GetArenaNoVirtual() == NULL) {
      delete temp;
    }
  }
}
void UserTreasureMapService_TreasureMapResponse::UnsafeArenaSwap(UserTreasureMapService_TreasureMapResponse* other) {
  if (other == this) return;
  GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
  InternalSwap(other);
}
void UserTreasureMapService_TreasureMapResponse::InternalSwap(UserTreasureMapService_TreasureMapResponse* other) {
  using std::swap;
  swap(hunt_info_, other->hunt_info_);
  swap(out_drop_, other->out_drop_);
  swap(result_, other->result_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata UserTreasureMapService_TreasureMapResponse::GetMetadata() const {
  protobuf_UserTreasureMap_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_UserTreasureMap_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void UserTreasureMapService::InitAsDefaultInstance() {
  ::sg::_UserTreasureMapService_default_instance_._instance.get_mutable()->req_ = const_cast< ::sg::UserTreasureMapService_TreasureMapRequest*>(
      ::sg::UserTreasureMapService_TreasureMapRequest::internal_default_instance());
  ::sg::_UserTreasureMapService_default_instance_._instance.get_mutable()->resp_ = const_cast< ::sg::UserTreasureMapService_TreasureMapResponse*>(
      ::sg::UserTreasureMapService_TreasureMapResponse::internal_default_instance());
}
void UserTreasureMapService::unsafe_arena_set_allocated_req(
    ::sg::UserTreasureMapService_TreasureMapRequest* req) {
  if (GetArenaNoVirtual() == NULL) {
    delete req_;
  }
  req_ = req;
  if (req) {
    set_has_req();
  } else {
    clear_has_req();
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sg.UserTreasureMapService.req)
}
void UserTreasureMapService::unsafe_arena_set_allocated_resp(
    ::sg::UserTreasureMapService_TreasureMapResponse* resp) {
  if (GetArenaNoVirtual() == NULL) {
    delete resp_;
  }
  resp_ = resp;
  if (resp) {
    set_has_resp();
  } else {
    clear_has_resp();
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sg.UserTreasureMapService.resp)
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int UserTreasureMapService::kReqFieldNumber;
const int UserTreasureMapService::kRespFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

UserTreasureMapService::UserTreasureMapService()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_UserTreasureMap_2eproto::scc_info_UserTreasureMapService.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:sg.UserTreasureMapService)
}
UserTreasureMapService::UserTreasureMapService(::google::protobuf::Arena* arena)
  : ::google::protobuf::Message(),
  _internal_metadata_(arena) {
  ::google::protobuf::internal::InitSCC(&protobuf_UserTreasureMap_2eproto::scc_info_UserTreasureMapService.base);
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:sg.UserTreasureMapService)
}
UserTreasureMapService::UserTreasureMapService(const UserTreasureMapService& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_req()) {
    req_ = new ::sg::UserTreasureMapService_TreasureMapRequest(*from.req_);
  } else {
    req_ = NULL;
  }
  if (from.has_resp()) {
    resp_ = new ::sg::UserTreasureMapService_TreasureMapResponse(*from.resp_);
  } else {
    resp_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:sg.UserTreasureMapService)
}

void UserTreasureMapService::SharedCtor() {
  ::memset(&req_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&resp_) -
      reinterpret_cast<char*>(&req_)) + sizeof(resp_));
}

UserTreasureMapService::~UserTreasureMapService() {
  // @@protoc_insertion_point(destructor:sg.UserTreasureMapService)
  SharedDtor();
}

void UserTreasureMapService::SharedDtor() {
  GOOGLE_DCHECK(GetArenaNoVirtual() == NULL);
  if (this != internal_default_instance()) delete req_;
  if (this != internal_default_instance()) delete resp_;
}

void UserTreasureMapService::ArenaDtor(void* object) {
  UserTreasureMapService* _this = reinterpret_cast< UserTreasureMapService* >(object);
  (void)_this;
}
void UserTreasureMapService::RegisterArenaDtor(::google::protobuf::Arena* arena) {
}
void UserTreasureMapService::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* UserTreasureMapService::descriptor() {
  ::protobuf_UserTreasureMap_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_UserTreasureMap_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const UserTreasureMapService& UserTreasureMapService::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_UserTreasureMap_2eproto::scc_info_UserTreasureMapService.base);
  return *internal_default_instance();
}


void UserTreasureMapService::Clear() {
// @@protoc_insertion_point(message_clear_start:sg.UserTreasureMapService)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(req_ != NULL);
      req_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(resp_ != NULL);
      resp_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool UserTreasureMapService::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:sg.UserTreasureMapService)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .sg.UserTreasureMapService.TreasureMapRequest req = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_req()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .sg.UserTreasureMapService.TreasureMapResponse resp = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_resp()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:sg.UserTreasureMapService)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:sg.UserTreasureMapService)
  return false;
#undef DO_
}

void UserTreasureMapService::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:sg.UserTreasureMapService)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .sg.UserTreasureMapService.TreasureMapRequest req = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->_internal_req(), output);
  }

  // optional .sg.UserTreasureMapService.TreasureMapResponse resp = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->_internal_resp(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:sg.UserTreasureMapService)
}

::google::protobuf::uint8* UserTreasureMapService::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:sg.UserTreasureMapService)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .sg.UserTreasureMapService.TreasureMapRequest req = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->_internal_req(), deterministic, target);
  }

  // optional .sg.UserTreasureMapService.TreasureMapResponse resp = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->_internal_resp(), deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sg.UserTreasureMapService)
  return target;
}

size_t UserTreasureMapService::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sg.UserTreasureMapService)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (_has_bits_[0 / 32] & 3u) {
    // optional .sg.UserTreasureMapService.TreasureMapRequest req = 1;
    if (has_req()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *req_);
    }

    // optional .sg.UserTreasureMapService.TreasureMapResponse resp = 2;
    if (has_resp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *resp_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UserTreasureMapService::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:sg.UserTreasureMapService)
  GOOGLE_DCHECK_NE(&from, this);
  const UserTreasureMapService* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const UserTreasureMapService>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:sg.UserTreasureMapService)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:sg.UserTreasureMapService)
    MergeFrom(*source);
  }
}

void UserTreasureMapService::MergeFrom(const UserTreasureMapService& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sg.UserTreasureMapService)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_req()->::sg::UserTreasureMapService_TreasureMapRequest::MergeFrom(from.req());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_resp()->::sg::UserTreasureMapService_TreasureMapResponse::MergeFrom(from.resp());
    }
  }
}

void UserTreasureMapService::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:sg.UserTreasureMapService)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UserTreasureMapService::CopyFrom(const UserTreasureMapService& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sg.UserTreasureMapService)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserTreasureMapService::IsInitialized() const {
  if (has_req()) {
    if (!this->req_->IsInitialized()) return false;
  }
  if (has_resp()) {
    if (!this->resp_->IsInitialized()) return false;
  }
  return true;
}

void UserTreasureMapService::Swap(UserTreasureMapService* other) {
  if (other == this) return;
  if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
    InternalSwap(other);
  } else {
    UserTreasureMapService* temp = New(GetArenaNoVirtual());
    temp->MergeFrom(*other);
    other->CopyFrom(*this);
    InternalSwap(temp);
    if (GetArenaNoVirtual() == NULL) {
      delete temp;
    }
  }
}
void UserTreasureMapService::UnsafeArenaSwap(UserTreasureMapService* other) {
  if (other == this) return;
  GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
  InternalSwap(other);
}
void UserTreasureMapService::InternalSwap(UserTreasureMapService* other) {
  using std::swap;
  swap(req_, other->req_);
  swap(resp_, other->resp_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata UserTreasureMapService::GetMetadata() const {
  protobuf_UserTreasureMap_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_UserTreasureMap_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void TreasureMapStateNotify::InitAsDefaultInstance() {
  ::sg::_TreasureMapStateNotify_default_instance_._instance.get_mutable()->hunt_info_ = const_cast< ::sg::TreasureHuntInfo*>(
      ::sg::TreasureHuntInfo::internal_default_instance());
  ::sg::_TreasureMapStateNotify_default_instance_._instance.get_mutable()->out_drop_ = const_cast< ::sg::Reward*>(
      ::sg::Reward::internal_default_instance());
}
void TreasureMapStateNotify::unsafe_arena_set_allocated_hunt_info(
    ::sg::TreasureHuntInfo* hunt_info) {
  if (GetArenaNoVirtual() == NULL) {
    delete hunt_info_;
  }
  hunt_info_ = hunt_info;
  if (hunt_info) {
    set_has_hunt_info();
  } else {
    clear_has_hunt_info();
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sg.TreasureMapStateNotify.hunt_info)
}
void TreasureMapStateNotify::unsafe_arena_set_allocated_out_drop(
    ::sg::Reward* out_drop) {
  if (GetArenaNoVirtual() == NULL) {
    delete out_drop_;
  }
  out_drop_ = out_drop;
  if (out_drop) {
    set_has_out_drop();
  } else {
    clear_has_out_drop();
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sg.TreasureMapStateNotify.out_drop)
}
void TreasureMapStateNotify::clear_out_drop() {
  if (out_drop_ != NULL) out_drop_->Clear();
  clear_has_out_drop();
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TreasureMapStateNotify::kHuntInfoFieldNumber;
const int TreasureMapStateNotify::kOutDropFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TreasureMapStateNotify::TreasureMapStateNotify()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_UserTreasureMap_2eproto::scc_info_TreasureMapStateNotify.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:sg.TreasureMapStateNotify)
}
TreasureMapStateNotify::TreasureMapStateNotify(::google::protobuf::Arena* arena)
  : ::google::protobuf::Message(),
  _internal_metadata_(arena) {
  ::google::protobuf::internal::InitSCC(&protobuf_UserTreasureMap_2eproto::scc_info_TreasureMapStateNotify.base);
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:sg.TreasureMapStateNotify)
}
TreasureMapStateNotify::TreasureMapStateNotify(const TreasureMapStateNotify& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_hunt_info()) {
    hunt_info_ = new ::sg::TreasureHuntInfo(*from.hunt_info_);
  } else {
    hunt_info_ = NULL;
  }
  if (from.has_out_drop()) {
    out_drop_ = new ::sg::Reward(*from.out_drop_);
  } else {
    out_drop_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:sg.TreasureMapStateNotify)
}

void TreasureMapStateNotify::SharedCtor() {
  ::memset(&hunt_info_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&out_drop_) -
      reinterpret_cast<char*>(&hunt_info_)) + sizeof(out_drop_));
}

TreasureMapStateNotify::~TreasureMapStateNotify() {
  // @@protoc_insertion_point(destructor:sg.TreasureMapStateNotify)
  SharedDtor();
}

void TreasureMapStateNotify::SharedDtor() {
  GOOGLE_DCHECK(GetArenaNoVirtual() == NULL);
  if (this != internal_default_instance()) delete hunt_info_;
  if (this != internal_default_instance()) delete out_drop_;
}

void TreasureMapStateNotify::ArenaDtor(void* object) {
  TreasureMapStateNotify* _this = reinterpret_cast< TreasureMapStateNotify* >(object);
  (void)_this;
}
void TreasureMapStateNotify::RegisterArenaDtor(::google::protobuf::Arena* arena) {
}
void TreasureMapStateNotify::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* TreasureMapStateNotify::descriptor() {
  ::protobuf_UserTreasureMap_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_UserTreasureMap_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const TreasureMapStateNotify& TreasureMapStateNotify::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_UserTreasureMap_2eproto::scc_info_TreasureMapStateNotify.base);
  return *internal_default_instance();
}


void TreasureMapStateNotify::Clear() {
// @@protoc_insertion_point(message_clear_start:sg.TreasureMapStateNotify)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(hunt_info_ != NULL);
      hunt_info_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(out_drop_ != NULL);
      out_drop_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool TreasureMapStateNotify::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:sg.TreasureMapStateNotify)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .sg.TreasureHuntInfo hunt_info = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_hunt_info()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .sg.Reward out_drop = 11;
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(90u /* 90 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_out_drop()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:sg.TreasureMapStateNotify)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:sg.TreasureMapStateNotify)
  return false;
#undef DO_
}

void TreasureMapStateNotify::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:sg.TreasureMapStateNotify)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .sg.TreasureHuntInfo hunt_info = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->_internal_hunt_info(), output);
  }

  // optional .sg.Reward out_drop = 11;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, this->_internal_out_drop(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:sg.TreasureMapStateNotify)
}

::google::protobuf::uint8* TreasureMapStateNotify::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:sg.TreasureMapStateNotify)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .sg.TreasureHuntInfo hunt_info = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->_internal_hunt_info(), deterministic, target);
  }

  // optional .sg.Reward out_drop = 11;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        11, this->_internal_out_drop(), deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sg.TreasureMapStateNotify)
  return target;
}

size_t TreasureMapStateNotify::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sg.TreasureMapStateNotify)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .sg.TreasureHuntInfo hunt_info = 1;
  if (has_hunt_info()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *hunt_info_);
  }
  // optional .sg.Reward out_drop = 11;
  if (has_out_drop()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *out_drop_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TreasureMapStateNotify::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:sg.TreasureMapStateNotify)
  GOOGLE_DCHECK_NE(&from, this);
  const TreasureMapStateNotify* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const TreasureMapStateNotify>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:sg.TreasureMapStateNotify)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:sg.TreasureMapStateNotify)
    MergeFrom(*source);
  }
}

void TreasureMapStateNotify::MergeFrom(const TreasureMapStateNotify& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sg.TreasureMapStateNotify)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_hunt_info()->::sg::TreasureHuntInfo::MergeFrom(from.hunt_info());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_out_drop()->::sg::Reward::MergeFrom(from.out_drop());
    }
  }
}

void TreasureMapStateNotify::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:sg.TreasureMapStateNotify)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TreasureMapStateNotify::CopyFrom(const TreasureMapStateNotify& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sg.TreasureMapStateNotify)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TreasureMapStateNotify::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (has_hunt_info()) {
    if (!this->hunt_info_->IsInitialized()) return false;
  }
  if (has_out_drop()) {
    if (!this->out_drop_->IsInitialized()) return false;
  }
  return true;
}

void TreasureMapStateNotify::Swap(TreasureMapStateNotify* other) {
  if (other == this) return;
  if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
    InternalSwap(other);
  } else {
    TreasureMapStateNotify* temp = New(GetArenaNoVirtual());
    temp->MergeFrom(*other);
    other->CopyFrom(*this);
    InternalSwap(temp);
    if (GetArenaNoVirtual() == NULL) {
      delete temp;
    }
  }
}
void TreasureMapStateNotify::UnsafeArenaSwap(TreasureMapStateNotify* other) {
  if (other == this) return;
  GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
  InternalSwap(other);
}
void TreasureMapStateNotify::InternalSwap(TreasureMapStateNotify* other) {
  using std::swap;
  swap(hunt_info_, other->hunt_info_);
  swap(out_drop_, other->out_drop_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata TreasureMapStateNotify::GetMetadata() const {
  protobuf_UserTreasureMap_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_UserTreasureMap_2eproto::file_level_metadata[kIndexInFileMessages];
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace sg
namespace google {
namespace protobuf {
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::sg::TreasureHuntInfo* Arena::CreateMaybeMessage< ::sg::TreasureHuntInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sg::TreasureHuntInfo >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::sg::UserTreasureMapService_TreasureMapRequest* Arena::CreateMaybeMessage< ::sg::UserTreasureMapService_TreasureMapRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sg::UserTreasureMapService_TreasureMapRequest >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::sg::UserTreasureMapService_TreasureMapResponse* Arena::CreateMaybeMessage< ::sg::UserTreasureMapService_TreasureMapResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sg::UserTreasureMapService_TreasureMapResponse >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::sg::UserTreasureMapService* Arena::CreateMaybeMessage< ::sg::UserTreasureMapService >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sg::UserTreasureMapService >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::sg::TreasureMapStateNotify* Arena::CreateMaybeMessage< ::sg::TreasureMapStateNotify >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sg::TreasureMapStateNotify >(arena);
}
}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)
