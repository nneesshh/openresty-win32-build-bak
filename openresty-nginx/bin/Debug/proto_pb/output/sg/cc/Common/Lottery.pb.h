// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Lottery.proto

#ifndef PROTOBUF_INCLUDED_Lottery_2eproto
#define PROTOBUF_INCLUDED_Lottery_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "BaseStruct.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_Lottery_2eproto 

namespace protobuf_Lottery_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[5];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_Lottery_2eproto
namespace sg {
class LotteryMachine;
class LotteryMachineDefaultTypeInternal;
extern LotteryMachineDefaultTypeInternal _LotteryMachine_default_instance_;
class LotteryNotify;
class LotteryNotifyDefaultTypeInternal;
extern LotteryNotifyDefaultTypeInternal _LotteryNotify_default_instance_;
class LotteryService;
class LotteryServiceDefaultTypeInternal;
extern LotteryServiceDefaultTypeInternal _LotteryService_default_instance_;
class LotteryService_LotteryRequest;
class LotteryService_LotteryRequestDefaultTypeInternal;
extern LotteryService_LotteryRequestDefaultTypeInternal _LotteryService_LotteryRequest_default_instance_;
class LotteryService_LotteryResponse;
class LotteryService_LotteryResponseDefaultTypeInternal;
extern LotteryService_LotteryResponseDefaultTypeInternal _LotteryService_LotteryResponse_default_instance_;
}  // namespace sg
namespace google {
namespace protobuf {
template<> ::sg::LotteryMachine* Arena::CreateMaybeMessage<::sg::LotteryMachine>(Arena*);
template<> ::sg::LotteryNotify* Arena::CreateMaybeMessage<::sg::LotteryNotify>(Arena*);
template<> ::sg::LotteryService* Arena::CreateMaybeMessage<::sg::LotteryService>(Arena*);
template<> ::sg::LotteryService_LotteryRequest* Arena::CreateMaybeMessage<::sg::LotteryService_LotteryRequest>(Arena*);
template<> ::sg::LotteryService_LotteryResponse* Arena::CreateMaybeMessage<::sg::LotteryService_LotteryResponse>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace sg {

enum LotteryService_LOTTERY_CMD {
  LotteryService_LOTTERY_CMD_QUERY = 1,
  LotteryService_LOTTERY_CMD_QUERY_NOTIFY = 2,
  LotteryService_LOTTERY_CMD_LOTTERY_ONCE = 3,
  LotteryService_LOTTERY_CMD_LOTTERY_TEN_TIMES = 4
};
bool LotteryService_LOTTERY_CMD_IsValid(int value);
const LotteryService_LOTTERY_CMD LotteryService_LOTTERY_CMD_LOTTERY_CMD_MIN = LotteryService_LOTTERY_CMD_QUERY;
const LotteryService_LOTTERY_CMD LotteryService_LOTTERY_CMD_LOTTERY_CMD_MAX = LotteryService_LOTTERY_CMD_LOTTERY_TEN_TIMES;
const int LotteryService_LOTTERY_CMD_LOTTERY_CMD_ARRAYSIZE = LotteryService_LOTTERY_CMD_LOTTERY_CMD_MAX + 1;

const ::google::protobuf::EnumDescriptor* LotteryService_LOTTERY_CMD_descriptor();
inline const ::std::string& LotteryService_LOTTERY_CMD_Name(LotteryService_LOTTERY_CMD value) {
  return ::google::protobuf::internal::NameOfEnum(
    LotteryService_LOTTERY_CMD_descriptor(), value);
}
inline bool LotteryService_LOTTERY_CMD_Parse(
    const ::std::string& name, LotteryService_LOTTERY_CMD* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LotteryService_LOTTERY_CMD>(
    LotteryService_LOTTERY_CMD_descriptor(), name, value);
}
// ===================================================================

class LotteryMachine : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.LotteryMachine) */ {
 public:
  LotteryMachine();
  virtual ~LotteryMachine();

  LotteryMachine(const LotteryMachine& from);

  inline LotteryMachine& operator=(const LotteryMachine& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LotteryMachine(LotteryMachine&& from) noexcept
    : LotteryMachine() {
    *this = ::std::move(from);
  }

  inline LotteryMachine& operator=(LotteryMachine&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const LotteryMachine& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LotteryMachine* internal_default_instance() {
    return reinterpret_cast<const LotteryMachine*>(
               &_LotteryMachine_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void UnsafeArenaSwap(LotteryMachine* other);
  void Swap(LotteryMachine* other);
  friend void swap(LotteryMachine& a, LotteryMachine& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LotteryMachine* New() const final {
    return CreateMaybeMessage<LotteryMachine>(NULL);
  }

  LotteryMachine* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LotteryMachine>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LotteryMachine& from);
  void MergeFrom(const LotteryMachine& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LotteryMachine* other);
  protected:
  explicit LotteryMachine(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // required int32 type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // required int32 cost_item = 3;
  bool has_cost_item() const;
  void clear_cost_item();
  static const int kCostItemFieldNumber = 3;
  ::google::protobuf::int32 cost_item() const;
  void set_cost_item(::google::protobuf::int32 value);

  // required int32 once_cost = 4;
  bool has_once_cost() const;
  void clear_once_cost();
  static const int kOnceCostFieldNumber = 4;
  ::google::protobuf::int32 once_cost() const;
  void set_once_cost(::google::protobuf::int32 value);

  // required int32 ten_times_cost = 5;
  bool has_ten_times_cost() const;
  void clear_ten_times_cost();
  static const int kTenTimesCostFieldNumber = 5;
  ::google::protobuf::int32 ten_times_cost() const;
  void set_ten_times_cost(::google::protobuf::int32 value);

  // required int32 remain_times = 6;
  bool has_remain_times() const;
  void clear_remain_times();
  static const int kRemainTimesFieldNumber = 6;
  ::google::protobuf::int32 remain_times() const;
  void set_remain_times(::google::protobuf::int32 value);

  // required int32 activity_id = 7;
  bool has_activity_id() const;
  void clear_activity_id();
  static const int kActivityIdFieldNumber = 7;
  ::google::protobuf::int32 activity_id() const;
  void set_activity_id(::google::protobuf::int32 value);

  // optional int32 cost_add = 8;
  bool has_cost_add() const;
  void clear_cost_add();
  static const int kCostAddFieldNumber = 8;
  ::google::protobuf::int32 cost_add() const;
  void set_cost_add(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.LotteryMachine)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_type();
  void clear_has_type();
  void set_has_cost_item();
  void clear_has_cost_item();
  void set_has_once_cost();
  void clear_has_once_cost();
  void set_has_ten_times_cost();
  void clear_has_ten_times_cost();
  void set_has_remain_times();
  void clear_has_remain_times();
  void set_has_activity_id();
  void clear_has_activity_id();
  void set_has_cost_add();
  void clear_has_cost_add();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 cost_item_;
  ::google::protobuf::int32 once_cost_;
  ::google::protobuf::int32 ten_times_cost_;
  ::google::protobuf::int32 remain_times_;
  ::google::protobuf::int32 activity_id_;
  ::google::protobuf::int32 cost_add_;
  friend struct ::protobuf_Lottery_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LotteryNotify : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.LotteryNotify) */ {
 public:
  LotteryNotify();
  virtual ~LotteryNotify();

  LotteryNotify(const LotteryNotify& from);

  inline LotteryNotify& operator=(const LotteryNotify& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LotteryNotify(LotteryNotify&& from) noexcept
    : LotteryNotify() {
    *this = ::std::move(from);
  }

  inline LotteryNotify& operator=(LotteryNotify&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const LotteryNotify& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LotteryNotify* internal_default_instance() {
    return reinterpret_cast<const LotteryNotify*>(
               &_LotteryNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void UnsafeArenaSwap(LotteryNotify* other);
  void Swap(LotteryNotify* other);
  friend void swap(LotteryNotify& a, LotteryNotify& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LotteryNotify* New() const final {
    return CreateMaybeMessage<LotteryNotify>(NULL);
  }

  LotteryNotify* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LotteryNotify>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LotteryNotify& from);
  void MergeFrom(const LotteryNotify& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LotteryNotify* other);
  protected:
  explicit LotteryNotify(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes nick = 2;
  bool has_nick() const;
  void clear_nick();
  static const int kNickFieldNumber = 2;
  const ::std::string& nick() const;
  void set_nick(const ::std::string& value);
  #if LANG_CXX11
  void set_nick(::std::string&& value);
  #endif
  void set_nick(const char* value);
  void set_nick(const void* value, size_t size);
  ::std::string* mutable_nick();
  ::std::string* release_nick();
  void set_allocated_nick(::std::string* nick);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_nick();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_nick(
      ::std::string* nick);

  // required uint64 uuid = 1;
  bool has_uuid() const;
  void clear_uuid();
  static const int kUuidFieldNumber = 1;
  ::google::protobuf::uint64 uuid() const;
  void set_uuid(::google::protobuf::uint64 value);

  // required int32 get_type = 3;
  bool has_get_type() const;
  void clear_get_type();
  static const int kGetTypeFieldNumber = 3;
  ::google::protobuf::int32 get_type() const;
  void set_get_type(::google::protobuf::int32 value);

  // required int32 get_typeid = 4;
  bool has_get_typeid() const;
  void clear_get_typeid();
  static const int kGetTypeidFieldNumber = 4;
  ::google::protobuf::int32 get_typeid() const;
  void set_get_typeid(::google::protobuf::int32 value);

  // required sfixed64 timestamp = 5;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 5;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:sg.LotteryNotify)
 private:
  void set_has_uuid();
  void clear_has_uuid();
  void set_has_nick();
  void clear_has_nick();
  void set_has_get_type();
  void clear_has_get_type();
  void set_has_get_typeid();
  void clear_has_get_typeid();
  void set_has_timestamp();
  void clear_has_timestamp();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr nick_;
  ::google::protobuf::uint64 uuid_;
  ::google::protobuf::int32 get_type_;
  ::google::protobuf::int32 get_typeid_;
  ::google::protobuf::int64 timestamp_;
  friend struct ::protobuf_Lottery_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LotteryService_LotteryRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.LotteryService.LotteryRequest) */ {
 public:
  LotteryService_LotteryRequest();
  virtual ~LotteryService_LotteryRequest();

  LotteryService_LotteryRequest(const LotteryService_LotteryRequest& from);

  inline LotteryService_LotteryRequest& operator=(const LotteryService_LotteryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LotteryService_LotteryRequest(LotteryService_LotteryRequest&& from) noexcept
    : LotteryService_LotteryRequest() {
    *this = ::std::move(from);
  }

  inline LotteryService_LotteryRequest& operator=(LotteryService_LotteryRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const LotteryService_LotteryRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LotteryService_LotteryRequest* internal_default_instance() {
    return reinterpret_cast<const LotteryService_LotteryRequest*>(
               &_LotteryService_LotteryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void UnsafeArenaSwap(LotteryService_LotteryRequest* other);
  void Swap(LotteryService_LotteryRequest* other);
  friend void swap(LotteryService_LotteryRequest& a, LotteryService_LotteryRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LotteryService_LotteryRequest* New() const final {
    return CreateMaybeMessage<LotteryService_LotteryRequest>(NULL);
  }

  LotteryService_LotteryRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LotteryService_LotteryRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LotteryService_LotteryRequest& from);
  void MergeFrom(const LotteryService_LotteryRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LotteryService_LotteryRequest* other);
  protected:
  explicit LotteryService_LotteryRequest(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 machine_id = 2;
  bool has_machine_id() const;
  void clear_machine_id();
  static const int kMachineIdFieldNumber = 2;
  ::google::protobuf::int32 machine_id() const;
  void set_machine_id(::google::protobuf::int32 value);

  // required .sg.LotteryService.LOTTERY_CMD cmd = 1;
  bool has_cmd() const;
  void clear_cmd();
  static const int kCmdFieldNumber = 1;
  ::sg::LotteryService_LOTTERY_CMD cmd() const;
  void set_cmd(::sg::LotteryService_LOTTERY_CMD value);

  // @@protoc_insertion_point(class_scope:sg.LotteryService.LotteryRequest)
 private:
  void set_has_cmd();
  void clear_has_cmd();
  void set_has_machine_id();
  void clear_has_machine_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 machine_id_;
  int cmd_;
  friend struct ::protobuf_Lottery_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LotteryService_LotteryResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.LotteryService.LotteryResponse) */ {
 public:
  LotteryService_LotteryResponse();
  virtual ~LotteryService_LotteryResponse();

  LotteryService_LotteryResponse(const LotteryService_LotteryResponse& from);

  inline LotteryService_LotteryResponse& operator=(const LotteryService_LotteryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LotteryService_LotteryResponse(LotteryService_LotteryResponse&& from) noexcept
    : LotteryService_LotteryResponse() {
    *this = ::std::move(from);
  }

  inline LotteryService_LotteryResponse& operator=(LotteryService_LotteryResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const LotteryService_LotteryResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LotteryService_LotteryResponse* internal_default_instance() {
    return reinterpret_cast<const LotteryService_LotteryResponse*>(
               &_LotteryService_LotteryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void UnsafeArenaSwap(LotteryService_LotteryResponse* other);
  void Swap(LotteryService_LotteryResponse* other);
  friend void swap(LotteryService_LotteryResponse& a, LotteryService_LotteryResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LotteryService_LotteryResponse* New() const final {
    return CreateMaybeMessage<LotteryService_LotteryResponse>(NULL);
  }

  LotteryService_LotteryResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LotteryService_LotteryResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LotteryService_LotteryResponse& from);
  void MergeFrom(const LotteryService_LotteryResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LotteryService_LotteryResponse* other);
  protected:
  explicit LotteryService_LotteryResponse(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sg.LotteryMachine machine_list = 2;
  int machine_list_size() const;
  void clear_machine_list();
  static const int kMachineListFieldNumber = 2;
  ::sg::LotteryMachine* mutable_machine_list(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::LotteryMachine >*
      mutable_machine_list();
  const ::sg::LotteryMachine& machine_list(int index) const;
  ::sg::LotteryMachine* add_machine_list();
  const ::google::protobuf::RepeatedPtrField< ::sg::LotteryMachine >&
      machine_list() const;

  // repeated .sg.LotteryNotify notifys = 3;
  int notifys_size() const;
  void clear_notifys();
  static const int kNotifysFieldNumber = 3;
  ::sg::LotteryNotify* mutable_notifys(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::LotteryNotify >*
      mutable_notifys();
  const ::sg::LotteryNotify& notifys(int index) const;
  ::sg::LotteryNotify* add_notifys();
  const ::google::protobuf::RepeatedPtrField< ::sg::LotteryNotify >&
      notifys() const;

  // optional .sg.Reward reward = 11;
  bool has_reward() const;
  void clear_reward();
  static const int kRewardFieldNumber = 11;
  private:
  const ::sg::Reward& _internal_reward() const;
  public:
  const ::sg::Reward& reward() const;
  ::sg::Reward* release_reward();
  ::sg::Reward* mutable_reward();
  void set_allocated_reward(::sg::Reward* reward);
  void unsafe_arena_set_allocated_reward(
      ::sg::Reward* reward);
  ::sg::Reward* unsafe_arena_release_reward();

  // required int32 result = 1;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::google::protobuf::int32 result() const;
  void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.LotteryService.LotteryResponse)
 private:
  void set_has_result();
  void clear_has_result();
  void set_has_reward();
  void clear_has_reward();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::LotteryMachine > machine_list_;
  ::google::protobuf::RepeatedPtrField< ::sg::LotteryNotify > notifys_;
  ::sg::Reward* reward_;
  ::google::protobuf::int32 result_;
  friend struct ::protobuf_Lottery_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LotteryService : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.LotteryService) */ {
 public:
  LotteryService();
  virtual ~LotteryService();

  LotteryService(const LotteryService& from);

  inline LotteryService& operator=(const LotteryService& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LotteryService(LotteryService&& from) noexcept
    : LotteryService() {
    *this = ::std::move(from);
  }

  inline LotteryService& operator=(LotteryService&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const LotteryService& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LotteryService* internal_default_instance() {
    return reinterpret_cast<const LotteryService*>(
               &_LotteryService_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void UnsafeArenaSwap(LotteryService* other);
  void Swap(LotteryService* other);
  friend void swap(LotteryService& a, LotteryService& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LotteryService* New() const final {
    return CreateMaybeMessage<LotteryService>(NULL);
  }

  LotteryService* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LotteryService>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LotteryService& from);
  void MergeFrom(const LotteryService& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LotteryService* other);
  protected:
  explicit LotteryService(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LotteryService_LotteryRequest LotteryRequest;
  typedef LotteryService_LotteryResponse LotteryResponse;

  typedef LotteryService_LOTTERY_CMD LOTTERY_CMD;
  static const LOTTERY_CMD QUERY =
    LotteryService_LOTTERY_CMD_QUERY;
  static const LOTTERY_CMD QUERY_NOTIFY =
    LotteryService_LOTTERY_CMD_QUERY_NOTIFY;
  static const LOTTERY_CMD LOTTERY_ONCE =
    LotteryService_LOTTERY_CMD_LOTTERY_ONCE;
  static const LOTTERY_CMD LOTTERY_TEN_TIMES =
    LotteryService_LOTTERY_CMD_LOTTERY_TEN_TIMES;
  static inline bool LOTTERY_CMD_IsValid(int value) {
    return LotteryService_LOTTERY_CMD_IsValid(value);
  }
  static const LOTTERY_CMD LOTTERY_CMD_MIN =
    LotteryService_LOTTERY_CMD_LOTTERY_CMD_MIN;
  static const LOTTERY_CMD LOTTERY_CMD_MAX =
    LotteryService_LOTTERY_CMD_LOTTERY_CMD_MAX;
  static const int LOTTERY_CMD_ARRAYSIZE =
    LotteryService_LOTTERY_CMD_LOTTERY_CMD_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LOTTERY_CMD_descriptor() {
    return LotteryService_LOTTERY_CMD_descriptor();
  }
  static inline const ::std::string& LOTTERY_CMD_Name(LOTTERY_CMD value) {
    return LotteryService_LOTTERY_CMD_Name(value);
  }
  static inline bool LOTTERY_CMD_Parse(const ::std::string& name,
      LOTTERY_CMD* value) {
    return LotteryService_LOTTERY_CMD_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .sg.LotteryService.LotteryRequest req = 1;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 1;
  private:
  const ::sg::LotteryService_LotteryRequest& _internal_req() const;
  public:
  const ::sg::LotteryService_LotteryRequest& req() const;
  ::sg::LotteryService_LotteryRequest* release_req();
  ::sg::LotteryService_LotteryRequest* mutable_req();
  void set_allocated_req(::sg::LotteryService_LotteryRequest* req);
  void unsafe_arena_set_allocated_req(
      ::sg::LotteryService_LotteryRequest* req);
  ::sg::LotteryService_LotteryRequest* unsafe_arena_release_req();

  // optional .sg.LotteryService.LotteryResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  private:
  const ::sg::LotteryService_LotteryResponse& _internal_resp() const;
  public:
  const ::sg::LotteryService_LotteryResponse& resp() const;
  ::sg::LotteryService_LotteryResponse* release_resp();
  ::sg::LotteryService_LotteryResponse* mutable_resp();
  void set_allocated_resp(::sg::LotteryService_LotteryResponse* resp);
  void unsafe_arena_set_allocated_resp(
      ::sg::LotteryService_LotteryResponse* resp);
  ::sg::LotteryService_LotteryResponse* unsafe_arena_release_resp();

  // @@protoc_insertion_point(class_scope:sg.LotteryService)
 private:
  void set_has_req();
  void clear_has_req();
  void set_has_resp();
  void clear_has_resp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::sg::LotteryService_LotteryRequest* req_;
  ::sg::LotteryService_LotteryResponse* resp_;
  friend struct ::protobuf_Lottery_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LotteryMachine

// required int32 id = 1;
inline bool LotteryMachine::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LotteryMachine::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LotteryMachine::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LotteryMachine::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 LotteryMachine::id() const {
  // @@protoc_insertion_point(field_get:sg.LotteryMachine.id)
  return id_;
}
inline void LotteryMachine::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:sg.LotteryMachine.id)
}

// required int32 type = 2;
inline bool LotteryMachine::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LotteryMachine::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LotteryMachine::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LotteryMachine::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 LotteryMachine::type() const {
  // @@protoc_insertion_point(field_get:sg.LotteryMachine.type)
  return type_;
}
inline void LotteryMachine::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:sg.LotteryMachine.type)
}

// required int32 cost_item = 3;
inline bool LotteryMachine::has_cost_item() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LotteryMachine::set_has_cost_item() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LotteryMachine::clear_has_cost_item() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LotteryMachine::clear_cost_item() {
  cost_item_ = 0;
  clear_has_cost_item();
}
inline ::google::protobuf::int32 LotteryMachine::cost_item() const {
  // @@protoc_insertion_point(field_get:sg.LotteryMachine.cost_item)
  return cost_item_;
}
inline void LotteryMachine::set_cost_item(::google::protobuf::int32 value) {
  set_has_cost_item();
  cost_item_ = value;
  // @@protoc_insertion_point(field_set:sg.LotteryMachine.cost_item)
}

// required int32 once_cost = 4;
inline bool LotteryMachine::has_once_cost() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LotteryMachine::set_has_once_cost() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LotteryMachine::clear_has_once_cost() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LotteryMachine::clear_once_cost() {
  once_cost_ = 0;
  clear_has_once_cost();
}
inline ::google::protobuf::int32 LotteryMachine::once_cost() const {
  // @@protoc_insertion_point(field_get:sg.LotteryMachine.once_cost)
  return once_cost_;
}
inline void LotteryMachine::set_once_cost(::google::protobuf::int32 value) {
  set_has_once_cost();
  once_cost_ = value;
  // @@protoc_insertion_point(field_set:sg.LotteryMachine.once_cost)
}

// required int32 ten_times_cost = 5;
inline bool LotteryMachine::has_ten_times_cost() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LotteryMachine::set_has_ten_times_cost() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LotteryMachine::clear_has_ten_times_cost() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LotteryMachine::clear_ten_times_cost() {
  ten_times_cost_ = 0;
  clear_has_ten_times_cost();
}
inline ::google::protobuf::int32 LotteryMachine::ten_times_cost() const {
  // @@protoc_insertion_point(field_get:sg.LotteryMachine.ten_times_cost)
  return ten_times_cost_;
}
inline void LotteryMachine::set_ten_times_cost(::google::protobuf::int32 value) {
  set_has_ten_times_cost();
  ten_times_cost_ = value;
  // @@protoc_insertion_point(field_set:sg.LotteryMachine.ten_times_cost)
}

// required int32 remain_times = 6;
inline bool LotteryMachine::has_remain_times() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LotteryMachine::set_has_remain_times() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LotteryMachine::clear_has_remain_times() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LotteryMachine::clear_remain_times() {
  remain_times_ = 0;
  clear_has_remain_times();
}
inline ::google::protobuf::int32 LotteryMachine::remain_times() const {
  // @@protoc_insertion_point(field_get:sg.LotteryMachine.remain_times)
  return remain_times_;
}
inline void LotteryMachine::set_remain_times(::google::protobuf::int32 value) {
  set_has_remain_times();
  remain_times_ = value;
  // @@protoc_insertion_point(field_set:sg.LotteryMachine.remain_times)
}

// required int32 activity_id = 7;
inline bool LotteryMachine::has_activity_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LotteryMachine::set_has_activity_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LotteryMachine::clear_has_activity_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LotteryMachine::clear_activity_id() {
  activity_id_ = 0;
  clear_has_activity_id();
}
inline ::google::protobuf::int32 LotteryMachine::activity_id() const {
  // @@protoc_insertion_point(field_get:sg.LotteryMachine.activity_id)
  return activity_id_;
}
inline void LotteryMachine::set_activity_id(::google::protobuf::int32 value) {
  set_has_activity_id();
  activity_id_ = value;
  // @@protoc_insertion_point(field_set:sg.LotteryMachine.activity_id)
}

// optional int32 cost_add = 8;
inline bool LotteryMachine::has_cost_add() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LotteryMachine::set_has_cost_add() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LotteryMachine::clear_has_cost_add() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LotteryMachine::clear_cost_add() {
  cost_add_ = 0;
  clear_has_cost_add();
}
inline ::google::protobuf::int32 LotteryMachine::cost_add() const {
  // @@protoc_insertion_point(field_get:sg.LotteryMachine.cost_add)
  return cost_add_;
}
inline void LotteryMachine::set_cost_add(::google::protobuf::int32 value) {
  set_has_cost_add();
  cost_add_ = value;
  // @@protoc_insertion_point(field_set:sg.LotteryMachine.cost_add)
}

// -------------------------------------------------------------------

// LotteryNotify

// required uint64 uuid = 1;
inline bool LotteryNotify::has_uuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LotteryNotify::set_has_uuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LotteryNotify::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LotteryNotify::clear_uuid() {
  uuid_ = GOOGLE_ULONGLONG(0);
  clear_has_uuid();
}
inline ::google::protobuf::uint64 LotteryNotify::uuid() const {
  // @@protoc_insertion_point(field_get:sg.LotteryNotify.uuid)
  return uuid_;
}
inline void LotteryNotify::set_uuid(::google::protobuf::uint64 value) {
  set_has_uuid();
  uuid_ = value;
  // @@protoc_insertion_point(field_set:sg.LotteryNotify.uuid)
}

// required bytes nick = 2;
inline bool LotteryNotify::has_nick() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LotteryNotify::set_has_nick() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LotteryNotify::clear_has_nick() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LotteryNotify::clear_nick() {
  nick_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_nick();
}
inline const ::std::string& LotteryNotify::nick() const {
  // @@protoc_insertion_point(field_get:sg.LotteryNotify.nick)
  return nick_.Get();
}
inline void LotteryNotify::set_nick(const ::std::string& value) {
  set_has_nick();
  nick_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:sg.LotteryNotify.nick)
}
#if LANG_CXX11
inline void LotteryNotify::set_nick(::std::string&& value) {
  set_has_nick();
  nick_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:sg.LotteryNotify.nick)
}
#endif
inline void LotteryNotify::set_nick(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_nick();
  nick_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:sg.LotteryNotify.nick)
}
inline void LotteryNotify::set_nick(const void* value,
    size_t size) {
  set_has_nick();
  nick_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:sg.LotteryNotify.nick)
}
inline ::std::string* LotteryNotify::mutable_nick() {
  set_has_nick();
  // @@protoc_insertion_point(field_mutable:sg.LotteryNotify.nick)
  return nick_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* LotteryNotify::release_nick() {
  // @@protoc_insertion_point(field_release:sg.LotteryNotify.nick)
  if (!has_nick()) {
    return NULL;
  }
  clear_has_nick();
  return nick_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void LotteryNotify::set_allocated_nick(::std::string* nick) {
  if (nick != NULL) {
    set_has_nick();
  } else {
    clear_has_nick();
  }
  nick_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nick,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:sg.LotteryNotify.nick)
}
inline ::std::string* LotteryNotify::unsafe_arena_release_nick() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.LotteryNotify.nick)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_nick();
  return nick_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void LotteryNotify::unsafe_arena_set_allocated_nick(
    ::std::string* nick) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (nick != NULL) {
    set_has_nick();
  } else {
    clear_has_nick();
  }
  nick_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      nick, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sg.LotteryNotify.nick)
}

// required int32 get_type = 3;
inline bool LotteryNotify::has_get_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LotteryNotify::set_has_get_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LotteryNotify::clear_has_get_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LotteryNotify::clear_get_type() {
  get_type_ = 0;
  clear_has_get_type();
}
inline ::google::protobuf::int32 LotteryNotify::get_type() const {
  // @@protoc_insertion_point(field_get:sg.LotteryNotify.get_type)
  return get_type_;
}
inline void LotteryNotify::set_get_type(::google::protobuf::int32 value) {
  set_has_get_type();
  get_type_ = value;
  // @@protoc_insertion_point(field_set:sg.LotteryNotify.get_type)
}

// required int32 get_typeid = 4;
inline bool LotteryNotify::has_get_typeid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LotteryNotify::set_has_get_typeid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LotteryNotify::clear_has_get_typeid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LotteryNotify::clear_get_typeid() {
  get_typeid_ = 0;
  clear_has_get_typeid();
}
inline ::google::protobuf::int32 LotteryNotify::get_typeid() const {
  // @@protoc_insertion_point(field_get:sg.LotteryNotify.get_typeid)
  return get_typeid_;
}
inline void LotteryNotify::set_get_typeid(::google::protobuf::int32 value) {
  set_has_get_typeid();
  get_typeid_ = value;
  // @@protoc_insertion_point(field_set:sg.LotteryNotify.get_typeid)
}

// required sfixed64 timestamp = 5;
inline bool LotteryNotify::has_timestamp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LotteryNotify::set_has_timestamp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LotteryNotify::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LotteryNotify::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 LotteryNotify::timestamp() const {
  // @@protoc_insertion_point(field_get:sg.LotteryNotify.timestamp)
  return timestamp_;
}
inline void LotteryNotify::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:sg.LotteryNotify.timestamp)
}

// -------------------------------------------------------------------

// LotteryService_LotteryRequest

// required .sg.LotteryService.LOTTERY_CMD cmd = 1;
inline bool LotteryService_LotteryRequest::has_cmd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LotteryService_LotteryRequest::set_has_cmd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LotteryService_LotteryRequest::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LotteryService_LotteryRequest::clear_cmd() {
  cmd_ = 1;
  clear_has_cmd();
}
inline ::sg::LotteryService_LOTTERY_CMD LotteryService_LotteryRequest::cmd() const {
  // @@protoc_insertion_point(field_get:sg.LotteryService.LotteryRequest.cmd)
  return static_cast< ::sg::LotteryService_LOTTERY_CMD >(cmd_);
}
inline void LotteryService_LotteryRequest::set_cmd(::sg::LotteryService_LOTTERY_CMD value) {
  assert(::sg::LotteryService_LOTTERY_CMD_IsValid(value));
  set_has_cmd();
  cmd_ = value;
  // @@protoc_insertion_point(field_set:sg.LotteryService.LotteryRequest.cmd)
}

// optional int32 machine_id = 2;
inline bool LotteryService_LotteryRequest::has_machine_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LotteryService_LotteryRequest::set_has_machine_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LotteryService_LotteryRequest::clear_has_machine_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LotteryService_LotteryRequest::clear_machine_id() {
  machine_id_ = 0;
  clear_has_machine_id();
}
inline ::google::protobuf::int32 LotteryService_LotteryRequest::machine_id() const {
  // @@protoc_insertion_point(field_get:sg.LotteryService.LotteryRequest.machine_id)
  return machine_id_;
}
inline void LotteryService_LotteryRequest::set_machine_id(::google::protobuf::int32 value) {
  set_has_machine_id();
  machine_id_ = value;
  // @@protoc_insertion_point(field_set:sg.LotteryService.LotteryRequest.machine_id)
}

// -------------------------------------------------------------------

// LotteryService_LotteryResponse

// required int32 result = 1;
inline bool LotteryService_LotteryResponse::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LotteryService_LotteryResponse::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LotteryService_LotteryResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LotteryService_LotteryResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 LotteryService_LotteryResponse::result() const {
  // @@protoc_insertion_point(field_get:sg.LotteryService.LotteryResponse.result)
  return result_;
}
inline void LotteryService_LotteryResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:sg.LotteryService.LotteryResponse.result)
}

// repeated .sg.LotteryMachine machine_list = 2;
inline int LotteryService_LotteryResponse::machine_list_size() const {
  return machine_list_.size();
}
inline void LotteryService_LotteryResponse::clear_machine_list() {
  machine_list_.Clear();
}
inline ::sg::LotteryMachine* LotteryService_LotteryResponse::mutable_machine_list(int index) {
  // @@protoc_insertion_point(field_mutable:sg.LotteryService.LotteryResponse.machine_list)
  return machine_list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::LotteryMachine >*
LotteryService_LotteryResponse::mutable_machine_list() {
  // @@protoc_insertion_point(field_mutable_list:sg.LotteryService.LotteryResponse.machine_list)
  return &machine_list_;
}
inline const ::sg::LotteryMachine& LotteryService_LotteryResponse::machine_list(int index) const {
  // @@protoc_insertion_point(field_get:sg.LotteryService.LotteryResponse.machine_list)
  return machine_list_.Get(index);
}
inline ::sg::LotteryMachine* LotteryService_LotteryResponse::add_machine_list() {
  // @@protoc_insertion_point(field_add:sg.LotteryService.LotteryResponse.machine_list)
  return machine_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::LotteryMachine >&
LotteryService_LotteryResponse::machine_list() const {
  // @@protoc_insertion_point(field_list:sg.LotteryService.LotteryResponse.machine_list)
  return machine_list_;
}

// repeated .sg.LotteryNotify notifys = 3;
inline int LotteryService_LotteryResponse::notifys_size() const {
  return notifys_.size();
}
inline void LotteryService_LotteryResponse::clear_notifys() {
  notifys_.Clear();
}
inline ::sg::LotteryNotify* LotteryService_LotteryResponse::mutable_notifys(int index) {
  // @@protoc_insertion_point(field_mutable:sg.LotteryService.LotteryResponse.notifys)
  return notifys_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::LotteryNotify >*
LotteryService_LotteryResponse::mutable_notifys() {
  // @@protoc_insertion_point(field_mutable_list:sg.LotteryService.LotteryResponse.notifys)
  return &notifys_;
}
inline const ::sg::LotteryNotify& LotteryService_LotteryResponse::notifys(int index) const {
  // @@protoc_insertion_point(field_get:sg.LotteryService.LotteryResponse.notifys)
  return notifys_.Get(index);
}
inline ::sg::LotteryNotify* LotteryService_LotteryResponse::add_notifys() {
  // @@protoc_insertion_point(field_add:sg.LotteryService.LotteryResponse.notifys)
  return notifys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::LotteryNotify >&
LotteryService_LotteryResponse::notifys() const {
  // @@protoc_insertion_point(field_list:sg.LotteryService.LotteryResponse.notifys)
  return notifys_;
}

// optional .sg.Reward reward = 11;
inline bool LotteryService_LotteryResponse::has_reward() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LotteryService_LotteryResponse::set_has_reward() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LotteryService_LotteryResponse::clear_has_reward() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::sg::Reward& LotteryService_LotteryResponse::_internal_reward() const {
  return *reward_;
}
inline const ::sg::Reward& LotteryService_LotteryResponse::reward() const {
  const ::sg::Reward* p = reward_;
  // @@protoc_insertion_point(field_get:sg.LotteryService.LotteryResponse.reward)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::Reward*>(
      &::sg::_Reward_default_instance_);
}
inline ::sg::Reward* LotteryService_LotteryResponse::release_reward() {
  // @@protoc_insertion_point(field_release:sg.LotteryService.LotteryResponse.reward)
  clear_has_reward();
  ::sg::Reward* temp = reward_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  reward_ = NULL;
  return temp;
}
inline ::sg::Reward* LotteryService_LotteryResponse::unsafe_arena_release_reward() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.LotteryService.LotteryResponse.reward)
  clear_has_reward();
  ::sg::Reward* temp = reward_;
  reward_ = NULL;
  return temp;
}
inline ::sg::Reward* LotteryService_LotteryResponse::mutable_reward() {
  set_has_reward();
  if (reward_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::Reward>(GetArenaNoVirtual());
    reward_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.LotteryService.LotteryResponse.reward)
  return reward_;
}
inline void LotteryService_LotteryResponse::set_allocated_reward(::sg::Reward* reward) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(reward_);
  }
  if (reward) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(reward)->GetArena();
    if (message_arena != submessage_arena) {
      reward = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, reward, submessage_arena);
    }
    set_has_reward();
  } else {
    clear_has_reward();
  }
  reward_ = reward;
  // @@protoc_insertion_point(field_set_allocated:sg.LotteryService.LotteryResponse.reward)
}

// -------------------------------------------------------------------

// LotteryService

// optional .sg.LotteryService.LotteryRequest req = 1;
inline bool LotteryService::has_req() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LotteryService::set_has_req() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LotteryService::clear_has_req() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LotteryService::clear_req() {
  if (req_ != NULL) req_->Clear();
  clear_has_req();
}
inline const ::sg::LotteryService_LotteryRequest& LotteryService::_internal_req() const {
  return *req_;
}
inline const ::sg::LotteryService_LotteryRequest& LotteryService::req() const {
  const ::sg::LotteryService_LotteryRequest* p = req_;
  // @@protoc_insertion_point(field_get:sg.LotteryService.req)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::LotteryService_LotteryRequest*>(
      &::sg::_LotteryService_LotteryRequest_default_instance_);
}
inline ::sg::LotteryService_LotteryRequest* LotteryService::release_req() {
  // @@protoc_insertion_point(field_release:sg.LotteryService.req)
  clear_has_req();
  ::sg::LotteryService_LotteryRequest* temp = req_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  req_ = NULL;
  return temp;
}
inline ::sg::LotteryService_LotteryRequest* LotteryService::unsafe_arena_release_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.LotteryService.req)
  clear_has_req();
  ::sg::LotteryService_LotteryRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline ::sg::LotteryService_LotteryRequest* LotteryService::mutable_req() {
  set_has_req();
  if (req_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::LotteryService_LotteryRequest>(GetArenaNoVirtual());
    req_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.LotteryService.req)
  return req_;
}
inline void LotteryService::set_allocated_req(::sg::LotteryService_LotteryRequest* req) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete req_;
  }
  if (req) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(req);
    if (message_arena != submessage_arena) {
      req = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, req, submessage_arena);
    }
    set_has_req();
  } else {
    clear_has_req();
  }
  req_ = req;
  // @@protoc_insertion_point(field_set_allocated:sg.LotteryService.req)
}

// optional .sg.LotteryService.LotteryResponse resp = 2;
inline bool LotteryService::has_resp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LotteryService::set_has_resp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LotteryService::clear_has_resp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LotteryService::clear_resp() {
  if (resp_ != NULL) resp_->Clear();
  clear_has_resp();
}
inline const ::sg::LotteryService_LotteryResponse& LotteryService::_internal_resp() const {
  return *resp_;
}
inline const ::sg::LotteryService_LotteryResponse& LotteryService::resp() const {
  const ::sg::LotteryService_LotteryResponse* p = resp_;
  // @@protoc_insertion_point(field_get:sg.LotteryService.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::LotteryService_LotteryResponse*>(
      &::sg::_LotteryService_LotteryResponse_default_instance_);
}
inline ::sg::LotteryService_LotteryResponse* LotteryService::release_resp() {
  // @@protoc_insertion_point(field_release:sg.LotteryService.resp)
  clear_has_resp();
  ::sg::LotteryService_LotteryResponse* temp = resp_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  resp_ = NULL;
  return temp;
}
inline ::sg::LotteryService_LotteryResponse* LotteryService::unsafe_arena_release_resp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.LotteryService.resp)
  clear_has_resp();
  ::sg::LotteryService_LotteryResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline ::sg::LotteryService_LotteryResponse* LotteryService::mutable_resp() {
  set_has_resp();
  if (resp_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::LotteryService_LotteryResponse>(GetArenaNoVirtual());
    resp_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.LotteryService.resp)
  return resp_;
}
inline void LotteryService::set_allocated_resp(::sg::LotteryService_LotteryResponse* resp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete resp_;
  }
  if (resp) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(resp);
    if (message_arena != submessage_arena) {
      resp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, resp, submessage_arena);
    }
    set_has_resp();
  } else {
    clear_has_resp();
  }
  resp_ = resp;
  // @@protoc_insertion_point(field_set_allocated:sg.LotteryService.resp)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace sg

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::sg::LotteryService_LOTTERY_CMD> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::LotteryService_LOTTERY_CMD>() {
  return ::sg::LotteryService_LOTTERY_CMD_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_Lottery_2eproto
