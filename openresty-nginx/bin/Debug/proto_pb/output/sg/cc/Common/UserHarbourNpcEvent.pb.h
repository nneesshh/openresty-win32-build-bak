// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: UserHarbourNpcEvent.proto

#ifndef PROTOBUF_INCLUDED_UserHarbourNpcEvent_2eproto
#define PROTOBUF_INCLUDED_UserHarbourNpcEvent_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "BaseStruct.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_UserHarbourNpcEvent_2eproto 

namespace protobuf_UserHarbourNpcEvent_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[9];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_UserHarbourNpcEvent_2eproto
namespace sg {
class HarborNpcEvent;
class HarborNpcEventDefaultTypeInternal;
extern HarborNpcEventDefaultTypeInternal _HarborNpcEvent_default_instance_;
class HarborNpcEventList;
class HarborNpcEventListDefaultTypeInternal;
extern HarborNpcEventListDefaultTypeInternal _HarborNpcEventList_default_instance_;
class UserHarborNpcEventNotify;
class UserHarborNpcEventNotifyDefaultTypeInternal;
extern UserHarborNpcEventNotifyDefaultTypeInternal _UserHarborNpcEventNotify_default_instance_;
class UserHarborNpcEventService;
class UserHarborNpcEventServiceDefaultTypeInternal;
extern UserHarborNpcEventServiceDefaultTypeInternal _UserHarborNpcEventService_default_instance_;
class UserHarborNpcEventService_EventRequest;
class UserHarborNpcEventService_EventRequestDefaultTypeInternal;
extern UserHarborNpcEventService_EventRequestDefaultTypeInternal _UserHarborNpcEventService_EventRequest_default_instance_;
class UserHarborNpcEventService_EventResponse;
class UserHarborNpcEventService_EventResponseDefaultTypeInternal;
extern UserHarborNpcEventService_EventResponseDefaultTypeInternal _UserHarborNpcEventService_EventResponse_default_instance_;
class UserHarborNpcStealActionService;
class UserHarborNpcStealActionServiceDefaultTypeInternal;
extern UserHarborNpcStealActionServiceDefaultTypeInternal _UserHarborNpcStealActionService_default_instance_;
class UserHarborNpcStealActionService_ActionRequest;
class UserHarborNpcStealActionService_ActionRequestDefaultTypeInternal;
extern UserHarborNpcStealActionService_ActionRequestDefaultTypeInternal _UserHarborNpcStealActionService_ActionRequest_default_instance_;
class UserHarborNpcStealActionService_ActionResponse;
class UserHarborNpcStealActionService_ActionResponseDefaultTypeInternal;
extern UserHarborNpcStealActionService_ActionResponseDefaultTypeInternal _UserHarborNpcStealActionService_ActionResponse_default_instance_;
}  // namespace sg
namespace google {
namespace protobuf {
template<> ::sg::HarborNpcEvent* Arena::CreateMaybeMessage<::sg::HarborNpcEvent>(Arena*);
template<> ::sg::HarborNpcEventList* Arena::CreateMaybeMessage<::sg::HarborNpcEventList>(Arena*);
template<> ::sg::UserHarborNpcEventNotify* Arena::CreateMaybeMessage<::sg::UserHarborNpcEventNotify>(Arena*);
template<> ::sg::UserHarborNpcEventService* Arena::CreateMaybeMessage<::sg::UserHarborNpcEventService>(Arena*);
template<> ::sg::UserHarborNpcEventService_EventRequest* Arena::CreateMaybeMessage<::sg::UserHarborNpcEventService_EventRequest>(Arena*);
template<> ::sg::UserHarborNpcEventService_EventResponse* Arena::CreateMaybeMessage<::sg::UserHarborNpcEventService_EventResponse>(Arena*);
template<> ::sg::UserHarborNpcStealActionService* Arena::CreateMaybeMessage<::sg::UserHarborNpcStealActionService>(Arena*);
template<> ::sg::UserHarborNpcStealActionService_ActionRequest* Arena::CreateMaybeMessage<::sg::UserHarborNpcStealActionService_ActionRequest>(Arena*);
template<> ::sg::UserHarborNpcStealActionService_ActionResponse* Arena::CreateMaybeMessage<::sg::UserHarborNpcStealActionService_ActionResponse>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace sg {

enum UserHarborNpcEventService_EVENT_COMMAND {
  UserHarborNpcEventService_EVENT_COMMAND_QUERY = 1
};
bool UserHarborNpcEventService_EVENT_COMMAND_IsValid(int value);
const UserHarborNpcEventService_EVENT_COMMAND UserHarborNpcEventService_EVENT_COMMAND_EVENT_COMMAND_MIN = UserHarborNpcEventService_EVENT_COMMAND_QUERY;
const UserHarborNpcEventService_EVENT_COMMAND UserHarborNpcEventService_EVENT_COMMAND_EVENT_COMMAND_MAX = UserHarborNpcEventService_EVENT_COMMAND_QUERY;
const int UserHarborNpcEventService_EVENT_COMMAND_EVENT_COMMAND_ARRAYSIZE = UserHarborNpcEventService_EVENT_COMMAND_EVENT_COMMAND_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserHarborNpcEventService_EVENT_COMMAND_descriptor();
inline const ::std::string& UserHarborNpcEventService_EVENT_COMMAND_Name(UserHarborNpcEventService_EVENT_COMMAND value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserHarborNpcEventService_EVENT_COMMAND_descriptor(), value);
}
inline bool UserHarborNpcEventService_EVENT_COMMAND_Parse(
    const ::std::string& name, UserHarborNpcEventService_EVENT_COMMAND* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserHarborNpcEventService_EVENT_COMMAND>(
    UserHarborNpcEventService_EVENT_COMMAND_descriptor(), name, value);
}
enum UserHarborNpcStealActionService_ACTION_COMMAND {
  UserHarborNpcStealActionService_ACTION_COMMAND_NPC_STEAL = 1,
  UserHarborNpcStealActionService_ACTION_COMMAND_PLAYER_CATCH = 2
};
bool UserHarborNpcStealActionService_ACTION_COMMAND_IsValid(int value);
const UserHarborNpcStealActionService_ACTION_COMMAND UserHarborNpcStealActionService_ACTION_COMMAND_ACTION_COMMAND_MIN = UserHarborNpcStealActionService_ACTION_COMMAND_NPC_STEAL;
const UserHarborNpcStealActionService_ACTION_COMMAND UserHarborNpcStealActionService_ACTION_COMMAND_ACTION_COMMAND_MAX = UserHarborNpcStealActionService_ACTION_COMMAND_PLAYER_CATCH;
const int UserHarborNpcStealActionService_ACTION_COMMAND_ACTION_COMMAND_ARRAYSIZE = UserHarborNpcStealActionService_ACTION_COMMAND_ACTION_COMMAND_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserHarborNpcStealActionService_ACTION_COMMAND_descriptor();
inline const ::std::string& UserHarborNpcStealActionService_ACTION_COMMAND_Name(UserHarborNpcStealActionService_ACTION_COMMAND value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserHarborNpcStealActionService_ACTION_COMMAND_descriptor(), value);
}
inline bool UserHarborNpcStealActionService_ACTION_COMMAND_Parse(
    const ::std::string& name, UserHarborNpcStealActionService_ACTION_COMMAND* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserHarborNpcStealActionService_ACTION_COMMAND>(
    UserHarborNpcStealActionService_ACTION_COMMAND_descriptor(), name, value);
}
enum OCCUPATION_TYPE {
  OCCUPATION_TYPE_COMMON = 1,
  OCCUPATION_TYPE_BEGGAR = 2,
  OCCUPATION_TYPE_VENDOR = 3,
  OCCUPATION_TYPE_THIEF = 4,
  OCCUPATION_TYPE_DINE_AND_DASH = 5,
  OCCUPATION_TYPE_VIP_ = 6,
  OCCUPATION_TYPE_KING = 7,
  OCCUPATION_TYPE_HUNGRY_GHOST = 11,
  OCCUPATION_TYPE_DRUNKARD = 12,
  OCCUPATION_TYPE_TRANSFORMER = 13,
  OCCUPATION_TYPE_DRUGSTER = 14,
  OCCUPATION_TYPE_CLOWN = 101,
  OCCUPATION_TYPE_DOUBLE_WALKER = 102
};
bool OCCUPATION_TYPE_IsValid(int value);
const OCCUPATION_TYPE OCCUPATION_TYPE_MIN = OCCUPATION_TYPE_COMMON;
const OCCUPATION_TYPE OCCUPATION_TYPE_MAX = OCCUPATION_TYPE_DOUBLE_WALKER;
const int OCCUPATION_TYPE_ARRAYSIZE = OCCUPATION_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* OCCUPATION_TYPE_descriptor();
inline const ::std::string& OCCUPATION_TYPE_Name(OCCUPATION_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    OCCUPATION_TYPE_descriptor(), value);
}
inline bool OCCUPATION_TYPE_Parse(
    const ::std::string& name, OCCUPATION_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OCCUPATION_TYPE>(
    OCCUPATION_TYPE_descriptor(), name, value);
}
enum OCCUPATION_STAGE {
  OCCUPATION_STAGE_ANY = 0,
  OCCUPATION_STAGE_HARBOR = 1,
  OCCUPATION_STAGE_SHIP_ENTERY = 2,
  OCCUPATION_STAGE_MAKE_FOOD_ORDER = 3,
  OCCUPATION_STAGE_EATING_OVER = 4,
  OCCUPATION_STAGE_PAY_OVER = 5
};
bool OCCUPATION_STAGE_IsValid(int value);
const OCCUPATION_STAGE OCCUPATION_STAGE_MIN = OCCUPATION_STAGE_ANY;
const OCCUPATION_STAGE OCCUPATION_STAGE_MAX = OCCUPATION_STAGE_PAY_OVER;
const int OCCUPATION_STAGE_ARRAYSIZE = OCCUPATION_STAGE_MAX + 1;

const ::google::protobuf::EnumDescriptor* OCCUPATION_STAGE_descriptor();
inline const ::std::string& OCCUPATION_STAGE_Name(OCCUPATION_STAGE value) {
  return ::google::protobuf::internal::NameOfEnum(
    OCCUPATION_STAGE_descriptor(), value);
}
inline bool OCCUPATION_STAGE_Parse(
    const ::std::string& name, OCCUPATION_STAGE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OCCUPATION_STAGE>(
    OCCUPATION_STAGE_descriptor(), name, value);
}
enum HARBOR_NPC_EVENT_TYPE {
  HARBOR_NPC_EVENT_TYPE_STEALING = 1,
  HARBOR_NPC_EVENT_TYPE_DASHING = 2,
  HARBOR_NPC_EVENT_TYPE_VIP = 3,
  HARBOR_NPC_EVENT_TYPE_KING = 4,
  HARBOR_NPC_EVENT_TYPE_STARVATION = 5,
  HARBOR_NPC_EVENT_TYPE_FIGHT_TRANSFORMER = 11,
  HARBOR_NPC_EVENT_TYPE_FIGHT_STAGE = 12
};
bool HARBOR_NPC_EVENT_TYPE_IsValid(int value);
const HARBOR_NPC_EVENT_TYPE HARBOR_NPC_EVENT_TYPE_MIN = HARBOR_NPC_EVENT_TYPE_STEALING;
const HARBOR_NPC_EVENT_TYPE HARBOR_NPC_EVENT_TYPE_MAX = HARBOR_NPC_EVENT_TYPE_FIGHT_STAGE;
const int HARBOR_NPC_EVENT_TYPE_ARRAYSIZE = HARBOR_NPC_EVENT_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* HARBOR_NPC_EVENT_TYPE_descriptor();
inline const ::std::string& HARBOR_NPC_EVENT_TYPE_Name(HARBOR_NPC_EVENT_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    HARBOR_NPC_EVENT_TYPE_descriptor(), value);
}
inline bool HARBOR_NPC_EVENT_TYPE_Parse(
    const ::std::string& name, HARBOR_NPC_EVENT_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HARBOR_NPC_EVENT_TYPE>(
    HARBOR_NPC_EVENT_TYPE_descriptor(), name, value);
}
enum HARBOR_NPC_EVENT_STATE {
  HARBOR_NPC_EVENT_STATE_OPEN = 1,
  HARBOR_NPC_EVENT_STATE_CLOSE = 2
};
bool HARBOR_NPC_EVENT_STATE_IsValid(int value);
const HARBOR_NPC_EVENT_STATE HARBOR_NPC_EVENT_STATE_MIN = HARBOR_NPC_EVENT_STATE_OPEN;
const HARBOR_NPC_EVENT_STATE HARBOR_NPC_EVENT_STATE_MAX = HARBOR_NPC_EVENT_STATE_CLOSE;
const int HARBOR_NPC_EVENT_STATE_ARRAYSIZE = HARBOR_NPC_EVENT_STATE_MAX + 1;

const ::google::protobuf::EnumDescriptor* HARBOR_NPC_EVENT_STATE_descriptor();
inline const ::std::string& HARBOR_NPC_EVENT_STATE_Name(HARBOR_NPC_EVENT_STATE value) {
  return ::google::protobuf::internal::NameOfEnum(
    HARBOR_NPC_EVENT_STATE_descriptor(), value);
}
inline bool HARBOR_NPC_EVENT_STATE_Parse(
    const ::std::string& name, HARBOR_NPC_EVENT_STATE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HARBOR_NPC_EVENT_STATE>(
    HARBOR_NPC_EVENT_STATE_descriptor(), name, value);
}
// ===================================================================

class HarborNpcEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.HarborNpcEvent) */ {
 public:
  HarborNpcEvent();
  virtual ~HarborNpcEvent();

  HarborNpcEvent(const HarborNpcEvent& from);

  inline HarborNpcEvent& operator=(const HarborNpcEvent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HarborNpcEvent(HarborNpcEvent&& from) noexcept
    : HarborNpcEvent() {
    *this = ::std::move(from);
  }

  inline HarborNpcEvent& operator=(HarborNpcEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const HarborNpcEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HarborNpcEvent* internal_default_instance() {
    return reinterpret_cast<const HarborNpcEvent*>(
               &_HarborNpcEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void UnsafeArenaSwap(HarborNpcEvent* other);
  void Swap(HarborNpcEvent* other);
  friend void swap(HarborNpcEvent& a, HarborNpcEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HarborNpcEvent* New() const final {
    return CreateMaybeMessage<HarborNpcEvent>(NULL);
  }

  HarborNpcEvent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HarborNpcEvent>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HarborNpcEvent& from);
  void MergeFrom(const HarborNpcEvent& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HarborNpcEvent* other);
  protected:
  explicit HarborNpcEvent(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 eventid = 1;
  bool has_eventid() const;
  void clear_eventid();
  static const int kEventidFieldNumber = 1;
  ::google::protobuf::int32 eventid() const;
  void set_eventid(::google::protobuf::int32 value);

  // required int32 npcid = 3;
  bool has_npcid() const;
  void clear_npcid();
  static const int kNpcidFieldNumber = 3;
  ::google::protobuf::int32 npcid() const;
  void set_npcid(::google::protobuf::int32 value);

  // required int32 state = 4;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 4;
  ::google::protobuf::int32 state() const;
  void set_state(::google::protobuf::int32 value);

  // optional int32 step = 12;
  bool has_step() const;
  void clear_step();
  static const int kStepFieldNumber = 12;
  ::google::protobuf::int32 step() const;
  void set_step(::google::protobuf::int32 value);

  // optional int32 param_funitureid = 15;
  bool has_param_funitureid() const;
  void clear_param_funitureid();
  static const int kParamFunitureidFieldNumber = 15;
  ::google::protobuf::int32 param_funitureid() const;
  void set_param_funitureid(::google::protobuf::int32 value);

  // optional int32 param_roomid = 13;
  bool has_param_roomid() const;
  void clear_param_roomid();
  static const int kParamRoomidFieldNumber = 13;
  ::google::protobuf::int32 param_roomid() const;
  void set_param_roomid(::google::protobuf::int32 value);

  // optional int32 param_npcid = 14;
  bool has_param_npcid() const;
  void clear_param_npcid();
  static const int kParamNpcidFieldNumber = 14;
  ::google::protobuf::int32 param_npcid() const;
  void set_param_npcid(::google::protobuf::int32 value);

  // required .sg.HARBOR_NPC_EVENT_TYPE event_type = 2;
  bool has_event_type() const;
  void clear_event_type();
  static const int kEventTypeFieldNumber = 2;
  ::sg::HARBOR_NPC_EVENT_TYPE event_type() const;
  void set_event_type(::sg::HARBOR_NPC_EVENT_TYPE value);

  // @@protoc_insertion_point(class_scope:sg.HarborNpcEvent)
 private:
  void set_has_eventid();
  void clear_has_eventid();
  void set_has_event_type();
  void clear_has_event_type();
  void set_has_npcid();
  void clear_has_npcid();
  void set_has_state();
  void clear_has_state();
  void set_has_step();
  void clear_has_step();
  void set_has_param_roomid();
  void clear_has_param_roomid();
  void set_has_param_npcid();
  void clear_has_param_npcid();
  void set_has_param_funitureid();
  void clear_has_param_funitureid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 eventid_;
  ::google::protobuf::int32 npcid_;
  ::google::protobuf::int32 state_;
  ::google::protobuf::int32 step_;
  ::google::protobuf::int32 param_funitureid_;
  ::google::protobuf::int32 param_roomid_;
  ::google::protobuf::int32 param_npcid_;
  int event_type_;
  friend struct ::protobuf_UserHarbourNpcEvent_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HarborNpcEventList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.HarborNpcEventList) */ {
 public:
  HarborNpcEventList();
  virtual ~HarborNpcEventList();

  HarborNpcEventList(const HarborNpcEventList& from);

  inline HarborNpcEventList& operator=(const HarborNpcEventList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HarborNpcEventList(HarborNpcEventList&& from) noexcept
    : HarborNpcEventList() {
    *this = ::std::move(from);
  }

  inline HarborNpcEventList& operator=(HarborNpcEventList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const HarborNpcEventList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HarborNpcEventList* internal_default_instance() {
    return reinterpret_cast<const HarborNpcEventList*>(
               &_HarborNpcEventList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void UnsafeArenaSwap(HarborNpcEventList* other);
  void Swap(HarborNpcEventList* other);
  friend void swap(HarborNpcEventList& a, HarborNpcEventList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HarborNpcEventList* New() const final {
    return CreateMaybeMessage<HarborNpcEventList>(NULL);
  }

  HarborNpcEventList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HarborNpcEventList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HarborNpcEventList& from);
  void MergeFrom(const HarborNpcEventList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HarborNpcEventList* other);
  protected:
  explicit HarborNpcEventList(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sg.HarborNpcEvent list = 1;
  int list_size() const;
  void clear_list();
  static const int kListFieldNumber = 1;
  ::sg::HarborNpcEvent* mutable_list(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::HarborNpcEvent >*
      mutable_list();
  const ::sg::HarborNpcEvent& list(int index) const;
  ::sg::HarborNpcEvent* add_list();
  const ::google::protobuf::RepeatedPtrField< ::sg::HarborNpcEvent >&
      list() const;

  // @@protoc_insertion_point(class_scope:sg.HarborNpcEventList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::HarborNpcEvent > list_;
  friend struct ::protobuf_UserHarbourNpcEvent_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserHarborNpcEventService_EventRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.UserHarborNpcEventService.EventRequest) */ {
 public:
  UserHarborNpcEventService_EventRequest();
  virtual ~UserHarborNpcEventService_EventRequest();

  UserHarborNpcEventService_EventRequest(const UserHarborNpcEventService_EventRequest& from);

  inline UserHarborNpcEventService_EventRequest& operator=(const UserHarborNpcEventService_EventRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserHarborNpcEventService_EventRequest(UserHarborNpcEventService_EventRequest&& from) noexcept
    : UserHarborNpcEventService_EventRequest() {
    *this = ::std::move(from);
  }

  inline UserHarborNpcEventService_EventRequest& operator=(UserHarborNpcEventService_EventRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserHarborNpcEventService_EventRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserHarborNpcEventService_EventRequest* internal_default_instance() {
    return reinterpret_cast<const UserHarborNpcEventService_EventRequest*>(
               &_UserHarborNpcEventService_EventRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void UnsafeArenaSwap(UserHarborNpcEventService_EventRequest* other);
  void Swap(UserHarborNpcEventService_EventRequest* other);
  friend void swap(UserHarborNpcEventService_EventRequest& a, UserHarborNpcEventService_EventRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserHarborNpcEventService_EventRequest* New() const final {
    return CreateMaybeMessage<UserHarborNpcEventService_EventRequest>(NULL);
  }

  UserHarborNpcEventService_EventRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserHarborNpcEventService_EventRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserHarborNpcEventService_EventRequest& from);
  void MergeFrom(const UserHarborNpcEventService_EventRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserHarborNpcEventService_EventRequest* other);
  protected:
  explicit UserHarborNpcEventService_EventRequest(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .sg.UserHarborNpcEventService.EVENT_COMMAND cmd = 1;
  bool has_cmd() const;
  void clear_cmd();
  static const int kCmdFieldNumber = 1;
  ::sg::UserHarborNpcEventService_EVENT_COMMAND cmd() const;
  void set_cmd(::sg::UserHarborNpcEventService_EVENT_COMMAND value);

  // @@protoc_insertion_point(class_scope:sg.UserHarborNpcEventService.EventRequest)
 private:
  void set_has_cmd();
  void clear_has_cmd();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int cmd_;
  friend struct ::protobuf_UserHarbourNpcEvent_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserHarborNpcEventService_EventResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.UserHarborNpcEventService.EventResponse) */ {
 public:
  UserHarborNpcEventService_EventResponse();
  virtual ~UserHarborNpcEventService_EventResponse();

  UserHarborNpcEventService_EventResponse(const UserHarborNpcEventService_EventResponse& from);

  inline UserHarborNpcEventService_EventResponse& operator=(const UserHarborNpcEventService_EventResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserHarborNpcEventService_EventResponse(UserHarborNpcEventService_EventResponse&& from) noexcept
    : UserHarborNpcEventService_EventResponse() {
    *this = ::std::move(from);
  }

  inline UserHarborNpcEventService_EventResponse& operator=(UserHarborNpcEventService_EventResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserHarborNpcEventService_EventResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserHarborNpcEventService_EventResponse* internal_default_instance() {
    return reinterpret_cast<const UserHarborNpcEventService_EventResponse*>(
               &_UserHarborNpcEventService_EventResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void UnsafeArenaSwap(UserHarborNpcEventService_EventResponse* other);
  void Swap(UserHarborNpcEventService_EventResponse* other);
  friend void swap(UserHarborNpcEventService_EventResponse& a, UserHarborNpcEventService_EventResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserHarborNpcEventService_EventResponse* New() const final {
    return CreateMaybeMessage<UserHarborNpcEventService_EventResponse>(NULL);
  }

  UserHarborNpcEventService_EventResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserHarborNpcEventService_EventResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserHarborNpcEventService_EventResponse& from);
  void MergeFrom(const UserHarborNpcEventService_EventResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserHarborNpcEventService_EventResponse* other);
  protected:
  explicit UserHarborNpcEventService_EventResponse(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .sg.HarborNpcEventList event_list = 2;
  bool has_event_list() const;
  void clear_event_list();
  static const int kEventListFieldNumber = 2;
  private:
  const ::sg::HarborNpcEventList& _internal_event_list() const;
  public:
  const ::sg::HarborNpcEventList& event_list() const;
  ::sg::HarborNpcEventList* release_event_list();
  ::sg::HarborNpcEventList* mutable_event_list();
  void set_allocated_event_list(::sg::HarborNpcEventList* event_list);
  void unsafe_arena_set_allocated_event_list(
      ::sg::HarborNpcEventList* event_list);
  ::sg::HarborNpcEventList* unsafe_arena_release_event_list();

  // required int32 result = 1;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::google::protobuf::int32 result() const;
  void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.UserHarborNpcEventService.EventResponse)
 private:
  void set_has_result();
  void clear_has_result();
  void set_has_event_list();
  void clear_has_event_list();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::sg::HarborNpcEventList* event_list_;
  ::google::protobuf::int32 result_;
  friend struct ::protobuf_UserHarbourNpcEvent_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserHarborNpcEventService : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.UserHarborNpcEventService) */ {
 public:
  UserHarborNpcEventService();
  virtual ~UserHarborNpcEventService();

  UserHarborNpcEventService(const UserHarborNpcEventService& from);

  inline UserHarborNpcEventService& operator=(const UserHarborNpcEventService& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserHarborNpcEventService(UserHarborNpcEventService&& from) noexcept
    : UserHarborNpcEventService() {
    *this = ::std::move(from);
  }

  inline UserHarborNpcEventService& operator=(UserHarborNpcEventService&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserHarborNpcEventService& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserHarborNpcEventService* internal_default_instance() {
    return reinterpret_cast<const UserHarborNpcEventService*>(
               &_UserHarborNpcEventService_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void UnsafeArenaSwap(UserHarborNpcEventService* other);
  void Swap(UserHarborNpcEventService* other);
  friend void swap(UserHarborNpcEventService& a, UserHarborNpcEventService& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserHarborNpcEventService* New() const final {
    return CreateMaybeMessage<UserHarborNpcEventService>(NULL);
  }

  UserHarborNpcEventService* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserHarborNpcEventService>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserHarborNpcEventService& from);
  void MergeFrom(const UserHarborNpcEventService& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserHarborNpcEventService* other);
  protected:
  explicit UserHarborNpcEventService(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UserHarborNpcEventService_EventRequest EventRequest;
  typedef UserHarborNpcEventService_EventResponse EventResponse;

  typedef UserHarborNpcEventService_EVENT_COMMAND EVENT_COMMAND;
  static const EVENT_COMMAND QUERY =
    UserHarborNpcEventService_EVENT_COMMAND_QUERY;
  static inline bool EVENT_COMMAND_IsValid(int value) {
    return UserHarborNpcEventService_EVENT_COMMAND_IsValid(value);
  }
  static const EVENT_COMMAND EVENT_COMMAND_MIN =
    UserHarborNpcEventService_EVENT_COMMAND_EVENT_COMMAND_MIN;
  static const EVENT_COMMAND EVENT_COMMAND_MAX =
    UserHarborNpcEventService_EVENT_COMMAND_EVENT_COMMAND_MAX;
  static const int EVENT_COMMAND_ARRAYSIZE =
    UserHarborNpcEventService_EVENT_COMMAND_EVENT_COMMAND_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EVENT_COMMAND_descriptor() {
    return UserHarborNpcEventService_EVENT_COMMAND_descriptor();
  }
  static inline const ::std::string& EVENT_COMMAND_Name(EVENT_COMMAND value) {
    return UserHarborNpcEventService_EVENT_COMMAND_Name(value);
  }
  static inline bool EVENT_COMMAND_Parse(const ::std::string& name,
      EVENT_COMMAND* value) {
    return UserHarborNpcEventService_EVENT_COMMAND_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .sg.UserHarborNpcEventService.EventRequest req = 1;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 1;
  private:
  const ::sg::UserHarborNpcEventService_EventRequest& _internal_req() const;
  public:
  const ::sg::UserHarborNpcEventService_EventRequest& req() const;
  ::sg::UserHarborNpcEventService_EventRequest* release_req();
  ::sg::UserHarborNpcEventService_EventRequest* mutable_req();
  void set_allocated_req(::sg::UserHarborNpcEventService_EventRequest* req);
  void unsafe_arena_set_allocated_req(
      ::sg::UserHarborNpcEventService_EventRequest* req);
  ::sg::UserHarborNpcEventService_EventRequest* unsafe_arena_release_req();

  // optional .sg.UserHarborNpcEventService.EventResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  private:
  const ::sg::UserHarborNpcEventService_EventResponse& _internal_resp() const;
  public:
  const ::sg::UserHarborNpcEventService_EventResponse& resp() const;
  ::sg::UserHarborNpcEventService_EventResponse* release_resp();
  ::sg::UserHarborNpcEventService_EventResponse* mutable_resp();
  void set_allocated_resp(::sg::UserHarborNpcEventService_EventResponse* resp);
  void unsafe_arena_set_allocated_resp(
      ::sg::UserHarborNpcEventService_EventResponse* resp);
  ::sg::UserHarborNpcEventService_EventResponse* unsafe_arena_release_resp();

  // @@protoc_insertion_point(class_scope:sg.UserHarborNpcEventService)
 private:
  void set_has_req();
  void clear_has_req();
  void set_has_resp();
  void clear_has_resp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::sg::UserHarborNpcEventService_EventRequest* req_;
  ::sg::UserHarborNpcEventService_EventResponse* resp_;
  friend struct ::protobuf_UserHarbourNpcEvent_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserHarborNpcEventNotify : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.UserHarborNpcEventNotify) */ {
 public:
  UserHarborNpcEventNotify();
  virtual ~UserHarborNpcEventNotify();

  UserHarborNpcEventNotify(const UserHarborNpcEventNotify& from);

  inline UserHarborNpcEventNotify& operator=(const UserHarborNpcEventNotify& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserHarborNpcEventNotify(UserHarborNpcEventNotify&& from) noexcept
    : UserHarborNpcEventNotify() {
    *this = ::std::move(from);
  }

  inline UserHarborNpcEventNotify& operator=(UserHarborNpcEventNotify&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserHarborNpcEventNotify& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserHarborNpcEventNotify* internal_default_instance() {
    return reinterpret_cast<const UserHarborNpcEventNotify*>(
               &_UserHarborNpcEventNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void UnsafeArenaSwap(UserHarborNpcEventNotify* other);
  void Swap(UserHarborNpcEventNotify* other);
  friend void swap(UserHarborNpcEventNotify& a, UserHarborNpcEventNotify& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserHarborNpcEventNotify* New() const final {
    return CreateMaybeMessage<UserHarborNpcEventNotify>(NULL);
  }

  UserHarborNpcEventNotify* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserHarborNpcEventNotify>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserHarborNpcEventNotify& from);
  void MergeFrom(const UserHarborNpcEventNotify& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserHarborNpcEventNotify* other);
  protected:
  explicit UserHarborNpcEventNotify(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .sg.HarborNpcEventList event_list = 1;
  bool has_event_list() const;
  void clear_event_list();
  static const int kEventListFieldNumber = 1;
  private:
  const ::sg::HarborNpcEventList& _internal_event_list() const;
  public:
  const ::sg::HarborNpcEventList& event_list() const;
  ::sg::HarborNpcEventList* release_event_list();
  ::sg::HarborNpcEventList* mutable_event_list();
  void set_allocated_event_list(::sg::HarborNpcEventList* event_list);
  void unsafe_arena_set_allocated_event_list(
      ::sg::HarborNpcEventList* event_list);
  ::sg::HarborNpcEventList* unsafe_arena_release_event_list();

  // @@protoc_insertion_point(class_scope:sg.UserHarborNpcEventNotify)
 private:
  void set_has_event_list();
  void clear_has_event_list();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::sg::HarborNpcEventList* event_list_;
  friend struct ::protobuf_UserHarbourNpcEvent_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserHarborNpcStealActionService_ActionRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.UserHarborNpcStealActionService.ActionRequest) */ {
 public:
  UserHarborNpcStealActionService_ActionRequest();
  virtual ~UserHarborNpcStealActionService_ActionRequest();

  UserHarborNpcStealActionService_ActionRequest(const UserHarborNpcStealActionService_ActionRequest& from);

  inline UserHarborNpcStealActionService_ActionRequest& operator=(const UserHarborNpcStealActionService_ActionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserHarborNpcStealActionService_ActionRequest(UserHarborNpcStealActionService_ActionRequest&& from) noexcept
    : UserHarborNpcStealActionService_ActionRequest() {
    *this = ::std::move(from);
  }

  inline UserHarborNpcStealActionService_ActionRequest& operator=(UserHarborNpcStealActionService_ActionRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserHarborNpcStealActionService_ActionRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserHarborNpcStealActionService_ActionRequest* internal_default_instance() {
    return reinterpret_cast<const UserHarborNpcStealActionService_ActionRequest*>(
               &_UserHarborNpcStealActionService_ActionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void UnsafeArenaSwap(UserHarborNpcStealActionService_ActionRequest* other);
  void Swap(UserHarborNpcStealActionService_ActionRequest* other);
  friend void swap(UserHarborNpcStealActionService_ActionRequest& a, UserHarborNpcStealActionService_ActionRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserHarborNpcStealActionService_ActionRequest* New() const final {
    return CreateMaybeMessage<UserHarborNpcStealActionService_ActionRequest>(NULL);
  }

  UserHarborNpcStealActionService_ActionRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserHarborNpcStealActionService_ActionRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserHarborNpcStealActionService_ActionRequest& from);
  void MergeFrom(const UserHarborNpcStealActionService_ActionRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserHarborNpcStealActionService_ActionRequest* other);
  protected:
  explicit UserHarborNpcStealActionService_ActionRequest(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 sailorid_list = 3;
  int sailorid_list_size() const;
  void clear_sailorid_list();
  static const int kSailoridListFieldNumber = 3;
  ::google::protobuf::int32 sailorid_list(int index) const;
  void set_sailorid_list(int index, ::google::protobuf::int32 value);
  void add_sailorid_list(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      sailorid_list() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_sailorid_list();

  // optional int32 npcid = 2;
  bool has_npcid() const;
  void clear_npcid();
  static const int kNpcidFieldNumber = 2;
  ::google::protobuf::int32 npcid() const;
  void set_npcid(::google::protobuf::int32 value);

  // required .sg.UserHarborNpcStealActionService.ACTION_COMMAND cmd = 1;
  bool has_cmd() const;
  void clear_cmd();
  static const int kCmdFieldNumber = 1;
  ::sg::UserHarborNpcStealActionService_ACTION_COMMAND cmd() const;
  void set_cmd(::sg::UserHarborNpcStealActionService_ACTION_COMMAND value);

  // @@protoc_insertion_point(class_scope:sg.UserHarborNpcStealActionService.ActionRequest)
 private:
  void set_has_cmd();
  void clear_has_cmd();
  void set_has_npcid();
  void clear_has_npcid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > sailorid_list_;
  ::google::protobuf::int32 npcid_;
  int cmd_;
  friend struct ::protobuf_UserHarbourNpcEvent_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserHarborNpcStealActionService_ActionResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.UserHarborNpcStealActionService.ActionResponse) */ {
 public:
  UserHarborNpcStealActionService_ActionResponse();
  virtual ~UserHarborNpcStealActionService_ActionResponse();

  UserHarborNpcStealActionService_ActionResponse(const UserHarborNpcStealActionService_ActionResponse& from);

  inline UserHarborNpcStealActionService_ActionResponse& operator=(const UserHarborNpcStealActionService_ActionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserHarborNpcStealActionService_ActionResponse(UserHarborNpcStealActionService_ActionResponse&& from) noexcept
    : UserHarborNpcStealActionService_ActionResponse() {
    *this = ::std::move(from);
  }

  inline UserHarborNpcStealActionService_ActionResponse& operator=(UserHarborNpcStealActionService_ActionResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserHarborNpcStealActionService_ActionResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserHarborNpcStealActionService_ActionResponse* internal_default_instance() {
    return reinterpret_cast<const UserHarborNpcStealActionService_ActionResponse*>(
               &_UserHarborNpcStealActionService_ActionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void UnsafeArenaSwap(UserHarborNpcStealActionService_ActionResponse* other);
  void Swap(UserHarborNpcStealActionService_ActionResponse* other);
  friend void swap(UserHarborNpcStealActionService_ActionResponse& a, UserHarborNpcStealActionService_ActionResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserHarborNpcStealActionService_ActionResponse* New() const final {
    return CreateMaybeMessage<UserHarborNpcStealActionService_ActionResponse>(NULL);
  }

  UserHarborNpcStealActionService_ActionResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserHarborNpcStealActionService_ActionResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserHarborNpcStealActionService_ActionResponse& from);
  void MergeFrom(const UserHarborNpcStealActionService_ActionResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserHarborNpcStealActionService_ActionResponse* other);
  protected:
  explicit UserHarborNpcStealActionService_ActionResponse(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sg.Item reward_list = 2;
  int reward_list_size() const;
  void clear_reward_list();
  static const int kRewardListFieldNumber = 2;
  ::sg::Item* mutable_reward_list(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::Item >*
      mutable_reward_list();
  const ::sg::Item& reward_list(int index) const;
  ::sg::Item* add_reward_list();
  const ::google::protobuf::RepeatedPtrField< ::sg::Item >&
      reward_list() const;

  // required int32 result = 1;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::google::protobuf::int32 result() const;
  void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sg.UserHarborNpcStealActionService.ActionResponse)
 private:
  void set_has_result();
  void clear_has_result();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::Item > reward_list_;
  ::google::protobuf::int32 result_;
  friend struct ::protobuf_UserHarbourNpcEvent_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserHarborNpcStealActionService : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sg.UserHarborNpcStealActionService) */ {
 public:
  UserHarborNpcStealActionService();
  virtual ~UserHarborNpcStealActionService();

  UserHarborNpcStealActionService(const UserHarborNpcStealActionService& from);

  inline UserHarborNpcStealActionService& operator=(const UserHarborNpcStealActionService& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserHarborNpcStealActionService(UserHarborNpcStealActionService&& from) noexcept
    : UserHarborNpcStealActionService() {
    *this = ::std::move(from);
  }

  inline UserHarborNpcStealActionService& operator=(UserHarborNpcStealActionService&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserHarborNpcStealActionService& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserHarborNpcStealActionService* internal_default_instance() {
    return reinterpret_cast<const UserHarborNpcStealActionService*>(
               &_UserHarborNpcStealActionService_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void UnsafeArenaSwap(UserHarborNpcStealActionService* other);
  void Swap(UserHarborNpcStealActionService* other);
  friend void swap(UserHarborNpcStealActionService& a, UserHarborNpcStealActionService& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserHarborNpcStealActionService* New() const final {
    return CreateMaybeMessage<UserHarborNpcStealActionService>(NULL);
  }

  UserHarborNpcStealActionService* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserHarborNpcStealActionService>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserHarborNpcStealActionService& from);
  void MergeFrom(const UserHarborNpcStealActionService& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserHarborNpcStealActionService* other);
  protected:
  explicit UserHarborNpcStealActionService(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UserHarborNpcStealActionService_ActionRequest ActionRequest;
  typedef UserHarborNpcStealActionService_ActionResponse ActionResponse;

  typedef UserHarborNpcStealActionService_ACTION_COMMAND ACTION_COMMAND;
  static const ACTION_COMMAND NPC_STEAL =
    UserHarborNpcStealActionService_ACTION_COMMAND_NPC_STEAL;
  static const ACTION_COMMAND PLAYER_CATCH =
    UserHarborNpcStealActionService_ACTION_COMMAND_PLAYER_CATCH;
  static inline bool ACTION_COMMAND_IsValid(int value) {
    return UserHarborNpcStealActionService_ACTION_COMMAND_IsValid(value);
  }
  static const ACTION_COMMAND ACTION_COMMAND_MIN =
    UserHarborNpcStealActionService_ACTION_COMMAND_ACTION_COMMAND_MIN;
  static const ACTION_COMMAND ACTION_COMMAND_MAX =
    UserHarborNpcStealActionService_ACTION_COMMAND_ACTION_COMMAND_MAX;
  static const int ACTION_COMMAND_ARRAYSIZE =
    UserHarborNpcStealActionService_ACTION_COMMAND_ACTION_COMMAND_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ACTION_COMMAND_descriptor() {
    return UserHarborNpcStealActionService_ACTION_COMMAND_descriptor();
  }
  static inline const ::std::string& ACTION_COMMAND_Name(ACTION_COMMAND value) {
    return UserHarborNpcStealActionService_ACTION_COMMAND_Name(value);
  }
  static inline bool ACTION_COMMAND_Parse(const ::std::string& name,
      ACTION_COMMAND* value) {
    return UserHarborNpcStealActionService_ACTION_COMMAND_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .sg.UserHarborNpcStealActionService.ActionRequest req = 1;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 1;
  private:
  const ::sg::UserHarborNpcStealActionService_ActionRequest& _internal_req() const;
  public:
  const ::sg::UserHarborNpcStealActionService_ActionRequest& req() const;
  ::sg::UserHarborNpcStealActionService_ActionRequest* release_req();
  ::sg::UserHarborNpcStealActionService_ActionRequest* mutable_req();
  void set_allocated_req(::sg::UserHarborNpcStealActionService_ActionRequest* req);
  void unsafe_arena_set_allocated_req(
      ::sg::UserHarborNpcStealActionService_ActionRequest* req);
  ::sg::UserHarborNpcStealActionService_ActionRequest* unsafe_arena_release_req();

  // optional .sg.UserHarborNpcStealActionService.ActionResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  private:
  const ::sg::UserHarborNpcStealActionService_ActionResponse& _internal_resp() const;
  public:
  const ::sg::UserHarborNpcStealActionService_ActionResponse& resp() const;
  ::sg::UserHarborNpcStealActionService_ActionResponse* release_resp();
  ::sg::UserHarborNpcStealActionService_ActionResponse* mutable_resp();
  void set_allocated_resp(::sg::UserHarborNpcStealActionService_ActionResponse* resp);
  void unsafe_arena_set_allocated_resp(
      ::sg::UserHarborNpcStealActionService_ActionResponse* resp);
  ::sg::UserHarborNpcStealActionService_ActionResponse* unsafe_arena_release_resp();

  // @@protoc_insertion_point(class_scope:sg.UserHarborNpcStealActionService)
 private:
  void set_has_req();
  void clear_has_req();
  void set_has_resp();
  void clear_has_resp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::sg::UserHarborNpcStealActionService_ActionRequest* req_;
  ::sg::UserHarborNpcStealActionService_ActionResponse* resp_;
  friend struct ::protobuf_UserHarbourNpcEvent_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// HarborNpcEvent

// required int32 eventid = 1;
inline bool HarborNpcEvent::has_eventid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HarborNpcEvent::set_has_eventid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HarborNpcEvent::clear_has_eventid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HarborNpcEvent::clear_eventid() {
  eventid_ = 0;
  clear_has_eventid();
}
inline ::google::protobuf::int32 HarborNpcEvent::eventid() const {
  // @@protoc_insertion_point(field_get:sg.HarborNpcEvent.eventid)
  return eventid_;
}
inline void HarborNpcEvent::set_eventid(::google::protobuf::int32 value) {
  set_has_eventid();
  eventid_ = value;
  // @@protoc_insertion_point(field_set:sg.HarborNpcEvent.eventid)
}

// required .sg.HARBOR_NPC_EVENT_TYPE event_type = 2;
inline bool HarborNpcEvent::has_event_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void HarborNpcEvent::set_has_event_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void HarborNpcEvent::clear_has_event_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void HarborNpcEvent::clear_event_type() {
  event_type_ = 1;
  clear_has_event_type();
}
inline ::sg::HARBOR_NPC_EVENT_TYPE HarborNpcEvent::event_type() const {
  // @@protoc_insertion_point(field_get:sg.HarborNpcEvent.event_type)
  return static_cast< ::sg::HARBOR_NPC_EVENT_TYPE >(event_type_);
}
inline void HarborNpcEvent::set_event_type(::sg::HARBOR_NPC_EVENT_TYPE value) {
  assert(::sg::HARBOR_NPC_EVENT_TYPE_IsValid(value));
  set_has_event_type();
  event_type_ = value;
  // @@protoc_insertion_point(field_set:sg.HarborNpcEvent.event_type)
}

// required int32 npcid = 3;
inline bool HarborNpcEvent::has_npcid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HarborNpcEvent::set_has_npcid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HarborNpcEvent::clear_has_npcid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HarborNpcEvent::clear_npcid() {
  npcid_ = 0;
  clear_has_npcid();
}
inline ::google::protobuf::int32 HarborNpcEvent::npcid() const {
  // @@protoc_insertion_point(field_get:sg.HarborNpcEvent.npcid)
  return npcid_;
}
inline void HarborNpcEvent::set_npcid(::google::protobuf::int32 value) {
  set_has_npcid();
  npcid_ = value;
  // @@protoc_insertion_point(field_set:sg.HarborNpcEvent.npcid)
}

// required int32 state = 4;
inline bool HarborNpcEvent::has_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HarborNpcEvent::set_has_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HarborNpcEvent::clear_has_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HarborNpcEvent::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 HarborNpcEvent::state() const {
  // @@protoc_insertion_point(field_get:sg.HarborNpcEvent.state)
  return state_;
}
inline void HarborNpcEvent::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:sg.HarborNpcEvent.state)
}

// optional int32 step = 12;
inline bool HarborNpcEvent::has_step() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HarborNpcEvent::set_has_step() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HarborNpcEvent::clear_has_step() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HarborNpcEvent::clear_step() {
  step_ = 0;
  clear_has_step();
}
inline ::google::protobuf::int32 HarborNpcEvent::step() const {
  // @@protoc_insertion_point(field_get:sg.HarborNpcEvent.step)
  return step_;
}
inline void HarborNpcEvent::set_step(::google::protobuf::int32 value) {
  set_has_step();
  step_ = value;
  // @@protoc_insertion_point(field_set:sg.HarborNpcEvent.step)
}

// optional int32 param_roomid = 13;
inline bool HarborNpcEvent::has_param_roomid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HarborNpcEvent::set_has_param_roomid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HarborNpcEvent::clear_has_param_roomid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HarborNpcEvent::clear_param_roomid() {
  param_roomid_ = 0;
  clear_has_param_roomid();
}
inline ::google::protobuf::int32 HarborNpcEvent::param_roomid() const {
  // @@protoc_insertion_point(field_get:sg.HarborNpcEvent.param_roomid)
  return param_roomid_;
}
inline void HarborNpcEvent::set_param_roomid(::google::protobuf::int32 value) {
  set_has_param_roomid();
  param_roomid_ = value;
  // @@protoc_insertion_point(field_set:sg.HarborNpcEvent.param_roomid)
}

// optional int32 param_npcid = 14;
inline bool HarborNpcEvent::has_param_npcid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void HarborNpcEvent::set_has_param_npcid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void HarborNpcEvent::clear_has_param_npcid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void HarborNpcEvent::clear_param_npcid() {
  param_npcid_ = 0;
  clear_has_param_npcid();
}
inline ::google::protobuf::int32 HarborNpcEvent::param_npcid() const {
  // @@protoc_insertion_point(field_get:sg.HarborNpcEvent.param_npcid)
  return param_npcid_;
}
inline void HarborNpcEvent::set_param_npcid(::google::protobuf::int32 value) {
  set_has_param_npcid();
  param_npcid_ = value;
  // @@protoc_insertion_point(field_set:sg.HarborNpcEvent.param_npcid)
}

// optional int32 param_funitureid = 15;
inline bool HarborNpcEvent::has_param_funitureid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HarborNpcEvent::set_has_param_funitureid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HarborNpcEvent::clear_has_param_funitureid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HarborNpcEvent::clear_param_funitureid() {
  param_funitureid_ = 0;
  clear_has_param_funitureid();
}
inline ::google::protobuf::int32 HarborNpcEvent::param_funitureid() const {
  // @@protoc_insertion_point(field_get:sg.HarborNpcEvent.param_funitureid)
  return param_funitureid_;
}
inline void HarborNpcEvent::set_param_funitureid(::google::protobuf::int32 value) {
  set_has_param_funitureid();
  param_funitureid_ = value;
  // @@protoc_insertion_point(field_set:sg.HarborNpcEvent.param_funitureid)
}

// -------------------------------------------------------------------

// HarborNpcEventList

// repeated .sg.HarborNpcEvent list = 1;
inline int HarborNpcEventList::list_size() const {
  return list_.size();
}
inline void HarborNpcEventList::clear_list() {
  list_.Clear();
}
inline ::sg::HarborNpcEvent* HarborNpcEventList::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:sg.HarborNpcEventList.list)
  return list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::HarborNpcEvent >*
HarborNpcEventList::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:sg.HarborNpcEventList.list)
  return &list_;
}
inline const ::sg::HarborNpcEvent& HarborNpcEventList::list(int index) const {
  // @@protoc_insertion_point(field_get:sg.HarborNpcEventList.list)
  return list_.Get(index);
}
inline ::sg::HarborNpcEvent* HarborNpcEventList::add_list() {
  // @@protoc_insertion_point(field_add:sg.HarborNpcEventList.list)
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::HarborNpcEvent >&
HarborNpcEventList::list() const {
  // @@protoc_insertion_point(field_list:sg.HarborNpcEventList.list)
  return list_;
}

// -------------------------------------------------------------------

// UserHarborNpcEventService_EventRequest

// required .sg.UserHarborNpcEventService.EVENT_COMMAND cmd = 1;
inline bool UserHarborNpcEventService_EventRequest::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserHarborNpcEventService_EventRequest::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserHarborNpcEventService_EventRequest::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserHarborNpcEventService_EventRequest::clear_cmd() {
  cmd_ = 1;
  clear_has_cmd();
}
inline ::sg::UserHarborNpcEventService_EVENT_COMMAND UserHarborNpcEventService_EventRequest::cmd() const {
  // @@protoc_insertion_point(field_get:sg.UserHarborNpcEventService.EventRequest.cmd)
  return static_cast< ::sg::UserHarborNpcEventService_EVENT_COMMAND >(cmd_);
}
inline void UserHarborNpcEventService_EventRequest::set_cmd(::sg::UserHarborNpcEventService_EVENT_COMMAND value) {
  assert(::sg::UserHarborNpcEventService_EVENT_COMMAND_IsValid(value));
  set_has_cmd();
  cmd_ = value;
  // @@protoc_insertion_point(field_set:sg.UserHarborNpcEventService.EventRequest.cmd)
}

// -------------------------------------------------------------------

// UserHarborNpcEventService_EventResponse

// required int32 result = 1;
inline bool UserHarborNpcEventService_EventResponse::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserHarborNpcEventService_EventResponse::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserHarborNpcEventService_EventResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserHarborNpcEventService_EventResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 UserHarborNpcEventService_EventResponse::result() const {
  // @@protoc_insertion_point(field_get:sg.UserHarborNpcEventService.EventResponse.result)
  return result_;
}
inline void UserHarborNpcEventService_EventResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:sg.UserHarborNpcEventService.EventResponse.result)
}

// optional .sg.HarborNpcEventList event_list = 2;
inline bool UserHarborNpcEventService_EventResponse::has_event_list() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserHarborNpcEventService_EventResponse::set_has_event_list() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserHarborNpcEventService_EventResponse::clear_has_event_list() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserHarborNpcEventService_EventResponse::clear_event_list() {
  if (event_list_ != NULL) event_list_->Clear();
  clear_has_event_list();
}
inline const ::sg::HarborNpcEventList& UserHarborNpcEventService_EventResponse::_internal_event_list() const {
  return *event_list_;
}
inline const ::sg::HarborNpcEventList& UserHarborNpcEventService_EventResponse::event_list() const {
  const ::sg::HarborNpcEventList* p = event_list_;
  // @@protoc_insertion_point(field_get:sg.UserHarborNpcEventService.EventResponse.event_list)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::HarborNpcEventList*>(
      &::sg::_HarborNpcEventList_default_instance_);
}
inline ::sg::HarborNpcEventList* UserHarborNpcEventService_EventResponse::release_event_list() {
  // @@protoc_insertion_point(field_release:sg.UserHarborNpcEventService.EventResponse.event_list)
  clear_has_event_list();
  ::sg::HarborNpcEventList* temp = event_list_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  event_list_ = NULL;
  return temp;
}
inline ::sg::HarborNpcEventList* UserHarborNpcEventService_EventResponse::unsafe_arena_release_event_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.UserHarborNpcEventService.EventResponse.event_list)
  clear_has_event_list();
  ::sg::HarborNpcEventList* temp = event_list_;
  event_list_ = NULL;
  return temp;
}
inline ::sg::HarborNpcEventList* UserHarborNpcEventService_EventResponse::mutable_event_list() {
  set_has_event_list();
  if (event_list_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::HarborNpcEventList>(GetArenaNoVirtual());
    event_list_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.UserHarborNpcEventService.EventResponse.event_list)
  return event_list_;
}
inline void UserHarborNpcEventService_EventResponse::set_allocated_event_list(::sg::HarborNpcEventList* event_list) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete event_list_;
  }
  if (event_list) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(event_list);
    if (message_arena != submessage_arena) {
      event_list = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, event_list, submessage_arena);
    }
    set_has_event_list();
  } else {
    clear_has_event_list();
  }
  event_list_ = event_list;
  // @@protoc_insertion_point(field_set_allocated:sg.UserHarborNpcEventService.EventResponse.event_list)
}

// -------------------------------------------------------------------

// UserHarborNpcEventService

// optional .sg.UserHarborNpcEventService.EventRequest req = 1;
inline bool UserHarborNpcEventService::has_req() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserHarborNpcEventService::set_has_req() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserHarborNpcEventService::clear_has_req() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserHarborNpcEventService::clear_req() {
  if (req_ != NULL) req_->Clear();
  clear_has_req();
}
inline const ::sg::UserHarborNpcEventService_EventRequest& UserHarborNpcEventService::_internal_req() const {
  return *req_;
}
inline const ::sg::UserHarborNpcEventService_EventRequest& UserHarborNpcEventService::req() const {
  const ::sg::UserHarborNpcEventService_EventRequest* p = req_;
  // @@protoc_insertion_point(field_get:sg.UserHarborNpcEventService.req)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::UserHarborNpcEventService_EventRequest*>(
      &::sg::_UserHarborNpcEventService_EventRequest_default_instance_);
}
inline ::sg::UserHarborNpcEventService_EventRequest* UserHarborNpcEventService::release_req() {
  // @@protoc_insertion_point(field_release:sg.UserHarborNpcEventService.req)
  clear_has_req();
  ::sg::UserHarborNpcEventService_EventRequest* temp = req_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  req_ = NULL;
  return temp;
}
inline ::sg::UserHarborNpcEventService_EventRequest* UserHarborNpcEventService::unsafe_arena_release_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.UserHarborNpcEventService.req)
  clear_has_req();
  ::sg::UserHarborNpcEventService_EventRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline ::sg::UserHarborNpcEventService_EventRequest* UserHarborNpcEventService::mutable_req() {
  set_has_req();
  if (req_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::UserHarborNpcEventService_EventRequest>(GetArenaNoVirtual());
    req_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.UserHarborNpcEventService.req)
  return req_;
}
inline void UserHarborNpcEventService::set_allocated_req(::sg::UserHarborNpcEventService_EventRequest* req) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete req_;
  }
  if (req) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(req);
    if (message_arena != submessage_arena) {
      req = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, req, submessage_arena);
    }
    set_has_req();
  } else {
    clear_has_req();
  }
  req_ = req;
  // @@protoc_insertion_point(field_set_allocated:sg.UserHarborNpcEventService.req)
}

// optional .sg.UserHarborNpcEventService.EventResponse resp = 2;
inline bool UserHarborNpcEventService::has_resp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserHarborNpcEventService::set_has_resp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserHarborNpcEventService::clear_has_resp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserHarborNpcEventService::clear_resp() {
  if (resp_ != NULL) resp_->Clear();
  clear_has_resp();
}
inline const ::sg::UserHarborNpcEventService_EventResponse& UserHarborNpcEventService::_internal_resp() const {
  return *resp_;
}
inline const ::sg::UserHarborNpcEventService_EventResponse& UserHarborNpcEventService::resp() const {
  const ::sg::UserHarborNpcEventService_EventResponse* p = resp_;
  // @@protoc_insertion_point(field_get:sg.UserHarborNpcEventService.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::UserHarborNpcEventService_EventResponse*>(
      &::sg::_UserHarborNpcEventService_EventResponse_default_instance_);
}
inline ::sg::UserHarborNpcEventService_EventResponse* UserHarborNpcEventService::release_resp() {
  // @@protoc_insertion_point(field_release:sg.UserHarborNpcEventService.resp)
  clear_has_resp();
  ::sg::UserHarborNpcEventService_EventResponse* temp = resp_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  resp_ = NULL;
  return temp;
}
inline ::sg::UserHarborNpcEventService_EventResponse* UserHarborNpcEventService::unsafe_arena_release_resp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.UserHarborNpcEventService.resp)
  clear_has_resp();
  ::sg::UserHarborNpcEventService_EventResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline ::sg::UserHarborNpcEventService_EventResponse* UserHarborNpcEventService::mutable_resp() {
  set_has_resp();
  if (resp_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::UserHarborNpcEventService_EventResponse>(GetArenaNoVirtual());
    resp_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.UserHarborNpcEventService.resp)
  return resp_;
}
inline void UserHarborNpcEventService::set_allocated_resp(::sg::UserHarborNpcEventService_EventResponse* resp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete resp_;
  }
  if (resp) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(resp);
    if (message_arena != submessage_arena) {
      resp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, resp, submessage_arena);
    }
    set_has_resp();
  } else {
    clear_has_resp();
  }
  resp_ = resp;
  // @@protoc_insertion_point(field_set_allocated:sg.UserHarborNpcEventService.resp)
}

// -------------------------------------------------------------------

// UserHarborNpcEventNotify

// required .sg.HarborNpcEventList event_list = 1;
inline bool UserHarborNpcEventNotify::has_event_list() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserHarborNpcEventNotify::set_has_event_list() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserHarborNpcEventNotify::clear_has_event_list() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserHarborNpcEventNotify::clear_event_list() {
  if (event_list_ != NULL) event_list_->Clear();
  clear_has_event_list();
}
inline const ::sg::HarborNpcEventList& UserHarborNpcEventNotify::_internal_event_list() const {
  return *event_list_;
}
inline const ::sg::HarborNpcEventList& UserHarborNpcEventNotify::event_list() const {
  const ::sg::HarborNpcEventList* p = event_list_;
  // @@protoc_insertion_point(field_get:sg.UserHarborNpcEventNotify.event_list)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::HarborNpcEventList*>(
      &::sg::_HarborNpcEventList_default_instance_);
}
inline ::sg::HarborNpcEventList* UserHarborNpcEventNotify::release_event_list() {
  // @@protoc_insertion_point(field_release:sg.UserHarborNpcEventNotify.event_list)
  clear_has_event_list();
  ::sg::HarborNpcEventList* temp = event_list_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  event_list_ = NULL;
  return temp;
}
inline ::sg::HarborNpcEventList* UserHarborNpcEventNotify::unsafe_arena_release_event_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.UserHarborNpcEventNotify.event_list)
  clear_has_event_list();
  ::sg::HarborNpcEventList* temp = event_list_;
  event_list_ = NULL;
  return temp;
}
inline ::sg::HarborNpcEventList* UserHarborNpcEventNotify::mutable_event_list() {
  set_has_event_list();
  if (event_list_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::HarborNpcEventList>(GetArenaNoVirtual());
    event_list_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.UserHarborNpcEventNotify.event_list)
  return event_list_;
}
inline void UserHarborNpcEventNotify::set_allocated_event_list(::sg::HarborNpcEventList* event_list) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete event_list_;
  }
  if (event_list) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(event_list);
    if (message_arena != submessage_arena) {
      event_list = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, event_list, submessage_arena);
    }
    set_has_event_list();
  } else {
    clear_has_event_list();
  }
  event_list_ = event_list;
  // @@protoc_insertion_point(field_set_allocated:sg.UserHarborNpcEventNotify.event_list)
}

// -------------------------------------------------------------------

// UserHarborNpcStealActionService_ActionRequest

// required .sg.UserHarborNpcStealActionService.ACTION_COMMAND cmd = 1;
inline bool UserHarborNpcStealActionService_ActionRequest::has_cmd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserHarborNpcStealActionService_ActionRequest::set_has_cmd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserHarborNpcStealActionService_ActionRequest::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserHarborNpcStealActionService_ActionRequest::clear_cmd() {
  cmd_ = 1;
  clear_has_cmd();
}
inline ::sg::UserHarborNpcStealActionService_ACTION_COMMAND UserHarborNpcStealActionService_ActionRequest::cmd() const {
  // @@protoc_insertion_point(field_get:sg.UserHarborNpcStealActionService.ActionRequest.cmd)
  return static_cast< ::sg::UserHarborNpcStealActionService_ACTION_COMMAND >(cmd_);
}
inline void UserHarborNpcStealActionService_ActionRequest::set_cmd(::sg::UserHarborNpcStealActionService_ACTION_COMMAND value) {
  assert(::sg::UserHarborNpcStealActionService_ACTION_COMMAND_IsValid(value));
  set_has_cmd();
  cmd_ = value;
  // @@protoc_insertion_point(field_set:sg.UserHarborNpcStealActionService.ActionRequest.cmd)
}

// optional int32 npcid = 2;
inline bool UserHarborNpcStealActionService_ActionRequest::has_npcid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserHarborNpcStealActionService_ActionRequest::set_has_npcid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserHarborNpcStealActionService_ActionRequest::clear_has_npcid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserHarborNpcStealActionService_ActionRequest::clear_npcid() {
  npcid_ = 0;
  clear_has_npcid();
}
inline ::google::protobuf::int32 UserHarborNpcStealActionService_ActionRequest::npcid() const {
  // @@protoc_insertion_point(field_get:sg.UserHarborNpcStealActionService.ActionRequest.npcid)
  return npcid_;
}
inline void UserHarborNpcStealActionService_ActionRequest::set_npcid(::google::protobuf::int32 value) {
  set_has_npcid();
  npcid_ = value;
  // @@protoc_insertion_point(field_set:sg.UserHarborNpcStealActionService.ActionRequest.npcid)
}

// repeated int32 sailorid_list = 3;
inline int UserHarborNpcStealActionService_ActionRequest::sailorid_list_size() const {
  return sailorid_list_.size();
}
inline void UserHarborNpcStealActionService_ActionRequest::clear_sailorid_list() {
  sailorid_list_.Clear();
}
inline ::google::protobuf::int32 UserHarborNpcStealActionService_ActionRequest::sailorid_list(int index) const {
  // @@protoc_insertion_point(field_get:sg.UserHarborNpcStealActionService.ActionRequest.sailorid_list)
  return sailorid_list_.Get(index);
}
inline void UserHarborNpcStealActionService_ActionRequest::set_sailorid_list(int index, ::google::protobuf::int32 value) {
  sailorid_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:sg.UserHarborNpcStealActionService.ActionRequest.sailorid_list)
}
inline void UserHarborNpcStealActionService_ActionRequest::add_sailorid_list(::google::protobuf::int32 value) {
  sailorid_list_.Add(value);
  // @@protoc_insertion_point(field_add:sg.UserHarborNpcStealActionService.ActionRequest.sailorid_list)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
UserHarborNpcStealActionService_ActionRequest::sailorid_list() const {
  // @@protoc_insertion_point(field_list:sg.UserHarborNpcStealActionService.ActionRequest.sailorid_list)
  return sailorid_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
UserHarborNpcStealActionService_ActionRequest::mutable_sailorid_list() {
  // @@protoc_insertion_point(field_mutable_list:sg.UserHarborNpcStealActionService.ActionRequest.sailorid_list)
  return &sailorid_list_;
}

// -------------------------------------------------------------------

// UserHarborNpcStealActionService_ActionResponse

// required int32 result = 1;
inline bool UserHarborNpcStealActionService_ActionResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserHarborNpcStealActionService_ActionResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserHarborNpcStealActionService_ActionResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserHarborNpcStealActionService_ActionResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 UserHarborNpcStealActionService_ActionResponse::result() const {
  // @@protoc_insertion_point(field_get:sg.UserHarborNpcStealActionService.ActionResponse.result)
  return result_;
}
inline void UserHarborNpcStealActionService_ActionResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:sg.UserHarborNpcStealActionService.ActionResponse.result)
}

// repeated .sg.Item reward_list = 2;
inline int UserHarborNpcStealActionService_ActionResponse::reward_list_size() const {
  return reward_list_.size();
}
inline ::sg::Item* UserHarborNpcStealActionService_ActionResponse::mutable_reward_list(int index) {
  // @@protoc_insertion_point(field_mutable:sg.UserHarborNpcStealActionService.ActionResponse.reward_list)
  return reward_list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::Item >*
UserHarborNpcStealActionService_ActionResponse::mutable_reward_list() {
  // @@protoc_insertion_point(field_mutable_list:sg.UserHarborNpcStealActionService.ActionResponse.reward_list)
  return &reward_list_;
}
inline const ::sg::Item& UserHarborNpcStealActionService_ActionResponse::reward_list(int index) const {
  // @@protoc_insertion_point(field_get:sg.UserHarborNpcStealActionService.ActionResponse.reward_list)
  return reward_list_.Get(index);
}
inline ::sg::Item* UserHarborNpcStealActionService_ActionResponse::add_reward_list() {
  // @@protoc_insertion_point(field_add:sg.UserHarborNpcStealActionService.ActionResponse.reward_list)
  return reward_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::Item >&
UserHarborNpcStealActionService_ActionResponse::reward_list() const {
  // @@protoc_insertion_point(field_list:sg.UserHarborNpcStealActionService.ActionResponse.reward_list)
  return reward_list_;
}

// -------------------------------------------------------------------

// UserHarborNpcStealActionService

// optional .sg.UserHarborNpcStealActionService.ActionRequest req = 1;
inline bool UserHarborNpcStealActionService::has_req() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserHarborNpcStealActionService::set_has_req() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserHarborNpcStealActionService::clear_has_req() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserHarborNpcStealActionService::clear_req() {
  if (req_ != NULL) req_->Clear();
  clear_has_req();
}
inline const ::sg::UserHarborNpcStealActionService_ActionRequest& UserHarborNpcStealActionService::_internal_req() const {
  return *req_;
}
inline const ::sg::UserHarborNpcStealActionService_ActionRequest& UserHarborNpcStealActionService::req() const {
  const ::sg::UserHarborNpcStealActionService_ActionRequest* p = req_;
  // @@protoc_insertion_point(field_get:sg.UserHarborNpcStealActionService.req)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::UserHarborNpcStealActionService_ActionRequest*>(
      &::sg::_UserHarborNpcStealActionService_ActionRequest_default_instance_);
}
inline ::sg::UserHarborNpcStealActionService_ActionRequest* UserHarborNpcStealActionService::release_req() {
  // @@protoc_insertion_point(field_release:sg.UserHarborNpcStealActionService.req)
  clear_has_req();
  ::sg::UserHarborNpcStealActionService_ActionRequest* temp = req_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  req_ = NULL;
  return temp;
}
inline ::sg::UserHarborNpcStealActionService_ActionRequest* UserHarborNpcStealActionService::unsafe_arena_release_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.UserHarborNpcStealActionService.req)
  clear_has_req();
  ::sg::UserHarborNpcStealActionService_ActionRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline ::sg::UserHarborNpcStealActionService_ActionRequest* UserHarborNpcStealActionService::mutable_req() {
  set_has_req();
  if (req_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::UserHarborNpcStealActionService_ActionRequest>(GetArenaNoVirtual());
    req_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.UserHarborNpcStealActionService.req)
  return req_;
}
inline void UserHarborNpcStealActionService::set_allocated_req(::sg::UserHarborNpcStealActionService_ActionRequest* req) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete req_;
  }
  if (req) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(req);
    if (message_arena != submessage_arena) {
      req = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, req, submessage_arena);
    }
    set_has_req();
  } else {
    clear_has_req();
  }
  req_ = req;
  // @@protoc_insertion_point(field_set_allocated:sg.UserHarborNpcStealActionService.req)
}

// optional .sg.UserHarborNpcStealActionService.ActionResponse resp = 2;
inline bool UserHarborNpcStealActionService::has_resp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserHarborNpcStealActionService::set_has_resp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserHarborNpcStealActionService::clear_has_resp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserHarborNpcStealActionService::clear_resp() {
  if (resp_ != NULL) resp_->Clear();
  clear_has_resp();
}
inline const ::sg::UserHarborNpcStealActionService_ActionResponse& UserHarborNpcStealActionService::_internal_resp() const {
  return *resp_;
}
inline const ::sg::UserHarborNpcStealActionService_ActionResponse& UserHarborNpcStealActionService::resp() const {
  const ::sg::UserHarborNpcStealActionService_ActionResponse* p = resp_;
  // @@protoc_insertion_point(field_get:sg.UserHarborNpcStealActionService.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::sg::UserHarborNpcStealActionService_ActionResponse*>(
      &::sg::_UserHarborNpcStealActionService_ActionResponse_default_instance_);
}
inline ::sg::UserHarborNpcStealActionService_ActionResponse* UserHarborNpcStealActionService::release_resp() {
  // @@protoc_insertion_point(field_release:sg.UserHarborNpcStealActionService.resp)
  clear_has_resp();
  ::sg::UserHarborNpcStealActionService_ActionResponse* temp = resp_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  resp_ = NULL;
  return temp;
}
inline ::sg::UserHarborNpcStealActionService_ActionResponse* UserHarborNpcStealActionService::unsafe_arena_release_resp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sg.UserHarborNpcStealActionService.resp)
  clear_has_resp();
  ::sg::UserHarborNpcStealActionService_ActionResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline ::sg::UserHarborNpcStealActionService_ActionResponse* UserHarborNpcStealActionService::mutable_resp() {
  set_has_resp();
  if (resp_ == NULL) {
    auto* p = CreateMaybeMessage<::sg::UserHarborNpcStealActionService_ActionResponse>(GetArenaNoVirtual());
    resp_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sg.UserHarborNpcStealActionService.resp)
  return resp_;
}
inline void UserHarborNpcStealActionService::set_allocated_resp(::sg::UserHarborNpcStealActionService_ActionResponse* resp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete resp_;
  }
  if (resp) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(resp);
    if (message_arena != submessage_arena) {
      resp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, resp, submessage_arena);
    }
    set_has_resp();
  } else {
    clear_has_resp();
  }
  resp_ = resp;
  // @@protoc_insertion_point(field_set_allocated:sg.UserHarborNpcStealActionService.resp)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace sg

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::sg::UserHarborNpcEventService_EVENT_COMMAND> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::UserHarborNpcEventService_EVENT_COMMAND>() {
  return ::sg::UserHarborNpcEventService_EVENT_COMMAND_descriptor();
}
template <> struct is_proto_enum< ::sg::UserHarborNpcStealActionService_ACTION_COMMAND> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::UserHarborNpcStealActionService_ACTION_COMMAND>() {
  return ::sg::UserHarborNpcStealActionService_ACTION_COMMAND_descriptor();
}
template <> struct is_proto_enum< ::sg::OCCUPATION_TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::OCCUPATION_TYPE>() {
  return ::sg::OCCUPATION_TYPE_descriptor();
}
template <> struct is_proto_enum< ::sg::OCCUPATION_STAGE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::OCCUPATION_STAGE>() {
  return ::sg::OCCUPATION_STAGE_descriptor();
}
template <> struct is_proto_enum< ::sg::HARBOR_NPC_EVENT_TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::HARBOR_NPC_EVENT_TYPE>() {
  return ::sg::HARBOR_NPC_EVENT_TYPE_descriptor();
}
template <> struct is_proto_enum< ::sg::HARBOR_NPC_EVENT_STATE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sg::HARBOR_NPC_EVENT_STATE>() {
  return ::sg::HARBOR_NPC_EVENT_STATE_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_UserHarbourNpcEvent_2eproto
