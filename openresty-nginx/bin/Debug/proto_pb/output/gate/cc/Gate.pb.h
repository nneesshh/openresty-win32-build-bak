// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Gate.proto

#ifndef PROTOBUF_INCLUDED_Gate_2eproto
#define PROTOBUF_INCLUDED_Gate_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_Gate_2eproto 

namespace protobuf_Gate_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[21];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_Gate_2eproto
namespace gate {
class AccountLoginService;
class AccountLoginServiceDefaultTypeInternal;
extern AccountLoginServiceDefaultTypeInternal _AccountLoginService_default_instance_;
class AccountLoginService_LoginRequest;
class AccountLoginService_LoginRequestDefaultTypeInternal;
extern AccountLoginService_LoginRequestDefaultTypeInternal _AccountLoginService_LoginRequest_default_instance_;
class AccountLoginService_LoginResponse;
class AccountLoginService_LoginResponseDefaultTypeInternal;
extern AccountLoginService_LoginResponseDefaultTypeInternal _AccountLoginService_LoginResponse_default_instance_;
class AccountReloginService;
class AccountReloginServiceDefaultTypeInternal;
extern AccountReloginServiceDefaultTypeInternal _AccountReloginService_default_instance_;
class AccountReloginService_ReloginRequest;
class AccountReloginService_ReloginRequestDefaultTypeInternal;
extern AccountReloginService_ReloginRequestDefaultTypeInternal _AccountReloginService_ReloginRequest_default_instance_;
class AccountReloginService_ReloginResponse;
class AccountReloginService_ReloginResponseDefaultTypeInternal;
extern AccountReloginService_ReloginResponseDefaultTypeInternal _AccountReloginService_ReloginResponse_default_instance_;
class ActiveCodeService;
class ActiveCodeServiceDefaultTypeInternal;
extern ActiveCodeServiceDefaultTypeInternal _ActiveCodeService_default_instance_;
class ActiveCodeService_ActiveRequest;
class ActiveCodeService_ActiveRequestDefaultTypeInternal;
extern ActiveCodeService_ActiveRequestDefaultTypeInternal _ActiveCodeService_ActiveRequest_default_instance_;
class ActiveCodeService_ActiveResponse;
class ActiveCodeService_ActiveResponseDefaultTypeInternal;
extern ActiveCodeService_ActiveResponseDefaultTypeInternal _ActiveCodeService_ActiveResponse_default_instance_;
class ErrorNo;
class ErrorNoDefaultTypeInternal;
extern ErrorNoDefaultTypeInternal _ErrorNo_default_instance_;
class FastRegisterAccountService;
class FastRegisterAccountServiceDefaultTypeInternal;
extern FastRegisterAccountServiceDefaultTypeInternal _FastRegisterAccountService_default_instance_;
class FastRegisterAccountService_RegisterRequest;
class FastRegisterAccountService_RegisterRequestDefaultTypeInternal;
extern FastRegisterAccountService_RegisterRequestDefaultTypeInternal _FastRegisterAccountService_RegisterRequest_default_instance_;
class FastRegisterAccountService_RegisterResponse;
class FastRegisterAccountService_RegisterResponseDefaultTypeInternal;
extern FastRegisterAccountService_RegisterResponseDefaultTypeInternal _FastRegisterAccountService_RegisterResponse_default_instance_;
class GameServer;
class GameServerDefaultTypeInternal;
extern GameServerDefaultTypeInternal _GameServer_default_instance_;
class GameServerList;
class GameServerListDefaultTypeInternal;
extern GameServerListDefaultTypeInternal _GameServerList_default_instance_;
class GameServerService;
class GameServerServiceDefaultTypeInternal;
extern GameServerServiceDefaultTypeInternal _GameServerService_default_instance_;
class GameServerService_GameServerRequest;
class GameServerService_GameServerRequestDefaultTypeInternal;
extern GameServerService_GameServerRequestDefaultTypeInternal _GameServerService_GameServerRequest_default_instance_;
class GameServerService_GameServerResponse;
class GameServerService_GameServerResponseDefaultTypeInternal;
extern GameServerService_GameServerResponseDefaultTypeInternal _GameServerService_GameServerResponse_default_instance_;
class RegisterAccountService;
class RegisterAccountServiceDefaultTypeInternal;
extern RegisterAccountServiceDefaultTypeInternal _RegisterAccountService_default_instance_;
class RegisterAccountService_RegisterRequest;
class RegisterAccountService_RegisterRequestDefaultTypeInternal;
extern RegisterAccountService_RegisterRequestDefaultTypeInternal _RegisterAccountService_RegisterRequest_default_instance_;
class RegisterAccountService_RegisterResponse;
class RegisterAccountService_RegisterResponseDefaultTypeInternal;
extern RegisterAccountService_RegisterResponseDefaultTypeInternal _RegisterAccountService_RegisterResponse_default_instance_;
}  // namespace gate
namespace google {
namespace protobuf {
template<> ::gate::AccountLoginService* Arena::CreateMaybeMessage<::gate::AccountLoginService>(Arena*);
template<> ::gate::AccountLoginService_LoginRequest* Arena::CreateMaybeMessage<::gate::AccountLoginService_LoginRequest>(Arena*);
template<> ::gate::AccountLoginService_LoginResponse* Arena::CreateMaybeMessage<::gate::AccountLoginService_LoginResponse>(Arena*);
template<> ::gate::AccountReloginService* Arena::CreateMaybeMessage<::gate::AccountReloginService>(Arena*);
template<> ::gate::AccountReloginService_ReloginRequest* Arena::CreateMaybeMessage<::gate::AccountReloginService_ReloginRequest>(Arena*);
template<> ::gate::AccountReloginService_ReloginResponse* Arena::CreateMaybeMessage<::gate::AccountReloginService_ReloginResponse>(Arena*);
template<> ::gate::ActiveCodeService* Arena::CreateMaybeMessage<::gate::ActiveCodeService>(Arena*);
template<> ::gate::ActiveCodeService_ActiveRequest* Arena::CreateMaybeMessage<::gate::ActiveCodeService_ActiveRequest>(Arena*);
template<> ::gate::ActiveCodeService_ActiveResponse* Arena::CreateMaybeMessage<::gate::ActiveCodeService_ActiveResponse>(Arena*);
template<> ::gate::ErrorNo* Arena::CreateMaybeMessage<::gate::ErrorNo>(Arena*);
template<> ::gate::FastRegisterAccountService* Arena::CreateMaybeMessage<::gate::FastRegisterAccountService>(Arena*);
template<> ::gate::FastRegisterAccountService_RegisterRequest* Arena::CreateMaybeMessage<::gate::FastRegisterAccountService_RegisterRequest>(Arena*);
template<> ::gate::FastRegisterAccountService_RegisterResponse* Arena::CreateMaybeMessage<::gate::FastRegisterAccountService_RegisterResponse>(Arena*);
template<> ::gate::GameServer* Arena::CreateMaybeMessage<::gate::GameServer>(Arena*);
template<> ::gate::GameServerList* Arena::CreateMaybeMessage<::gate::GameServerList>(Arena*);
template<> ::gate::GameServerService* Arena::CreateMaybeMessage<::gate::GameServerService>(Arena*);
template<> ::gate::GameServerService_GameServerRequest* Arena::CreateMaybeMessage<::gate::GameServerService_GameServerRequest>(Arena*);
template<> ::gate::GameServerService_GameServerResponse* Arena::CreateMaybeMessage<::gate::GameServerService_GameServerResponse>(Arena*);
template<> ::gate::RegisterAccountService* Arena::CreateMaybeMessage<::gate::RegisterAccountService>(Arena*);
template<> ::gate::RegisterAccountService_RegisterRequest* Arena::CreateMaybeMessage<::gate::RegisterAccountService_RegisterRequest>(Arena*);
template<> ::gate::RegisterAccountService_RegisterResponse* Arena::CreateMaybeMessage<::gate::RegisterAccountService_RegisterResponse>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace gate {

enum ErrorNo_ERROR_NO {
  ErrorNo_ERROR_NO_RELOGIN = -9000,
  ErrorNo_ERROR_NO_IP_IS_BANNED = -9001,
  ErrorNo_ERROR_NO_UID_IS_BANNED = -9002
};
bool ErrorNo_ERROR_NO_IsValid(int value);
const ErrorNo_ERROR_NO ErrorNo_ERROR_NO_ERROR_NO_MIN = ErrorNo_ERROR_NO_UID_IS_BANNED;
const ErrorNo_ERROR_NO ErrorNo_ERROR_NO_ERROR_NO_MAX = ErrorNo_ERROR_NO_RELOGIN;
const int ErrorNo_ERROR_NO_ERROR_NO_ARRAYSIZE = ErrorNo_ERROR_NO_ERROR_NO_MAX + 1;

const ::google::protobuf::EnumDescriptor* ErrorNo_ERROR_NO_descriptor();
inline const ::std::string& ErrorNo_ERROR_NO_Name(ErrorNo_ERROR_NO value) {
  return ::google::protobuf::internal::NameOfEnum(
    ErrorNo_ERROR_NO_descriptor(), value);
}
inline bool ErrorNo_ERROR_NO_Parse(
    const ::std::string& name, ErrorNo_ERROR_NO* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ErrorNo_ERROR_NO>(
    ErrorNo_ERROR_NO_descriptor(), name, value);
}
enum RegisterAccountService_RESULT {
  RegisterAccountService_RESULT_OK = 0,
  RegisterAccountService_RESULT_UID_OR_PWD_TOO_SHORT = -1,
  RegisterAccountService_RESULT_UID_ALREADY_EXISTS = -2,
  RegisterAccountService_RESULT_UID_MUST_START_WITH_A_LETTER = -3,
  RegisterAccountService_RESULT_EMAIL_INVALID = -4,
  RegisterAccountService_RESULT_DB_ERROR = -8888,
  RegisterAccountService_RESULT_ASYNC_WAIT = -9999
};
bool RegisterAccountService_RESULT_IsValid(int value);
const RegisterAccountService_RESULT RegisterAccountService_RESULT_RESULT_MIN = RegisterAccountService_RESULT_ASYNC_WAIT;
const RegisterAccountService_RESULT RegisterAccountService_RESULT_RESULT_MAX = RegisterAccountService_RESULT_OK;
const int RegisterAccountService_RESULT_RESULT_ARRAYSIZE = RegisterAccountService_RESULT_RESULT_MAX + 1;

const ::google::protobuf::EnumDescriptor* RegisterAccountService_RESULT_descriptor();
inline const ::std::string& RegisterAccountService_RESULT_Name(RegisterAccountService_RESULT value) {
  return ::google::protobuf::internal::NameOfEnum(
    RegisterAccountService_RESULT_descriptor(), value);
}
inline bool RegisterAccountService_RESULT_Parse(
    const ::std::string& name, RegisterAccountService_RESULT* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RegisterAccountService_RESULT>(
    RegisterAccountService_RESULT_descriptor(), name, value);
}
enum AccountLoginService_RESULT {
  AccountLoginService_RESULT_OK = 0,
  AccountLoginService_RESULT_UID_OR_PWD_IS_NOT_VALID = -1,
  AccountLoginService_RESULT_USER_ASSETS_LOAD_FAILED = -2,
  AccountLoginService_RESULT_TOO_MANY_REQUEST = -3,
  AccountLoginService_RESULT_GAME_SERVER_NOT_READY = -4,
  AccountLoginService_RESULT_NEED_ACTIVATE = -5
};
bool AccountLoginService_RESULT_IsValid(int value);
const AccountLoginService_RESULT AccountLoginService_RESULT_RESULT_MIN = AccountLoginService_RESULT_NEED_ACTIVATE;
const AccountLoginService_RESULT AccountLoginService_RESULT_RESULT_MAX = AccountLoginService_RESULT_OK;
const int AccountLoginService_RESULT_RESULT_ARRAYSIZE = AccountLoginService_RESULT_RESULT_MAX + 1;

const ::google::protobuf::EnumDescriptor* AccountLoginService_RESULT_descriptor();
inline const ::std::string& AccountLoginService_RESULT_Name(AccountLoginService_RESULT value) {
  return ::google::protobuf::internal::NameOfEnum(
    AccountLoginService_RESULT_descriptor(), value);
}
inline bool AccountLoginService_RESULT_Parse(
    const ::std::string& name, AccountLoginService_RESULT* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AccountLoginService_RESULT>(
    AccountLoginService_RESULT_descriptor(), name, value);
}
enum AccountReloginService_RESULT {
  AccountReloginService_RESULT_OK = 0,
  AccountReloginService_RESULT_FAILED = 1
};
bool AccountReloginService_RESULT_IsValid(int value);
const AccountReloginService_RESULT AccountReloginService_RESULT_RESULT_MIN = AccountReloginService_RESULT_OK;
const AccountReloginService_RESULT AccountReloginService_RESULT_RESULT_MAX = AccountReloginService_RESULT_FAILED;
const int AccountReloginService_RESULT_RESULT_ARRAYSIZE = AccountReloginService_RESULT_RESULT_MAX + 1;

const ::google::protobuf::EnumDescriptor* AccountReloginService_RESULT_descriptor();
inline const ::std::string& AccountReloginService_RESULT_Name(AccountReloginService_RESULT value) {
  return ::google::protobuf::internal::NameOfEnum(
    AccountReloginService_RESULT_descriptor(), value);
}
inline bool AccountReloginService_RESULT_Parse(
    const ::std::string& name, AccountReloginService_RESULT* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AccountReloginService_RESULT>(
    AccountReloginService_RESULT_descriptor(), name, value);
}
enum GameServerService_GAME_SERVER_COMMAND {
  GameServerService_GAME_SERVER_COMMAND_QUERY = 1,
  GameServerService_GAME_SERVER_COMMAND_SELECT_SERVER = 2
};
bool GameServerService_GAME_SERVER_COMMAND_IsValid(int value);
const GameServerService_GAME_SERVER_COMMAND GameServerService_GAME_SERVER_COMMAND_GAME_SERVER_COMMAND_MIN = GameServerService_GAME_SERVER_COMMAND_QUERY;
const GameServerService_GAME_SERVER_COMMAND GameServerService_GAME_SERVER_COMMAND_GAME_SERVER_COMMAND_MAX = GameServerService_GAME_SERVER_COMMAND_SELECT_SERVER;
const int GameServerService_GAME_SERVER_COMMAND_GAME_SERVER_COMMAND_ARRAYSIZE = GameServerService_GAME_SERVER_COMMAND_GAME_SERVER_COMMAND_MAX + 1;

const ::google::protobuf::EnumDescriptor* GameServerService_GAME_SERVER_COMMAND_descriptor();
inline const ::std::string& GameServerService_GAME_SERVER_COMMAND_Name(GameServerService_GAME_SERVER_COMMAND value) {
  return ::google::protobuf::internal::NameOfEnum(
    GameServerService_GAME_SERVER_COMMAND_descriptor(), value);
}
inline bool GameServerService_GAME_SERVER_COMMAND_Parse(
    const ::std::string& name, GameServerService_GAME_SERVER_COMMAND* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GameServerService_GAME_SERVER_COMMAND>(
    GameServerService_GAME_SERVER_COMMAND_descriptor(), name, value);
}
enum GATE_ACCOUNT_STATUS {
  GATE_ACCOUNT_STATUS_LOCKED = -1,
  GATE_ACCOUNT_STATUS_NORMAL = 0,
  GATE_ACCOUNT_STATUS_ACTIVATED = 1
};
bool GATE_ACCOUNT_STATUS_IsValid(int value);
const GATE_ACCOUNT_STATUS GATE_ACCOUNT_STATUS_MIN = GATE_ACCOUNT_STATUS_LOCKED;
const GATE_ACCOUNT_STATUS GATE_ACCOUNT_STATUS_MAX = GATE_ACCOUNT_STATUS_ACTIVATED;
const int GATE_ACCOUNT_STATUS_ARRAYSIZE = GATE_ACCOUNT_STATUS_MAX + 1;

const ::google::protobuf::EnumDescriptor* GATE_ACCOUNT_STATUS_descriptor();
inline const ::std::string& GATE_ACCOUNT_STATUS_Name(GATE_ACCOUNT_STATUS value) {
  return ::google::protobuf::internal::NameOfEnum(
    GATE_ACCOUNT_STATUS_descriptor(), value);
}
inline bool GATE_ACCOUNT_STATUS_Parse(
    const ::std::string& name, GATE_ACCOUNT_STATUS* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GATE_ACCOUNT_STATUS>(
    GATE_ACCOUNT_STATUS_descriptor(), name, value);
}
// ===================================================================

class ErrorNo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gate.ErrorNo) */ {
 public:
  ErrorNo();
  virtual ~ErrorNo();

  ErrorNo(const ErrorNo& from);

  inline ErrorNo& operator=(const ErrorNo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ErrorNo(ErrorNo&& from) noexcept
    : ErrorNo() {
    *this = ::std::move(from);
  }

  inline ErrorNo& operator=(ErrorNo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const ErrorNo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ErrorNo* internal_default_instance() {
    return reinterpret_cast<const ErrorNo*>(
               &_ErrorNo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void UnsafeArenaSwap(ErrorNo* other);
  void Swap(ErrorNo* other);
  friend void swap(ErrorNo& a, ErrorNo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ErrorNo* New() const final {
    return CreateMaybeMessage<ErrorNo>(NULL);
  }

  ErrorNo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ErrorNo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ErrorNo& from);
  void MergeFrom(const ErrorNo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ErrorNo* other);
  protected:
  explicit ErrorNo(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ErrorNo_ERROR_NO ERROR_NO;
  static const ERROR_NO RELOGIN =
    ErrorNo_ERROR_NO_RELOGIN;
  static const ERROR_NO IP_IS_BANNED =
    ErrorNo_ERROR_NO_IP_IS_BANNED;
  static const ERROR_NO UID_IS_BANNED =
    ErrorNo_ERROR_NO_UID_IS_BANNED;
  static inline bool ERROR_NO_IsValid(int value) {
    return ErrorNo_ERROR_NO_IsValid(value);
  }
  static const ERROR_NO ERROR_NO_MIN =
    ErrorNo_ERROR_NO_ERROR_NO_MIN;
  static const ERROR_NO ERROR_NO_MAX =
    ErrorNo_ERROR_NO_ERROR_NO_MAX;
  static const int ERROR_NO_ARRAYSIZE =
    ErrorNo_ERROR_NO_ERROR_NO_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ERROR_NO_descriptor() {
    return ErrorNo_ERROR_NO_descriptor();
  }
  static inline const ::std::string& ERROR_NO_Name(ERROR_NO value) {
    return ErrorNo_ERROR_NO_Name(value);
  }
  static inline bool ERROR_NO_Parse(const ::std::string& name,
      ERROR_NO* value) {
    return ErrorNo_ERROR_NO_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required bytes desc = 2;
  bool has_desc() const;
  void clear_desc();
  static const int kDescFieldNumber = 2;
  const ::std::string& desc() const;
  void set_desc(const ::std::string& value);
  #if LANG_CXX11
  void set_desc(::std::string&& value);
  #endif
  void set_desc(const char* value);
  void set_desc(const void* value, size_t size);
  ::std::string* mutable_desc();
  ::std::string* release_desc();
  void set_allocated_desc(::std::string* desc);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_desc();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_desc(
      ::std::string* desc);

  // required int32 error_no = 1;
  bool has_error_no() const;
  void clear_error_no();
  static const int kErrorNoFieldNumber = 1;
  ::google::protobuf::int32 error_no() const;
  void set_error_no(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:gate.ErrorNo)
 private:
  void set_has_error_no();
  void clear_has_error_no();
  void set_has_desc();
  void clear_has_desc();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr desc_;
  ::google::protobuf::int32 error_no_;
  friend struct ::protobuf_Gate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RegisterAccountService_RegisterRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gate.RegisterAccountService.RegisterRequest) */ {
 public:
  RegisterAccountService_RegisterRequest();
  virtual ~RegisterAccountService_RegisterRequest();

  RegisterAccountService_RegisterRequest(const RegisterAccountService_RegisterRequest& from);

  inline RegisterAccountService_RegisterRequest& operator=(const RegisterAccountService_RegisterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegisterAccountService_RegisterRequest(RegisterAccountService_RegisterRequest&& from) noexcept
    : RegisterAccountService_RegisterRequest() {
    *this = ::std::move(from);
  }

  inline RegisterAccountService_RegisterRequest& operator=(RegisterAccountService_RegisterRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterAccountService_RegisterRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegisterAccountService_RegisterRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterAccountService_RegisterRequest*>(
               &_RegisterAccountService_RegisterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void UnsafeArenaSwap(RegisterAccountService_RegisterRequest* other);
  void Swap(RegisterAccountService_RegisterRequest* other);
  friend void swap(RegisterAccountService_RegisterRequest& a, RegisterAccountService_RegisterRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegisterAccountService_RegisterRequest* New() const final {
    return CreateMaybeMessage<RegisterAccountService_RegisterRequest>(NULL);
  }

  RegisterAccountService_RegisterRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegisterAccountService_RegisterRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegisterAccountService_RegisterRequest& from);
  void MergeFrom(const RegisterAccountService_RegisterRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterAccountService_RegisterRequest* other);
  protected:
  explicit RegisterAccountService_RegisterRequest(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes uid = 1;
  bool has_uid() const;
  void clear_uid();
  static const int kUidFieldNumber = 1;
  const ::std::string& uid() const;
  void set_uid(const ::std::string& value);
  #if LANG_CXX11
  void set_uid(::std::string&& value);
  #endif
  void set_uid(const char* value);
  void set_uid(const void* value, size_t size);
  ::std::string* mutable_uid();
  ::std::string* release_uid();
  void set_allocated_uid(::std::string* uid);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_uid();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_uid(
      ::std::string* uid);

  // required bytes pwd = 2;
  bool has_pwd() const;
  void clear_pwd();
  static const int kPwdFieldNumber = 2;
  const ::std::string& pwd() const;
  void set_pwd(const ::std::string& value);
  #if LANG_CXX11
  void set_pwd(::std::string&& value);
  #endif
  void set_pwd(const char* value);
  void set_pwd(const void* value, size_t size);
  ::std::string* mutable_pwd();
  ::std::string* release_pwd();
  void set_allocated_pwd(::std::string* pwd);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_pwd();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_pwd(
      ::std::string* pwd);

  // required bytes nick = 3;
  bool has_nick() const;
  void clear_nick();
  static const int kNickFieldNumber = 3;
  const ::std::string& nick() const;
  void set_nick(const ::std::string& value);
  #if LANG_CXX11
  void set_nick(::std::string&& value);
  #endif
  void set_nick(const char* value);
  void set_nick(const void* value, size_t size);
  ::std::string* mutable_nick();
  ::std::string* release_nick();
  void set_allocated_nick(::std::string* nick);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_nick();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_nick(
      ::std::string* nick);

  // required bytes email = 4;
  bool has_email() const;
  void clear_email();
  static const int kEmailFieldNumber = 4;
  const ::std::string& email() const;
  void set_email(const ::std::string& value);
  #if LANG_CXX11
  void set_email(::std::string&& value);
  #endif
  void set_email(const char* value);
  void set_email(const void* value, size_t size);
  ::std::string* mutable_email();
  ::std::string* release_email();
  void set_allocated_email(::std::string* email);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_email();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_email(
      ::std::string* email);

  // optional bytes sponsor_uid = 11;
  bool has_sponsor_uid() const;
  void clear_sponsor_uid();
  static const int kSponsorUidFieldNumber = 11;
  const ::std::string& sponsor_uid() const;
  void set_sponsor_uid(const ::std::string& value);
  #if LANG_CXX11
  void set_sponsor_uid(::std::string&& value);
  #endif
  void set_sponsor_uid(const char* value);
  void set_sponsor_uid(const void* value, size_t size);
  ::std::string* mutable_sponsor_uid();
  ::std::string* release_sponsor_uid();
  void set_allocated_sponsor_uid(::std::string* sponsor_uid);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_sponsor_uid();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_sponsor_uid(
      ::std::string* sponsor_uid);

  // @@protoc_insertion_point(class_scope:gate.RegisterAccountService.RegisterRequest)
 private:
  void set_has_uid();
  void clear_has_uid();
  void set_has_pwd();
  void clear_has_pwd();
  void set_has_nick();
  void clear_has_nick();
  void set_has_email();
  void clear_has_email();
  void set_has_sponsor_uid();
  void clear_has_sponsor_uid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr uid_;
  ::google::protobuf::internal::ArenaStringPtr pwd_;
  ::google::protobuf::internal::ArenaStringPtr nick_;
  ::google::protobuf::internal::ArenaStringPtr email_;
  ::google::protobuf::internal::ArenaStringPtr sponsor_uid_;
  friend struct ::protobuf_Gate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RegisterAccountService_RegisterResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gate.RegisterAccountService.RegisterResponse) */ {
 public:
  RegisterAccountService_RegisterResponse();
  virtual ~RegisterAccountService_RegisterResponse();

  RegisterAccountService_RegisterResponse(const RegisterAccountService_RegisterResponse& from);

  inline RegisterAccountService_RegisterResponse& operator=(const RegisterAccountService_RegisterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegisterAccountService_RegisterResponse(RegisterAccountService_RegisterResponse&& from) noexcept
    : RegisterAccountService_RegisterResponse() {
    *this = ::std::move(from);
  }

  inline RegisterAccountService_RegisterResponse& operator=(RegisterAccountService_RegisterResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterAccountService_RegisterResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegisterAccountService_RegisterResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterAccountService_RegisterResponse*>(
               &_RegisterAccountService_RegisterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void UnsafeArenaSwap(RegisterAccountService_RegisterResponse* other);
  void Swap(RegisterAccountService_RegisterResponse* other);
  friend void swap(RegisterAccountService_RegisterResponse& a, RegisterAccountService_RegisterResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegisterAccountService_RegisterResponse* New() const final {
    return CreateMaybeMessage<RegisterAccountService_RegisterResponse>(NULL);
  }

  RegisterAccountService_RegisterResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegisterAccountService_RegisterResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegisterAccountService_RegisterResponse& from);
  void MergeFrom(const RegisterAccountService_RegisterResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterAccountService_RegisterResponse* other);
  protected:
  explicit RegisterAccountService_RegisterResponse(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::google::protobuf::int32 result() const;
  void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:gate.RegisterAccountService.RegisterResponse)
 private:
  void set_has_result();
  void clear_has_result();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 result_;
  friend struct ::protobuf_Gate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RegisterAccountService : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gate.RegisterAccountService) */ {
 public:
  RegisterAccountService();
  virtual ~RegisterAccountService();

  RegisterAccountService(const RegisterAccountService& from);

  inline RegisterAccountService& operator=(const RegisterAccountService& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegisterAccountService(RegisterAccountService&& from) noexcept
    : RegisterAccountService() {
    *this = ::std::move(from);
  }

  inline RegisterAccountService& operator=(RegisterAccountService&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterAccountService& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegisterAccountService* internal_default_instance() {
    return reinterpret_cast<const RegisterAccountService*>(
               &_RegisterAccountService_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void UnsafeArenaSwap(RegisterAccountService* other);
  void Swap(RegisterAccountService* other);
  friend void swap(RegisterAccountService& a, RegisterAccountService& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegisterAccountService* New() const final {
    return CreateMaybeMessage<RegisterAccountService>(NULL);
  }

  RegisterAccountService* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegisterAccountService>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegisterAccountService& from);
  void MergeFrom(const RegisterAccountService& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterAccountService* other);
  protected:
  explicit RegisterAccountService(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RegisterAccountService_RegisterRequest RegisterRequest;
  typedef RegisterAccountService_RegisterResponse RegisterResponse;

  typedef RegisterAccountService_RESULT RESULT;
  static const RESULT OK =
    RegisterAccountService_RESULT_OK;
  static const RESULT UID_OR_PWD_TOO_SHORT =
    RegisterAccountService_RESULT_UID_OR_PWD_TOO_SHORT;
  static const RESULT UID_ALREADY_EXISTS =
    RegisterAccountService_RESULT_UID_ALREADY_EXISTS;
  static const RESULT UID_MUST_START_WITH_A_LETTER =
    RegisterAccountService_RESULT_UID_MUST_START_WITH_A_LETTER;
  static const RESULT EMAIL_INVALID =
    RegisterAccountService_RESULT_EMAIL_INVALID;
  static const RESULT DB_ERROR =
    RegisterAccountService_RESULT_DB_ERROR;
  static const RESULT ASYNC_WAIT =
    RegisterAccountService_RESULT_ASYNC_WAIT;
  static inline bool RESULT_IsValid(int value) {
    return RegisterAccountService_RESULT_IsValid(value);
  }
  static const RESULT RESULT_MIN =
    RegisterAccountService_RESULT_RESULT_MIN;
  static const RESULT RESULT_MAX =
    RegisterAccountService_RESULT_RESULT_MAX;
  static const int RESULT_ARRAYSIZE =
    RegisterAccountService_RESULT_RESULT_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RESULT_descriptor() {
    return RegisterAccountService_RESULT_descriptor();
  }
  static inline const ::std::string& RESULT_Name(RESULT value) {
    return RegisterAccountService_RESULT_Name(value);
  }
  static inline bool RESULT_Parse(const ::std::string& name,
      RESULT* value) {
    return RegisterAccountService_RESULT_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .gate.RegisterAccountService.RegisterRequest req = 1;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 1;
  private:
  const ::gate::RegisterAccountService_RegisterRequest& _internal_req() const;
  public:
  const ::gate::RegisterAccountService_RegisterRequest& req() const;
  ::gate::RegisterAccountService_RegisterRequest* release_req();
  ::gate::RegisterAccountService_RegisterRequest* mutable_req();
  void set_allocated_req(::gate::RegisterAccountService_RegisterRequest* req);
  void unsafe_arena_set_allocated_req(
      ::gate::RegisterAccountService_RegisterRequest* req);
  ::gate::RegisterAccountService_RegisterRequest* unsafe_arena_release_req();

  // optional .gate.RegisterAccountService.RegisterResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  private:
  const ::gate::RegisterAccountService_RegisterResponse& _internal_resp() const;
  public:
  const ::gate::RegisterAccountService_RegisterResponse& resp() const;
  ::gate::RegisterAccountService_RegisterResponse* release_resp();
  ::gate::RegisterAccountService_RegisterResponse* mutable_resp();
  void set_allocated_resp(::gate::RegisterAccountService_RegisterResponse* resp);
  void unsafe_arena_set_allocated_resp(
      ::gate::RegisterAccountService_RegisterResponse* resp);
  ::gate::RegisterAccountService_RegisterResponse* unsafe_arena_release_resp();

  // @@protoc_insertion_point(class_scope:gate.RegisterAccountService)
 private:
  void set_has_req();
  void clear_has_req();
  void set_has_resp();
  void clear_has_resp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::gate::RegisterAccountService_RegisterRequest* req_;
  ::gate::RegisterAccountService_RegisterResponse* resp_;
  friend struct ::protobuf_Gate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FastRegisterAccountService_RegisterRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gate.FastRegisterAccountService.RegisterRequest) */ {
 public:
  FastRegisterAccountService_RegisterRequest();
  virtual ~FastRegisterAccountService_RegisterRequest();

  FastRegisterAccountService_RegisterRequest(const FastRegisterAccountService_RegisterRequest& from);

  inline FastRegisterAccountService_RegisterRequest& operator=(const FastRegisterAccountService_RegisterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FastRegisterAccountService_RegisterRequest(FastRegisterAccountService_RegisterRequest&& from) noexcept
    : FastRegisterAccountService_RegisterRequest() {
    *this = ::std::move(from);
  }

  inline FastRegisterAccountService_RegisterRequest& operator=(FastRegisterAccountService_RegisterRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const FastRegisterAccountService_RegisterRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FastRegisterAccountService_RegisterRequest* internal_default_instance() {
    return reinterpret_cast<const FastRegisterAccountService_RegisterRequest*>(
               &_FastRegisterAccountService_RegisterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void UnsafeArenaSwap(FastRegisterAccountService_RegisterRequest* other);
  void Swap(FastRegisterAccountService_RegisterRequest* other);
  friend void swap(FastRegisterAccountService_RegisterRequest& a, FastRegisterAccountService_RegisterRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FastRegisterAccountService_RegisterRequest* New() const final {
    return CreateMaybeMessage<FastRegisterAccountService_RegisterRequest>(NULL);
  }

  FastRegisterAccountService_RegisterRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FastRegisterAccountService_RegisterRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FastRegisterAccountService_RegisterRequest& from);
  void MergeFrom(const FastRegisterAccountService_RegisterRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FastRegisterAccountService_RegisterRequest* other);
  protected:
  explicit FastRegisterAccountService_RegisterRequest(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:gate.FastRegisterAccountService.RegisterRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Gate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FastRegisterAccountService_RegisterResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gate.FastRegisterAccountService.RegisterResponse) */ {
 public:
  FastRegisterAccountService_RegisterResponse();
  virtual ~FastRegisterAccountService_RegisterResponse();

  FastRegisterAccountService_RegisterResponse(const FastRegisterAccountService_RegisterResponse& from);

  inline FastRegisterAccountService_RegisterResponse& operator=(const FastRegisterAccountService_RegisterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FastRegisterAccountService_RegisterResponse(FastRegisterAccountService_RegisterResponse&& from) noexcept
    : FastRegisterAccountService_RegisterResponse() {
    *this = ::std::move(from);
  }

  inline FastRegisterAccountService_RegisterResponse& operator=(FastRegisterAccountService_RegisterResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const FastRegisterAccountService_RegisterResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FastRegisterAccountService_RegisterResponse* internal_default_instance() {
    return reinterpret_cast<const FastRegisterAccountService_RegisterResponse*>(
               &_FastRegisterAccountService_RegisterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void UnsafeArenaSwap(FastRegisterAccountService_RegisterResponse* other);
  void Swap(FastRegisterAccountService_RegisterResponse* other);
  friend void swap(FastRegisterAccountService_RegisterResponse& a, FastRegisterAccountService_RegisterResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FastRegisterAccountService_RegisterResponse* New() const final {
    return CreateMaybeMessage<FastRegisterAccountService_RegisterResponse>(NULL);
  }

  FastRegisterAccountService_RegisterResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FastRegisterAccountService_RegisterResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FastRegisterAccountService_RegisterResponse& from);
  void MergeFrom(const FastRegisterAccountService_RegisterResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FastRegisterAccountService_RegisterResponse* other);
  protected:
  explicit FastRegisterAccountService_RegisterResponse(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes uid = 1;
  bool has_uid() const;
  void clear_uid();
  static const int kUidFieldNumber = 1;
  const ::std::string& uid() const;
  void set_uid(const ::std::string& value);
  #if LANG_CXX11
  void set_uid(::std::string&& value);
  #endif
  void set_uid(const char* value);
  void set_uid(const void* value, size_t size);
  ::std::string* mutable_uid();
  ::std::string* release_uid();
  void set_allocated_uid(::std::string* uid);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_uid();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_uid(
      ::std::string* uid);

  // required bytes pwd = 2;
  bool has_pwd() const;
  void clear_pwd();
  static const int kPwdFieldNumber = 2;
  const ::std::string& pwd() const;
  void set_pwd(const ::std::string& value);
  #if LANG_CXX11
  void set_pwd(::std::string&& value);
  #endif
  void set_pwd(const char* value);
  void set_pwd(const void* value, size_t size);
  ::std::string* mutable_pwd();
  ::std::string* release_pwd();
  void set_allocated_pwd(::std::string* pwd);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_pwd();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_pwd(
      ::std::string* pwd);

  // required bytes nick = 3;
  bool has_nick() const;
  void clear_nick();
  static const int kNickFieldNumber = 3;
  const ::std::string& nick() const;
  void set_nick(const ::std::string& value);
  #if LANG_CXX11
  void set_nick(::std::string&& value);
  #endif
  void set_nick(const char* value);
  void set_nick(const void* value, size_t size);
  ::std::string* mutable_nick();
  ::std::string* release_nick();
  void set_allocated_nick(::std::string* nick);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_nick();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_nick(
      ::std::string* nick);

  // required bytes email = 4;
  bool has_email() const;
  void clear_email();
  static const int kEmailFieldNumber = 4;
  const ::std::string& email() const;
  void set_email(const ::std::string& value);
  #if LANG_CXX11
  void set_email(::std::string&& value);
  #endif
  void set_email(const char* value);
  void set_email(const void* value, size_t size);
  ::std::string* mutable_email();
  ::std::string* release_email();
  void set_allocated_email(::std::string* email);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_email();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_email(
      ::std::string* email);

  // optional bytes sponsor_uid = 11;
  bool has_sponsor_uid() const;
  void clear_sponsor_uid();
  static const int kSponsorUidFieldNumber = 11;
  const ::std::string& sponsor_uid() const;
  void set_sponsor_uid(const ::std::string& value);
  #if LANG_CXX11
  void set_sponsor_uid(::std::string&& value);
  #endif
  void set_sponsor_uid(const char* value);
  void set_sponsor_uid(const void* value, size_t size);
  ::std::string* mutable_sponsor_uid();
  ::std::string* release_sponsor_uid();
  void set_allocated_sponsor_uid(::std::string* sponsor_uid);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_sponsor_uid();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_sponsor_uid(
      ::std::string* sponsor_uid);

  // @@protoc_insertion_point(class_scope:gate.FastRegisterAccountService.RegisterResponse)
 private:
  void set_has_uid();
  void clear_has_uid();
  void set_has_pwd();
  void clear_has_pwd();
  void set_has_nick();
  void clear_has_nick();
  void set_has_email();
  void clear_has_email();
  void set_has_sponsor_uid();
  void clear_has_sponsor_uid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr uid_;
  ::google::protobuf::internal::ArenaStringPtr pwd_;
  ::google::protobuf::internal::ArenaStringPtr nick_;
  ::google::protobuf::internal::ArenaStringPtr email_;
  ::google::protobuf::internal::ArenaStringPtr sponsor_uid_;
  friend struct ::protobuf_Gate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FastRegisterAccountService : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gate.FastRegisterAccountService) */ {
 public:
  FastRegisterAccountService();
  virtual ~FastRegisterAccountService();

  FastRegisterAccountService(const FastRegisterAccountService& from);

  inline FastRegisterAccountService& operator=(const FastRegisterAccountService& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FastRegisterAccountService(FastRegisterAccountService&& from) noexcept
    : FastRegisterAccountService() {
    *this = ::std::move(from);
  }

  inline FastRegisterAccountService& operator=(FastRegisterAccountService&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const FastRegisterAccountService& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FastRegisterAccountService* internal_default_instance() {
    return reinterpret_cast<const FastRegisterAccountService*>(
               &_FastRegisterAccountService_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void UnsafeArenaSwap(FastRegisterAccountService* other);
  void Swap(FastRegisterAccountService* other);
  friend void swap(FastRegisterAccountService& a, FastRegisterAccountService& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FastRegisterAccountService* New() const final {
    return CreateMaybeMessage<FastRegisterAccountService>(NULL);
  }

  FastRegisterAccountService* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FastRegisterAccountService>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FastRegisterAccountService& from);
  void MergeFrom(const FastRegisterAccountService& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FastRegisterAccountService* other);
  protected:
  explicit FastRegisterAccountService(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef FastRegisterAccountService_RegisterRequest RegisterRequest;
  typedef FastRegisterAccountService_RegisterResponse RegisterResponse;

  // accessors -------------------------------------------------------

  // optional .gate.FastRegisterAccountService.RegisterRequest req = 1;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 1;
  private:
  const ::gate::FastRegisterAccountService_RegisterRequest& _internal_req() const;
  public:
  const ::gate::FastRegisterAccountService_RegisterRequest& req() const;
  ::gate::FastRegisterAccountService_RegisterRequest* release_req();
  ::gate::FastRegisterAccountService_RegisterRequest* mutable_req();
  void set_allocated_req(::gate::FastRegisterAccountService_RegisterRequest* req);
  void unsafe_arena_set_allocated_req(
      ::gate::FastRegisterAccountService_RegisterRequest* req);
  ::gate::FastRegisterAccountService_RegisterRequest* unsafe_arena_release_req();

  // optional .gate.FastRegisterAccountService.RegisterResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  private:
  const ::gate::FastRegisterAccountService_RegisterResponse& _internal_resp() const;
  public:
  const ::gate::FastRegisterAccountService_RegisterResponse& resp() const;
  ::gate::FastRegisterAccountService_RegisterResponse* release_resp();
  ::gate::FastRegisterAccountService_RegisterResponse* mutable_resp();
  void set_allocated_resp(::gate::FastRegisterAccountService_RegisterResponse* resp);
  void unsafe_arena_set_allocated_resp(
      ::gate::FastRegisterAccountService_RegisterResponse* resp);
  ::gate::FastRegisterAccountService_RegisterResponse* unsafe_arena_release_resp();

  // @@protoc_insertion_point(class_scope:gate.FastRegisterAccountService)
 private:
  void set_has_req();
  void clear_has_req();
  void set_has_resp();
  void clear_has_resp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::gate::FastRegisterAccountService_RegisterRequest* req_;
  ::gate::FastRegisterAccountService_RegisterResponse* resp_;
  friend struct ::protobuf_Gate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AccountLoginService_LoginRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gate.AccountLoginService.LoginRequest) */ {
 public:
  AccountLoginService_LoginRequest();
  virtual ~AccountLoginService_LoginRequest();

  AccountLoginService_LoginRequest(const AccountLoginService_LoginRequest& from);

  inline AccountLoginService_LoginRequest& operator=(const AccountLoginService_LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccountLoginService_LoginRequest(AccountLoginService_LoginRequest&& from) noexcept
    : AccountLoginService_LoginRequest() {
    *this = ::std::move(from);
  }

  inline AccountLoginService_LoginRequest& operator=(AccountLoginService_LoginRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountLoginService_LoginRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AccountLoginService_LoginRequest* internal_default_instance() {
    return reinterpret_cast<const AccountLoginService_LoginRequest*>(
               &_AccountLoginService_LoginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void UnsafeArenaSwap(AccountLoginService_LoginRequest* other);
  void Swap(AccountLoginService_LoginRequest* other);
  friend void swap(AccountLoginService_LoginRequest& a, AccountLoginService_LoginRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccountLoginService_LoginRequest* New() const final {
    return CreateMaybeMessage<AccountLoginService_LoginRequest>(NULL);
  }

  AccountLoginService_LoginRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AccountLoginService_LoginRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AccountLoginService_LoginRequest& from);
  void MergeFrom(const AccountLoginService_LoginRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountLoginService_LoginRequest* other);
  protected:
  explicit AccountLoginService_LoginRequest(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes uid = 1;
  bool has_uid() const;
  void clear_uid();
  static const int kUidFieldNumber = 1;
  const ::std::string& uid() const;
  void set_uid(const ::std::string& value);
  #if LANG_CXX11
  void set_uid(::std::string&& value);
  #endif
  void set_uid(const char* value);
  void set_uid(const void* value, size_t size);
  ::std::string* mutable_uid();
  ::std::string* release_uid();
  void set_allocated_uid(::std::string* uid);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_uid();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_uid(
      ::std::string* uid);

  // required bytes pwd = 2;
  bool has_pwd() const;
  void clear_pwd();
  static const int kPwdFieldNumber = 2;
  const ::std::string& pwd() const;
  void set_pwd(const ::std::string& value);
  #if LANG_CXX11
  void set_pwd(::std::string&& value);
  #endif
  void set_pwd(const char* value);
  void set_pwd(const void* value, size_t size);
  ::std::string* mutable_pwd();
  ::std::string* release_pwd();
  void set_allocated_pwd(::std::string* pwd);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_pwd();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_pwd(
      ::std::string* pwd);

  // optional bytes channel_platid = 12;
  bool has_channel_platid() const;
  void clear_channel_platid();
  static const int kChannelPlatidFieldNumber = 12;
  const ::std::string& channel_platid() const;
  void set_channel_platid(const ::std::string& value);
  #if LANG_CXX11
  void set_channel_platid(::std::string&& value);
  #endif
  void set_channel_platid(const char* value);
  void set_channel_platid(const void* value, size_t size);
  ::std::string* mutable_channel_platid();
  ::std::string* release_channel_platid();
  void set_allocated_channel_platid(::std::string* channel_platid);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_channel_platid();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_channel_platid(
      ::std::string* channel_platid);

  // optional bytes channel_gameid = 13;
  bool has_channel_gameid() const;
  void clear_channel_gameid();
  static const int kChannelGameidFieldNumber = 13;
  const ::std::string& channel_gameid() const;
  void set_channel_gameid(const ::std::string& value);
  #if LANG_CXX11
  void set_channel_gameid(::std::string&& value);
  #endif
  void set_channel_gameid(const char* value);
  void set_channel_gameid(const void* value, size_t size);
  ::std::string* mutable_channel_gameid();
  ::std::string* release_channel_gameid();
  void set_allocated_channel_gameid(::std::string* channel_gameid);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_channel_gameid();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_channel_gameid(
      ::std::string* channel_gameid);

  // optional int32 ws_entryid = 11;
  bool has_ws_entryid() const;
  void clear_ws_entryid();
  static const int kWsEntryidFieldNumber = 11;
  ::google::protobuf::int32 ws_entryid() const;
  void set_ws_entryid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:gate.AccountLoginService.LoginRequest)
 private:
  void set_has_uid();
  void clear_has_uid();
  void set_has_pwd();
  void clear_has_pwd();
  void set_has_ws_entryid();
  void clear_has_ws_entryid();
  void set_has_channel_platid();
  void clear_has_channel_platid();
  void set_has_channel_gameid();
  void clear_has_channel_gameid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr uid_;
  ::google::protobuf::internal::ArenaStringPtr pwd_;
  ::google::protobuf::internal::ArenaStringPtr channel_platid_;
  ::google::protobuf::internal::ArenaStringPtr channel_gameid_;
  ::google::protobuf::int32 ws_entryid_;
  friend struct ::protobuf_Gate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AccountLoginService_LoginResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gate.AccountLoginService.LoginResponse) */ {
 public:
  AccountLoginService_LoginResponse();
  virtual ~AccountLoginService_LoginResponse();

  AccountLoginService_LoginResponse(const AccountLoginService_LoginResponse& from);

  inline AccountLoginService_LoginResponse& operator=(const AccountLoginService_LoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccountLoginService_LoginResponse(AccountLoginService_LoginResponse&& from) noexcept
    : AccountLoginService_LoginResponse() {
    *this = ::std::move(from);
  }

  inline AccountLoginService_LoginResponse& operator=(AccountLoginService_LoginResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountLoginService_LoginResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AccountLoginService_LoginResponse* internal_default_instance() {
    return reinterpret_cast<const AccountLoginService_LoginResponse*>(
               &_AccountLoginService_LoginResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void UnsafeArenaSwap(AccountLoginService_LoginResponse* other);
  void Swap(AccountLoginService_LoginResponse* other);
  friend void swap(AccountLoginService_LoginResponse& a, AccountLoginService_LoginResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccountLoginService_LoginResponse* New() const final {
    return CreateMaybeMessage<AccountLoginService_LoginResponse>(NULL);
  }

  AccountLoginService_LoginResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AccountLoginService_LoginResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AccountLoginService_LoginResponse& from);
  void MergeFrom(const AccountLoginService_LoginResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountLoginService_LoginResponse* other);
  protected:
  explicit AccountLoginService_LoginResponse(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 uuid = 2;
  bool has_uuid() const;
  void clear_uuid();
  static const int kUuidFieldNumber = 2;
  ::google::protobuf::uint64 uuid() const;
  void set_uuid(::google::protobuf::uint64 value);

  // required .gate.AccountLoginService.RESULT result = 1;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::gate::AccountLoginService_RESULT result() const;
  void set_result(::gate::AccountLoginService_RESULT value);

  // @@protoc_insertion_point(class_scope:gate.AccountLoginService.LoginResponse)
 private:
  void set_has_result();
  void clear_has_result();
  void set_has_uuid();
  void clear_has_uuid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 uuid_;
  int result_;
  friend struct ::protobuf_Gate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AccountLoginService : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gate.AccountLoginService) */ {
 public:
  AccountLoginService();
  virtual ~AccountLoginService();

  AccountLoginService(const AccountLoginService& from);

  inline AccountLoginService& operator=(const AccountLoginService& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccountLoginService(AccountLoginService&& from) noexcept
    : AccountLoginService() {
    *this = ::std::move(from);
  }

  inline AccountLoginService& operator=(AccountLoginService&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountLoginService& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AccountLoginService* internal_default_instance() {
    return reinterpret_cast<const AccountLoginService*>(
               &_AccountLoginService_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void UnsafeArenaSwap(AccountLoginService* other);
  void Swap(AccountLoginService* other);
  friend void swap(AccountLoginService& a, AccountLoginService& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccountLoginService* New() const final {
    return CreateMaybeMessage<AccountLoginService>(NULL);
  }

  AccountLoginService* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AccountLoginService>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AccountLoginService& from);
  void MergeFrom(const AccountLoginService& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountLoginService* other);
  protected:
  explicit AccountLoginService(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef AccountLoginService_LoginRequest LoginRequest;
  typedef AccountLoginService_LoginResponse LoginResponse;

  typedef AccountLoginService_RESULT RESULT;
  static const RESULT OK =
    AccountLoginService_RESULT_OK;
  static const RESULT UID_OR_PWD_IS_NOT_VALID =
    AccountLoginService_RESULT_UID_OR_PWD_IS_NOT_VALID;
  static const RESULT USER_ASSETS_LOAD_FAILED =
    AccountLoginService_RESULT_USER_ASSETS_LOAD_FAILED;
  static const RESULT TOO_MANY_REQUEST =
    AccountLoginService_RESULT_TOO_MANY_REQUEST;
  static const RESULT GAME_SERVER_NOT_READY =
    AccountLoginService_RESULT_GAME_SERVER_NOT_READY;
  static const RESULT NEED_ACTIVATE =
    AccountLoginService_RESULT_NEED_ACTIVATE;
  static inline bool RESULT_IsValid(int value) {
    return AccountLoginService_RESULT_IsValid(value);
  }
  static const RESULT RESULT_MIN =
    AccountLoginService_RESULT_RESULT_MIN;
  static const RESULT RESULT_MAX =
    AccountLoginService_RESULT_RESULT_MAX;
  static const int RESULT_ARRAYSIZE =
    AccountLoginService_RESULT_RESULT_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RESULT_descriptor() {
    return AccountLoginService_RESULT_descriptor();
  }
  static inline const ::std::string& RESULT_Name(RESULT value) {
    return AccountLoginService_RESULT_Name(value);
  }
  static inline bool RESULT_Parse(const ::std::string& name,
      RESULT* value) {
    return AccountLoginService_RESULT_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .gate.AccountLoginService.LoginRequest req = 1;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 1;
  private:
  const ::gate::AccountLoginService_LoginRequest& _internal_req() const;
  public:
  const ::gate::AccountLoginService_LoginRequest& req() const;
  ::gate::AccountLoginService_LoginRequest* release_req();
  ::gate::AccountLoginService_LoginRequest* mutable_req();
  void set_allocated_req(::gate::AccountLoginService_LoginRequest* req);
  void unsafe_arena_set_allocated_req(
      ::gate::AccountLoginService_LoginRequest* req);
  ::gate::AccountLoginService_LoginRequest* unsafe_arena_release_req();

  // optional .gate.AccountLoginService.LoginResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  private:
  const ::gate::AccountLoginService_LoginResponse& _internal_resp() const;
  public:
  const ::gate::AccountLoginService_LoginResponse& resp() const;
  ::gate::AccountLoginService_LoginResponse* release_resp();
  ::gate::AccountLoginService_LoginResponse* mutable_resp();
  void set_allocated_resp(::gate::AccountLoginService_LoginResponse* resp);
  void unsafe_arena_set_allocated_resp(
      ::gate::AccountLoginService_LoginResponse* resp);
  ::gate::AccountLoginService_LoginResponse* unsafe_arena_release_resp();

  // @@protoc_insertion_point(class_scope:gate.AccountLoginService)
 private:
  void set_has_req();
  void clear_has_req();
  void set_has_resp();
  void clear_has_resp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::gate::AccountLoginService_LoginRequest* req_;
  ::gate::AccountLoginService_LoginResponse* resp_;
  friend struct ::protobuf_Gate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AccountReloginService_ReloginRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gate.AccountReloginService.ReloginRequest) */ {
 public:
  AccountReloginService_ReloginRequest();
  virtual ~AccountReloginService_ReloginRequest();

  AccountReloginService_ReloginRequest(const AccountReloginService_ReloginRequest& from);

  inline AccountReloginService_ReloginRequest& operator=(const AccountReloginService_ReloginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccountReloginService_ReloginRequest(AccountReloginService_ReloginRequest&& from) noexcept
    : AccountReloginService_ReloginRequest() {
    *this = ::std::move(from);
  }

  inline AccountReloginService_ReloginRequest& operator=(AccountReloginService_ReloginRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountReloginService_ReloginRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AccountReloginService_ReloginRequest* internal_default_instance() {
    return reinterpret_cast<const AccountReloginService_ReloginRequest*>(
               &_AccountReloginService_ReloginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void UnsafeArenaSwap(AccountReloginService_ReloginRequest* other);
  void Swap(AccountReloginService_ReloginRequest* other);
  friend void swap(AccountReloginService_ReloginRequest& a, AccountReloginService_ReloginRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccountReloginService_ReloginRequest* New() const final {
    return CreateMaybeMessage<AccountReloginService_ReloginRequest>(NULL);
  }

  AccountReloginService_ReloginRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AccountReloginService_ReloginRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AccountReloginService_ReloginRequest& from);
  void MergeFrom(const AccountReloginService_ReloginRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountReloginService_ReloginRequest* other);
  protected:
  explicit AccountReloginService_ReloginRequest(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes uid = 1;
  bool has_uid() const;
  void clear_uid();
  static const int kUidFieldNumber = 1;
  const ::std::string& uid() const;
  void set_uid(const ::std::string& value);
  #if LANG_CXX11
  void set_uid(::std::string&& value);
  #endif
  void set_uid(const char* value);
  void set_uid(const void* value, size_t size);
  ::std::string* mutable_uid();
  ::std::string* release_uid();
  void set_allocated_uid(::std::string* uid);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_uid();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_uid(
      ::std::string* uid);

  // required bytes pwd = 2;
  bool has_pwd() const;
  void clear_pwd();
  static const int kPwdFieldNumber = 2;
  const ::std::string& pwd() const;
  void set_pwd(const ::std::string& value);
  #if LANG_CXX11
  void set_pwd(::std::string&& value);
  #endif
  void set_pwd(const char* value);
  void set_pwd(const void* value, size_t size);
  ::std::string* mutable_pwd();
  ::std::string* release_pwd();
  void set_allocated_pwd(::std::string* pwd);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_pwd();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_pwd(
      ::std::string* pwd);

  // @@protoc_insertion_point(class_scope:gate.AccountReloginService.ReloginRequest)
 private:
  void set_has_uid();
  void clear_has_uid();
  void set_has_pwd();
  void clear_has_pwd();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr uid_;
  ::google::protobuf::internal::ArenaStringPtr pwd_;
  friend struct ::protobuf_Gate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AccountReloginService_ReloginResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gate.AccountReloginService.ReloginResponse) */ {
 public:
  AccountReloginService_ReloginResponse();
  virtual ~AccountReloginService_ReloginResponse();

  AccountReloginService_ReloginResponse(const AccountReloginService_ReloginResponse& from);

  inline AccountReloginService_ReloginResponse& operator=(const AccountReloginService_ReloginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccountReloginService_ReloginResponse(AccountReloginService_ReloginResponse&& from) noexcept
    : AccountReloginService_ReloginResponse() {
    *this = ::std::move(from);
  }

  inline AccountReloginService_ReloginResponse& operator=(AccountReloginService_ReloginResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountReloginService_ReloginResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AccountReloginService_ReloginResponse* internal_default_instance() {
    return reinterpret_cast<const AccountReloginService_ReloginResponse*>(
               &_AccountReloginService_ReloginResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void UnsafeArenaSwap(AccountReloginService_ReloginResponse* other);
  void Swap(AccountReloginService_ReloginResponse* other);
  friend void swap(AccountReloginService_ReloginResponse& a, AccountReloginService_ReloginResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccountReloginService_ReloginResponse* New() const final {
    return CreateMaybeMessage<AccountReloginService_ReloginResponse>(NULL);
  }

  AccountReloginService_ReloginResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AccountReloginService_ReloginResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AccountReloginService_ReloginResponse& from);
  void MergeFrom(const AccountReloginService_ReloginResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountReloginService_ReloginResponse* other);
  protected:
  explicit AccountReloginService_ReloginResponse(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 uuid = 2;
  bool has_uuid() const;
  void clear_uuid();
  static const int kUuidFieldNumber = 2;
  ::google::protobuf::uint64 uuid() const;
  void set_uuid(::google::protobuf::uint64 value);

  // required .gate.AccountReloginService.RESULT result = 1;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::gate::AccountReloginService_RESULT result() const;
  void set_result(::gate::AccountReloginService_RESULT value);

  // @@protoc_insertion_point(class_scope:gate.AccountReloginService.ReloginResponse)
 private:
  void set_has_result();
  void clear_has_result();
  void set_has_uuid();
  void clear_has_uuid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 uuid_;
  int result_;
  friend struct ::protobuf_Gate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AccountReloginService : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gate.AccountReloginService) */ {
 public:
  AccountReloginService();
  virtual ~AccountReloginService();

  AccountReloginService(const AccountReloginService& from);

  inline AccountReloginService& operator=(const AccountReloginService& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccountReloginService(AccountReloginService&& from) noexcept
    : AccountReloginService() {
    *this = ::std::move(from);
  }

  inline AccountReloginService& operator=(AccountReloginService&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountReloginService& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AccountReloginService* internal_default_instance() {
    return reinterpret_cast<const AccountReloginService*>(
               &_AccountReloginService_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void UnsafeArenaSwap(AccountReloginService* other);
  void Swap(AccountReloginService* other);
  friend void swap(AccountReloginService& a, AccountReloginService& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccountReloginService* New() const final {
    return CreateMaybeMessage<AccountReloginService>(NULL);
  }

  AccountReloginService* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AccountReloginService>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AccountReloginService& from);
  void MergeFrom(const AccountReloginService& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountReloginService* other);
  protected:
  explicit AccountReloginService(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef AccountReloginService_ReloginRequest ReloginRequest;
  typedef AccountReloginService_ReloginResponse ReloginResponse;

  typedef AccountReloginService_RESULT RESULT;
  static const RESULT OK =
    AccountReloginService_RESULT_OK;
  static const RESULT FAILED =
    AccountReloginService_RESULT_FAILED;
  static inline bool RESULT_IsValid(int value) {
    return AccountReloginService_RESULT_IsValid(value);
  }
  static const RESULT RESULT_MIN =
    AccountReloginService_RESULT_RESULT_MIN;
  static const RESULT RESULT_MAX =
    AccountReloginService_RESULT_RESULT_MAX;
  static const int RESULT_ARRAYSIZE =
    AccountReloginService_RESULT_RESULT_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RESULT_descriptor() {
    return AccountReloginService_RESULT_descriptor();
  }
  static inline const ::std::string& RESULT_Name(RESULT value) {
    return AccountReloginService_RESULT_Name(value);
  }
  static inline bool RESULT_Parse(const ::std::string& name,
      RESULT* value) {
    return AccountReloginService_RESULT_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .gate.AccountReloginService.ReloginRequest req = 1;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 1;
  private:
  const ::gate::AccountReloginService_ReloginRequest& _internal_req() const;
  public:
  const ::gate::AccountReloginService_ReloginRequest& req() const;
  ::gate::AccountReloginService_ReloginRequest* release_req();
  ::gate::AccountReloginService_ReloginRequest* mutable_req();
  void set_allocated_req(::gate::AccountReloginService_ReloginRequest* req);
  void unsafe_arena_set_allocated_req(
      ::gate::AccountReloginService_ReloginRequest* req);
  ::gate::AccountReloginService_ReloginRequest* unsafe_arena_release_req();

  // optional .gate.AccountReloginService.ReloginResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  private:
  const ::gate::AccountReloginService_ReloginResponse& _internal_resp() const;
  public:
  const ::gate::AccountReloginService_ReloginResponse& resp() const;
  ::gate::AccountReloginService_ReloginResponse* release_resp();
  ::gate::AccountReloginService_ReloginResponse* mutable_resp();
  void set_allocated_resp(::gate::AccountReloginService_ReloginResponse* resp);
  void unsafe_arena_set_allocated_resp(
      ::gate::AccountReloginService_ReloginResponse* resp);
  ::gate::AccountReloginService_ReloginResponse* unsafe_arena_release_resp();

  // @@protoc_insertion_point(class_scope:gate.AccountReloginService)
 private:
  void set_has_req();
  void clear_has_req();
  void set_has_resp();
  void clear_has_resp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::gate::AccountReloginService_ReloginRequest* req_;
  ::gate::AccountReloginService_ReloginResponse* resp_;
  friend struct ::protobuf_Gate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GameServer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gate.GameServer) */ {
 public:
  GameServer();
  virtual ~GameServer();

  GameServer(const GameServer& from);

  inline GameServer& operator=(const GameServer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameServer(GameServer&& from) noexcept
    : GameServer() {
    *this = ::std::move(from);
  }

  inline GameServer& operator=(GameServer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const GameServer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameServer* internal_default_instance() {
    return reinterpret_cast<const GameServer*>(
               &_GameServer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void UnsafeArenaSwap(GameServer* other);
  void Swap(GameServer* other);
  friend void swap(GameServer& a, GameServer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameServer* New() const final {
    return CreateMaybeMessage<GameServer>(NULL);
  }

  GameServer* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameServer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GameServer& from);
  void MergeFrom(const GameServer& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameServer* other);
  protected:
  explicit GameServer(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const void* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_name();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      ::std::string* name);

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:gate.GameServer)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_name();
  void clear_has_name();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int32 id_;
  friend struct ::protobuf_Gate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GameServerList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gate.GameServerList) */ {
 public:
  GameServerList();
  virtual ~GameServerList();

  GameServerList(const GameServerList& from);

  inline GameServerList& operator=(const GameServerList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameServerList(GameServerList&& from) noexcept
    : GameServerList() {
    *this = ::std::move(from);
  }

  inline GameServerList& operator=(GameServerList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const GameServerList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameServerList* internal_default_instance() {
    return reinterpret_cast<const GameServerList*>(
               &_GameServerList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void UnsafeArenaSwap(GameServerList* other);
  void Swap(GameServerList* other);
  friend void swap(GameServerList& a, GameServerList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameServerList* New() const final {
    return CreateMaybeMessage<GameServerList>(NULL);
  }

  GameServerList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameServerList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GameServerList& from);
  void MergeFrom(const GameServerList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameServerList* other);
  protected:
  explicit GameServerList(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .gate.GameServer list = 1;
  int list_size() const;
  void clear_list();
  static const int kListFieldNumber = 1;
  ::gate::GameServer* mutable_list(int index);
  ::google::protobuf::RepeatedPtrField< ::gate::GameServer >*
      mutable_list();
  const ::gate::GameServer& list(int index) const;
  ::gate::GameServer* add_list();
  const ::google::protobuf::RepeatedPtrField< ::gate::GameServer >&
      list() const;

  // @@protoc_insertion_point(class_scope:gate.GameServerList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::gate::GameServer > list_;
  friend struct ::protobuf_Gate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GameServerService_GameServerRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gate.GameServerService.GameServerRequest) */ {
 public:
  GameServerService_GameServerRequest();
  virtual ~GameServerService_GameServerRequest();

  GameServerService_GameServerRequest(const GameServerService_GameServerRequest& from);

  inline GameServerService_GameServerRequest& operator=(const GameServerService_GameServerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameServerService_GameServerRequest(GameServerService_GameServerRequest&& from) noexcept
    : GameServerService_GameServerRequest() {
    *this = ::std::move(from);
  }

  inline GameServerService_GameServerRequest& operator=(GameServerService_GameServerRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const GameServerService_GameServerRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameServerService_GameServerRequest* internal_default_instance() {
    return reinterpret_cast<const GameServerService_GameServerRequest*>(
               &_GameServerService_GameServerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void UnsafeArenaSwap(GameServerService_GameServerRequest* other);
  void Swap(GameServerService_GameServerRequest* other);
  friend void swap(GameServerService_GameServerRequest& a, GameServerService_GameServerRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameServerService_GameServerRequest* New() const final {
    return CreateMaybeMessage<GameServerService_GameServerRequest>(NULL);
  }

  GameServerService_GameServerRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameServerService_GameServerRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GameServerService_GameServerRequest& from);
  void MergeFrom(const GameServerService_GameServerRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameServerService_GameServerRequest* other);
  protected:
  explicit GameServerService_GameServerRequest(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 serverid = 2;
  bool has_serverid() const;
  void clear_serverid();
  static const int kServeridFieldNumber = 2;
  ::google::protobuf::int32 serverid() const;
  void set_serverid(::google::protobuf::int32 value);

  // required .gate.GameServerService.GAME_SERVER_COMMAND cmd = 1;
  bool has_cmd() const;
  void clear_cmd();
  static const int kCmdFieldNumber = 1;
  ::gate::GameServerService_GAME_SERVER_COMMAND cmd() const;
  void set_cmd(::gate::GameServerService_GAME_SERVER_COMMAND value);

  // @@protoc_insertion_point(class_scope:gate.GameServerService.GameServerRequest)
 private:
  void set_has_cmd();
  void clear_has_cmd();
  void set_has_serverid();
  void clear_has_serverid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 serverid_;
  int cmd_;
  friend struct ::protobuf_Gate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GameServerService_GameServerResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gate.GameServerService.GameServerResponse) */ {
 public:
  GameServerService_GameServerResponse();
  virtual ~GameServerService_GameServerResponse();

  GameServerService_GameServerResponse(const GameServerService_GameServerResponse& from);

  inline GameServerService_GameServerResponse& operator=(const GameServerService_GameServerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameServerService_GameServerResponse(GameServerService_GameServerResponse&& from) noexcept
    : GameServerService_GameServerResponse() {
    *this = ::std::move(from);
  }

  inline GameServerService_GameServerResponse& operator=(GameServerService_GameServerResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const GameServerService_GameServerResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameServerService_GameServerResponse* internal_default_instance() {
    return reinterpret_cast<const GameServerService_GameServerResponse*>(
               &_GameServerService_GameServerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void UnsafeArenaSwap(GameServerService_GameServerResponse* other);
  void Swap(GameServerService_GameServerResponse* other);
  friend void swap(GameServerService_GameServerResponse& a, GameServerService_GameServerResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameServerService_GameServerResponse* New() const final {
    return CreateMaybeMessage<GameServerService_GameServerResponse>(NULL);
  }

  GameServerService_GameServerResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameServerService_GameServerResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GameServerService_GameServerResponse& from);
  void MergeFrom(const GameServerService_GameServerResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameServerService_GameServerResponse* other);
  protected:
  explicit GameServerService_GameServerResponse(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .gate.GameServerList server_list = 2;
  bool has_server_list() const;
  void clear_server_list();
  static const int kServerListFieldNumber = 2;
  private:
  const ::gate::GameServerList& _internal_server_list() const;
  public:
  const ::gate::GameServerList& server_list() const;
  ::gate::GameServerList* release_server_list();
  ::gate::GameServerList* mutable_server_list();
  void set_allocated_server_list(::gate::GameServerList* server_list);
  void unsafe_arena_set_allocated_server_list(
      ::gate::GameServerList* server_list);
  ::gate::GameServerList* unsafe_arena_release_server_list();

  // required int32 result = 1;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::google::protobuf::int32 result() const;
  void set_result(::google::protobuf::int32 value);

  // optional int32 last_serverid = 3;
  bool has_last_serverid() const;
  void clear_last_serverid();
  static const int kLastServeridFieldNumber = 3;
  ::google::protobuf::int32 last_serverid() const;
  void set_last_serverid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:gate.GameServerService.GameServerResponse)
 private:
  void set_has_result();
  void clear_has_result();
  void set_has_server_list();
  void clear_has_server_list();
  void set_has_last_serverid();
  void clear_has_last_serverid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::gate::GameServerList* server_list_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 last_serverid_;
  friend struct ::protobuf_Gate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GameServerService : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gate.GameServerService) */ {
 public:
  GameServerService();
  virtual ~GameServerService();

  GameServerService(const GameServerService& from);

  inline GameServerService& operator=(const GameServerService& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameServerService(GameServerService&& from) noexcept
    : GameServerService() {
    *this = ::std::move(from);
  }

  inline GameServerService& operator=(GameServerService&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const GameServerService& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameServerService* internal_default_instance() {
    return reinterpret_cast<const GameServerService*>(
               &_GameServerService_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void UnsafeArenaSwap(GameServerService* other);
  void Swap(GameServerService* other);
  friend void swap(GameServerService& a, GameServerService& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameServerService* New() const final {
    return CreateMaybeMessage<GameServerService>(NULL);
  }

  GameServerService* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameServerService>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GameServerService& from);
  void MergeFrom(const GameServerService& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameServerService* other);
  protected:
  explicit GameServerService(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GameServerService_GameServerRequest GameServerRequest;
  typedef GameServerService_GameServerResponse GameServerResponse;

  typedef GameServerService_GAME_SERVER_COMMAND GAME_SERVER_COMMAND;
  static const GAME_SERVER_COMMAND QUERY =
    GameServerService_GAME_SERVER_COMMAND_QUERY;
  static const GAME_SERVER_COMMAND SELECT_SERVER =
    GameServerService_GAME_SERVER_COMMAND_SELECT_SERVER;
  static inline bool GAME_SERVER_COMMAND_IsValid(int value) {
    return GameServerService_GAME_SERVER_COMMAND_IsValid(value);
  }
  static const GAME_SERVER_COMMAND GAME_SERVER_COMMAND_MIN =
    GameServerService_GAME_SERVER_COMMAND_GAME_SERVER_COMMAND_MIN;
  static const GAME_SERVER_COMMAND GAME_SERVER_COMMAND_MAX =
    GameServerService_GAME_SERVER_COMMAND_GAME_SERVER_COMMAND_MAX;
  static const int GAME_SERVER_COMMAND_ARRAYSIZE =
    GameServerService_GAME_SERVER_COMMAND_GAME_SERVER_COMMAND_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  GAME_SERVER_COMMAND_descriptor() {
    return GameServerService_GAME_SERVER_COMMAND_descriptor();
  }
  static inline const ::std::string& GAME_SERVER_COMMAND_Name(GAME_SERVER_COMMAND value) {
    return GameServerService_GAME_SERVER_COMMAND_Name(value);
  }
  static inline bool GAME_SERVER_COMMAND_Parse(const ::std::string& name,
      GAME_SERVER_COMMAND* value) {
    return GameServerService_GAME_SERVER_COMMAND_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .gate.GameServerService.GameServerRequest req = 1;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 1;
  private:
  const ::gate::GameServerService_GameServerRequest& _internal_req() const;
  public:
  const ::gate::GameServerService_GameServerRequest& req() const;
  ::gate::GameServerService_GameServerRequest* release_req();
  ::gate::GameServerService_GameServerRequest* mutable_req();
  void set_allocated_req(::gate::GameServerService_GameServerRequest* req);
  void unsafe_arena_set_allocated_req(
      ::gate::GameServerService_GameServerRequest* req);
  ::gate::GameServerService_GameServerRequest* unsafe_arena_release_req();

  // optional .gate.GameServerService.GameServerResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  private:
  const ::gate::GameServerService_GameServerResponse& _internal_resp() const;
  public:
  const ::gate::GameServerService_GameServerResponse& resp() const;
  ::gate::GameServerService_GameServerResponse* release_resp();
  ::gate::GameServerService_GameServerResponse* mutable_resp();
  void set_allocated_resp(::gate::GameServerService_GameServerResponse* resp);
  void unsafe_arena_set_allocated_resp(
      ::gate::GameServerService_GameServerResponse* resp);
  ::gate::GameServerService_GameServerResponse* unsafe_arena_release_resp();

  // @@protoc_insertion_point(class_scope:gate.GameServerService)
 private:
  void set_has_req();
  void clear_has_req();
  void set_has_resp();
  void clear_has_resp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::gate::GameServerService_GameServerRequest* req_;
  ::gate::GameServerService_GameServerResponse* resp_;
  friend struct ::protobuf_Gate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ActiveCodeService_ActiveRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gate.ActiveCodeService.ActiveRequest) */ {
 public:
  ActiveCodeService_ActiveRequest();
  virtual ~ActiveCodeService_ActiveRequest();

  ActiveCodeService_ActiveRequest(const ActiveCodeService_ActiveRequest& from);

  inline ActiveCodeService_ActiveRequest& operator=(const ActiveCodeService_ActiveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ActiveCodeService_ActiveRequest(ActiveCodeService_ActiveRequest&& from) noexcept
    : ActiveCodeService_ActiveRequest() {
    *this = ::std::move(from);
  }

  inline ActiveCodeService_ActiveRequest& operator=(ActiveCodeService_ActiveRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const ActiveCodeService_ActiveRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActiveCodeService_ActiveRequest* internal_default_instance() {
    return reinterpret_cast<const ActiveCodeService_ActiveRequest*>(
               &_ActiveCodeService_ActiveRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void UnsafeArenaSwap(ActiveCodeService_ActiveRequest* other);
  void Swap(ActiveCodeService_ActiveRequest* other);
  friend void swap(ActiveCodeService_ActiveRequest& a, ActiveCodeService_ActiveRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ActiveCodeService_ActiveRequest* New() const final {
    return CreateMaybeMessage<ActiveCodeService_ActiveRequest>(NULL);
  }

  ActiveCodeService_ActiveRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ActiveCodeService_ActiveRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ActiveCodeService_ActiveRequest& from);
  void MergeFrom(const ActiveCodeService_ActiveRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActiveCodeService_ActiveRequest* other);
  protected:
  explicit ActiveCodeService_ActiveRequest(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes active_code = 1;
  bool has_active_code() const;
  void clear_active_code();
  static const int kActiveCodeFieldNumber = 1;
  const ::std::string& active_code() const;
  void set_active_code(const ::std::string& value);
  #if LANG_CXX11
  void set_active_code(::std::string&& value);
  #endif
  void set_active_code(const char* value);
  void set_active_code(const void* value, size_t size);
  ::std::string* mutable_active_code();
  ::std::string* release_active_code();
  void set_allocated_active_code(::std::string* active_code);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_active_code();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_active_code(
      ::std::string* active_code);

  // required bytes uid = 2;
  bool has_uid() const;
  void clear_uid();
  static const int kUidFieldNumber = 2;
  const ::std::string& uid() const;
  void set_uid(const ::std::string& value);
  #if LANG_CXX11
  void set_uid(::std::string&& value);
  #endif
  void set_uid(const char* value);
  void set_uid(const void* value, size_t size);
  ::std::string* mutable_uid();
  ::std::string* release_uid();
  void set_allocated_uid(::std::string* uid);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_uid();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_uid(
      ::std::string* uid);

  // @@protoc_insertion_point(class_scope:gate.ActiveCodeService.ActiveRequest)
 private:
  void set_has_active_code();
  void clear_has_active_code();
  void set_has_uid();
  void clear_has_uid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr active_code_;
  ::google::protobuf::internal::ArenaStringPtr uid_;
  friend struct ::protobuf_Gate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ActiveCodeService_ActiveResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gate.ActiveCodeService.ActiveResponse) */ {
 public:
  ActiveCodeService_ActiveResponse();
  virtual ~ActiveCodeService_ActiveResponse();

  ActiveCodeService_ActiveResponse(const ActiveCodeService_ActiveResponse& from);

  inline ActiveCodeService_ActiveResponse& operator=(const ActiveCodeService_ActiveResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ActiveCodeService_ActiveResponse(ActiveCodeService_ActiveResponse&& from) noexcept
    : ActiveCodeService_ActiveResponse() {
    *this = ::std::move(from);
  }

  inline ActiveCodeService_ActiveResponse& operator=(ActiveCodeService_ActiveResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const ActiveCodeService_ActiveResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActiveCodeService_ActiveResponse* internal_default_instance() {
    return reinterpret_cast<const ActiveCodeService_ActiveResponse*>(
               &_ActiveCodeService_ActiveResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void UnsafeArenaSwap(ActiveCodeService_ActiveResponse* other);
  void Swap(ActiveCodeService_ActiveResponse* other);
  friend void swap(ActiveCodeService_ActiveResponse& a, ActiveCodeService_ActiveResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ActiveCodeService_ActiveResponse* New() const final {
    return CreateMaybeMessage<ActiveCodeService_ActiveResponse>(NULL);
  }

  ActiveCodeService_ActiveResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ActiveCodeService_ActiveResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ActiveCodeService_ActiveResponse& from);
  void MergeFrom(const ActiveCodeService_ActiveResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActiveCodeService_ActiveResponse* other);
  protected:
  explicit ActiveCodeService_ActiveResponse(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 result = 1;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::google::protobuf::int32 result() const;
  void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:gate.ActiveCodeService.ActiveResponse)
 private:
  void set_has_result();
  void clear_has_result();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 result_;
  friend struct ::protobuf_Gate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ActiveCodeService : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gate.ActiveCodeService) */ {
 public:
  ActiveCodeService();
  virtual ~ActiveCodeService();

  ActiveCodeService(const ActiveCodeService& from);

  inline ActiveCodeService& operator=(const ActiveCodeService& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ActiveCodeService(ActiveCodeService&& from) noexcept
    : ActiveCodeService() {
    *this = ::std::move(from);
  }

  inline ActiveCodeService& operator=(ActiveCodeService&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const ActiveCodeService& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActiveCodeService* internal_default_instance() {
    return reinterpret_cast<const ActiveCodeService*>(
               &_ActiveCodeService_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void UnsafeArenaSwap(ActiveCodeService* other);
  void Swap(ActiveCodeService* other);
  friend void swap(ActiveCodeService& a, ActiveCodeService& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ActiveCodeService* New() const final {
    return CreateMaybeMessage<ActiveCodeService>(NULL);
  }

  ActiveCodeService* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ActiveCodeService>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ActiveCodeService& from);
  void MergeFrom(const ActiveCodeService& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActiveCodeService* other);
  protected:
  explicit ActiveCodeService(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ActiveCodeService_ActiveRequest ActiveRequest;
  typedef ActiveCodeService_ActiveResponse ActiveResponse;

  // accessors -------------------------------------------------------

  // optional .gate.ActiveCodeService.ActiveRequest req = 1;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 1;
  private:
  const ::gate::ActiveCodeService_ActiveRequest& _internal_req() const;
  public:
  const ::gate::ActiveCodeService_ActiveRequest& req() const;
  ::gate::ActiveCodeService_ActiveRequest* release_req();
  ::gate::ActiveCodeService_ActiveRequest* mutable_req();
  void set_allocated_req(::gate::ActiveCodeService_ActiveRequest* req);
  void unsafe_arena_set_allocated_req(
      ::gate::ActiveCodeService_ActiveRequest* req);
  ::gate::ActiveCodeService_ActiveRequest* unsafe_arena_release_req();

  // optional .gate.ActiveCodeService.ActiveResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  private:
  const ::gate::ActiveCodeService_ActiveResponse& _internal_resp() const;
  public:
  const ::gate::ActiveCodeService_ActiveResponse& resp() const;
  ::gate::ActiveCodeService_ActiveResponse* release_resp();
  ::gate::ActiveCodeService_ActiveResponse* mutable_resp();
  void set_allocated_resp(::gate::ActiveCodeService_ActiveResponse* resp);
  void unsafe_arena_set_allocated_resp(
      ::gate::ActiveCodeService_ActiveResponse* resp);
  ::gate::ActiveCodeService_ActiveResponse* unsafe_arena_release_resp();

  // @@protoc_insertion_point(class_scope:gate.ActiveCodeService)
 private:
  void set_has_req();
  void clear_has_req();
  void set_has_resp();
  void clear_has_resp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::gate::ActiveCodeService_ActiveRequest* req_;
  ::gate::ActiveCodeService_ActiveResponse* resp_;
  friend struct ::protobuf_Gate_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ErrorNo

// required int32 error_no = 1;
inline bool ErrorNo::has_error_no() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ErrorNo::set_has_error_no() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ErrorNo::clear_has_error_no() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ErrorNo::clear_error_no() {
  error_no_ = 0;
  clear_has_error_no();
}
inline ::google::protobuf::int32 ErrorNo::error_no() const {
  // @@protoc_insertion_point(field_get:gate.ErrorNo.error_no)
  return error_no_;
}
inline void ErrorNo::set_error_no(::google::protobuf::int32 value) {
  set_has_error_no();
  error_no_ = value;
  // @@protoc_insertion_point(field_set:gate.ErrorNo.error_no)
}

// required bytes desc = 2;
inline bool ErrorNo::has_desc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ErrorNo::set_has_desc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ErrorNo::clear_has_desc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ErrorNo::clear_desc() {
  desc_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_desc();
}
inline const ::std::string& ErrorNo::desc() const {
  // @@protoc_insertion_point(field_get:gate.ErrorNo.desc)
  return desc_.Get();
}
inline void ErrorNo::set_desc(const ::std::string& value) {
  set_has_desc();
  desc_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:gate.ErrorNo.desc)
}
#if LANG_CXX11
inline void ErrorNo::set_desc(::std::string&& value) {
  set_has_desc();
  desc_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:gate.ErrorNo.desc)
}
#endif
inline void ErrorNo::set_desc(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_desc();
  desc_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:gate.ErrorNo.desc)
}
inline void ErrorNo::set_desc(const void* value,
    size_t size) {
  set_has_desc();
  desc_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:gate.ErrorNo.desc)
}
inline ::std::string* ErrorNo::mutable_desc() {
  set_has_desc();
  // @@protoc_insertion_point(field_mutable:gate.ErrorNo.desc)
  return desc_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* ErrorNo::release_desc() {
  // @@protoc_insertion_point(field_release:gate.ErrorNo.desc)
  if (!has_desc()) {
    return NULL;
  }
  clear_has_desc();
  return desc_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void ErrorNo::set_allocated_desc(::std::string* desc) {
  if (desc != NULL) {
    set_has_desc();
  } else {
    clear_has_desc();
  }
  desc_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), desc,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:gate.ErrorNo.desc)
}
inline ::std::string* ErrorNo::unsafe_arena_release_desc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gate.ErrorNo.desc)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_desc();
  return desc_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void ErrorNo::unsafe_arena_set_allocated_desc(
    ::std::string* desc) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (desc != NULL) {
    set_has_desc();
  } else {
    clear_has_desc();
  }
  desc_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      desc, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gate.ErrorNo.desc)
}

// -------------------------------------------------------------------

// RegisterAccountService_RegisterRequest

// required bytes uid = 1;
inline bool RegisterAccountService_RegisterRequest::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterAccountService_RegisterRequest::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterAccountService_RegisterRequest::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterAccountService_RegisterRequest::clear_uid() {
  uid_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_uid();
}
inline const ::std::string& RegisterAccountService_RegisterRequest::uid() const {
  // @@protoc_insertion_point(field_get:gate.RegisterAccountService.RegisterRequest.uid)
  return uid_.Get();
}
inline void RegisterAccountService_RegisterRequest::set_uid(const ::std::string& value) {
  set_has_uid();
  uid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:gate.RegisterAccountService.RegisterRequest.uid)
}
#if LANG_CXX11
inline void RegisterAccountService_RegisterRequest::set_uid(::std::string&& value) {
  set_has_uid();
  uid_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:gate.RegisterAccountService.RegisterRequest.uid)
}
#endif
inline void RegisterAccountService_RegisterRequest::set_uid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_uid();
  uid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:gate.RegisterAccountService.RegisterRequest.uid)
}
inline void RegisterAccountService_RegisterRequest::set_uid(const void* value,
    size_t size) {
  set_has_uid();
  uid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:gate.RegisterAccountService.RegisterRequest.uid)
}
inline ::std::string* RegisterAccountService_RegisterRequest::mutable_uid() {
  set_has_uid();
  // @@protoc_insertion_point(field_mutable:gate.RegisterAccountService.RegisterRequest.uid)
  return uid_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* RegisterAccountService_RegisterRequest::release_uid() {
  // @@protoc_insertion_point(field_release:gate.RegisterAccountService.RegisterRequest.uid)
  if (!has_uid()) {
    return NULL;
  }
  clear_has_uid();
  return uid_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void RegisterAccountService_RegisterRequest::set_allocated_uid(::std::string* uid) {
  if (uid != NULL) {
    set_has_uid();
  } else {
    clear_has_uid();
  }
  uid_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uid,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:gate.RegisterAccountService.RegisterRequest.uid)
}
inline ::std::string* RegisterAccountService_RegisterRequest::unsafe_arena_release_uid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gate.RegisterAccountService.RegisterRequest.uid)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_uid();
  return uid_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void RegisterAccountService_RegisterRequest::unsafe_arena_set_allocated_uid(
    ::std::string* uid) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (uid != NULL) {
    set_has_uid();
  } else {
    clear_has_uid();
  }
  uid_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      uid, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gate.RegisterAccountService.RegisterRequest.uid)
}

// required bytes pwd = 2;
inline bool RegisterAccountService_RegisterRequest::has_pwd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegisterAccountService_RegisterRequest::set_has_pwd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegisterAccountService_RegisterRequest::clear_has_pwd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegisterAccountService_RegisterRequest::clear_pwd() {
  pwd_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_pwd();
}
inline const ::std::string& RegisterAccountService_RegisterRequest::pwd() const {
  // @@protoc_insertion_point(field_get:gate.RegisterAccountService.RegisterRequest.pwd)
  return pwd_.Get();
}
inline void RegisterAccountService_RegisterRequest::set_pwd(const ::std::string& value) {
  set_has_pwd();
  pwd_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:gate.RegisterAccountService.RegisterRequest.pwd)
}
#if LANG_CXX11
inline void RegisterAccountService_RegisterRequest::set_pwd(::std::string&& value) {
  set_has_pwd();
  pwd_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:gate.RegisterAccountService.RegisterRequest.pwd)
}
#endif
inline void RegisterAccountService_RegisterRequest::set_pwd(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pwd();
  pwd_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:gate.RegisterAccountService.RegisterRequest.pwd)
}
inline void RegisterAccountService_RegisterRequest::set_pwd(const void* value,
    size_t size) {
  set_has_pwd();
  pwd_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:gate.RegisterAccountService.RegisterRequest.pwd)
}
inline ::std::string* RegisterAccountService_RegisterRequest::mutable_pwd() {
  set_has_pwd();
  // @@protoc_insertion_point(field_mutable:gate.RegisterAccountService.RegisterRequest.pwd)
  return pwd_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* RegisterAccountService_RegisterRequest::release_pwd() {
  // @@protoc_insertion_point(field_release:gate.RegisterAccountService.RegisterRequest.pwd)
  if (!has_pwd()) {
    return NULL;
  }
  clear_has_pwd();
  return pwd_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void RegisterAccountService_RegisterRequest::set_allocated_pwd(::std::string* pwd) {
  if (pwd != NULL) {
    set_has_pwd();
  } else {
    clear_has_pwd();
  }
  pwd_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pwd,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:gate.RegisterAccountService.RegisterRequest.pwd)
}
inline ::std::string* RegisterAccountService_RegisterRequest::unsafe_arena_release_pwd() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gate.RegisterAccountService.RegisterRequest.pwd)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_pwd();
  return pwd_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void RegisterAccountService_RegisterRequest::unsafe_arena_set_allocated_pwd(
    ::std::string* pwd) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (pwd != NULL) {
    set_has_pwd();
  } else {
    clear_has_pwd();
  }
  pwd_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      pwd, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gate.RegisterAccountService.RegisterRequest.pwd)
}

// required bytes nick = 3;
inline bool RegisterAccountService_RegisterRequest::has_nick() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegisterAccountService_RegisterRequest::set_has_nick() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegisterAccountService_RegisterRequest::clear_has_nick() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegisterAccountService_RegisterRequest::clear_nick() {
  nick_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_nick();
}
inline const ::std::string& RegisterAccountService_RegisterRequest::nick() const {
  // @@protoc_insertion_point(field_get:gate.RegisterAccountService.RegisterRequest.nick)
  return nick_.Get();
}
inline void RegisterAccountService_RegisterRequest::set_nick(const ::std::string& value) {
  set_has_nick();
  nick_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:gate.RegisterAccountService.RegisterRequest.nick)
}
#if LANG_CXX11
inline void RegisterAccountService_RegisterRequest::set_nick(::std::string&& value) {
  set_has_nick();
  nick_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:gate.RegisterAccountService.RegisterRequest.nick)
}
#endif
inline void RegisterAccountService_RegisterRequest::set_nick(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_nick();
  nick_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:gate.RegisterAccountService.RegisterRequest.nick)
}
inline void RegisterAccountService_RegisterRequest::set_nick(const void* value,
    size_t size) {
  set_has_nick();
  nick_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:gate.RegisterAccountService.RegisterRequest.nick)
}
inline ::std::string* RegisterAccountService_RegisterRequest::mutable_nick() {
  set_has_nick();
  // @@protoc_insertion_point(field_mutable:gate.RegisterAccountService.RegisterRequest.nick)
  return nick_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* RegisterAccountService_RegisterRequest::release_nick() {
  // @@protoc_insertion_point(field_release:gate.RegisterAccountService.RegisterRequest.nick)
  if (!has_nick()) {
    return NULL;
  }
  clear_has_nick();
  return nick_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void RegisterAccountService_RegisterRequest::set_allocated_nick(::std::string* nick) {
  if (nick != NULL) {
    set_has_nick();
  } else {
    clear_has_nick();
  }
  nick_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nick,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:gate.RegisterAccountService.RegisterRequest.nick)
}
inline ::std::string* RegisterAccountService_RegisterRequest::unsafe_arena_release_nick() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gate.RegisterAccountService.RegisterRequest.nick)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_nick();
  return nick_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void RegisterAccountService_RegisterRequest::unsafe_arena_set_allocated_nick(
    ::std::string* nick) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (nick != NULL) {
    set_has_nick();
  } else {
    clear_has_nick();
  }
  nick_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      nick, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gate.RegisterAccountService.RegisterRequest.nick)
}

// required bytes email = 4;
inline bool RegisterAccountService_RegisterRequest::has_email() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RegisterAccountService_RegisterRequest::set_has_email() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RegisterAccountService_RegisterRequest::clear_has_email() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RegisterAccountService_RegisterRequest::clear_email() {
  email_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_email();
}
inline const ::std::string& RegisterAccountService_RegisterRequest::email() const {
  // @@protoc_insertion_point(field_get:gate.RegisterAccountService.RegisterRequest.email)
  return email_.Get();
}
inline void RegisterAccountService_RegisterRequest::set_email(const ::std::string& value) {
  set_has_email();
  email_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:gate.RegisterAccountService.RegisterRequest.email)
}
#if LANG_CXX11
inline void RegisterAccountService_RegisterRequest::set_email(::std::string&& value) {
  set_has_email();
  email_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:gate.RegisterAccountService.RegisterRequest.email)
}
#endif
inline void RegisterAccountService_RegisterRequest::set_email(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_email();
  email_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:gate.RegisterAccountService.RegisterRequest.email)
}
inline void RegisterAccountService_RegisterRequest::set_email(const void* value,
    size_t size) {
  set_has_email();
  email_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:gate.RegisterAccountService.RegisterRequest.email)
}
inline ::std::string* RegisterAccountService_RegisterRequest::mutable_email() {
  set_has_email();
  // @@protoc_insertion_point(field_mutable:gate.RegisterAccountService.RegisterRequest.email)
  return email_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* RegisterAccountService_RegisterRequest::release_email() {
  // @@protoc_insertion_point(field_release:gate.RegisterAccountService.RegisterRequest.email)
  if (!has_email()) {
    return NULL;
  }
  clear_has_email();
  return email_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void RegisterAccountService_RegisterRequest::set_allocated_email(::std::string* email) {
  if (email != NULL) {
    set_has_email();
  } else {
    clear_has_email();
  }
  email_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), email,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:gate.RegisterAccountService.RegisterRequest.email)
}
inline ::std::string* RegisterAccountService_RegisterRequest::unsafe_arena_release_email() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gate.RegisterAccountService.RegisterRequest.email)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_email();
  return email_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void RegisterAccountService_RegisterRequest::unsafe_arena_set_allocated_email(
    ::std::string* email) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (email != NULL) {
    set_has_email();
  } else {
    clear_has_email();
  }
  email_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      email, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gate.RegisterAccountService.RegisterRequest.email)
}

// optional bytes sponsor_uid = 11;
inline bool RegisterAccountService_RegisterRequest::has_sponsor_uid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RegisterAccountService_RegisterRequest::set_has_sponsor_uid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RegisterAccountService_RegisterRequest::clear_has_sponsor_uid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RegisterAccountService_RegisterRequest::clear_sponsor_uid() {
  sponsor_uid_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_sponsor_uid();
}
inline const ::std::string& RegisterAccountService_RegisterRequest::sponsor_uid() const {
  // @@protoc_insertion_point(field_get:gate.RegisterAccountService.RegisterRequest.sponsor_uid)
  return sponsor_uid_.Get();
}
inline void RegisterAccountService_RegisterRequest::set_sponsor_uid(const ::std::string& value) {
  set_has_sponsor_uid();
  sponsor_uid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:gate.RegisterAccountService.RegisterRequest.sponsor_uid)
}
#if LANG_CXX11
inline void RegisterAccountService_RegisterRequest::set_sponsor_uid(::std::string&& value) {
  set_has_sponsor_uid();
  sponsor_uid_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:gate.RegisterAccountService.RegisterRequest.sponsor_uid)
}
#endif
inline void RegisterAccountService_RegisterRequest::set_sponsor_uid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sponsor_uid();
  sponsor_uid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:gate.RegisterAccountService.RegisterRequest.sponsor_uid)
}
inline void RegisterAccountService_RegisterRequest::set_sponsor_uid(const void* value,
    size_t size) {
  set_has_sponsor_uid();
  sponsor_uid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:gate.RegisterAccountService.RegisterRequest.sponsor_uid)
}
inline ::std::string* RegisterAccountService_RegisterRequest::mutable_sponsor_uid() {
  set_has_sponsor_uid();
  // @@protoc_insertion_point(field_mutable:gate.RegisterAccountService.RegisterRequest.sponsor_uid)
  return sponsor_uid_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* RegisterAccountService_RegisterRequest::release_sponsor_uid() {
  // @@protoc_insertion_point(field_release:gate.RegisterAccountService.RegisterRequest.sponsor_uid)
  if (!has_sponsor_uid()) {
    return NULL;
  }
  clear_has_sponsor_uid();
  return sponsor_uid_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void RegisterAccountService_RegisterRequest::set_allocated_sponsor_uid(::std::string* sponsor_uid) {
  if (sponsor_uid != NULL) {
    set_has_sponsor_uid();
  } else {
    clear_has_sponsor_uid();
  }
  sponsor_uid_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sponsor_uid,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:gate.RegisterAccountService.RegisterRequest.sponsor_uid)
}
inline ::std::string* RegisterAccountService_RegisterRequest::unsafe_arena_release_sponsor_uid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gate.RegisterAccountService.RegisterRequest.sponsor_uid)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_sponsor_uid();
  return sponsor_uid_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void RegisterAccountService_RegisterRequest::unsafe_arena_set_allocated_sponsor_uid(
    ::std::string* sponsor_uid) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (sponsor_uid != NULL) {
    set_has_sponsor_uid();
  } else {
    clear_has_sponsor_uid();
  }
  sponsor_uid_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      sponsor_uid, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gate.RegisterAccountService.RegisterRequest.sponsor_uid)
}

// -------------------------------------------------------------------

// RegisterAccountService_RegisterResponse

// required int32 result = 1;
inline bool RegisterAccountService_RegisterResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterAccountService_RegisterResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterAccountService_RegisterResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterAccountService_RegisterResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 RegisterAccountService_RegisterResponse::result() const {
  // @@protoc_insertion_point(field_get:gate.RegisterAccountService.RegisterResponse.result)
  return result_;
}
inline void RegisterAccountService_RegisterResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:gate.RegisterAccountService.RegisterResponse.result)
}

// -------------------------------------------------------------------

// RegisterAccountService

// optional .gate.RegisterAccountService.RegisterRequest req = 1;
inline bool RegisterAccountService::has_req() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterAccountService::set_has_req() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterAccountService::clear_has_req() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterAccountService::clear_req() {
  if (req_ != NULL) req_->Clear();
  clear_has_req();
}
inline const ::gate::RegisterAccountService_RegisterRequest& RegisterAccountService::_internal_req() const {
  return *req_;
}
inline const ::gate::RegisterAccountService_RegisterRequest& RegisterAccountService::req() const {
  const ::gate::RegisterAccountService_RegisterRequest* p = req_;
  // @@protoc_insertion_point(field_get:gate.RegisterAccountService.req)
  return p != NULL ? *p : *reinterpret_cast<const ::gate::RegisterAccountService_RegisterRequest*>(
      &::gate::_RegisterAccountService_RegisterRequest_default_instance_);
}
inline ::gate::RegisterAccountService_RegisterRequest* RegisterAccountService::release_req() {
  // @@protoc_insertion_point(field_release:gate.RegisterAccountService.req)
  clear_has_req();
  ::gate::RegisterAccountService_RegisterRequest* temp = req_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  req_ = NULL;
  return temp;
}
inline ::gate::RegisterAccountService_RegisterRequest* RegisterAccountService::unsafe_arena_release_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gate.RegisterAccountService.req)
  clear_has_req();
  ::gate::RegisterAccountService_RegisterRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline ::gate::RegisterAccountService_RegisterRequest* RegisterAccountService::mutable_req() {
  set_has_req();
  if (req_ == NULL) {
    auto* p = CreateMaybeMessage<::gate::RegisterAccountService_RegisterRequest>(GetArenaNoVirtual());
    req_ = p;
  }
  // @@protoc_insertion_point(field_mutable:gate.RegisterAccountService.req)
  return req_;
}
inline void RegisterAccountService::set_allocated_req(::gate::RegisterAccountService_RegisterRequest* req) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete req_;
  }
  if (req) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(req);
    if (message_arena != submessage_arena) {
      req = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, req, submessage_arena);
    }
    set_has_req();
  } else {
    clear_has_req();
  }
  req_ = req;
  // @@protoc_insertion_point(field_set_allocated:gate.RegisterAccountService.req)
}

// optional .gate.RegisterAccountService.RegisterResponse resp = 2;
inline bool RegisterAccountService::has_resp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegisterAccountService::set_has_resp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegisterAccountService::clear_has_resp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegisterAccountService::clear_resp() {
  if (resp_ != NULL) resp_->Clear();
  clear_has_resp();
}
inline const ::gate::RegisterAccountService_RegisterResponse& RegisterAccountService::_internal_resp() const {
  return *resp_;
}
inline const ::gate::RegisterAccountService_RegisterResponse& RegisterAccountService::resp() const {
  const ::gate::RegisterAccountService_RegisterResponse* p = resp_;
  // @@protoc_insertion_point(field_get:gate.RegisterAccountService.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::gate::RegisterAccountService_RegisterResponse*>(
      &::gate::_RegisterAccountService_RegisterResponse_default_instance_);
}
inline ::gate::RegisterAccountService_RegisterResponse* RegisterAccountService::release_resp() {
  // @@protoc_insertion_point(field_release:gate.RegisterAccountService.resp)
  clear_has_resp();
  ::gate::RegisterAccountService_RegisterResponse* temp = resp_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  resp_ = NULL;
  return temp;
}
inline ::gate::RegisterAccountService_RegisterResponse* RegisterAccountService::unsafe_arena_release_resp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gate.RegisterAccountService.resp)
  clear_has_resp();
  ::gate::RegisterAccountService_RegisterResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline ::gate::RegisterAccountService_RegisterResponse* RegisterAccountService::mutable_resp() {
  set_has_resp();
  if (resp_ == NULL) {
    auto* p = CreateMaybeMessage<::gate::RegisterAccountService_RegisterResponse>(GetArenaNoVirtual());
    resp_ = p;
  }
  // @@protoc_insertion_point(field_mutable:gate.RegisterAccountService.resp)
  return resp_;
}
inline void RegisterAccountService::set_allocated_resp(::gate::RegisterAccountService_RegisterResponse* resp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete resp_;
  }
  if (resp) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(resp);
    if (message_arena != submessage_arena) {
      resp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, resp, submessage_arena);
    }
    set_has_resp();
  } else {
    clear_has_resp();
  }
  resp_ = resp;
  // @@protoc_insertion_point(field_set_allocated:gate.RegisterAccountService.resp)
}

// -------------------------------------------------------------------

// FastRegisterAccountService_RegisterRequest

// -------------------------------------------------------------------

// FastRegisterAccountService_RegisterResponse

// required bytes uid = 1;
inline bool FastRegisterAccountService_RegisterResponse::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FastRegisterAccountService_RegisterResponse::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FastRegisterAccountService_RegisterResponse::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FastRegisterAccountService_RegisterResponse::clear_uid() {
  uid_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_uid();
}
inline const ::std::string& FastRegisterAccountService_RegisterResponse::uid() const {
  // @@protoc_insertion_point(field_get:gate.FastRegisterAccountService.RegisterResponse.uid)
  return uid_.Get();
}
inline void FastRegisterAccountService_RegisterResponse::set_uid(const ::std::string& value) {
  set_has_uid();
  uid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:gate.FastRegisterAccountService.RegisterResponse.uid)
}
#if LANG_CXX11
inline void FastRegisterAccountService_RegisterResponse::set_uid(::std::string&& value) {
  set_has_uid();
  uid_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:gate.FastRegisterAccountService.RegisterResponse.uid)
}
#endif
inline void FastRegisterAccountService_RegisterResponse::set_uid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_uid();
  uid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:gate.FastRegisterAccountService.RegisterResponse.uid)
}
inline void FastRegisterAccountService_RegisterResponse::set_uid(const void* value,
    size_t size) {
  set_has_uid();
  uid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:gate.FastRegisterAccountService.RegisterResponse.uid)
}
inline ::std::string* FastRegisterAccountService_RegisterResponse::mutable_uid() {
  set_has_uid();
  // @@protoc_insertion_point(field_mutable:gate.FastRegisterAccountService.RegisterResponse.uid)
  return uid_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* FastRegisterAccountService_RegisterResponse::release_uid() {
  // @@protoc_insertion_point(field_release:gate.FastRegisterAccountService.RegisterResponse.uid)
  if (!has_uid()) {
    return NULL;
  }
  clear_has_uid();
  return uid_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void FastRegisterAccountService_RegisterResponse::set_allocated_uid(::std::string* uid) {
  if (uid != NULL) {
    set_has_uid();
  } else {
    clear_has_uid();
  }
  uid_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uid,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:gate.FastRegisterAccountService.RegisterResponse.uid)
}
inline ::std::string* FastRegisterAccountService_RegisterResponse::unsafe_arena_release_uid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gate.FastRegisterAccountService.RegisterResponse.uid)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_uid();
  return uid_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void FastRegisterAccountService_RegisterResponse::unsafe_arena_set_allocated_uid(
    ::std::string* uid) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (uid != NULL) {
    set_has_uid();
  } else {
    clear_has_uid();
  }
  uid_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      uid, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gate.FastRegisterAccountService.RegisterResponse.uid)
}

// required bytes pwd = 2;
inline bool FastRegisterAccountService_RegisterResponse::has_pwd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FastRegisterAccountService_RegisterResponse::set_has_pwd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FastRegisterAccountService_RegisterResponse::clear_has_pwd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FastRegisterAccountService_RegisterResponse::clear_pwd() {
  pwd_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_pwd();
}
inline const ::std::string& FastRegisterAccountService_RegisterResponse::pwd() const {
  // @@protoc_insertion_point(field_get:gate.FastRegisterAccountService.RegisterResponse.pwd)
  return pwd_.Get();
}
inline void FastRegisterAccountService_RegisterResponse::set_pwd(const ::std::string& value) {
  set_has_pwd();
  pwd_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:gate.FastRegisterAccountService.RegisterResponse.pwd)
}
#if LANG_CXX11
inline void FastRegisterAccountService_RegisterResponse::set_pwd(::std::string&& value) {
  set_has_pwd();
  pwd_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:gate.FastRegisterAccountService.RegisterResponse.pwd)
}
#endif
inline void FastRegisterAccountService_RegisterResponse::set_pwd(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pwd();
  pwd_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:gate.FastRegisterAccountService.RegisterResponse.pwd)
}
inline void FastRegisterAccountService_RegisterResponse::set_pwd(const void* value,
    size_t size) {
  set_has_pwd();
  pwd_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:gate.FastRegisterAccountService.RegisterResponse.pwd)
}
inline ::std::string* FastRegisterAccountService_RegisterResponse::mutable_pwd() {
  set_has_pwd();
  // @@protoc_insertion_point(field_mutable:gate.FastRegisterAccountService.RegisterResponse.pwd)
  return pwd_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* FastRegisterAccountService_RegisterResponse::release_pwd() {
  // @@protoc_insertion_point(field_release:gate.FastRegisterAccountService.RegisterResponse.pwd)
  if (!has_pwd()) {
    return NULL;
  }
  clear_has_pwd();
  return pwd_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void FastRegisterAccountService_RegisterResponse::set_allocated_pwd(::std::string* pwd) {
  if (pwd != NULL) {
    set_has_pwd();
  } else {
    clear_has_pwd();
  }
  pwd_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pwd,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:gate.FastRegisterAccountService.RegisterResponse.pwd)
}
inline ::std::string* FastRegisterAccountService_RegisterResponse::unsafe_arena_release_pwd() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gate.FastRegisterAccountService.RegisterResponse.pwd)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_pwd();
  return pwd_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void FastRegisterAccountService_RegisterResponse::unsafe_arena_set_allocated_pwd(
    ::std::string* pwd) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (pwd != NULL) {
    set_has_pwd();
  } else {
    clear_has_pwd();
  }
  pwd_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      pwd, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gate.FastRegisterAccountService.RegisterResponse.pwd)
}

// required bytes nick = 3;
inline bool FastRegisterAccountService_RegisterResponse::has_nick() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FastRegisterAccountService_RegisterResponse::set_has_nick() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FastRegisterAccountService_RegisterResponse::clear_has_nick() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FastRegisterAccountService_RegisterResponse::clear_nick() {
  nick_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_nick();
}
inline const ::std::string& FastRegisterAccountService_RegisterResponse::nick() const {
  // @@protoc_insertion_point(field_get:gate.FastRegisterAccountService.RegisterResponse.nick)
  return nick_.Get();
}
inline void FastRegisterAccountService_RegisterResponse::set_nick(const ::std::string& value) {
  set_has_nick();
  nick_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:gate.FastRegisterAccountService.RegisterResponse.nick)
}
#if LANG_CXX11
inline void FastRegisterAccountService_RegisterResponse::set_nick(::std::string&& value) {
  set_has_nick();
  nick_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:gate.FastRegisterAccountService.RegisterResponse.nick)
}
#endif
inline void FastRegisterAccountService_RegisterResponse::set_nick(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_nick();
  nick_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:gate.FastRegisterAccountService.RegisterResponse.nick)
}
inline void FastRegisterAccountService_RegisterResponse::set_nick(const void* value,
    size_t size) {
  set_has_nick();
  nick_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:gate.FastRegisterAccountService.RegisterResponse.nick)
}
inline ::std::string* FastRegisterAccountService_RegisterResponse::mutable_nick() {
  set_has_nick();
  // @@protoc_insertion_point(field_mutable:gate.FastRegisterAccountService.RegisterResponse.nick)
  return nick_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* FastRegisterAccountService_RegisterResponse::release_nick() {
  // @@protoc_insertion_point(field_release:gate.FastRegisterAccountService.RegisterResponse.nick)
  if (!has_nick()) {
    return NULL;
  }
  clear_has_nick();
  return nick_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void FastRegisterAccountService_RegisterResponse::set_allocated_nick(::std::string* nick) {
  if (nick != NULL) {
    set_has_nick();
  } else {
    clear_has_nick();
  }
  nick_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nick,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:gate.FastRegisterAccountService.RegisterResponse.nick)
}
inline ::std::string* FastRegisterAccountService_RegisterResponse::unsafe_arena_release_nick() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gate.FastRegisterAccountService.RegisterResponse.nick)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_nick();
  return nick_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void FastRegisterAccountService_RegisterResponse::unsafe_arena_set_allocated_nick(
    ::std::string* nick) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (nick != NULL) {
    set_has_nick();
  } else {
    clear_has_nick();
  }
  nick_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      nick, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gate.FastRegisterAccountService.RegisterResponse.nick)
}

// required bytes email = 4;
inline bool FastRegisterAccountService_RegisterResponse::has_email() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FastRegisterAccountService_RegisterResponse::set_has_email() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FastRegisterAccountService_RegisterResponse::clear_has_email() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FastRegisterAccountService_RegisterResponse::clear_email() {
  email_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_email();
}
inline const ::std::string& FastRegisterAccountService_RegisterResponse::email() const {
  // @@protoc_insertion_point(field_get:gate.FastRegisterAccountService.RegisterResponse.email)
  return email_.Get();
}
inline void FastRegisterAccountService_RegisterResponse::set_email(const ::std::string& value) {
  set_has_email();
  email_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:gate.FastRegisterAccountService.RegisterResponse.email)
}
#if LANG_CXX11
inline void FastRegisterAccountService_RegisterResponse::set_email(::std::string&& value) {
  set_has_email();
  email_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:gate.FastRegisterAccountService.RegisterResponse.email)
}
#endif
inline void FastRegisterAccountService_RegisterResponse::set_email(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_email();
  email_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:gate.FastRegisterAccountService.RegisterResponse.email)
}
inline void FastRegisterAccountService_RegisterResponse::set_email(const void* value,
    size_t size) {
  set_has_email();
  email_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:gate.FastRegisterAccountService.RegisterResponse.email)
}
inline ::std::string* FastRegisterAccountService_RegisterResponse::mutable_email() {
  set_has_email();
  // @@protoc_insertion_point(field_mutable:gate.FastRegisterAccountService.RegisterResponse.email)
  return email_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* FastRegisterAccountService_RegisterResponse::release_email() {
  // @@protoc_insertion_point(field_release:gate.FastRegisterAccountService.RegisterResponse.email)
  if (!has_email()) {
    return NULL;
  }
  clear_has_email();
  return email_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void FastRegisterAccountService_RegisterResponse::set_allocated_email(::std::string* email) {
  if (email != NULL) {
    set_has_email();
  } else {
    clear_has_email();
  }
  email_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), email,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:gate.FastRegisterAccountService.RegisterResponse.email)
}
inline ::std::string* FastRegisterAccountService_RegisterResponse::unsafe_arena_release_email() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gate.FastRegisterAccountService.RegisterResponse.email)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_email();
  return email_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void FastRegisterAccountService_RegisterResponse::unsafe_arena_set_allocated_email(
    ::std::string* email) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (email != NULL) {
    set_has_email();
  } else {
    clear_has_email();
  }
  email_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      email, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gate.FastRegisterAccountService.RegisterResponse.email)
}

// optional bytes sponsor_uid = 11;
inline bool FastRegisterAccountService_RegisterResponse::has_sponsor_uid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FastRegisterAccountService_RegisterResponse::set_has_sponsor_uid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FastRegisterAccountService_RegisterResponse::clear_has_sponsor_uid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FastRegisterAccountService_RegisterResponse::clear_sponsor_uid() {
  sponsor_uid_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_sponsor_uid();
}
inline const ::std::string& FastRegisterAccountService_RegisterResponse::sponsor_uid() const {
  // @@protoc_insertion_point(field_get:gate.FastRegisterAccountService.RegisterResponse.sponsor_uid)
  return sponsor_uid_.Get();
}
inline void FastRegisterAccountService_RegisterResponse::set_sponsor_uid(const ::std::string& value) {
  set_has_sponsor_uid();
  sponsor_uid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:gate.FastRegisterAccountService.RegisterResponse.sponsor_uid)
}
#if LANG_CXX11
inline void FastRegisterAccountService_RegisterResponse::set_sponsor_uid(::std::string&& value) {
  set_has_sponsor_uid();
  sponsor_uid_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:gate.FastRegisterAccountService.RegisterResponse.sponsor_uid)
}
#endif
inline void FastRegisterAccountService_RegisterResponse::set_sponsor_uid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sponsor_uid();
  sponsor_uid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:gate.FastRegisterAccountService.RegisterResponse.sponsor_uid)
}
inline void FastRegisterAccountService_RegisterResponse::set_sponsor_uid(const void* value,
    size_t size) {
  set_has_sponsor_uid();
  sponsor_uid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:gate.FastRegisterAccountService.RegisterResponse.sponsor_uid)
}
inline ::std::string* FastRegisterAccountService_RegisterResponse::mutable_sponsor_uid() {
  set_has_sponsor_uid();
  // @@protoc_insertion_point(field_mutable:gate.FastRegisterAccountService.RegisterResponse.sponsor_uid)
  return sponsor_uid_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* FastRegisterAccountService_RegisterResponse::release_sponsor_uid() {
  // @@protoc_insertion_point(field_release:gate.FastRegisterAccountService.RegisterResponse.sponsor_uid)
  if (!has_sponsor_uid()) {
    return NULL;
  }
  clear_has_sponsor_uid();
  return sponsor_uid_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void FastRegisterAccountService_RegisterResponse::set_allocated_sponsor_uid(::std::string* sponsor_uid) {
  if (sponsor_uid != NULL) {
    set_has_sponsor_uid();
  } else {
    clear_has_sponsor_uid();
  }
  sponsor_uid_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sponsor_uid,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:gate.FastRegisterAccountService.RegisterResponse.sponsor_uid)
}
inline ::std::string* FastRegisterAccountService_RegisterResponse::unsafe_arena_release_sponsor_uid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gate.FastRegisterAccountService.RegisterResponse.sponsor_uid)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_sponsor_uid();
  return sponsor_uid_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void FastRegisterAccountService_RegisterResponse::unsafe_arena_set_allocated_sponsor_uid(
    ::std::string* sponsor_uid) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (sponsor_uid != NULL) {
    set_has_sponsor_uid();
  } else {
    clear_has_sponsor_uid();
  }
  sponsor_uid_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      sponsor_uid, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gate.FastRegisterAccountService.RegisterResponse.sponsor_uid)
}

// -------------------------------------------------------------------

// FastRegisterAccountService

// optional .gate.FastRegisterAccountService.RegisterRequest req = 1;
inline bool FastRegisterAccountService::has_req() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FastRegisterAccountService::set_has_req() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FastRegisterAccountService::clear_has_req() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FastRegisterAccountService::clear_req() {
  if (req_ != NULL) req_->Clear();
  clear_has_req();
}
inline const ::gate::FastRegisterAccountService_RegisterRequest& FastRegisterAccountService::_internal_req() const {
  return *req_;
}
inline const ::gate::FastRegisterAccountService_RegisterRequest& FastRegisterAccountService::req() const {
  const ::gate::FastRegisterAccountService_RegisterRequest* p = req_;
  // @@protoc_insertion_point(field_get:gate.FastRegisterAccountService.req)
  return p != NULL ? *p : *reinterpret_cast<const ::gate::FastRegisterAccountService_RegisterRequest*>(
      &::gate::_FastRegisterAccountService_RegisterRequest_default_instance_);
}
inline ::gate::FastRegisterAccountService_RegisterRequest* FastRegisterAccountService::release_req() {
  // @@protoc_insertion_point(field_release:gate.FastRegisterAccountService.req)
  clear_has_req();
  ::gate::FastRegisterAccountService_RegisterRequest* temp = req_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  req_ = NULL;
  return temp;
}
inline ::gate::FastRegisterAccountService_RegisterRequest* FastRegisterAccountService::unsafe_arena_release_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gate.FastRegisterAccountService.req)
  clear_has_req();
  ::gate::FastRegisterAccountService_RegisterRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline ::gate::FastRegisterAccountService_RegisterRequest* FastRegisterAccountService::mutable_req() {
  set_has_req();
  if (req_ == NULL) {
    auto* p = CreateMaybeMessage<::gate::FastRegisterAccountService_RegisterRequest>(GetArenaNoVirtual());
    req_ = p;
  }
  // @@protoc_insertion_point(field_mutable:gate.FastRegisterAccountService.req)
  return req_;
}
inline void FastRegisterAccountService::set_allocated_req(::gate::FastRegisterAccountService_RegisterRequest* req) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete req_;
  }
  if (req) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(req);
    if (message_arena != submessage_arena) {
      req = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, req, submessage_arena);
    }
    set_has_req();
  } else {
    clear_has_req();
  }
  req_ = req;
  // @@protoc_insertion_point(field_set_allocated:gate.FastRegisterAccountService.req)
}

// optional .gate.FastRegisterAccountService.RegisterResponse resp = 2;
inline bool FastRegisterAccountService::has_resp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FastRegisterAccountService::set_has_resp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FastRegisterAccountService::clear_has_resp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FastRegisterAccountService::clear_resp() {
  if (resp_ != NULL) resp_->Clear();
  clear_has_resp();
}
inline const ::gate::FastRegisterAccountService_RegisterResponse& FastRegisterAccountService::_internal_resp() const {
  return *resp_;
}
inline const ::gate::FastRegisterAccountService_RegisterResponse& FastRegisterAccountService::resp() const {
  const ::gate::FastRegisterAccountService_RegisterResponse* p = resp_;
  // @@protoc_insertion_point(field_get:gate.FastRegisterAccountService.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::gate::FastRegisterAccountService_RegisterResponse*>(
      &::gate::_FastRegisterAccountService_RegisterResponse_default_instance_);
}
inline ::gate::FastRegisterAccountService_RegisterResponse* FastRegisterAccountService::release_resp() {
  // @@protoc_insertion_point(field_release:gate.FastRegisterAccountService.resp)
  clear_has_resp();
  ::gate::FastRegisterAccountService_RegisterResponse* temp = resp_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  resp_ = NULL;
  return temp;
}
inline ::gate::FastRegisterAccountService_RegisterResponse* FastRegisterAccountService::unsafe_arena_release_resp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gate.FastRegisterAccountService.resp)
  clear_has_resp();
  ::gate::FastRegisterAccountService_RegisterResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline ::gate::FastRegisterAccountService_RegisterResponse* FastRegisterAccountService::mutable_resp() {
  set_has_resp();
  if (resp_ == NULL) {
    auto* p = CreateMaybeMessage<::gate::FastRegisterAccountService_RegisterResponse>(GetArenaNoVirtual());
    resp_ = p;
  }
  // @@protoc_insertion_point(field_mutable:gate.FastRegisterAccountService.resp)
  return resp_;
}
inline void FastRegisterAccountService::set_allocated_resp(::gate::FastRegisterAccountService_RegisterResponse* resp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete resp_;
  }
  if (resp) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(resp);
    if (message_arena != submessage_arena) {
      resp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, resp, submessage_arena);
    }
    set_has_resp();
  } else {
    clear_has_resp();
  }
  resp_ = resp;
  // @@protoc_insertion_point(field_set_allocated:gate.FastRegisterAccountService.resp)
}

// -------------------------------------------------------------------

// AccountLoginService_LoginRequest

// required bytes uid = 1;
inline bool AccountLoginService_LoginRequest::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccountLoginService_LoginRequest::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccountLoginService_LoginRequest::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccountLoginService_LoginRequest::clear_uid() {
  uid_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_uid();
}
inline const ::std::string& AccountLoginService_LoginRequest::uid() const {
  // @@protoc_insertion_point(field_get:gate.AccountLoginService.LoginRequest.uid)
  return uid_.Get();
}
inline void AccountLoginService_LoginRequest::set_uid(const ::std::string& value) {
  set_has_uid();
  uid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:gate.AccountLoginService.LoginRequest.uid)
}
#if LANG_CXX11
inline void AccountLoginService_LoginRequest::set_uid(::std::string&& value) {
  set_has_uid();
  uid_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:gate.AccountLoginService.LoginRequest.uid)
}
#endif
inline void AccountLoginService_LoginRequest::set_uid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_uid();
  uid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:gate.AccountLoginService.LoginRequest.uid)
}
inline void AccountLoginService_LoginRequest::set_uid(const void* value,
    size_t size) {
  set_has_uid();
  uid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:gate.AccountLoginService.LoginRequest.uid)
}
inline ::std::string* AccountLoginService_LoginRequest::mutable_uid() {
  set_has_uid();
  // @@protoc_insertion_point(field_mutable:gate.AccountLoginService.LoginRequest.uid)
  return uid_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* AccountLoginService_LoginRequest::release_uid() {
  // @@protoc_insertion_point(field_release:gate.AccountLoginService.LoginRequest.uid)
  if (!has_uid()) {
    return NULL;
  }
  clear_has_uid();
  return uid_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void AccountLoginService_LoginRequest::set_allocated_uid(::std::string* uid) {
  if (uid != NULL) {
    set_has_uid();
  } else {
    clear_has_uid();
  }
  uid_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uid,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:gate.AccountLoginService.LoginRequest.uid)
}
inline ::std::string* AccountLoginService_LoginRequest::unsafe_arena_release_uid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gate.AccountLoginService.LoginRequest.uid)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_uid();
  return uid_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void AccountLoginService_LoginRequest::unsafe_arena_set_allocated_uid(
    ::std::string* uid) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (uid != NULL) {
    set_has_uid();
  } else {
    clear_has_uid();
  }
  uid_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      uid, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gate.AccountLoginService.LoginRequest.uid)
}

// required bytes pwd = 2;
inline bool AccountLoginService_LoginRequest::has_pwd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccountLoginService_LoginRequest::set_has_pwd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccountLoginService_LoginRequest::clear_has_pwd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccountLoginService_LoginRequest::clear_pwd() {
  pwd_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_pwd();
}
inline const ::std::string& AccountLoginService_LoginRequest::pwd() const {
  // @@protoc_insertion_point(field_get:gate.AccountLoginService.LoginRequest.pwd)
  return pwd_.Get();
}
inline void AccountLoginService_LoginRequest::set_pwd(const ::std::string& value) {
  set_has_pwd();
  pwd_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:gate.AccountLoginService.LoginRequest.pwd)
}
#if LANG_CXX11
inline void AccountLoginService_LoginRequest::set_pwd(::std::string&& value) {
  set_has_pwd();
  pwd_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:gate.AccountLoginService.LoginRequest.pwd)
}
#endif
inline void AccountLoginService_LoginRequest::set_pwd(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pwd();
  pwd_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:gate.AccountLoginService.LoginRequest.pwd)
}
inline void AccountLoginService_LoginRequest::set_pwd(const void* value,
    size_t size) {
  set_has_pwd();
  pwd_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:gate.AccountLoginService.LoginRequest.pwd)
}
inline ::std::string* AccountLoginService_LoginRequest::mutable_pwd() {
  set_has_pwd();
  // @@protoc_insertion_point(field_mutable:gate.AccountLoginService.LoginRequest.pwd)
  return pwd_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* AccountLoginService_LoginRequest::release_pwd() {
  // @@protoc_insertion_point(field_release:gate.AccountLoginService.LoginRequest.pwd)
  if (!has_pwd()) {
    return NULL;
  }
  clear_has_pwd();
  return pwd_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void AccountLoginService_LoginRequest::set_allocated_pwd(::std::string* pwd) {
  if (pwd != NULL) {
    set_has_pwd();
  } else {
    clear_has_pwd();
  }
  pwd_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pwd,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:gate.AccountLoginService.LoginRequest.pwd)
}
inline ::std::string* AccountLoginService_LoginRequest::unsafe_arena_release_pwd() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gate.AccountLoginService.LoginRequest.pwd)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_pwd();
  return pwd_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void AccountLoginService_LoginRequest::unsafe_arena_set_allocated_pwd(
    ::std::string* pwd) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (pwd != NULL) {
    set_has_pwd();
  } else {
    clear_has_pwd();
  }
  pwd_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      pwd, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gate.AccountLoginService.LoginRequest.pwd)
}

// optional int32 ws_entryid = 11;
inline bool AccountLoginService_LoginRequest::has_ws_entryid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AccountLoginService_LoginRequest::set_has_ws_entryid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AccountLoginService_LoginRequest::clear_has_ws_entryid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AccountLoginService_LoginRequest::clear_ws_entryid() {
  ws_entryid_ = 0;
  clear_has_ws_entryid();
}
inline ::google::protobuf::int32 AccountLoginService_LoginRequest::ws_entryid() const {
  // @@protoc_insertion_point(field_get:gate.AccountLoginService.LoginRequest.ws_entryid)
  return ws_entryid_;
}
inline void AccountLoginService_LoginRequest::set_ws_entryid(::google::protobuf::int32 value) {
  set_has_ws_entryid();
  ws_entryid_ = value;
  // @@protoc_insertion_point(field_set:gate.AccountLoginService.LoginRequest.ws_entryid)
}

// optional bytes channel_platid = 12;
inline bool AccountLoginService_LoginRequest::has_channel_platid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AccountLoginService_LoginRequest::set_has_channel_platid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AccountLoginService_LoginRequest::clear_has_channel_platid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AccountLoginService_LoginRequest::clear_channel_platid() {
  channel_platid_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_channel_platid();
}
inline const ::std::string& AccountLoginService_LoginRequest::channel_platid() const {
  // @@protoc_insertion_point(field_get:gate.AccountLoginService.LoginRequest.channel_platid)
  return channel_platid_.Get();
}
inline void AccountLoginService_LoginRequest::set_channel_platid(const ::std::string& value) {
  set_has_channel_platid();
  channel_platid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:gate.AccountLoginService.LoginRequest.channel_platid)
}
#if LANG_CXX11
inline void AccountLoginService_LoginRequest::set_channel_platid(::std::string&& value) {
  set_has_channel_platid();
  channel_platid_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:gate.AccountLoginService.LoginRequest.channel_platid)
}
#endif
inline void AccountLoginService_LoginRequest::set_channel_platid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_channel_platid();
  channel_platid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:gate.AccountLoginService.LoginRequest.channel_platid)
}
inline void AccountLoginService_LoginRequest::set_channel_platid(const void* value,
    size_t size) {
  set_has_channel_platid();
  channel_platid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:gate.AccountLoginService.LoginRequest.channel_platid)
}
inline ::std::string* AccountLoginService_LoginRequest::mutable_channel_platid() {
  set_has_channel_platid();
  // @@protoc_insertion_point(field_mutable:gate.AccountLoginService.LoginRequest.channel_platid)
  return channel_platid_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* AccountLoginService_LoginRequest::release_channel_platid() {
  // @@protoc_insertion_point(field_release:gate.AccountLoginService.LoginRequest.channel_platid)
  if (!has_channel_platid()) {
    return NULL;
  }
  clear_has_channel_platid();
  return channel_platid_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void AccountLoginService_LoginRequest::set_allocated_channel_platid(::std::string* channel_platid) {
  if (channel_platid != NULL) {
    set_has_channel_platid();
  } else {
    clear_has_channel_platid();
  }
  channel_platid_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), channel_platid,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:gate.AccountLoginService.LoginRequest.channel_platid)
}
inline ::std::string* AccountLoginService_LoginRequest::unsafe_arena_release_channel_platid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gate.AccountLoginService.LoginRequest.channel_platid)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_channel_platid();
  return channel_platid_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void AccountLoginService_LoginRequest::unsafe_arena_set_allocated_channel_platid(
    ::std::string* channel_platid) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (channel_platid != NULL) {
    set_has_channel_platid();
  } else {
    clear_has_channel_platid();
  }
  channel_platid_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      channel_platid, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gate.AccountLoginService.LoginRequest.channel_platid)
}

// optional bytes channel_gameid = 13;
inline bool AccountLoginService_LoginRequest::has_channel_gameid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AccountLoginService_LoginRequest::set_has_channel_gameid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AccountLoginService_LoginRequest::clear_has_channel_gameid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AccountLoginService_LoginRequest::clear_channel_gameid() {
  channel_gameid_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_channel_gameid();
}
inline const ::std::string& AccountLoginService_LoginRequest::channel_gameid() const {
  // @@protoc_insertion_point(field_get:gate.AccountLoginService.LoginRequest.channel_gameid)
  return channel_gameid_.Get();
}
inline void AccountLoginService_LoginRequest::set_channel_gameid(const ::std::string& value) {
  set_has_channel_gameid();
  channel_gameid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:gate.AccountLoginService.LoginRequest.channel_gameid)
}
#if LANG_CXX11
inline void AccountLoginService_LoginRequest::set_channel_gameid(::std::string&& value) {
  set_has_channel_gameid();
  channel_gameid_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:gate.AccountLoginService.LoginRequest.channel_gameid)
}
#endif
inline void AccountLoginService_LoginRequest::set_channel_gameid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_channel_gameid();
  channel_gameid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:gate.AccountLoginService.LoginRequest.channel_gameid)
}
inline void AccountLoginService_LoginRequest::set_channel_gameid(const void* value,
    size_t size) {
  set_has_channel_gameid();
  channel_gameid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:gate.AccountLoginService.LoginRequest.channel_gameid)
}
inline ::std::string* AccountLoginService_LoginRequest::mutable_channel_gameid() {
  set_has_channel_gameid();
  // @@protoc_insertion_point(field_mutable:gate.AccountLoginService.LoginRequest.channel_gameid)
  return channel_gameid_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* AccountLoginService_LoginRequest::release_channel_gameid() {
  // @@protoc_insertion_point(field_release:gate.AccountLoginService.LoginRequest.channel_gameid)
  if (!has_channel_gameid()) {
    return NULL;
  }
  clear_has_channel_gameid();
  return channel_gameid_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void AccountLoginService_LoginRequest::set_allocated_channel_gameid(::std::string* channel_gameid) {
  if (channel_gameid != NULL) {
    set_has_channel_gameid();
  } else {
    clear_has_channel_gameid();
  }
  channel_gameid_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), channel_gameid,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:gate.AccountLoginService.LoginRequest.channel_gameid)
}
inline ::std::string* AccountLoginService_LoginRequest::unsafe_arena_release_channel_gameid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gate.AccountLoginService.LoginRequest.channel_gameid)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_channel_gameid();
  return channel_gameid_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void AccountLoginService_LoginRequest::unsafe_arena_set_allocated_channel_gameid(
    ::std::string* channel_gameid) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (channel_gameid != NULL) {
    set_has_channel_gameid();
  } else {
    clear_has_channel_gameid();
  }
  channel_gameid_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      channel_gameid, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gate.AccountLoginService.LoginRequest.channel_gameid)
}

// -------------------------------------------------------------------

// AccountLoginService_LoginResponse

// required .gate.AccountLoginService.RESULT result = 1;
inline bool AccountLoginService_LoginResponse::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccountLoginService_LoginResponse::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccountLoginService_LoginResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccountLoginService_LoginResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::gate::AccountLoginService_RESULT AccountLoginService_LoginResponse::result() const {
  // @@protoc_insertion_point(field_get:gate.AccountLoginService.LoginResponse.result)
  return static_cast< ::gate::AccountLoginService_RESULT >(result_);
}
inline void AccountLoginService_LoginResponse::set_result(::gate::AccountLoginService_RESULT value) {
  assert(::gate::AccountLoginService_RESULT_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:gate.AccountLoginService.LoginResponse.result)
}

// optional uint64 uuid = 2;
inline bool AccountLoginService_LoginResponse::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccountLoginService_LoginResponse::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccountLoginService_LoginResponse::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccountLoginService_LoginResponse::clear_uuid() {
  uuid_ = GOOGLE_ULONGLONG(0);
  clear_has_uuid();
}
inline ::google::protobuf::uint64 AccountLoginService_LoginResponse::uuid() const {
  // @@protoc_insertion_point(field_get:gate.AccountLoginService.LoginResponse.uuid)
  return uuid_;
}
inline void AccountLoginService_LoginResponse::set_uuid(::google::protobuf::uint64 value) {
  set_has_uuid();
  uuid_ = value;
  // @@protoc_insertion_point(field_set:gate.AccountLoginService.LoginResponse.uuid)
}

// -------------------------------------------------------------------

// AccountLoginService

// optional .gate.AccountLoginService.LoginRequest req = 1;
inline bool AccountLoginService::has_req() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccountLoginService::set_has_req() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccountLoginService::clear_has_req() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccountLoginService::clear_req() {
  if (req_ != NULL) req_->Clear();
  clear_has_req();
}
inline const ::gate::AccountLoginService_LoginRequest& AccountLoginService::_internal_req() const {
  return *req_;
}
inline const ::gate::AccountLoginService_LoginRequest& AccountLoginService::req() const {
  const ::gate::AccountLoginService_LoginRequest* p = req_;
  // @@protoc_insertion_point(field_get:gate.AccountLoginService.req)
  return p != NULL ? *p : *reinterpret_cast<const ::gate::AccountLoginService_LoginRequest*>(
      &::gate::_AccountLoginService_LoginRequest_default_instance_);
}
inline ::gate::AccountLoginService_LoginRequest* AccountLoginService::release_req() {
  // @@protoc_insertion_point(field_release:gate.AccountLoginService.req)
  clear_has_req();
  ::gate::AccountLoginService_LoginRequest* temp = req_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  req_ = NULL;
  return temp;
}
inline ::gate::AccountLoginService_LoginRequest* AccountLoginService::unsafe_arena_release_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gate.AccountLoginService.req)
  clear_has_req();
  ::gate::AccountLoginService_LoginRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline ::gate::AccountLoginService_LoginRequest* AccountLoginService::mutable_req() {
  set_has_req();
  if (req_ == NULL) {
    auto* p = CreateMaybeMessage<::gate::AccountLoginService_LoginRequest>(GetArenaNoVirtual());
    req_ = p;
  }
  // @@protoc_insertion_point(field_mutable:gate.AccountLoginService.req)
  return req_;
}
inline void AccountLoginService::set_allocated_req(::gate::AccountLoginService_LoginRequest* req) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete req_;
  }
  if (req) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(req);
    if (message_arena != submessage_arena) {
      req = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, req, submessage_arena);
    }
    set_has_req();
  } else {
    clear_has_req();
  }
  req_ = req;
  // @@protoc_insertion_point(field_set_allocated:gate.AccountLoginService.req)
}

// optional .gate.AccountLoginService.LoginResponse resp = 2;
inline bool AccountLoginService::has_resp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccountLoginService::set_has_resp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccountLoginService::clear_has_resp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccountLoginService::clear_resp() {
  if (resp_ != NULL) resp_->Clear();
  clear_has_resp();
}
inline const ::gate::AccountLoginService_LoginResponse& AccountLoginService::_internal_resp() const {
  return *resp_;
}
inline const ::gate::AccountLoginService_LoginResponse& AccountLoginService::resp() const {
  const ::gate::AccountLoginService_LoginResponse* p = resp_;
  // @@protoc_insertion_point(field_get:gate.AccountLoginService.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::gate::AccountLoginService_LoginResponse*>(
      &::gate::_AccountLoginService_LoginResponse_default_instance_);
}
inline ::gate::AccountLoginService_LoginResponse* AccountLoginService::release_resp() {
  // @@protoc_insertion_point(field_release:gate.AccountLoginService.resp)
  clear_has_resp();
  ::gate::AccountLoginService_LoginResponse* temp = resp_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  resp_ = NULL;
  return temp;
}
inline ::gate::AccountLoginService_LoginResponse* AccountLoginService::unsafe_arena_release_resp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gate.AccountLoginService.resp)
  clear_has_resp();
  ::gate::AccountLoginService_LoginResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline ::gate::AccountLoginService_LoginResponse* AccountLoginService::mutable_resp() {
  set_has_resp();
  if (resp_ == NULL) {
    auto* p = CreateMaybeMessage<::gate::AccountLoginService_LoginResponse>(GetArenaNoVirtual());
    resp_ = p;
  }
  // @@protoc_insertion_point(field_mutable:gate.AccountLoginService.resp)
  return resp_;
}
inline void AccountLoginService::set_allocated_resp(::gate::AccountLoginService_LoginResponse* resp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete resp_;
  }
  if (resp) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(resp);
    if (message_arena != submessage_arena) {
      resp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, resp, submessage_arena);
    }
    set_has_resp();
  } else {
    clear_has_resp();
  }
  resp_ = resp;
  // @@protoc_insertion_point(field_set_allocated:gate.AccountLoginService.resp)
}

// -------------------------------------------------------------------

// AccountReloginService_ReloginRequest

// required bytes uid = 1;
inline bool AccountReloginService_ReloginRequest::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccountReloginService_ReloginRequest::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccountReloginService_ReloginRequest::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccountReloginService_ReloginRequest::clear_uid() {
  uid_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_uid();
}
inline const ::std::string& AccountReloginService_ReloginRequest::uid() const {
  // @@protoc_insertion_point(field_get:gate.AccountReloginService.ReloginRequest.uid)
  return uid_.Get();
}
inline void AccountReloginService_ReloginRequest::set_uid(const ::std::string& value) {
  set_has_uid();
  uid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:gate.AccountReloginService.ReloginRequest.uid)
}
#if LANG_CXX11
inline void AccountReloginService_ReloginRequest::set_uid(::std::string&& value) {
  set_has_uid();
  uid_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:gate.AccountReloginService.ReloginRequest.uid)
}
#endif
inline void AccountReloginService_ReloginRequest::set_uid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_uid();
  uid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:gate.AccountReloginService.ReloginRequest.uid)
}
inline void AccountReloginService_ReloginRequest::set_uid(const void* value,
    size_t size) {
  set_has_uid();
  uid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:gate.AccountReloginService.ReloginRequest.uid)
}
inline ::std::string* AccountReloginService_ReloginRequest::mutable_uid() {
  set_has_uid();
  // @@protoc_insertion_point(field_mutable:gate.AccountReloginService.ReloginRequest.uid)
  return uid_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* AccountReloginService_ReloginRequest::release_uid() {
  // @@protoc_insertion_point(field_release:gate.AccountReloginService.ReloginRequest.uid)
  if (!has_uid()) {
    return NULL;
  }
  clear_has_uid();
  return uid_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void AccountReloginService_ReloginRequest::set_allocated_uid(::std::string* uid) {
  if (uid != NULL) {
    set_has_uid();
  } else {
    clear_has_uid();
  }
  uid_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uid,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:gate.AccountReloginService.ReloginRequest.uid)
}
inline ::std::string* AccountReloginService_ReloginRequest::unsafe_arena_release_uid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gate.AccountReloginService.ReloginRequest.uid)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_uid();
  return uid_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void AccountReloginService_ReloginRequest::unsafe_arena_set_allocated_uid(
    ::std::string* uid) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (uid != NULL) {
    set_has_uid();
  } else {
    clear_has_uid();
  }
  uid_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      uid, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gate.AccountReloginService.ReloginRequest.uid)
}

// required bytes pwd = 2;
inline bool AccountReloginService_ReloginRequest::has_pwd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccountReloginService_ReloginRequest::set_has_pwd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccountReloginService_ReloginRequest::clear_has_pwd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccountReloginService_ReloginRequest::clear_pwd() {
  pwd_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_pwd();
}
inline const ::std::string& AccountReloginService_ReloginRequest::pwd() const {
  // @@protoc_insertion_point(field_get:gate.AccountReloginService.ReloginRequest.pwd)
  return pwd_.Get();
}
inline void AccountReloginService_ReloginRequest::set_pwd(const ::std::string& value) {
  set_has_pwd();
  pwd_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:gate.AccountReloginService.ReloginRequest.pwd)
}
#if LANG_CXX11
inline void AccountReloginService_ReloginRequest::set_pwd(::std::string&& value) {
  set_has_pwd();
  pwd_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:gate.AccountReloginService.ReloginRequest.pwd)
}
#endif
inline void AccountReloginService_ReloginRequest::set_pwd(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pwd();
  pwd_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:gate.AccountReloginService.ReloginRequest.pwd)
}
inline void AccountReloginService_ReloginRequest::set_pwd(const void* value,
    size_t size) {
  set_has_pwd();
  pwd_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:gate.AccountReloginService.ReloginRequest.pwd)
}
inline ::std::string* AccountReloginService_ReloginRequest::mutable_pwd() {
  set_has_pwd();
  // @@protoc_insertion_point(field_mutable:gate.AccountReloginService.ReloginRequest.pwd)
  return pwd_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* AccountReloginService_ReloginRequest::release_pwd() {
  // @@protoc_insertion_point(field_release:gate.AccountReloginService.ReloginRequest.pwd)
  if (!has_pwd()) {
    return NULL;
  }
  clear_has_pwd();
  return pwd_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void AccountReloginService_ReloginRequest::set_allocated_pwd(::std::string* pwd) {
  if (pwd != NULL) {
    set_has_pwd();
  } else {
    clear_has_pwd();
  }
  pwd_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pwd,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:gate.AccountReloginService.ReloginRequest.pwd)
}
inline ::std::string* AccountReloginService_ReloginRequest::unsafe_arena_release_pwd() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gate.AccountReloginService.ReloginRequest.pwd)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_pwd();
  return pwd_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void AccountReloginService_ReloginRequest::unsafe_arena_set_allocated_pwd(
    ::std::string* pwd) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (pwd != NULL) {
    set_has_pwd();
  } else {
    clear_has_pwd();
  }
  pwd_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      pwd, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gate.AccountReloginService.ReloginRequest.pwd)
}

// -------------------------------------------------------------------

// AccountReloginService_ReloginResponse

// required .gate.AccountReloginService.RESULT result = 1;
inline bool AccountReloginService_ReloginResponse::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccountReloginService_ReloginResponse::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccountReloginService_ReloginResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccountReloginService_ReloginResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::gate::AccountReloginService_RESULT AccountReloginService_ReloginResponse::result() const {
  // @@protoc_insertion_point(field_get:gate.AccountReloginService.ReloginResponse.result)
  return static_cast< ::gate::AccountReloginService_RESULT >(result_);
}
inline void AccountReloginService_ReloginResponse::set_result(::gate::AccountReloginService_RESULT value) {
  assert(::gate::AccountReloginService_RESULT_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:gate.AccountReloginService.ReloginResponse.result)
}

// optional uint64 uuid = 2;
inline bool AccountReloginService_ReloginResponse::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccountReloginService_ReloginResponse::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccountReloginService_ReloginResponse::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccountReloginService_ReloginResponse::clear_uuid() {
  uuid_ = GOOGLE_ULONGLONG(0);
  clear_has_uuid();
}
inline ::google::protobuf::uint64 AccountReloginService_ReloginResponse::uuid() const {
  // @@protoc_insertion_point(field_get:gate.AccountReloginService.ReloginResponse.uuid)
  return uuid_;
}
inline void AccountReloginService_ReloginResponse::set_uuid(::google::protobuf::uint64 value) {
  set_has_uuid();
  uuid_ = value;
  // @@protoc_insertion_point(field_set:gate.AccountReloginService.ReloginResponse.uuid)
}

// -------------------------------------------------------------------

// AccountReloginService

// optional .gate.AccountReloginService.ReloginRequest req = 1;
inline bool AccountReloginService::has_req() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccountReloginService::set_has_req() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccountReloginService::clear_has_req() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccountReloginService::clear_req() {
  if (req_ != NULL) req_->Clear();
  clear_has_req();
}
inline const ::gate::AccountReloginService_ReloginRequest& AccountReloginService::_internal_req() const {
  return *req_;
}
inline const ::gate::AccountReloginService_ReloginRequest& AccountReloginService::req() const {
  const ::gate::AccountReloginService_ReloginRequest* p = req_;
  // @@protoc_insertion_point(field_get:gate.AccountReloginService.req)
  return p != NULL ? *p : *reinterpret_cast<const ::gate::AccountReloginService_ReloginRequest*>(
      &::gate::_AccountReloginService_ReloginRequest_default_instance_);
}
inline ::gate::AccountReloginService_ReloginRequest* AccountReloginService::release_req() {
  // @@protoc_insertion_point(field_release:gate.AccountReloginService.req)
  clear_has_req();
  ::gate::AccountReloginService_ReloginRequest* temp = req_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  req_ = NULL;
  return temp;
}
inline ::gate::AccountReloginService_ReloginRequest* AccountReloginService::unsafe_arena_release_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gate.AccountReloginService.req)
  clear_has_req();
  ::gate::AccountReloginService_ReloginRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline ::gate::AccountReloginService_ReloginRequest* AccountReloginService::mutable_req() {
  set_has_req();
  if (req_ == NULL) {
    auto* p = CreateMaybeMessage<::gate::AccountReloginService_ReloginRequest>(GetArenaNoVirtual());
    req_ = p;
  }
  // @@protoc_insertion_point(field_mutable:gate.AccountReloginService.req)
  return req_;
}
inline void AccountReloginService::set_allocated_req(::gate::AccountReloginService_ReloginRequest* req) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete req_;
  }
  if (req) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(req);
    if (message_arena != submessage_arena) {
      req = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, req, submessage_arena);
    }
    set_has_req();
  } else {
    clear_has_req();
  }
  req_ = req;
  // @@protoc_insertion_point(field_set_allocated:gate.AccountReloginService.req)
}

// optional .gate.AccountReloginService.ReloginResponse resp = 2;
inline bool AccountReloginService::has_resp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccountReloginService::set_has_resp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccountReloginService::clear_has_resp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccountReloginService::clear_resp() {
  if (resp_ != NULL) resp_->Clear();
  clear_has_resp();
}
inline const ::gate::AccountReloginService_ReloginResponse& AccountReloginService::_internal_resp() const {
  return *resp_;
}
inline const ::gate::AccountReloginService_ReloginResponse& AccountReloginService::resp() const {
  const ::gate::AccountReloginService_ReloginResponse* p = resp_;
  // @@protoc_insertion_point(field_get:gate.AccountReloginService.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::gate::AccountReloginService_ReloginResponse*>(
      &::gate::_AccountReloginService_ReloginResponse_default_instance_);
}
inline ::gate::AccountReloginService_ReloginResponse* AccountReloginService::release_resp() {
  // @@protoc_insertion_point(field_release:gate.AccountReloginService.resp)
  clear_has_resp();
  ::gate::AccountReloginService_ReloginResponse* temp = resp_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  resp_ = NULL;
  return temp;
}
inline ::gate::AccountReloginService_ReloginResponse* AccountReloginService::unsafe_arena_release_resp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gate.AccountReloginService.resp)
  clear_has_resp();
  ::gate::AccountReloginService_ReloginResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline ::gate::AccountReloginService_ReloginResponse* AccountReloginService::mutable_resp() {
  set_has_resp();
  if (resp_ == NULL) {
    auto* p = CreateMaybeMessage<::gate::AccountReloginService_ReloginResponse>(GetArenaNoVirtual());
    resp_ = p;
  }
  // @@protoc_insertion_point(field_mutable:gate.AccountReloginService.resp)
  return resp_;
}
inline void AccountReloginService::set_allocated_resp(::gate::AccountReloginService_ReloginResponse* resp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete resp_;
  }
  if (resp) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(resp);
    if (message_arena != submessage_arena) {
      resp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, resp, submessage_arena);
    }
    set_has_resp();
  } else {
    clear_has_resp();
  }
  resp_ = resp;
  // @@protoc_insertion_point(field_set_allocated:gate.AccountReloginService.resp)
}

// -------------------------------------------------------------------

// GameServer

// required int32 id = 1;
inline bool GameServer::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameServer::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameServer::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameServer::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 GameServer::id() const {
  // @@protoc_insertion_point(field_get:gate.GameServer.id)
  return id_;
}
inline void GameServer::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:gate.GameServer.id)
}

// required bytes name = 2;
inline bool GameServer::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameServer::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameServer::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameServer::clear_name() {
  name_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_name();
}
inline const ::std::string& GameServer::name() const {
  // @@protoc_insertion_point(field_get:gate.GameServer.name)
  return name_.Get();
}
inline void GameServer::set_name(const ::std::string& value) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:gate.GameServer.name)
}
#if LANG_CXX11
inline void GameServer::set_name(::std::string&& value) {
  set_has_name();
  name_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:gate.GameServer.name)
}
#endif
inline void GameServer::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:gate.GameServer.name)
}
inline void GameServer::set_name(const void* value,
    size_t size) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:gate.GameServer.name)
}
inline ::std::string* GameServer::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:gate.GameServer.name)
  return name_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* GameServer::release_name() {
  // @@protoc_insertion_point(field_release:gate.GameServer.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void GameServer::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:gate.GameServer.name)
}
inline ::std::string* GameServer::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gate.GameServer.name)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_name();
  return name_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void GameServer::unsafe_arena_set_allocated_name(
    ::std::string* name) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      name, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gate.GameServer.name)
}

// -------------------------------------------------------------------

// GameServerList

// repeated .gate.GameServer list = 1;
inline int GameServerList::list_size() const {
  return list_.size();
}
inline void GameServerList::clear_list() {
  list_.Clear();
}
inline ::gate::GameServer* GameServerList::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:gate.GameServerList.list)
  return list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::gate::GameServer >*
GameServerList::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:gate.GameServerList.list)
  return &list_;
}
inline const ::gate::GameServer& GameServerList::list(int index) const {
  // @@protoc_insertion_point(field_get:gate.GameServerList.list)
  return list_.Get(index);
}
inline ::gate::GameServer* GameServerList::add_list() {
  // @@protoc_insertion_point(field_add:gate.GameServerList.list)
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::gate::GameServer >&
GameServerList::list() const {
  // @@protoc_insertion_point(field_list:gate.GameServerList.list)
  return list_;
}

// -------------------------------------------------------------------

// GameServerService_GameServerRequest

// required .gate.GameServerService.GAME_SERVER_COMMAND cmd = 1;
inline bool GameServerService_GameServerRequest::has_cmd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameServerService_GameServerRequest::set_has_cmd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameServerService_GameServerRequest::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameServerService_GameServerRequest::clear_cmd() {
  cmd_ = 1;
  clear_has_cmd();
}
inline ::gate::GameServerService_GAME_SERVER_COMMAND GameServerService_GameServerRequest::cmd() const {
  // @@protoc_insertion_point(field_get:gate.GameServerService.GameServerRequest.cmd)
  return static_cast< ::gate::GameServerService_GAME_SERVER_COMMAND >(cmd_);
}
inline void GameServerService_GameServerRequest::set_cmd(::gate::GameServerService_GAME_SERVER_COMMAND value) {
  assert(::gate::GameServerService_GAME_SERVER_COMMAND_IsValid(value));
  set_has_cmd();
  cmd_ = value;
  // @@protoc_insertion_point(field_set:gate.GameServerService.GameServerRequest.cmd)
}

// optional int32 serverid = 2;
inline bool GameServerService_GameServerRequest::has_serverid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameServerService_GameServerRequest::set_has_serverid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameServerService_GameServerRequest::clear_has_serverid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameServerService_GameServerRequest::clear_serverid() {
  serverid_ = 0;
  clear_has_serverid();
}
inline ::google::protobuf::int32 GameServerService_GameServerRequest::serverid() const {
  // @@protoc_insertion_point(field_get:gate.GameServerService.GameServerRequest.serverid)
  return serverid_;
}
inline void GameServerService_GameServerRequest::set_serverid(::google::protobuf::int32 value) {
  set_has_serverid();
  serverid_ = value;
  // @@protoc_insertion_point(field_set:gate.GameServerService.GameServerRequest.serverid)
}

// -------------------------------------------------------------------

// GameServerService_GameServerResponse

// required int32 result = 1;
inline bool GameServerService_GameServerResponse::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameServerService_GameServerResponse::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameServerService_GameServerResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameServerService_GameServerResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 GameServerService_GameServerResponse::result() const {
  // @@protoc_insertion_point(field_get:gate.GameServerService.GameServerResponse.result)
  return result_;
}
inline void GameServerService_GameServerResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:gate.GameServerService.GameServerResponse.result)
}

// optional .gate.GameServerList server_list = 2;
inline bool GameServerService_GameServerResponse::has_server_list() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameServerService_GameServerResponse::set_has_server_list() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameServerService_GameServerResponse::clear_has_server_list() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameServerService_GameServerResponse::clear_server_list() {
  if (server_list_ != NULL) server_list_->Clear();
  clear_has_server_list();
}
inline const ::gate::GameServerList& GameServerService_GameServerResponse::_internal_server_list() const {
  return *server_list_;
}
inline const ::gate::GameServerList& GameServerService_GameServerResponse::server_list() const {
  const ::gate::GameServerList* p = server_list_;
  // @@protoc_insertion_point(field_get:gate.GameServerService.GameServerResponse.server_list)
  return p != NULL ? *p : *reinterpret_cast<const ::gate::GameServerList*>(
      &::gate::_GameServerList_default_instance_);
}
inline ::gate::GameServerList* GameServerService_GameServerResponse::release_server_list() {
  // @@protoc_insertion_point(field_release:gate.GameServerService.GameServerResponse.server_list)
  clear_has_server_list();
  ::gate::GameServerList* temp = server_list_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  server_list_ = NULL;
  return temp;
}
inline ::gate::GameServerList* GameServerService_GameServerResponse::unsafe_arena_release_server_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gate.GameServerService.GameServerResponse.server_list)
  clear_has_server_list();
  ::gate::GameServerList* temp = server_list_;
  server_list_ = NULL;
  return temp;
}
inline ::gate::GameServerList* GameServerService_GameServerResponse::mutable_server_list() {
  set_has_server_list();
  if (server_list_ == NULL) {
    auto* p = CreateMaybeMessage<::gate::GameServerList>(GetArenaNoVirtual());
    server_list_ = p;
  }
  // @@protoc_insertion_point(field_mutable:gate.GameServerService.GameServerResponse.server_list)
  return server_list_;
}
inline void GameServerService_GameServerResponse::set_allocated_server_list(::gate::GameServerList* server_list) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete server_list_;
  }
  if (server_list) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(server_list);
    if (message_arena != submessage_arena) {
      server_list = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, server_list, submessage_arena);
    }
    set_has_server_list();
  } else {
    clear_has_server_list();
  }
  server_list_ = server_list;
  // @@protoc_insertion_point(field_set_allocated:gate.GameServerService.GameServerResponse.server_list)
}

// optional int32 last_serverid = 3;
inline bool GameServerService_GameServerResponse::has_last_serverid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameServerService_GameServerResponse::set_has_last_serverid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameServerService_GameServerResponse::clear_has_last_serverid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameServerService_GameServerResponse::clear_last_serverid() {
  last_serverid_ = 0;
  clear_has_last_serverid();
}
inline ::google::protobuf::int32 GameServerService_GameServerResponse::last_serverid() const {
  // @@protoc_insertion_point(field_get:gate.GameServerService.GameServerResponse.last_serverid)
  return last_serverid_;
}
inline void GameServerService_GameServerResponse::set_last_serverid(::google::protobuf::int32 value) {
  set_has_last_serverid();
  last_serverid_ = value;
  // @@protoc_insertion_point(field_set:gate.GameServerService.GameServerResponse.last_serverid)
}

// -------------------------------------------------------------------

// GameServerService

// optional .gate.GameServerService.GameServerRequest req = 1;
inline bool GameServerService::has_req() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameServerService::set_has_req() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameServerService::clear_has_req() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameServerService::clear_req() {
  if (req_ != NULL) req_->Clear();
  clear_has_req();
}
inline const ::gate::GameServerService_GameServerRequest& GameServerService::_internal_req() const {
  return *req_;
}
inline const ::gate::GameServerService_GameServerRequest& GameServerService::req() const {
  const ::gate::GameServerService_GameServerRequest* p = req_;
  // @@protoc_insertion_point(field_get:gate.GameServerService.req)
  return p != NULL ? *p : *reinterpret_cast<const ::gate::GameServerService_GameServerRequest*>(
      &::gate::_GameServerService_GameServerRequest_default_instance_);
}
inline ::gate::GameServerService_GameServerRequest* GameServerService::release_req() {
  // @@protoc_insertion_point(field_release:gate.GameServerService.req)
  clear_has_req();
  ::gate::GameServerService_GameServerRequest* temp = req_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  req_ = NULL;
  return temp;
}
inline ::gate::GameServerService_GameServerRequest* GameServerService::unsafe_arena_release_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gate.GameServerService.req)
  clear_has_req();
  ::gate::GameServerService_GameServerRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline ::gate::GameServerService_GameServerRequest* GameServerService::mutable_req() {
  set_has_req();
  if (req_ == NULL) {
    auto* p = CreateMaybeMessage<::gate::GameServerService_GameServerRequest>(GetArenaNoVirtual());
    req_ = p;
  }
  // @@protoc_insertion_point(field_mutable:gate.GameServerService.req)
  return req_;
}
inline void GameServerService::set_allocated_req(::gate::GameServerService_GameServerRequest* req) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete req_;
  }
  if (req) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(req);
    if (message_arena != submessage_arena) {
      req = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, req, submessage_arena);
    }
    set_has_req();
  } else {
    clear_has_req();
  }
  req_ = req;
  // @@protoc_insertion_point(field_set_allocated:gate.GameServerService.req)
}

// optional .gate.GameServerService.GameServerResponse resp = 2;
inline bool GameServerService::has_resp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameServerService::set_has_resp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameServerService::clear_has_resp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameServerService::clear_resp() {
  if (resp_ != NULL) resp_->Clear();
  clear_has_resp();
}
inline const ::gate::GameServerService_GameServerResponse& GameServerService::_internal_resp() const {
  return *resp_;
}
inline const ::gate::GameServerService_GameServerResponse& GameServerService::resp() const {
  const ::gate::GameServerService_GameServerResponse* p = resp_;
  // @@protoc_insertion_point(field_get:gate.GameServerService.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::gate::GameServerService_GameServerResponse*>(
      &::gate::_GameServerService_GameServerResponse_default_instance_);
}
inline ::gate::GameServerService_GameServerResponse* GameServerService::release_resp() {
  // @@protoc_insertion_point(field_release:gate.GameServerService.resp)
  clear_has_resp();
  ::gate::GameServerService_GameServerResponse* temp = resp_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  resp_ = NULL;
  return temp;
}
inline ::gate::GameServerService_GameServerResponse* GameServerService::unsafe_arena_release_resp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gate.GameServerService.resp)
  clear_has_resp();
  ::gate::GameServerService_GameServerResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline ::gate::GameServerService_GameServerResponse* GameServerService::mutable_resp() {
  set_has_resp();
  if (resp_ == NULL) {
    auto* p = CreateMaybeMessage<::gate::GameServerService_GameServerResponse>(GetArenaNoVirtual());
    resp_ = p;
  }
  // @@protoc_insertion_point(field_mutable:gate.GameServerService.resp)
  return resp_;
}
inline void GameServerService::set_allocated_resp(::gate::GameServerService_GameServerResponse* resp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete resp_;
  }
  if (resp) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(resp);
    if (message_arena != submessage_arena) {
      resp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, resp, submessage_arena);
    }
    set_has_resp();
  } else {
    clear_has_resp();
  }
  resp_ = resp;
  // @@protoc_insertion_point(field_set_allocated:gate.GameServerService.resp)
}

// -------------------------------------------------------------------

// ActiveCodeService_ActiveRequest

// required bytes active_code = 1;
inline bool ActiveCodeService_ActiveRequest::has_active_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActiveCodeService_ActiveRequest::set_has_active_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActiveCodeService_ActiveRequest::clear_has_active_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActiveCodeService_ActiveRequest::clear_active_code() {
  active_code_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_active_code();
}
inline const ::std::string& ActiveCodeService_ActiveRequest::active_code() const {
  // @@protoc_insertion_point(field_get:gate.ActiveCodeService.ActiveRequest.active_code)
  return active_code_.Get();
}
inline void ActiveCodeService_ActiveRequest::set_active_code(const ::std::string& value) {
  set_has_active_code();
  active_code_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:gate.ActiveCodeService.ActiveRequest.active_code)
}
#if LANG_CXX11
inline void ActiveCodeService_ActiveRequest::set_active_code(::std::string&& value) {
  set_has_active_code();
  active_code_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:gate.ActiveCodeService.ActiveRequest.active_code)
}
#endif
inline void ActiveCodeService_ActiveRequest::set_active_code(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_active_code();
  active_code_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:gate.ActiveCodeService.ActiveRequest.active_code)
}
inline void ActiveCodeService_ActiveRequest::set_active_code(const void* value,
    size_t size) {
  set_has_active_code();
  active_code_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:gate.ActiveCodeService.ActiveRequest.active_code)
}
inline ::std::string* ActiveCodeService_ActiveRequest::mutable_active_code() {
  set_has_active_code();
  // @@protoc_insertion_point(field_mutable:gate.ActiveCodeService.ActiveRequest.active_code)
  return active_code_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* ActiveCodeService_ActiveRequest::release_active_code() {
  // @@protoc_insertion_point(field_release:gate.ActiveCodeService.ActiveRequest.active_code)
  if (!has_active_code()) {
    return NULL;
  }
  clear_has_active_code();
  return active_code_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void ActiveCodeService_ActiveRequest::set_allocated_active_code(::std::string* active_code) {
  if (active_code != NULL) {
    set_has_active_code();
  } else {
    clear_has_active_code();
  }
  active_code_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), active_code,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:gate.ActiveCodeService.ActiveRequest.active_code)
}
inline ::std::string* ActiveCodeService_ActiveRequest::unsafe_arena_release_active_code() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gate.ActiveCodeService.ActiveRequest.active_code)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_active_code();
  return active_code_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void ActiveCodeService_ActiveRequest::unsafe_arena_set_allocated_active_code(
    ::std::string* active_code) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (active_code != NULL) {
    set_has_active_code();
  } else {
    clear_has_active_code();
  }
  active_code_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      active_code, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gate.ActiveCodeService.ActiveRequest.active_code)
}

// required bytes uid = 2;
inline bool ActiveCodeService_ActiveRequest::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActiveCodeService_ActiveRequest::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActiveCodeService_ActiveRequest::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActiveCodeService_ActiveRequest::clear_uid() {
  uid_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_uid();
}
inline const ::std::string& ActiveCodeService_ActiveRequest::uid() const {
  // @@protoc_insertion_point(field_get:gate.ActiveCodeService.ActiveRequest.uid)
  return uid_.Get();
}
inline void ActiveCodeService_ActiveRequest::set_uid(const ::std::string& value) {
  set_has_uid();
  uid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:gate.ActiveCodeService.ActiveRequest.uid)
}
#if LANG_CXX11
inline void ActiveCodeService_ActiveRequest::set_uid(::std::string&& value) {
  set_has_uid();
  uid_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:gate.ActiveCodeService.ActiveRequest.uid)
}
#endif
inline void ActiveCodeService_ActiveRequest::set_uid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_uid();
  uid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:gate.ActiveCodeService.ActiveRequest.uid)
}
inline void ActiveCodeService_ActiveRequest::set_uid(const void* value,
    size_t size) {
  set_has_uid();
  uid_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:gate.ActiveCodeService.ActiveRequest.uid)
}
inline ::std::string* ActiveCodeService_ActiveRequest::mutable_uid() {
  set_has_uid();
  // @@protoc_insertion_point(field_mutable:gate.ActiveCodeService.ActiveRequest.uid)
  return uid_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* ActiveCodeService_ActiveRequest::release_uid() {
  // @@protoc_insertion_point(field_release:gate.ActiveCodeService.ActiveRequest.uid)
  if (!has_uid()) {
    return NULL;
  }
  clear_has_uid();
  return uid_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void ActiveCodeService_ActiveRequest::set_allocated_uid(::std::string* uid) {
  if (uid != NULL) {
    set_has_uid();
  } else {
    clear_has_uid();
  }
  uid_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uid,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:gate.ActiveCodeService.ActiveRequest.uid)
}
inline ::std::string* ActiveCodeService_ActiveRequest::unsafe_arena_release_uid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gate.ActiveCodeService.ActiveRequest.uid)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_uid();
  return uid_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void ActiveCodeService_ActiveRequest::unsafe_arena_set_allocated_uid(
    ::std::string* uid) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (uid != NULL) {
    set_has_uid();
  } else {
    clear_has_uid();
  }
  uid_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      uid, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gate.ActiveCodeService.ActiveRequest.uid)
}

// -------------------------------------------------------------------

// ActiveCodeService_ActiveResponse

// optional int32 result = 1;
inline bool ActiveCodeService_ActiveResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActiveCodeService_ActiveResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActiveCodeService_ActiveResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActiveCodeService_ActiveResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ActiveCodeService_ActiveResponse::result() const {
  // @@protoc_insertion_point(field_get:gate.ActiveCodeService.ActiveResponse.result)
  return result_;
}
inline void ActiveCodeService_ActiveResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:gate.ActiveCodeService.ActiveResponse.result)
}

// -------------------------------------------------------------------

// ActiveCodeService

// optional .gate.ActiveCodeService.ActiveRequest req = 1;
inline bool ActiveCodeService::has_req() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActiveCodeService::set_has_req() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActiveCodeService::clear_has_req() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActiveCodeService::clear_req() {
  if (req_ != NULL) req_->Clear();
  clear_has_req();
}
inline const ::gate::ActiveCodeService_ActiveRequest& ActiveCodeService::_internal_req() const {
  return *req_;
}
inline const ::gate::ActiveCodeService_ActiveRequest& ActiveCodeService::req() const {
  const ::gate::ActiveCodeService_ActiveRequest* p = req_;
  // @@protoc_insertion_point(field_get:gate.ActiveCodeService.req)
  return p != NULL ? *p : *reinterpret_cast<const ::gate::ActiveCodeService_ActiveRequest*>(
      &::gate::_ActiveCodeService_ActiveRequest_default_instance_);
}
inline ::gate::ActiveCodeService_ActiveRequest* ActiveCodeService::release_req() {
  // @@protoc_insertion_point(field_release:gate.ActiveCodeService.req)
  clear_has_req();
  ::gate::ActiveCodeService_ActiveRequest* temp = req_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  req_ = NULL;
  return temp;
}
inline ::gate::ActiveCodeService_ActiveRequest* ActiveCodeService::unsafe_arena_release_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gate.ActiveCodeService.req)
  clear_has_req();
  ::gate::ActiveCodeService_ActiveRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline ::gate::ActiveCodeService_ActiveRequest* ActiveCodeService::mutable_req() {
  set_has_req();
  if (req_ == NULL) {
    auto* p = CreateMaybeMessage<::gate::ActiveCodeService_ActiveRequest>(GetArenaNoVirtual());
    req_ = p;
  }
  // @@protoc_insertion_point(field_mutable:gate.ActiveCodeService.req)
  return req_;
}
inline void ActiveCodeService::set_allocated_req(::gate::ActiveCodeService_ActiveRequest* req) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete req_;
  }
  if (req) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(req);
    if (message_arena != submessage_arena) {
      req = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, req, submessage_arena);
    }
    set_has_req();
  } else {
    clear_has_req();
  }
  req_ = req;
  // @@protoc_insertion_point(field_set_allocated:gate.ActiveCodeService.req)
}

// optional .gate.ActiveCodeService.ActiveResponse resp = 2;
inline bool ActiveCodeService::has_resp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActiveCodeService::set_has_resp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActiveCodeService::clear_has_resp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActiveCodeService::clear_resp() {
  if (resp_ != NULL) resp_->Clear();
  clear_has_resp();
}
inline const ::gate::ActiveCodeService_ActiveResponse& ActiveCodeService::_internal_resp() const {
  return *resp_;
}
inline const ::gate::ActiveCodeService_ActiveResponse& ActiveCodeService::resp() const {
  const ::gate::ActiveCodeService_ActiveResponse* p = resp_;
  // @@protoc_insertion_point(field_get:gate.ActiveCodeService.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::gate::ActiveCodeService_ActiveResponse*>(
      &::gate::_ActiveCodeService_ActiveResponse_default_instance_);
}
inline ::gate::ActiveCodeService_ActiveResponse* ActiveCodeService::release_resp() {
  // @@protoc_insertion_point(field_release:gate.ActiveCodeService.resp)
  clear_has_resp();
  ::gate::ActiveCodeService_ActiveResponse* temp = resp_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  resp_ = NULL;
  return temp;
}
inline ::gate::ActiveCodeService_ActiveResponse* ActiveCodeService::unsafe_arena_release_resp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gate.ActiveCodeService.resp)
  clear_has_resp();
  ::gate::ActiveCodeService_ActiveResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline ::gate::ActiveCodeService_ActiveResponse* ActiveCodeService::mutable_resp() {
  set_has_resp();
  if (resp_ == NULL) {
    auto* p = CreateMaybeMessage<::gate::ActiveCodeService_ActiveResponse>(GetArenaNoVirtual());
    resp_ = p;
  }
  // @@protoc_insertion_point(field_mutable:gate.ActiveCodeService.resp)
  return resp_;
}
inline void ActiveCodeService::set_allocated_resp(::gate::ActiveCodeService_ActiveResponse* resp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete resp_;
  }
  if (resp) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(resp);
    if (message_arena != submessage_arena) {
      resp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, resp, submessage_arena);
    }
    set_has_resp();
  } else {
    clear_has_resp();
  }
  resp_ = resp;
  // @@protoc_insertion_point(field_set_allocated:gate.ActiveCodeService.resp)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace gate

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::gate::ErrorNo_ERROR_NO> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::gate::ErrorNo_ERROR_NO>() {
  return ::gate::ErrorNo_ERROR_NO_descriptor();
}
template <> struct is_proto_enum< ::gate::RegisterAccountService_RESULT> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::gate::RegisterAccountService_RESULT>() {
  return ::gate::RegisterAccountService_RESULT_descriptor();
}
template <> struct is_proto_enum< ::gate::AccountLoginService_RESULT> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::gate::AccountLoginService_RESULT>() {
  return ::gate::AccountLoginService_RESULT_descriptor();
}
template <> struct is_proto_enum< ::gate::AccountReloginService_RESULT> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::gate::AccountReloginService_RESULT>() {
  return ::gate::AccountReloginService_RESULT_descriptor();
}
template <> struct is_proto_enum< ::gate::GameServerService_GAME_SERVER_COMMAND> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::gate::GameServerService_GAME_SERVER_COMMAND>() {
  return ::gate::GameServerService_GAME_SERVER_COMMAND_descriptor();
}
template <> struct is_proto_enum< ::gate::GATE_ACCOUNT_STATUS> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::gate::GATE_ACCOUNT_STATUS>() {
  return ::gate::GATE_ACCOUNT_STATUS_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_Gate_2eproto
