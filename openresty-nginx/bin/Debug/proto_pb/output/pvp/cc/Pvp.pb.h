// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Pvp.proto

#ifndef PROTOBUF_INCLUDED_Pvp_2eproto
#define PROTOBUF_INCLUDED_Pvp_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "BaseStruct.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_Pvp_2eproto 

namespace protobuf_Pvp_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[24];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_Pvp_2eproto
namespace pvp {
class CardList;
class CardListDefaultTypeInternal;
extern CardListDefaultTypeInternal _CardList_default_instance_;
class CombatFrame;
class CombatFrameDefaultTypeInternal;
extern CombatFrameDefaultTypeInternal _CombatFrame_default_instance_;
class CombatFrameList;
class CombatFrameListDefaultTypeInternal;
extern CombatFrameListDefaultTypeInternal _CombatFrameList_default_instance_;
class CombatResult;
class CombatResultDefaultTypeInternal;
extern CombatResultDefaultTypeInternal _CombatResult_default_instance_;
class PlayerData;
class PlayerDataDefaultTypeInternal;
extern PlayerDataDefaultTypeInternal _PlayerData_default_instance_;
class PvpCombat;
class PvpCombatDefaultTypeInternal;
extern PvpCombatDefaultTypeInternal _PvpCombat_default_instance_;
class PvpCombatStartNotify;
class PvpCombatStartNotifyDefaultTypeInternal;
extern PvpCombatStartNotifyDefaultTypeInternal _PvpCombatStartNotify_default_instance_;
class PvpEventLog;
class PvpEventLogDefaultTypeInternal;
extern PvpEventLogDefaultTypeInternal _PvpEventLog_default_instance_;
class PvpEventLogList;
class PvpEventLogListDefaultTypeInternal;
extern PvpEventLogListDefaultTypeInternal _PvpEventLogList_default_instance_;
class PvpEventLogStateNotify;
class PvpEventLogStateNotifyDefaultTypeInternal;
extern PvpEventLogStateNotifyDefaultTypeInternal _PvpEventLogStateNotify_default_instance_;
class PvpFrameNotify;
class PvpFrameNotifyDefaultTypeInternal;
extern PvpFrameNotifyDefaultTypeInternal _PvpFrameNotify_default_instance_;
class PvpLootNotify;
class PvpLootNotifyDefaultTypeInternal;
extern PvpLootNotifyDefaultTypeInternal _PvpLootNotify_default_instance_;
class PvpReward;
class PvpRewardDefaultTypeInternal;
extern PvpRewardDefaultTypeInternal _PvpReward_default_instance_;
class PvpRewardNotify;
class PvpRewardNotifyDefaultTypeInternal;
extern PvpRewardNotifyDefaultTypeInternal _PvpRewardNotify_default_instance_;
class PvpService;
class PvpServiceDefaultTypeInternal;
extern PvpServiceDefaultTypeInternal _PvpService_default_instance_;
class PvpService_PvpRequest;
class PvpService_PvpRequestDefaultTypeInternal;
extern PvpService_PvpRequestDefaultTypeInternal _PvpService_PvpRequest_default_instance_;
class PvpService_PvpResponse;
class PvpService_PvpResponseDefaultTypeInternal;
extern PvpService_PvpResponseDefaultTypeInternal _PvpService_PvpResponse_default_instance_;
class RandList;
class RandListDefaultTypeInternal;
extern RandListDefaultTypeInternal _RandList_default_instance_;
class StageData;
class StageDataDefaultTypeInternal;
extern StageDataDefaultTypeInternal _StageData_default_instance_;
class StageDataList;
class StageDataListDefaultTypeInternal;
extern StageDataListDefaultTypeInternal _StageDataList_default_instance_;
class UserInput;
class UserInputDefaultTypeInternal;
extern UserInputDefaultTypeInternal _UserInput_default_instance_;
class UserPvpEventLogService;
class UserPvpEventLogServiceDefaultTypeInternal;
extern UserPvpEventLogServiceDefaultTypeInternal _UserPvpEventLogService_default_instance_;
class UserPvpEventLogService_EventLogRequest;
class UserPvpEventLogService_EventLogRequestDefaultTypeInternal;
extern UserPvpEventLogService_EventLogRequestDefaultTypeInternal _UserPvpEventLogService_EventLogRequest_default_instance_;
class UserPvpEventLogService_EventLogResponse;
class UserPvpEventLogService_EventLogResponseDefaultTypeInternal;
extern UserPvpEventLogService_EventLogResponseDefaultTypeInternal _UserPvpEventLogService_EventLogResponse_default_instance_;
}  // namespace pvp
namespace google {
namespace protobuf {
template<> ::pvp::CardList* Arena::CreateMaybeMessage<::pvp::CardList>(Arena*);
template<> ::pvp::CombatFrame* Arena::CreateMaybeMessage<::pvp::CombatFrame>(Arena*);
template<> ::pvp::CombatFrameList* Arena::CreateMaybeMessage<::pvp::CombatFrameList>(Arena*);
template<> ::pvp::CombatResult* Arena::CreateMaybeMessage<::pvp::CombatResult>(Arena*);
template<> ::pvp::PlayerData* Arena::CreateMaybeMessage<::pvp::PlayerData>(Arena*);
template<> ::pvp::PvpCombat* Arena::CreateMaybeMessage<::pvp::PvpCombat>(Arena*);
template<> ::pvp::PvpCombatStartNotify* Arena::CreateMaybeMessage<::pvp::PvpCombatStartNotify>(Arena*);
template<> ::pvp::PvpEventLog* Arena::CreateMaybeMessage<::pvp::PvpEventLog>(Arena*);
template<> ::pvp::PvpEventLogList* Arena::CreateMaybeMessage<::pvp::PvpEventLogList>(Arena*);
template<> ::pvp::PvpEventLogStateNotify* Arena::CreateMaybeMessage<::pvp::PvpEventLogStateNotify>(Arena*);
template<> ::pvp::PvpFrameNotify* Arena::CreateMaybeMessage<::pvp::PvpFrameNotify>(Arena*);
template<> ::pvp::PvpLootNotify* Arena::CreateMaybeMessage<::pvp::PvpLootNotify>(Arena*);
template<> ::pvp::PvpReward* Arena::CreateMaybeMessage<::pvp::PvpReward>(Arena*);
template<> ::pvp::PvpRewardNotify* Arena::CreateMaybeMessage<::pvp::PvpRewardNotify>(Arena*);
template<> ::pvp::PvpService* Arena::CreateMaybeMessage<::pvp::PvpService>(Arena*);
template<> ::pvp::PvpService_PvpRequest* Arena::CreateMaybeMessage<::pvp::PvpService_PvpRequest>(Arena*);
template<> ::pvp::PvpService_PvpResponse* Arena::CreateMaybeMessage<::pvp::PvpService_PvpResponse>(Arena*);
template<> ::pvp::RandList* Arena::CreateMaybeMessage<::pvp::RandList>(Arena*);
template<> ::pvp::StageData* Arena::CreateMaybeMessage<::pvp::StageData>(Arena*);
template<> ::pvp::StageDataList* Arena::CreateMaybeMessage<::pvp::StageDataList>(Arena*);
template<> ::pvp::UserInput* Arena::CreateMaybeMessage<::pvp::UserInput>(Arena*);
template<> ::pvp::UserPvpEventLogService* Arena::CreateMaybeMessage<::pvp::UserPvpEventLogService>(Arena*);
template<> ::pvp::UserPvpEventLogService_EventLogRequest* Arena::CreateMaybeMessage<::pvp::UserPvpEventLogService_EventLogRequest>(Arena*);
template<> ::pvp::UserPvpEventLogService_EventLogResponse* Arena::CreateMaybeMessage<::pvp::UserPvpEventLogService_EventLogResponse>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace pvp {

enum UserInput_INPUT_OPCODE {
  UserInput_INPUT_OPCODE_BATTLE_STATS = 1,
  UserInput_INPUT_OPCODE_ADD_CARD = 2
};
bool UserInput_INPUT_OPCODE_IsValid(int value);
const UserInput_INPUT_OPCODE UserInput_INPUT_OPCODE_INPUT_OPCODE_MIN = UserInput_INPUT_OPCODE_BATTLE_STATS;
const UserInput_INPUT_OPCODE UserInput_INPUT_OPCODE_INPUT_OPCODE_MAX = UserInput_INPUT_OPCODE_ADD_CARD;
const int UserInput_INPUT_OPCODE_INPUT_OPCODE_ARRAYSIZE = UserInput_INPUT_OPCODE_INPUT_OPCODE_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserInput_INPUT_OPCODE_descriptor();
inline const ::std::string& UserInput_INPUT_OPCODE_Name(UserInput_INPUT_OPCODE value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserInput_INPUT_OPCODE_descriptor(), value);
}
inline bool UserInput_INPUT_OPCODE_Parse(
    const ::std::string& name, UserInput_INPUT_OPCODE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserInput_INPUT_OPCODE>(
    UserInput_INPUT_OPCODE_descriptor(), name, value);
}
enum CombatFrame_FRAME_STATE {
  CombatFrame_FRAME_STATE_FRAME_HEAD = 1,
  CombatFrame_FRAME_STATE_FRAME_MIDDLE = 2,
  CombatFrame_FRAME_STATE_FRAME_MIDDLE_WITH_INPUT = 3,
  CombatFrame_FRAME_STATE_FRAME_TAIL = 4
};
bool CombatFrame_FRAME_STATE_IsValid(int value);
const CombatFrame_FRAME_STATE CombatFrame_FRAME_STATE_FRAME_STATE_MIN = CombatFrame_FRAME_STATE_FRAME_HEAD;
const CombatFrame_FRAME_STATE CombatFrame_FRAME_STATE_FRAME_STATE_MAX = CombatFrame_FRAME_STATE_FRAME_TAIL;
const int CombatFrame_FRAME_STATE_FRAME_STATE_ARRAYSIZE = CombatFrame_FRAME_STATE_FRAME_STATE_MAX + 1;

const ::google::protobuf::EnumDescriptor* CombatFrame_FRAME_STATE_descriptor();
inline const ::std::string& CombatFrame_FRAME_STATE_Name(CombatFrame_FRAME_STATE value) {
  return ::google::protobuf::internal::NameOfEnum(
    CombatFrame_FRAME_STATE_descriptor(), value);
}
inline bool CombatFrame_FRAME_STATE_Parse(
    const ::std::string& name, CombatFrame_FRAME_STATE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CombatFrame_FRAME_STATE>(
    CombatFrame_FRAME_STATE_descriptor(), name, value);
}
enum PvpService_PVP_COMMAND {
  PvpService_PVP_COMMAND_QUERY = 1,
  PvpService_PVP_COMMAND_UPLOAD = 2,
  PvpService_PVP_COMMAND_JOIN = 11,
  PvpService_PVP_COMMAND_INPUT = 12,
  PvpService_PVP_COMMAND_CANCEL = 13,
  PvpService_PVP_COMMAND_ACCEP_REWARD = 14
};
bool PvpService_PVP_COMMAND_IsValid(int value);
const PvpService_PVP_COMMAND PvpService_PVP_COMMAND_PVP_COMMAND_MIN = PvpService_PVP_COMMAND_QUERY;
const PvpService_PVP_COMMAND PvpService_PVP_COMMAND_PVP_COMMAND_MAX = PvpService_PVP_COMMAND_ACCEP_REWARD;
const int PvpService_PVP_COMMAND_PVP_COMMAND_ARRAYSIZE = PvpService_PVP_COMMAND_PVP_COMMAND_MAX + 1;

const ::google::protobuf::EnumDescriptor* PvpService_PVP_COMMAND_descriptor();
inline const ::std::string& PvpService_PVP_COMMAND_Name(PvpService_PVP_COMMAND value) {
  return ::google::protobuf::internal::NameOfEnum(
    PvpService_PVP_COMMAND_descriptor(), value);
}
inline bool PvpService_PVP_COMMAND_Parse(
    const ::std::string& name, PvpService_PVP_COMMAND* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PvpService_PVP_COMMAND>(
    PvpService_PVP_COMMAND_descriptor(), name, value);
}
enum PvpEventLog_LOOT_STATE {
  PvpEventLog_LOOT_STATE_IDLE = 0,
  PvpEventLog_LOOT_STATE_START = 1,
  PvpEventLog_LOOT_STATE_OVER = 2,
  PvpEventLog_LOOT_STATE_REFUND = 3
};
bool PvpEventLog_LOOT_STATE_IsValid(int value);
const PvpEventLog_LOOT_STATE PvpEventLog_LOOT_STATE_LOOT_STATE_MIN = PvpEventLog_LOOT_STATE_IDLE;
const PvpEventLog_LOOT_STATE PvpEventLog_LOOT_STATE_LOOT_STATE_MAX = PvpEventLog_LOOT_STATE_REFUND;
const int PvpEventLog_LOOT_STATE_LOOT_STATE_ARRAYSIZE = PvpEventLog_LOOT_STATE_LOOT_STATE_MAX + 1;

const ::google::protobuf::EnumDescriptor* PvpEventLog_LOOT_STATE_descriptor();
inline const ::std::string& PvpEventLog_LOOT_STATE_Name(PvpEventLog_LOOT_STATE value) {
  return ::google::protobuf::internal::NameOfEnum(
    PvpEventLog_LOOT_STATE_descriptor(), value);
}
inline bool PvpEventLog_LOOT_STATE_Parse(
    const ::std::string& name, PvpEventLog_LOOT_STATE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PvpEventLog_LOOT_STATE>(
    PvpEventLog_LOOT_STATE_descriptor(), name, value);
}
enum PvpEventLog_DEFEND_STATE {
  PvpEventLog_DEFEND_STATE_SUSPEND = 0,
  PvpEventLog_DEFEND_STATE_WIN = 1,
  PvpEventLog_DEFEND_STATE_LOSE = 2
};
bool PvpEventLog_DEFEND_STATE_IsValid(int value);
const PvpEventLog_DEFEND_STATE PvpEventLog_DEFEND_STATE_DEFEND_STATE_MIN = PvpEventLog_DEFEND_STATE_SUSPEND;
const PvpEventLog_DEFEND_STATE PvpEventLog_DEFEND_STATE_DEFEND_STATE_MAX = PvpEventLog_DEFEND_STATE_LOSE;
const int PvpEventLog_DEFEND_STATE_DEFEND_STATE_ARRAYSIZE = PvpEventLog_DEFEND_STATE_DEFEND_STATE_MAX + 1;

const ::google::protobuf::EnumDescriptor* PvpEventLog_DEFEND_STATE_descriptor();
inline const ::std::string& PvpEventLog_DEFEND_STATE_Name(PvpEventLog_DEFEND_STATE value) {
  return ::google::protobuf::internal::NameOfEnum(
    PvpEventLog_DEFEND_STATE_descriptor(), value);
}
inline bool PvpEventLog_DEFEND_STATE_Parse(
    const ::std::string& name, PvpEventLog_DEFEND_STATE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PvpEventLog_DEFEND_STATE>(
    PvpEventLog_DEFEND_STATE_descriptor(), name, value);
}
enum UserPvpEventLogService_EVENT_LOG_COMMAND {
  UserPvpEventLogService_EVENT_LOG_COMMAND_QUERY_LOG = 1,
  UserPvpEventLogService_EVENT_LOG_COMMAND_REFUND_LOG = 2
};
bool UserPvpEventLogService_EVENT_LOG_COMMAND_IsValid(int value);
const UserPvpEventLogService_EVENT_LOG_COMMAND UserPvpEventLogService_EVENT_LOG_COMMAND_EVENT_LOG_COMMAND_MIN = UserPvpEventLogService_EVENT_LOG_COMMAND_QUERY_LOG;
const UserPvpEventLogService_EVENT_LOG_COMMAND UserPvpEventLogService_EVENT_LOG_COMMAND_EVENT_LOG_COMMAND_MAX = UserPvpEventLogService_EVENT_LOG_COMMAND_REFUND_LOG;
const int UserPvpEventLogService_EVENT_LOG_COMMAND_EVENT_LOG_COMMAND_ARRAYSIZE = UserPvpEventLogService_EVENT_LOG_COMMAND_EVENT_LOG_COMMAND_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserPvpEventLogService_EVENT_LOG_COMMAND_descriptor();
inline const ::std::string& UserPvpEventLogService_EVENT_LOG_COMMAND_Name(UserPvpEventLogService_EVENT_LOG_COMMAND value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserPvpEventLogService_EVENT_LOG_COMMAND_descriptor(), value);
}
inline bool UserPvpEventLogService_EVENT_LOG_COMMAND_Parse(
    const ::std::string& name, UserPvpEventLogService_EVENT_LOG_COMMAND* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserPvpEventLogService_EVENT_LOG_COMMAND>(
    UserPvpEventLogService_EVENT_LOG_COMMAND_descriptor(), name, value);
}
enum COMBAT_TYPE {
  COMBAT_NONE = 0,
  COMBAT_ARENA = 1
};
bool COMBAT_TYPE_IsValid(int value);
const COMBAT_TYPE COMBAT_TYPE_MIN = COMBAT_NONE;
const COMBAT_TYPE COMBAT_TYPE_MAX = COMBAT_ARENA;
const int COMBAT_TYPE_ARRAYSIZE = COMBAT_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* COMBAT_TYPE_descriptor();
inline const ::std::string& COMBAT_TYPE_Name(COMBAT_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    COMBAT_TYPE_descriptor(), value);
}
inline bool COMBAT_TYPE_Parse(
    const ::std::string& name, COMBAT_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<COMBAT_TYPE>(
    COMBAT_TYPE_descriptor(), name, value);
}
enum PVP_STAGE_STATE {
  PVP_STAGE_STATE_TO_DELETE = -1,
  PVP_STAGE_STATE_OFFLINE = 0,
  PVP_STAGE_STATE_ONLINE = 1
};
bool PVP_STAGE_STATE_IsValid(int value);
const PVP_STAGE_STATE PVP_STAGE_STATE_MIN = PVP_STAGE_STATE_TO_DELETE;
const PVP_STAGE_STATE PVP_STAGE_STATE_MAX = PVP_STAGE_STATE_ONLINE;
const int PVP_STAGE_STATE_ARRAYSIZE = PVP_STAGE_STATE_MAX + 1;

const ::google::protobuf::EnumDescriptor* PVP_STAGE_STATE_descriptor();
inline const ::std::string& PVP_STAGE_STATE_Name(PVP_STAGE_STATE value) {
  return ::google::protobuf::internal::NameOfEnum(
    PVP_STAGE_STATE_descriptor(), value);
}
inline bool PVP_STAGE_STATE_Parse(
    const ::std::string& name, PVP_STAGE_STATE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PVP_STAGE_STATE>(
    PVP_STAGE_STATE_descriptor(), name, value);
}
enum PVP_EVENT_TYPE {
  PVP_EVENT_TYPE_LOOT = 1
};
bool PVP_EVENT_TYPE_IsValid(int value);
const PVP_EVENT_TYPE PVP_EVENT_TYPE_MIN = PVP_EVENT_TYPE_LOOT;
const PVP_EVENT_TYPE PVP_EVENT_TYPE_MAX = PVP_EVENT_TYPE_LOOT;
const int PVP_EVENT_TYPE_ARRAYSIZE = PVP_EVENT_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* PVP_EVENT_TYPE_descriptor();
inline const ::std::string& PVP_EVENT_TYPE_Name(PVP_EVENT_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    PVP_EVENT_TYPE_descriptor(), value);
}
inline bool PVP_EVENT_TYPE_Parse(
    const ::std::string& name, PVP_EVENT_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PVP_EVENT_TYPE>(
    PVP_EVENT_TYPE_descriptor(), name, value);
}
// ===================================================================

class RandList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pvp.RandList) */ {
 public:
  RandList();
  virtual ~RandList();

  RandList(const RandList& from);

  inline RandList& operator=(const RandList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RandList(RandList&& from) noexcept
    : RandList() {
    *this = ::std::move(from);
  }

  inline RandList& operator=(RandList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const RandList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RandList* internal_default_instance() {
    return reinterpret_cast<const RandList*>(
               &_RandList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void UnsafeArenaSwap(RandList* other);
  void Swap(RandList* other);
  friend void swap(RandList& a, RandList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RandList* New() const final {
    return CreateMaybeMessage<RandList>(NULL);
  }

  RandList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RandList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RandList& from);
  void MergeFrom(const RandList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RandList* other);
  protected:
  explicit RandList(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 list = 1;
  int list_size() const;
  void clear_list();
  static const int kListFieldNumber = 1;
  ::google::protobuf::int32 list(int index) const;
  void set_list(int index, ::google::protobuf::int32 value);
  void add_list(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      list() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_list();

  // @@protoc_insertion_point(class_scope:pvp.RandList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > list_;
  friend struct ::protobuf_Pvp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StageData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pvp.StageData) */ {
 public:
  StageData();
  virtual ~StageData();

  StageData(const StageData& from);

  inline StageData& operator=(const StageData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StageData(StageData&& from) noexcept
    : StageData() {
    *this = ::std::move(from);
  }

  inline StageData& operator=(StageData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const StageData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StageData* internal_default_instance() {
    return reinterpret_cast<const StageData*>(
               &_StageData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void UnsafeArenaSwap(StageData* other);
  void Swap(StageData* other);
  friend void swap(StageData& a, StageData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StageData* New() const final {
    return CreateMaybeMessage<StageData>(NULL);
  }

  StageData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StageData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StageData& from);
  void MergeFrom(const StageData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StageData* other);
  protected:
  explicit StageData(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes name = 3;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const void* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_name();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      ::std::string* name);

  // required bytes desc = 4;
  bool has_desc() const;
  void clear_desc();
  static const int kDescFieldNumber = 4;
  const ::std::string& desc() const;
  void set_desc(const ::std::string& value);
  #if LANG_CXX11
  void set_desc(::std::string&& value);
  #endif
  void set_desc(const char* value);
  void set_desc(const void* value, size_t size);
  ::std::string* mutable_desc();
  ::std::string* release_desc();
  void set_allocated_desc(::std::string* desc);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_desc();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_desc(
      ::std::string* desc);

  // required bytes data_bytes = 5;
  bool has_data_bytes() const;
  void clear_data_bytes();
  static const int kDataBytesFieldNumber = 5;
  const ::std::string& data_bytes() const;
  void set_data_bytes(const ::std::string& value);
  #if LANG_CXX11
  void set_data_bytes(::std::string&& value);
  #endif
  void set_data_bytes(const char* value);
  void set_data_bytes(const void* value, size_t size);
  ::std::string* mutable_data_bytes();
  ::std::string* release_data_bytes();
  void set_allocated_data_bytes(::std::string* data_bytes);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_data_bytes();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_data_bytes(
      ::std::string* data_bytes);

  // required int32 serverid = 1;
  bool has_serverid() const;
  void clear_serverid();
  static const int kServeridFieldNumber = 1;
  ::google::protobuf::int32 serverid() const;
  void set_serverid(::google::protobuf::int32 value);

  // required int32 stageid = 2;
  bool has_stageid() const;
  void clear_stageid();
  static const int kStageidFieldNumber = 2;
  ::google::protobuf::int32 stageid() const;
  void set_stageid(::google::protobuf::int32 value);

  // optional int32 gold = 6;
  bool has_gold() const;
  void clear_gold();
  static const int kGoldFieldNumber = 6;
  ::google::protobuf::int32 gold() const;
  void set_gold(::google::protobuf::int32 value);

  // required sfixed64 optime = 11;
  bool has_optime() const;
  void clear_optime();
  static const int kOptimeFieldNumber = 11;
  ::google::protobuf::int64 optime() const;
  void set_optime(::google::protobuf::int64 value);

  // optional .pvp.PVP_STAGE_STATE state = 7;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 7;
  ::pvp::PVP_STAGE_STATE state() const;
  void set_state(::pvp::PVP_STAGE_STATE value);

  // @@protoc_insertion_point(class_scope:pvp.StageData)
 private:
  void set_has_serverid();
  void clear_has_serverid();
  void set_has_stageid();
  void clear_has_stageid();
  void set_has_name();
  void clear_has_name();
  void set_has_desc();
  void clear_has_desc();
  void set_has_data_bytes();
  void clear_has_data_bytes();
  void set_has_gold();
  void clear_has_gold();
  void set_has_state();
  void clear_has_state();
  void set_has_optime();
  void clear_has_optime();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr desc_;
  ::google::protobuf::internal::ArenaStringPtr data_bytes_;
  ::google::protobuf::int32 serverid_;
  ::google::protobuf::int32 stageid_;
  ::google::protobuf::int32 gold_;
  ::google::protobuf::int64 optime_;
  int state_;
  friend struct ::protobuf_Pvp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StageDataList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pvp.StageDataList) */ {
 public:
  StageDataList();
  virtual ~StageDataList();

  StageDataList(const StageDataList& from);

  inline StageDataList& operator=(const StageDataList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StageDataList(StageDataList&& from) noexcept
    : StageDataList() {
    *this = ::std::move(from);
  }

  inline StageDataList& operator=(StageDataList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const StageDataList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StageDataList* internal_default_instance() {
    return reinterpret_cast<const StageDataList*>(
               &_StageDataList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void UnsafeArenaSwap(StageDataList* other);
  void Swap(StageDataList* other);
  friend void swap(StageDataList& a, StageDataList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StageDataList* New() const final {
    return CreateMaybeMessage<StageDataList>(NULL);
  }

  StageDataList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StageDataList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StageDataList& from);
  void MergeFrom(const StageDataList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StageDataList* other);
  protected:
  explicit StageDataList(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pvp.StageData list = 1;
  int list_size() const;
  void clear_list();
  static const int kListFieldNumber = 1;
  ::pvp::StageData* mutable_list(int index);
  ::google::protobuf::RepeatedPtrField< ::pvp::StageData >*
      mutable_list();
  const ::pvp::StageData& list(int index) const;
  ::pvp::StageData* add_list();
  const ::google::protobuf::RepeatedPtrField< ::pvp::StageData >&
      list() const;

  // @@protoc_insertion_point(class_scope:pvp.StageDataList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::pvp::StageData > list_;
  friend struct ::protobuf_Pvp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CardList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pvp.CardList) */ {
 public:
  CardList();
  virtual ~CardList();

  CardList(const CardList& from);

  inline CardList& operator=(const CardList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CardList(CardList&& from) noexcept
    : CardList() {
    *this = ::std::move(from);
  }

  inline CardList& operator=(CardList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const CardList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CardList* internal_default_instance() {
    return reinterpret_cast<const CardList*>(
               &_CardList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void UnsafeArenaSwap(CardList* other);
  void Swap(CardList* other);
  friend void swap(CardList& a, CardList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CardList* New() const final {
    return CreateMaybeMessage<CardList>(NULL);
  }

  CardList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CardList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CardList& from);
  void MergeFrom(const CardList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CardList* other);
  protected:
  explicit CardList(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sg.Sailor list = 1;
  int list_size() const;
  void clear_list();
  static const int kListFieldNumber = 1;
  ::sg::Sailor* mutable_list(int index);
  ::google::protobuf::RepeatedPtrField< ::sg::Sailor >*
      mutable_list();
  const ::sg::Sailor& list(int index) const;
  ::sg::Sailor* add_list();
  const ::google::protobuf::RepeatedPtrField< ::sg::Sailor >&
      list() const;

  // @@protoc_insertion_point(class_scope:pvp.CardList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::sg::Sailor > list_;
  friend struct ::protobuf_Pvp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PlayerData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pvp.PlayerData) */ {
 public:
  PlayerData();
  virtual ~PlayerData();

  PlayerData(const PlayerData& from);

  inline PlayerData& operator=(const PlayerData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayerData(PlayerData&& from) noexcept
    : PlayerData() {
    *this = ::std::move(from);
  }

  inline PlayerData& operator=(PlayerData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerData* internal_default_instance() {
    return reinterpret_cast<const PlayerData*>(
               &_PlayerData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void UnsafeArenaSwap(PlayerData* other);
  void Swap(PlayerData* other);
  friend void swap(PlayerData& a, PlayerData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayerData* New() const final {
    return CreateMaybeMessage<PlayerData>(NULL);
  }

  PlayerData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PlayerData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PlayerData& from);
  void MergeFrom(const PlayerData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerData* other);
  protected:
  explicit PlayerData(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes nick = 3;
  bool has_nick() const;
  void clear_nick();
  static const int kNickFieldNumber = 3;
  const ::std::string& nick() const;
  void set_nick(const ::std::string& value);
  #if LANG_CXX11
  void set_nick(::std::string&& value);
  #endif
  void set_nick(const char* value);
  void set_nick(const void* value, size_t size);
  ::std::string* mutable_nick();
  ::std::string* release_nick();
  void set_allocated_nick(::std::string* nick);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_nick();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_nick(
      ::std::string* nick);

  // optional .pvp.CardList card_list = 11;
  bool has_card_list() const;
  void clear_card_list();
  static const int kCardListFieldNumber = 11;
  private:
  const ::pvp::CardList& _internal_card_list() const;
  public:
  const ::pvp::CardList& card_list() const;
  ::pvp::CardList* release_card_list();
  ::pvp::CardList* mutable_card_list();
  void set_allocated_card_list(::pvp::CardList* card_list);
  void unsafe_arena_set_allocated_card_list(
      ::pvp::CardList* card_list);
  ::pvp::CardList* unsafe_arena_release_card_list();

  // required uint64 uuid = 2;
  bool has_uuid() const;
  void clear_uuid();
  static const int kUuidFieldNumber = 2;
  ::google::protobuf::uint64 uuid() const;
  void set_uuid(::google::protobuf::uint64 value);

  // required int32 pid = 1;
  bool has_pid() const;
  void clear_pid();
  static const int kPidFieldNumber = 1;
  ::google::protobuf::int32 pid() const;
  void set_pid(::google::protobuf::int32 value);

  // optional int32 level = 4;
  bool has_level() const;
  void clear_level();
  static const int kLevelFieldNumber = 4;
  ::google::protobuf::int32 level() const;
  void set_level(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pvp.PlayerData)
 private:
  void set_has_pid();
  void clear_has_pid();
  void set_has_uuid();
  void clear_has_uuid();
  void set_has_nick();
  void clear_has_nick();
  void set_has_level();
  void clear_has_level();
  void set_has_card_list();
  void clear_has_card_list();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr nick_;
  ::pvp::CardList* card_list_;
  ::google::protobuf::uint64 uuid_;
  ::google::protobuf::int32 pid_;
  ::google::protobuf::int32 level_;
  friend struct ::protobuf_Pvp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserInput : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pvp.UserInput) */ {
 public:
  UserInput();
  virtual ~UserInput();

  UserInput(const UserInput& from);

  inline UserInput& operator=(const UserInput& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserInput(UserInput&& from) noexcept
    : UserInput() {
    *this = ::std::move(from);
  }

  inline UserInput& operator=(UserInput&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserInput& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserInput* internal_default_instance() {
    return reinterpret_cast<const UserInput*>(
               &_UserInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void UnsafeArenaSwap(UserInput* other);
  void Swap(UserInput* other);
  friend void swap(UserInput& a, UserInput& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserInput* New() const final {
    return CreateMaybeMessage<UserInput>(NULL);
  }

  UserInput* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserInput>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserInput& from);
  void MergeFrom(const UserInput& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserInput* other);
  protected:
  explicit UserInput(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UserInput_INPUT_OPCODE INPUT_OPCODE;
  static const INPUT_OPCODE BATTLE_STATS =
    UserInput_INPUT_OPCODE_BATTLE_STATS;
  static const INPUT_OPCODE ADD_CARD =
    UserInput_INPUT_OPCODE_ADD_CARD;
  static inline bool INPUT_OPCODE_IsValid(int value) {
    return UserInput_INPUT_OPCODE_IsValid(value);
  }
  static const INPUT_OPCODE INPUT_OPCODE_MIN =
    UserInput_INPUT_OPCODE_INPUT_OPCODE_MIN;
  static const INPUT_OPCODE INPUT_OPCODE_MAX =
    UserInput_INPUT_OPCODE_INPUT_OPCODE_MAX;
  static const int INPUT_OPCODE_ARRAYSIZE =
    UserInput_INPUT_OPCODE_INPUT_OPCODE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  INPUT_OPCODE_descriptor() {
    return UserInput_INPUT_OPCODE_descriptor();
  }
  static inline const ::std::string& INPUT_OPCODE_Name(INPUT_OPCODE value) {
    return UserInput_INPUT_OPCODE_Name(value);
  }
  static inline bool INPUT_OPCODE_Parse(const ::std::string& name,
      INPUT_OPCODE* value) {
    return UserInput_INPUT_OPCODE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional int32 score = 2;
  bool has_score() const;
  void clear_score();
  static const int kScoreFieldNumber = 2;
  ::google::protobuf::int32 score() const;
  void set_score(::google::protobuf::int32 value);

  // optional int32 star = 3;
  bool has_star() const;
  void clear_star();
  static const int kStarFieldNumber = 3;
  ::google::protobuf::int32 star() const;
  void set_star(::google::protobuf::int32 value);

  // optional int32 playerid = 11;
  bool has_playerid() const;
  void clear_playerid();
  static const int kPlayeridFieldNumber = 11;
  ::google::protobuf::int32 playerid() const;
  void set_playerid(::google::protobuf::int32 value);

  // optional int32 cardid = 12;
  bool has_cardid() const;
  void clear_cardid();
  static const int kCardidFieldNumber = 12;
  ::google::protobuf::int32 cardid() const;
  void set_cardid(::google::protobuf::int32 value);

  // optional int32 pos_x = 13;
  bool has_pos_x() const;
  void clear_pos_x();
  static const int kPosXFieldNumber = 13;
  ::google::protobuf::int32 pos_x() const;
  void set_pos_x(::google::protobuf::int32 value);

  // optional int32 pos_y = 14;
  bool has_pos_y() const;
  void clear_pos_y();
  static const int kPosYFieldNumber = 14;
  ::google::protobuf::int32 pos_y() const;
  void set_pos_y(::google::protobuf::int32 value);

  // required .pvp.UserInput.INPUT_OPCODE code = 1;
  bool has_code() const;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::pvp::UserInput_INPUT_OPCODE code() const;
  void set_code(::pvp::UserInput_INPUT_OPCODE value);

  // @@protoc_insertion_point(class_scope:pvp.UserInput)
 private:
  void set_has_code();
  void clear_has_code();
  void set_has_score();
  void clear_has_score();
  void set_has_star();
  void clear_has_star();
  void set_has_playerid();
  void clear_has_playerid();
  void set_has_cardid();
  void clear_has_cardid();
  void set_has_pos_x();
  void clear_has_pos_x();
  void set_has_pos_y();
  void clear_has_pos_y();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 score_;
  ::google::protobuf::int32 star_;
  ::google::protobuf::int32 playerid_;
  ::google::protobuf::int32 cardid_;
  ::google::protobuf::int32 pos_x_;
  ::google::protobuf::int32 pos_y_;
  int code_;
  friend struct ::protobuf_Pvp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CombatFrame : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pvp.CombatFrame) */ {
 public:
  CombatFrame();
  virtual ~CombatFrame();

  CombatFrame(const CombatFrame& from);

  inline CombatFrame& operator=(const CombatFrame& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CombatFrame(CombatFrame&& from) noexcept
    : CombatFrame() {
    *this = ::std::move(from);
  }

  inline CombatFrame& operator=(CombatFrame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const CombatFrame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CombatFrame* internal_default_instance() {
    return reinterpret_cast<const CombatFrame*>(
               &_CombatFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void UnsafeArenaSwap(CombatFrame* other);
  void Swap(CombatFrame* other);
  friend void swap(CombatFrame& a, CombatFrame& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CombatFrame* New() const final {
    return CreateMaybeMessage<CombatFrame>(NULL);
  }

  CombatFrame* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CombatFrame>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CombatFrame& from);
  void MergeFrom(const CombatFrame& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CombatFrame* other);
  protected:
  explicit CombatFrame(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CombatFrame_FRAME_STATE FRAME_STATE;
  static const FRAME_STATE FRAME_HEAD =
    CombatFrame_FRAME_STATE_FRAME_HEAD;
  static const FRAME_STATE FRAME_MIDDLE =
    CombatFrame_FRAME_STATE_FRAME_MIDDLE;
  static const FRAME_STATE FRAME_MIDDLE_WITH_INPUT =
    CombatFrame_FRAME_STATE_FRAME_MIDDLE_WITH_INPUT;
  static const FRAME_STATE FRAME_TAIL =
    CombatFrame_FRAME_STATE_FRAME_TAIL;
  static inline bool FRAME_STATE_IsValid(int value) {
    return CombatFrame_FRAME_STATE_IsValid(value);
  }
  static const FRAME_STATE FRAME_STATE_MIN =
    CombatFrame_FRAME_STATE_FRAME_STATE_MIN;
  static const FRAME_STATE FRAME_STATE_MAX =
    CombatFrame_FRAME_STATE_FRAME_STATE_MAX;
  static const int FRAME_STATE_ARRAYSIZE =
    CombatFrame_FRAME_STATE_FRAME_STATE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FRAME_STATE_descriptor() {
    return CombatFrame_FRAME_STATE_descriptor();
  }
  static inline const ::std::string& FRAME_STATE_Name(FRAME_STATE value) {
    return CombatFrame_FRAME_STATE_Name(value);
  }
  static inline bool FRAME_STATE_Parse(const ::std::string& name,
      FRAME_STATE* value) {
    return CombatFrame_FRAME_STATE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .pvp.UserInput input = 3;
  bool has_input() const;
  void clear_input();
  static const int kInputFieldNumber = 3;
  private:
  const ::pvp::UserInput& _internal_input() const;
  public:
  const ::pvp::UserInput& input() const;
  ::pvp::UserInput* release_input();
  ::pvp::UserInput* mutable_input();
  void set_allocated_input(::pvp::UserInput* input);
  void unsafe_arena_set_allocated_input(
      ::pvp::UserInput* input);
  ::pvp::UserInput* unsafe_arena_release_input();

  // required int64 frameid = 1;
  bool has_frameid() const;
  void clear_frameid();
  static const int kFrameidFieldNumber = 1;
  ::google::protobuf::int64 frameid() const;
  void set_frameid(::google::protobuf::int64 value);

  // required .pvp.CombatFrame.FRAME_STATE frame_state = 2;
  bool has_frame_state() const;
  void clear_frame_state();
  static const int kFrameStateFieldNumber = 2;
  ::pvp::CombatFrame_FRAME_STATE frame_state() const;
  void set_frame_state(::pvp::CombatFrame_FRAME_STATE value);

  // @@protoc_insertion_point(class_scope:pvp.CombatFrame)
 private:
  void set_has_frameid();
  void clear_has_frameid();
  void set_has_frame_state();
  void clear_has_frame_state();
  void set_has_input();
  void clear_has_input();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::pvp::UserInput* input_;
  ::google::protobuf::int64 frameid_;
  int frame_state_;
  friend struct ::protobuf_Pvp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CombatFrameList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pvp.CombatFrameList) */ {
 public:
  CombatFrameList();
  virtual ~CombatFrameList();

  CombatFrameList(const CombatFrameList& from);

  inline CombatFrameList& operator=(const CombatFrameList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CombatFrameList(CombatFrameList&& from) noexcept
    : CombatFrameList() {
    *this = ::std::move(from);
  }

  inline CombatFrameList& operator=(CombatFrameList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const CombatFrameList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CombatFrameList* internal_default_instance() {
    return reinterpret_cast<const CombatFrameList*>(
               &_CombatFrameList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void UnsafeArenaSwap(CombatFrameList* other);
  void Swap(CombatFrameList* other);
  friend void swap(CombatFrameList& a, CombatFrameList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CombatFrameList* New() const final {
    return CreateMaybeMessage<CombatFrameList>(NULL);
  }

  CombatFrameList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CombatFrameList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CombatFrameList& from);
  void MergeFrom(const CombatFrameList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CombatFrameList* other);
  protected:
  explicit CombatFrameList(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pvp.CombatFrame list = 1;
  int list_size() const;
  void clear_list();
  static const int kListFieldNumber = 1;
  ::pvp::CombatFrame* mutable_list(int index);
  ::google::protobuf::RepeatedPtrField< ::pvp::CombatFrame >*
      mutable_list();
  const ::pvp::CombatFrame& list(int index) const;
  ::pvp::CombatFrame* add_list();
  const ::google::protobuf::RepeatedPtrField< ::pvp::CombatFrame >&
      list() const;

  // @@protoc_insertion_point(class_scope:pvp.CombatFrameList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::pvp::CombatFrame > list_;
  friend struct ::protobuf_Pvp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CombatResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pvp.CombatResult) */ {
 public:
  CombatResult();
  virtual ~CombatResult();

  CombatResult(const CombatResult& from);

  inline CombatResult& operator=(const CombatResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CombatResult(CombatResult&& from) noexcept
    : CombatResult() {
    *this = ::std::move(from);
  }

  inline CombatResult& operator=(CombatResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const CombatResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CombatResult* internal_default_instance() {
    return reinterpret_cast<const CombatResult*>(
               &_CombatResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void UnsafeArenaSwap(CombatResult* other);
  void Swap(CombatResult* other);
  friend void swap(CombatResult& a, CombatResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CombatResult* New() const final {
    return CreateMaybeMessage<CombatResult>(NULL);
  }

  CombatResult* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CombatResult>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CombatResult& from);
  void MergeFrom(const CombatResult& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CombatResult* other);
  protected:
  explicit CombatResult(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 score = 2;
  bool has_score() const;
  void clear_score();
  static const int kScoreFieldNumber = 2;
  ::google::protobuf::int32 score() const;
  void set_score(::google::protobuf::int32 value);

  // optional int32 star = 3;
  bool has_star() const;
  void clear_star();
  static const int kStarFieldNumber = 3;
  ::google::protobuf::int32 star() const;
  void set_star(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pvp.CombatResult)
 private:
  void set_has_score();
  void clear_has_score();
  void set_has_star();
  void clear_has_star();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 score_;
  ::google::protobuf::int32 star_;
  friend struct ::protobuf_Pvp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PvpCombat : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pvp.PvpCombat) */ {
 public:
  PvpCombat();
  virtual ~PvpCombat();

  PvpCombat(const PvpCombat& from);

  inline PvpCombat& operator=(const PvpCombat& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PvpCombat(PvpCombat&& from) noexcept
    : PvpCombat() {
    *this = ::std::move(from);
  }

  inline PvpCombat& operator=(PvpCombat&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const PvpCombat& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PvpCombat* internal_default_instance() {
    return reinterpret_cast<const PvpCombat*>(
               &_PvpCombat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void UnsafeArenaSwap(PvpCombat* other);
  void Swap(PvpCombat* other);
  friend void swap(PvpCombat& a, PvpCombat& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PvpCombat* New() const final {
    return CreateMaybeMessage<PvpCombat>(NULL);
  }

  PvpCombat* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PvpCombat>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PvpCombat& from);
  void MergeFrom(const PvpCombat& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PvpCombat* other);
  protected:
  explicit PvpCombat(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pvp.StageData stage_data = 3;
  bool has_stage_data() const;
  void clear_stage_data();
  static const int kStageDataFieldNumber = 3;
  private:
  const ::pvp::StageData& _internal_stage_data() const;
  public:
  const ::pvp::StageData& stage_data() const;
  ::pvp::StageData* release_stage_data();
  ::pvp::StageData* mutable_stage_data();
  void set_allocated_stage_data(::pvp::StageData* stage_data);
  void unsafe_arena_set_allocated_stage_data(
      ::pvp::StageData* stage_data);
  ::pvp::StageData* unsafe_arena_release_stage_data();

  // optional .pvp.RandList rand_list = 4;
  bool has_rand_list() const;
  void clear_rand_list();
  static const int kRandListFieldNumber = 4;
  private:
  const ::pvp::RandList& _internal_rand_list() const;
  public:
  const ::pvp::RandList& rand_list() const;
  ::pvp::RandList* release_rand_list();
  ::pvp::RandList* mutable_rand_list();
  void set_allocated_rand_list(::pvp::RandList* rand_list);
  void unsafe_arena_set_allocated_rand_list(
      ::pvp::RandList* rand_list);
  ::pvp::RandList* unsafe_arena_release_rand_list();

  // required int32 combatid = 1;
  bool has_combatid() const;
  void clear_combatid();
  static const int kCombatidFieldNumber = 1;
  ::google::protobuf::int32 combatid() const;
  void set_combatid(::google::protobuf::int32 value);

  // required .pvp.COMBAT_TYPE combat_type = 2;
  bool has_combat_type() const;
  void clear_combat_type();
  static const int kCombatTypeFieldNumber = 2;
  ::pvp::COMBAT_TYPE combat_type() const;
  void set_combat_type(::pvp::COMBAT_TYPE value);

  // @@protoc_insertion_point(class_scope:pvp.PvpCombat)
 private:
  void set_has_combatid();
  void clear_has_combatid();
  void set_has_combat_type();
  void clear_has_combat_type();
  void set_has_stage_data();
  void clear_has_stage_data();
  void set_has_rand_list();
  void clear_has_rand_list();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::pvp::StageData* stage_data_;
  ::pvp::RandList* rand_list_;
  ::google::protobuf::int32 combatid_;
  int combat_type_;
  friend struct ::protobuf_Pvp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PvpService_PvpRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pvp.PvpService.PvpRequest) */ {
 public:
  PvpService_PvpRequest();
  virtual ~PvpService_PvpRequest();

  PvpService_PvpRequest(const PvpService_PvpRequest& from);

  inline PvpService_PvpRequest& operator=(const PvpService_PvpRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PvpService_PvpRequest(PvpService_PvpRequest&& from) noexcept
    : PvpService_PvpRequest() {
    *this = ::std::move(from);
  }

  inline PvpService_PvpRequest& operator=(PvpService_PvpRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const PvpService_PvpRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PvpService_PvpRequest* internal_default_instance() {
    return reinterpret_cast<const PvpService_PvpRequest*>(
               &_PvpService_PvpRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void UnsafeArenaSwap(PvpService_PvpRequest* other);
  void Swap(PvpService_PvpRequest* other);
  friend void swap(PvpService_PvpRequest& a, PvpService_PvpRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PvpService_PvpRequest* New() const final {
    return CreateMaybeMessage<PvpService_PvpRequest>(NULL);
  }

  PvpService_PvpRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PvpService_PvpRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PvpService_PvpRequest& from);
  void MergeFrom(const PvpService_PvpRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PvpService_PvpRequest* other);
  protected:
  explicit PvpService_PvpRequest(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 select_card_list = 11;
  int select_card_list_size() const;
  void clear_select_card_list();
  static const int kSelectCardListFieldNumber = 11;
  ::google::protobuf::int32 select_card_list(int index) const;
  void set_select_card_list(int index, ::google::protobuf::int32 value);
  void add_select_card_list(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      select_card_list() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_select_card_list();

  // optional .pvp.StageData stage_data = 3;
  bool has_stage_data() const;
  void clear_stage_data();
  static const int kStageDataFieldNumber = 3;
  private:
  const ::pvp::StageData& _internal_stage_data() const;
  public:
  const ::pvp::StageData& stage_data() const;
  ::pvp::StageData* release_stage_data();
  ::pvp::StageData* mutable_stage_data();
  void set_allocated_stage_data(::pvp::StageData* stage_data);
  void unsafe_arena_set_allocated_stage_data(
      ::pvp::StageData* stage_data);
  ::pvp::StageData* unsafe_arena_release_stage_data();

  // optional .pvp.CardList card_list = 4;
  bool has_card_list() const;
  void clear_card_list();
  static const int kCardListFieldNumber = 4;
  private:
  const ::pvp::CardList& _internal_card_list() const;
  public:
  const ::pvp::CardList& card_list() const;
  ::pvp::CardList* release_card_list();
  ::pvp::CardList* mutable_card_list();
  void set_allocated_card_list(::pvp::CardList* card_list);
  void unsafe_arena_set_allocated_card_list(
      ::pvp::CardList* card_list);
  ::pvp::CardList* unsafe_arena_release_card_list();

  // optional .pvp.UserInput user_input = 12;
  bool has_user_input() const;
  void clear_user_input();
  static const int kUserInputFieldNumber = 12;
  private:
  const ::pvp::UserInput& _internal_user_input() const;
  public:
  const ::pvp::UserInput& user_input() const;
  ::pvp::UserInput* release_user_input();
  ::pvp::UserInput* mutable_user_input();
  void set_allocated_user_input(::pvp::UserInput* user_input);
  void unsafe_arena_set_allocated_user_input(
      ::pvp::UserInput* user_input);
  ::pvp::UserInput* unsafe_arena_release_user_input();

  // optional .pvp.COMBAT_TYPE combat_type = 2;
  bool has_combat_type() const;
  void clear_combat_type();
  static const int kCombatTypeFieldNumber = 2;
  ::pvp::COMBAT_TYPE combat_type() const;
  void set_combat_type(::pvp::COMBAT_TYPE value);

  // required .pvp.PvpService.PVP_COMMAND cmd = 1;
  bool has_cmd() const;
  void clear_cmd();
  static const int kCmdFieldNumber = 1;
  ::pvp::PvpService_PVP_COMMAND cmd() const;
  void set_cmd(::pvp::PvpService_PVP_COMMAND value);

  // @@protoc_insertion_point(class_scope:pvp.PvpService.PvpRequest)
 private:
  void set_has_cmd();
  void clear_has_cmd();
  void set_has_combat_type();
  void clear_has_combat_type();
  void set_has_stage_data();
  void clear_has_stage_data();
  void set_has_card_list();
  void clear_has_card_list();
  void set_has_user_input();
  void clear_has_user_input();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > select_card_list_;
  ::pvp::StageData* stage_data_;
  ::pvp::CardList* card_list_;
  ::pvp::UserInput* user_input_;
  int combat_type_;
  int cmd_;
  friend struct ::protobuf_Pvp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PvpService_PvpResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pvp.PvpService.PvpResponse) */ {
 public:
  PvpService_PvpResponse();
  virtual ~PvpService_PvpResponse();

  PvpService_PvpResponse(const PvpService_PvpResponse& from);

  inline PvpService_PvpResponse& operator=(const PvpService_PvpResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PvpService_PvpResponse(PvpService_PvpResponse&& from) noexcept
    : PvpService_PvpResponse() {
    *this = ::std::move(from);
  }

  inline PvpService_PvpResponse& operator=(PvpService_PvpResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const PvpService_PvpResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PvpService_PvpResponse* internal_default_instance() {
    return reinterpret_cast<const PvpService_PvpResponse*>(
               &_PvpService_PvpResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void UnsafeArenaSwap(PvpService_PvpResponse* other);
  void Swap(PvpService_PvpResponse* other);
  friend void swap(PvpService_PvpResponse& a, PvpService_PvpResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PvpService_PvpResponse* New() const final {
    return CreateMaybeMessage<PvpService_PvpResponse>(NULL);
  }

  PvpService_PvpResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PvpService_PvpResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PvpService_PvpResponse& from);
  void MergeFrom(const PvpService_PvpResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PvpService_PvpResponse* other);
  protected:
  explicit PvpService_PvpResponse(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pvp.PvpCombat combat = 2;
  bool has_combat() const;
  void clear_combat();
  static const int kCombatFieldNumber = 2;
  private:
  const ::pvp::PvpCombat& _internal_combat() const;
  public:
  const ::pvp::PvpCombat& combat() const;
  ::pvp::PvpCombat* release_combat();
  ::pvp::PvpCombat* mutable_combat();
  void set_allocated_combat(::pvp::PvpCombat* combat);
  void unsafe_arena_set_allocated_combat(
      ::pvp::PvpCombat* combat);
  ::pvp::PvpCombat* unsafe_arena_release_combat();

  // required int32 result = 1;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::google::protobuf::int32 result() const;
  void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pvp.PvpService.PvpResponse)
 private:
  void set_has_result();
  void clear_has_result();
  void set_has_combat();
  void clear_has_combat();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::pvp::PvpCombat* combat_;
  ::google::protobuf::int32 result_;
  friend struct ::protobuf_Pvp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PvpService : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pvp.PvpService) */ {
 public:
  PvpService();
  virtual ~PvpService();

  PvpService(const PvpService& from);

  inline PvpService& operator=(const PvpService& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PvpService(PvpService&& from) noexcept
    : PvpService() {
    *this = ::std::move(from);
  }

  inline PvpService& operator=(PvpService&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const PvpService& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PvpService* internal_default_instance() {
    return reinterpret_cast<const PvpService*>(
               &_PvpService_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void UnsafeArenaSwap(PvpService* other);
  void Swap(PvpService* other);
  friend void swap(PvpService& a, PvpService& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PvpService* New() const final {
    return CreateMaybeMessage<PvpService>(NULL);
  }

  PvpService* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PvpService>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PvpService& from);
  void MergeFrom(const PvpService& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PvpService* other);
  protected:
  explicit PvpService(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PvpService_PvpRequest PvpRequest;
  typedef PvpService_PvpResponse PvpResponse;

  typedef PvpService_PVP_COMMAND PVP_COMMAND;
  static const PVP_COMMAND QUERY =
    PvpService_PVP_COMMAND_QUERY;
  static const PVP_COMMAND UPLOAD =
    PvpService_PVP_COMMAND_UPLOAD;
  static const PVP_COMMAND JOIN =
    PvpService_PVP_COMMAND_JOIN;
  static const PVP_COMMAND INPUT =
    PvpService_PVP_COMMAND_INPUT;
  static const PVP_COMMAND CANCEL =
    PvpService_PVP_COMMAND_CANCEL;
  static const PVP_COMMAND ACCEP_REWARD =
    PvpService_PVP_COMMAND_ACCEP_REWARD;
  static inline bool PVP_COMMAND_IsValid(int value) {
    return PvpService_PVP_COMMAND_IsValid(value);
  }
  static const PVP_COMMAND PVP_COMMAND_MIN =
    PvpService_PVP_COMMAND_PVP_COMMAND_MIN;
  static const PVP_COMMAND PVP_COMMAND_MAX =
    PvpService_PVP_COMMAND_PVP_COMMAND_MAX;
  static const int PVP_COMMAND_ARRAYSIZE =
    PvpService_PVP_COMMAND_PVP_COMMAND_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PVP_COMMAND_descriptor() {
    return PvpService_PVP_COMMAND_descriptor();
  }
  static inline const ::std::string& PVP_COMMAND_Name(PVP_COMMAND value) {
    return PvpService_PVP_COMMAND_Name(value);
  }
  static inline bool PVP_COMMAND_Parse(const ::std::string& name,
      PVP_COMMAND* value) {
    return PvpService_PVP_COMMAND_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .pvp.PvpService.PvpRequest req = 1;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 1;
  private:
  const ::pvp::PvpService_PvpRequest& _internal_req() const;
  public:
  const ::pvp::PvpService_PvpRequest& req() const;
  ::pvp::PvpService_PvpRequest* release_req();
  ::pvp::PvpService_PvpRequest* mutable_req();
  void set_allocated_req(::pvp::PvpService_PvpRequest* req);
  void unsafe_arena_set_allocated_req(
      ::pvp::PvpService_PvpRequest* req);
  ::pvp::PvpService_PvpRequest* unsafe_arena_release_req();

  // optional .pvp.PvpService.PvpResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  private:
  const ::pvp::PvpService_PvpResponse& _internal_resp() const;
  public:
  const ::pvp::PvpService_PvpResponse& resp() const;
  ::pvp::PvpService_PvpResponse* release_resp();
  ::pvp::PvpService_PvpResponse* mutable_resp();
  void set_allocated_resp(::pvp::PvpService_PvpResponse* resp);
  void unsafe_arena_set_allocated_resp(
      ::pvp::PvpService_PvpResponse* resp);
  ::pvp::PvpService_PvpResponse* unsafe_arena_release_resp();

  // @@protoc_insertion_point(class_scope:pvp.PvpService)
 private:
  void set_has_req();
  void clear_has_req();
  void set_has_resp();
  void clear_has_resp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::pvp::PvpService_PvpRequest* req_;
  ::pvp::PvpService_PvpResponse* resp_;
  friend struct ::protobuf_Pvp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PvpCombatStartNotify : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pvp.PvpCombatStartNotify) */ {
 public:
  PvpCombatStartNotify();
  virtual ~PvpCombatStartNotify();

  PvpCombatStartNotify(const PvpCombatStartNotify& from);

  inline PvpCombatStartNotify& operator=(const PvpCombatStartNotify& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PvpCombatStartNotify(PvpCombatStartNotify&& from) noexcept
    : PvpCombatStartNotify() {
    *this = ::std::move(from);
  }

  inline PvpCombatStartNotify& operator=(PvpCombatStartNotify&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const PvpCombatStartNotify& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PvpCombatStartNotify* internal_default_instance() {
    return reinterpret_cast<const PvpCombatStartNotify*>(
               &_PvpCombatStartNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void UnsafeArenaSwap(PvpCombatStartNotify* other);
  void Swap(PvpCombatStartNotify* other);
  friend void swap(PvpCombatStartNotify& a, PvpCombatStartNotify& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PvpCombatStartNotify* New() const final {
    return CreateMaybeMessage<PvpCombatStartNotify>(NULL);
  }

  PvpCombatStartNotify* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PvpCombatStartNotify>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PvpCombatStartNotify& from);
  void MergeFrom(const PvpCombatStartNotify& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PvpCombatStartNotify* other);
  protected:
  explicit PvpCombatStartNotify(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pvp.PlayerData player0 = 1;
  bool has_player0() const;
  void clear_player0();
  static const int kPlayer0FieldNumber = 1;
  private:
  const ::pvp::PlayerData& _internal_player0() const;
  public:
  const ::pvp::PlayerData& player0() const;
  ::pvp::PlayerData* release_player0();
  ::pvp::PlayerData* mutable_player0();
  void set_allocated_player0(::pvp::PlayerData* player0);
  void unsafe_arena_set_allocated_player0(
      ::pvp::PlayerData* player0);
  ::pvp::PlayerData* unsafe_arena_release_player0();

  // required .pvp.PlayerData player1 = 2;
  bool has_player1() const;
  void clear_player1();
  static const int kPlayer1FieldNumber = 2;
  private:
  const ::pvp::PlayerData& _internal_player1() const;
  public:
  const ::pvp::PlayerData& player1() const;
  ::pvp::PlayerData* release_player1();
  ::pvp::PlayerData* mutable_player1();
  void set_allocated_player1(::pvp::PlayerData* player1);
  void unsafe_arena_set_allocated_player1(
      ::pvp::PlayerData* player1);
  ::pvp::PlayerData* unsafe_arena_release_player1();

  // @@protoc_insertion_point(class_scope:pvp.PvpCombatStartNotify)
 private:
  void set_has_player0();
  void clear_has_player0();
  void set_has_player1();
  void clear_has_player1();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::pvp::PlayerData* player0_;
  ::pvp::PlayerData* player1_;
  friend struct ::protobuf_Pvp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PvpFrameNotify : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pvp.PvpFrameNotify) */ {
 public:
  PvpFrameNotify();
  virtual ~PvpFrameNotify();

  PvpFrameNotify(const PvpFrameNotify& from);

  inline PvpFrameNotify& operator=(const PvpFrameNotify& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PvpFrameNotify(PvpFrameNotify&& from) noexcept
    : PvpFrameNotify() {
    *this = ::std::move(from);
  }

  inline PvpFrameNotify& operator=(PvpFrameNotify&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const PvpFrameNotify& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PvpFrameNotify* internal_default_instance() {
    return reinterpret_cast<const PvpFrameNotify*>(
               &_PvpFrameNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void UnsafeArenaSwap(PvpFrameNotify* other);
  void Swap(PvpFrameNotify* other);
  friend void swap(PvpFrameNotify& a, PvpFrameNotify& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PvpFrameNotify* New() const final {
    return CreateMaybeMessage<PvpFrameNotify>(NULL);
  }

  PvpFrameNotify* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PvpFrameNotify>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PvpFrameNotify& from);
  void MergeFrom(const PvpFrameNotify& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PvpFrameNotify* other);
  protected:
  explicit PvpFrameNotify(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pvp.CombatFrameList frame_list = 1;
  bool has_frame_list() const;
  void clear_frame_list();
  static const int kFrameListFieldNumber = 1;
  private:
  const ::pvp::CombatFrameList& _internal_frame_list() const;
  public:
  const ::pvp::CombatFrameList& frame_list() const;
  ::pvp::CombatFrameList* release_frame_list();
  ::pvp::CombatFrameList* mutable_frame_list();
  void set_allocated_frame_list(::pvp::CombatFrameList* frame_list);
  void unsafe_arena_set_allocated_frame_list(
      ::pvp::CombatFrameList* frame_list);
  ::pvp::CombatFrameList* unsafe_arena_release_frame_list();

  // optional .pvp.CombatResult result = 2;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 2;
  private:
  const ::pvp::CombatResult& _internal_result() const;
  public:
  const ::pvp::CombatResult& result() const;
  ::pvp::CombatResult* release_result();
  ::pvp::CombatResult* mutable_result();
  void set_allocated_result(::pvp::CombatResult* result);
  void unsafe_arena_set_allocated_result(
      ::pvp::CombatResult* result);
  ::pvp::CombatResult* unsafe_arena_release_result();

  // @@protoc_insertion_point(class_scope:pvp.PvpFrameNotify)
 private:
  void set_has_frame_list();
  void clear_has_frame_list();
  void set_has_result();
  void clear_has_result();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::pvp::CombatFrameList* frame_list_;
  ::pvp::CombatResult* result_;
  friend struct ::protobuf_Pvp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PvpReward : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pvp.PvpReward) */ {
 public:
  PvpReward();
  virtual ~PvpReward();

  PvpReward(const PvpReward& from);

  inline PvpReward& operator=(const PvpReward& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PvpReward(PvpReward&& from) noexcept
    : PvpReward() {
    *this = ::std::move(from);
  }

  inline PvpReward& operator=(PvpReward&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const PvpReward& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PvpReward* internal_default_instance() {
    return reinterpret_cast<const PvpReward*>(
               &_PvpReward_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void UnsafeArenaSwap(PvpReward* other);
  void Swap(PvpReward* other);
  friend void swap(PvpReward& a, PvpReward& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PvpReward* New() const final {
    return CreateMaybeMessage<PvpReward>(NULL);
  }

  PvpReward* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PvpReward>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PvpReward& from);
  void MergeFrom(const PvpReward& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PvpReward* other);
  protected:
  explicit PvpReward(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 typeid = 1;
  bool has_typeid_() const;
  void clear_typeid_();
  static const int kTypeidFieldNumber = 1;
  ::google::protobuf::uint64 typeid_() const;
  void set_typeid_(::google::protobuf::uint64 value);

  // required uint64 num = 2;
  bool has_num() const;
  void clear_num();
  static const int kNumFieldNumber = 2;
  ::google::protobuf::uint64 num() const;
  void set_num(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pvp.PvpReward)
 private:
  void set_has_typeid_();
  void clear_has_typeid_();
  void set_has_num();
  void clear_has_num();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 typeid__;
  ::google::protobuf::uint64 num_;
  friend struct ::protobuf_Pvp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PvpRewardNotify : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pvp.PvpRewardNotify) */ {
 public:
  PvpRewardNotify();
  virtual ~PvpRewardNotify();

  PvpRewardNotify(const PvpRewardNotify& from);

  inline PvpRewardNotify& operator=(const PvpRewardNotify& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PvpRewardNotify(PvpRewardNotify&& from) noexcept
    : PvpRewardNotify() {
    *this = ::std::move(from);
  }

  inline PvpRewardNotify& operator=(PvpRewardNotify&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const PvpRewardNotify& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PvpRewardNotify* internal_default_instance() {
    return reinterpret_cast<const PvpRewardNotify*>(
               &_PvpRewardNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void UnsafeArenaSwap(PvpRewardNotify* other);
  void Swap(PvpRewardNotify* other);
  friend void swap(PvpRewardNotify& a, PvpRewardNotify& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PvpRewardNotify* New() const final {
    return CreateMaybeMessage<PvpRewardNotify>(NULL);
  }

  PvpRewardNotify* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PvpRewardNotify>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PvpRewardNotify& from);
  void MergeFrom(const PvpRewardNotify& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PvpRewardNotify* other);
  protected:
  explicit PvpRewardNotify(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pvp.PvpReward reward_list = 2;
  int reward_list_size() const;
  void clear_reward_list();
  static const int kRewardListFieldNumber = 2;
  ::pvp::PvpReward* mutable_reward_list(int index);
  ::google::protobuf::RepeatedPtrField< ::pvp::PvpReward >*
      mutable_reward_list();
  const ::pvp::PvpReward& reward_list(int index) const;
  ::pvp::PvpReward* add_reward_list();
  const ::google::protobuf::RepeatedPtrField< ::pvp::PvpReward >&
      reward_list() const;

  // required int32 combatid = 1;
  bool has_combatid() const;
  void clear_combatid();
  static const int kCombatidFieldNumber = 1;
  ::google::protobuf::int32 combatid() const;
  void set_combatid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pvp.PvpRewardNotify)
 private:
  void set_has_combatid();
  void clear_has_combatid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::pvp::PvpReward > reward_list_;
  ::google::protobuf::int32 combatid_;
  friend struct ::protobuf_Pvp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PvpEventLog : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pvp.PvpEventLog) */ {
 public:
  PvpEventLog();
  virtual ~PvpEventLog();

  PvpEventLog(const PvpEventLog& from);

  inline PvpEventLog& operator=(const PvpEventLog& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PvpEventLog(PvpEventLog&& from) noexcept
    : PvpEventLog() {
    *this = ::std::move(from);
  }

  inline PvpEventLog& operator=(PvpEventLog&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const PvpEventLog& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PvpEventLog* internal_default_instance() {
    return reinterpret_cast<const PvpEventLog*>(
               &_PvpEventLog_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void UnsafeArenaSwap(PvpEventLog* other);
  void Swap(PvpEventLog* other);
  friend void swap(PvpEventLog& a, PvpEventLog& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PvpEventLog* New() const final {
    return CreateMaybeMessage<PvpEventLog>(NULL);
  }

  PvpEventLog* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PvpEventLog>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PvpEventLog& from);
  void MergeFrom(const PvpEventLog& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PvpEventLog* other);
  protected:
  explicit PvpEventLog(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PvpEventLog_LOOT_STATE LOOT_STATE;
  static const LOOT_STATE IDLE =
    PvpEventLog_LOOT_STATE_IDLE;
  static const LOOT_STATE START =
    PvpEventLog_LOOT_STATE_START;
  static const LOOT_STATE OVER =
    PvpEventLog_LOOT_STATE_OVER;
  static const LOOT_STATE REFUND =
    PvpEventLog_LOOT_STATE_REFUND;
  static inline bool LOOT_STATE_IsValid(int value) {
    return PvpEventLog_LOOT_STATE_IsValid(value);
  }
  static const LOOT_STATE LOOT_STATE_MIN =
    PvpEventLog_LOOT_STATE_LOOT_STATE_MIN;
  static const LOOT_STATE LOOT_STATE_MAX =
    PvpEventLog_LOOT_STATE_LOOT_STATE_MAX;
  static const int LOOT_STATE_ARRAYSIZE =
    PvpEventLog_LOOT_STATE_LOOT_STATE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LOOT_STATE_descriptor() {
    return PvpEventLog_LOOT_STATE_descriptor();
  }
  static inline const ::std::string& LOOT_STATE_Name(LOOT_STATE value) {
    return PvpEventLog_LOOT_STATE_Name(value);
  }
  static inline bool LOOT_STATE_Parse(const ::std::string& name,
      LOOT_STATE* value) {
    return PvpEventLog_LOOT_STATE_Parse(name, value);
  }

  typedef PvpEventLog_DEFEND_STATE DEFEND_STATE;
  static const DEFEND_STATE SUSPEND =
    PvpEventLog_DEFEND_STATE_SUSPEND;
  static const DEFEND_STATE WIN =
    PvpEventLog_DEFEND_STATE_WIN;
  static const DEFEND_STATE LOSE =
    PvpEventLog_DEFEND_STATE_LOSE;
  static inline bool DEFEND_STATE_IsValid(int value) {
    return PvpEventLog_DEFEND_STATE_IsValid(value);
  }
  static const DEFEND_STATE DEFEND_STATE_MIN =
    PvpEventLog_DEFEND_STATE_DEFEND_STATE_MIN;
  static const DEFEND_STATE DEFEND_STATE_MAX =
    PvpEventLog_DEFEND_STATE_DEFEND_STATE_MAX;
  static const int DEFEND_STATE_ARRAYSIZE =
    PvpEventLog_DEFEND_STATE_DEFEND_STATE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DEFEND_STATE_descriptor() {
    return PvpEventLog_DEFEND_STATE_descriptor();
  }
  static inline const ::std::string& DEFEND_STATE_Name(DEFEND_STATE value) {
    return PvpEventLog_DEFEND_STATE_Name(value);
  }
  static inline bool DEFEND_STATE_Parse(const ::std::string& name,
      DEFEND_STATE* value) {
    return PvpEventLog_DEFEND_STATE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required bytes source_nick = 5;
  bool has_source_nick() const;
  void clear_source_nick();
  static const int kSourceNickFieldNumber = 5;
  const ::std::string& source_nick() const;
  void set_source_nick(const ::std::string& value);
  #if LANG_CXX11
  void set_source_nick(::std::string&& value);
  #endif
  void set_source_nick(const char* value);
  void set_source_nick(const void* value, size_t size);
  ::std::string* mutable_source_nick();
  ::std::string* release_source_nick();
  void set_allocated_source_nick(::std::string* source_nick);
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  ::std::string* unsafe_arena_release_source_nick();
  PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_source_nick(
      ::std::string* source_nick);

  // required .pvp.CardList source_card_list = 6;
  bool has_source_card_list() const;
  void clear_source_card_list();
  static const int kSourceCardListFieldNumber = 6;
  private:
  const ::pvp::CardList& _internal_source_card_list() const;
  public:
  const ::pvp::CardList& source_card_list() const;
  ::pvp::CardList* release_source_card_list();
  ::pvp::CardList* mutable_source_card_list();
  void set_allocated_source_card_list(::pvp::CardList* source_card_list);
  void unsafe_arena_set_allocated_source_card_list(
      ::pvp::CardList* source_card_list);
  ::pvp::CardList* unsafe_arena_release_source_card_list();

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // required int32 event_state = 3;
  bool has_event_state() const;
  void clear_event_state();
  static const int kEventStateFieldNumber = 3;
  ::google::protobuf::int32 event_state() const;
  void set_event_state(::google::protobuf::int32 value);

  // required .pvp.PvpEventLog.DEFEND_STATE defend_state = 4;
  bool has_defend_state() const;
  void clear_defend_state();
  static const int kDefendStateFieldNumber = 4;
  ::pvp::PvpEventLog_DEFEND_STATE defend_state() const;
  void set_defend_state(::pvp::PvpEventLog_DEFEND_STATE value);

  // required int32 gold_lock = 7;
  bool has_gold_lock() const;
  void clear_gold_lock();
  static const int kGoldLockFieldNumber = 7;
  ::google::protobuf::int32 gold_lock() const;
  void set_gold_lock(::google::protobuf::int32 value);

  // required int32 gold_refund = 8;
  bool has_gold_refund() const;
  void clear_gold_refund();
  static const int kGoldRefundFieldNumber = 8;
  ::google::protobuf::int32 gold_refund() const;
  void set_gold_refund(::google::protobuf::int32 value);

  // optional sfixed64 optime = 11;
  bool has_optime() const;
  void clear_optime();
  static const int kOptimeFieldNumber = 11;
  ::google::protobuf::int64 optime() const;
  void set_optime(::google::protobuf::int64 value);

  // required .pvp.PVP_EVENT_TYPE event_type = 2;
  bool has_event_type() const;
  void clear_event_type();
  static const int kEventTypeFieldNumber = 2;
  ::pvp::PVP_EVENT_TYPE event_type() const;
  void set_event_type(::pvp::PVP_EVENT_TYPE value);

  // @@protoc_insertion_point(class_scope:pvp.PvpEventLog)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_event_type();
  void clear_has_event_type();
  void set_has_event_state();
  void clear_has_event_state();
  void set_has_defend_state();
  void clear_has_defend_state();
  void set_has_source_nick();
  void clear_has_source_nick();
  void set_has_source_card_list();
  void clear_has_source_card_list();
  void set_has_gold_lock();
  void clear_has_gold_lock();
  void set_has_gold_refund();
  void clear_has_gold_refund();
  void set_has_optime();
  void clear_has_optime();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr source_nick_;
  ::pvp::CardList* source_card_list_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 event_state_;
  int defend_state_;
  ::google::protobuf::int32 gold_lock_;
  ::google::protobuf::int32 gold_refund_;
  ::google::protobuf::int64 optime_;
  int event_type_;
  friend struct ::protobuf_Pvp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PvpEventLogList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pvp.PvpEventLogList) */ {
 public:
  PvpEventLogList();
  virtual ~PvpEventLogList();

  PvpEventLogList(const PvpEventLogList& from);

  inline PvpEventLogList& operator=(const PvpEventLogList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PvpEventLogList(PvpEventLogList&& from) noexcept
    : PvpEventLogList() {
    *this = ::std::move(from);
  }

  inline PvpEventLogList& operator=(PvpEventLogList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const PvpEventLogList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PvpEventLogList* internal_default_instance() {
    return reinterpret_cast<const PvpEventLogList*>(
               &_PvpEventLogList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void UnsafeArenaSwap(PvpEventLogList* other);
  void Swap(PvpEventLogList* other);
  friend void swap(PvpEventLogList& a, PvpEventLogList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PvpEventLogList* New() const final {
    return CreateMaybeMessage<PvpEventLogList>(NULL);
  }

  PvpEventLogList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PvpEventLogList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PvpEventLogList& from);
  void MergeFrom(const PvpEventLogList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PvpEventLogList* other);
  protected:
  explicit PvpEventLogList(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pvp.PvpEventLog list = 1;
  int list_size() const;
  void clear_list();
  static const int kListFieldNumber = 1;
  ::pvp::PvpEventLog* mutable_list(int index);
  ::google::protobuf::RepeatedPtrField< ::pvp::PvpEventLog >*
      mutable_list();
  const ::pvp::PvpEventLog& list(int index) const;
  ::pvp::PvpEventLog* add_list();
  const ::google::protobuf::RepeatedPtrField< ::pvp::PvpEventLog >&
      list() const;

  // @@protoc_insertion_point(class_scope:pvp.PvpEventLogList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::pvp::PvpEventLog > list_;
  friend struct ::protobuf_Pvp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserPvpEventLogService_EventLogRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pvp.UserPvpEventLogService.EventLogRequest) */ {
 public:
  UserPvpEventLogService_EventLogRequest();
  virtual ~UserPvpEventLogService_EventLogRequest();

  UserPvpEventLogService_EventLogRequest(const UserPvpEventLogService_EventLogRequest& from);

  inline UserPvpEventLogService_EventLogRequest& operator=(const UserPvpEventLogService_EventLogRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserPvpEventLogService_EventLogRequest(UserPvpEventLogService_EventLogRequest&& from) noexcept
    : UserPvpEventLogService_EventLogRequest() {
    *this = ::std::move(from);
  }

  inline UserPvpEventLogService_EventLogRequest& operator=(UserPvpEventLogService_EventLogRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserPvpEventLogService_EventLogRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserPvpEventLogService_EventLogRequest* internal_default_instance() {
    return reinterpret_cast<const UserPvpEventLogService_EventLogRequest*>(
               &_UserPvpEventLogService_EventLogRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void UnsafeArenaSwap(UserPvpEventLogService_EventLogRequest* other);
  void Swap(UserPvpEventLogService_EventLogRequest* other);
  friend void swap(UserPvpEventLogService_EventLogRequest& a, UserPvpEventLogService_EventLogRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserPvpEventLogService_EventLogRequest* New() const final {
    return CreateMaybeMessage<UserPvpEventLogService_EventLogRequest>(NULL);
  }

  UserPvpEventLogService_EventLogRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserPvpEventLogService_EventLogRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserPvpEventLogService_EventLogRequest& from);
  void MergeFrom(const UserPvpEventLogService_EventLogRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserPvpEventLogService_EventLogRequest* other);
  protected:
  explicit UserPvpEventLogService_EventLogRequest(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 refund_id = 2;
  bool has_refund_id() const;
  void clear_refund_id();
  static const int kRefundIdFieldNumber = 2;
  ::google::protobuf::int32 refund_id() const;
  void set_refund_id(::google::protobuf::int32 value);

  // required .pvp.UserPvpEventLogService.EVENT_LOG_COMMAND cmd = 1;
  bool has_cmd() const;
  void clear_cmd();
  static const int kCmdFieldNumber = 1;
  ::pvp::UserPvpEventLogService_EVENT_LOG_COMMAND cmd() const;
  void set_cmd(::pvp::UserPvpEventLogService_EVENT_LOG_COMMAND value);

  // @@protoc_insertion_point(class_scope:pvp.UserPvpEventLogService.EventLogRequest)
 private:
  void set_has_cmd();
  void clear_has_cmd();
  void set_has_refund_id();
  void clear_has_refund_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 refund_id_;
  int cmd_;
  friend struct ::protobuf_Pvp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserPvpEventLogService_EventLogResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pvp.UserPvpEventLogService.EventLogResponse) */ {
 public:
  UserPvpEventLogService_EventLogResponse();
  virtual ~UserPvpEventLogService_EventLogResponse();

  UserPvpEventLogService_EventLogResponse(const UserPvpEventLogService_EventLogResponse& from);

  inline UserPvpEventLogService_EventLogResponse& operator=(const UserPvpEventLogService_EventLogResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserPvpEventLogService_EventLogResponse(UserPvpEventLogService_EventLogResponse&& from) noexcept
    : UserPvpEventLogService_EventLogResponse() {
    *this = ::std::move(from);
  }

  inline UserPvpEventLogService_EventLogResponse& operator=(UserPvpEventLogService_EventLogResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserPvpEventLogService_EventLogResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserPvpEventLogService_EventLogResponse* internal_default_instance() {
    return reinterpret_cast<const UserPvpEventLogService_EventLogResponse*>(
               &_UserPvpEventLogService_EventLogResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void UnsafeArenaSwap(UserPvpEventLogService_EventLogResponse* other);
  void Swap(UserPvpEventLogService_EventLogResponse* other);
  friend void swap(UserPvpEventLogService_EventLogResponse& a, UserPvpEventLogService_EventLogResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserPvpEventLogService_EventLogResponse* New() const final {
    return CreateMaybeMessage<UserPvpEventLogService_EventLogResponse>(NULL);
  }

  UserPvpEventLogService_EventLogResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserPvpEventLogService_EventLogResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserPvpEventLogService_EventLogResponse& from);
  void MergeFrom(const UserPvpEventLogService_EventLogResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserPvpEventLogService_EventLogResponse* other);
  protected:
  explicit UserPvpEventLogService_EventLogResponse(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pvp.PvpEventLogList log_list = 11;
  bool has_log_list() const;
  void clear_log_list();
  static const int kLogListFieldNumber = 11;
  private:
  const ::pvp::PvpEventLogList& _internal_log_list() const;
  public:
  const ::pvp::PvpEventLogList& log_list() const;
  ::pvp::PvpEventLogList* release_log_list();
  ::pvp::PvpEventLogList* mutable_log_list();
  void set_allocated_log_list(::pvp::PvpEventLogList* log_list);
  void unsafe_arena_set_allocated_log_list(
      ::pvp::PvpEventLogList* log_list);
  ::pvp::PvpEventLogList* unsafe_arena_release_log_list();

  // required int32 result = 1;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::google::protobuf::int32 result() const;
  void set_result(::google::protobuf::int32 value);

  // optional int32 gold_refund = 12;
  bool has_gold_refund() const;
  void clear_gold_refund();
  static const int kGoldRefundFieldNumber = 12;
  ::google::protobuf::int32 gold_refund() const;
  void set_gold_refund(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pvp.UserPvpEventLogService.EventLogResponse)
 private:
  void set_has_result();
  void clear_has_result();
  void set_has_log_list();
  void clear_has_log_list();
  void set_has_gold_refund();
  void clear_has_gold_refund();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::pvp::PvpEventLogList* log_list_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 gold_refund_;
  friend struct ::protobuf_Pvp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserPvpEventLogService : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pvp.UserPvpEventLogService) */ {
 public:
  UserPvpEventLogService();
  virtual ~UserPvpEventLogService();

  UserPvpEventLogService(const UserPvpEventLogService& from);

  inline UserPvpEventLogService& operator=(const UserPvpEventLogService& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserPvpEventLogService(UserPvpEventLogService&& from) noexcept
    : UserPvpEventLogService() {
    *this = ::std::move(from);
  }

  inline UserPvpEventLogService& operator=(UserPvpEventLogService&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserPvpEventLogService& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserPvpEventLogService* internal_default_instance() {
    return reinterpret_cast<const UserPvpEventLogService*>(
               &_UserPvpEventLogService_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void UnsafeArenaSwap(UserPvpEventLogService* other);
  void Swap(UserPvpEventLogService* other);
  friend void swap(UserPvpEventLogService& a, UserPvpEventLogService& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserPvpEventLogService* New() const final {
    return CreateMaybeMessage<UserPvpEventLogService>(NULL);
  }

  UserPvpEventLogService* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserPvpEventLogService>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserPvpEventLogService& from);
  void MergeFrom(const UserPvpEventLogService& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserPvpEventLogService* other);
  protected:
  explicit UserPvpEventLogService(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UserPvpEventLogService_EventLogRequest EventLogRequest;
  typedef UserPvpEventLogService_EventLogResponse EventLogResponse;

  typedef UserPvpEventLogService_EVENT_LOG_COMMAND EVENT_LOG_COMMAND;
  static const EVENT_LOG_COMMAND QUERY_LOG =
    UserPvpEventLogService_EVENT_LOG_COMMAND_QUERY_LOG;
  static const EVENT_LOG_COMMAND REFUND_LOG =
    UserPvpEventLogService_EVENT_LOG_COMMAND_REFUND_LOG;
  static inline bool EVENT_LOG_COMMAND_IsValid(int value) {
    return UserPvpEventLogService_EVENT_LOG_COMMAND_IsValid(value);
  }
  static const EVENT_LOG_COMMAND EVENT_LOG_COMMAND_MIN =
    UserPvpEventLogService_EVENT_LOG_COMMAND_EVENT_LOG_COMMAND_MIN;
  static const EVENT_LOG_COMMAND EVENT_LOG_COMMAND_MAX =
    UserPvpEventLogService_EVENT_LOG_COMMAND_EVENT_LOG_COMMAND_MAX;
  static const int EVENT_LOG_COMMAND_ARRAYSIZE =
    UserPvpEventLogService_EVENT_LOG_COMMAND_EVENT_LOG_COMMAND_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EVENT_LOG_COMMAND_descriptor() {
    return UserPvpEventLogService_EVENT_LOG_COMMAND_descriptor();
  }
  static inline const ::std::string& EVENT_LOG_COMMAND_Name(EVENT_LOG_COMMAND value) {
    return UserPvpEventLogService_EVENT_LOG_COMMAND_Name(value);
  }
  static inline bool EVENT_LOG_COMMAND_Parse(const ::std::string& name,
      EVENT_LOG_COMMAND* value) {
    return UserPvpEventLogService_EVENT_LOG_COMMAND_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .pvp.UserPvpEventLogService.EventLogRequest req = 1;
  bool has_req() const;
  void clear_req();
  static const int kReqFieldNumber = 1;
  private:
  const ::pvp::UserPvpEventLogService_EventLogRequest& _internal_req() const;
  public:
  const ::pvp::UserPvpEventLogService_EventLogRequest& req() const;
  ::pvp::UserPvpEventLogService_EventLogRequest* release_req();
  ::pvp::UserPvpEventLogService_EventLogRequest* mutable_req();
  void set_allocated_req(::pvp::UserPvpEventLogService_EventLogRequest* req);
  void unsafe_arena_set_allocated_req(
      ::pvp::UserPvpEventLogService_EventLogRequest* req);
  ::pvp::UserPvpEventLogService_EventLogRequest* unsafe_arena_release_req();

  // optional .pvp.UserPvpEventLogService.EventLogResponse resp = 2;
  bool has_resp() const;
  void clear_resp();
  static const int kRespFieldNumber = 2;
  private:
  const ::pvp::UserPvpEventLogService_EventLogResponse& _internal_resp() const;
  public:
  const ::pvp::UserPvpEventLogService_EventLogResponse& resp() const;
  ::pvp::UserPvpEventLogService_EventLogResponse* release_resp();
  ::pvp::UserPvpEventLogService_EventLogResponse* mutable_resp();
  void set_allocated_resp(::pvp::UserPvpEventLogService_EventLogResponse* resp);
  void unsafe_arena_set_allocated_resp(
      ::pvp::UserPvpEventLogService_EventLogResponse* resp);
  ::pvp::UserPvpEventLogService_EventLogResponse* unsafe_arena_release_resp();

  // @@protoc_insertion_point(class_scope:pvp.UserPvpEventLogService)
 private:
  void set_has_req();
  void clear_has_req();
  void set_has_resp();
  void clear_has_resp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::pvp::UserPvpEventLogService_EventLogRequest* req_;
  ::pvp::UserPvpEventLogService_EventLogResponse* resp_;
  friend struct ::protobuf_Pvp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PvpEventLogStateNotify : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pvp.PvpEventLogStateNotify) */ {
 public:
  PvpEventLogStateNotify();
  virtual ~PvpEventLogStateNotify();

  PvpEventLogStateNotify(const PvpEventLogStateNotify& from);

  inline PvpEventLogStateNotify& operator=(const PvpEventLogStateNotify& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PvpEventLogStateNotify(PvpEventLogStateNotify&& from) noexcept
    : PvpEventLogStateNotify() {
    *this = ::std::move(from);
  }

  inline PvpEventLogStateNotify& operator=(PvpEventLogStateNotify&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const PvpEventLogStateNotify& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PvpEventLogStateNotify* internal_default_instance() {
    return reinterpret_cast<const PvpEventLogStateNotify*>(
               &_PvpEventLogStateNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void UnsafeArenaSwap(PvpEventLogStateNotify* other);
  void Swap(PvpEventLogStateNotify* other);
  friend void swap(PvpEventLogStateNotify& a, PvpEventLogStateNotify& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PvpEventLogStateNotify* New() const final {
    return CreateMaybeMessage<PvpEventLogStateNotify>(NULL);
  }

  PvpEventLogStateNotify* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PvpEventLogStateNotify>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PvpEventLogStateNotify& from);
  void MergeFrom(const PvpEventLogStateNotify& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PvpEventLogStateNotify* other);
  protected:
  explicit PvpEventLogStateNotify(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pvp.PvpEventLogList log_list = 1;
  bool has_log_list() const;
  void clear_log_list();
  static const int kLogListFieldNumber = 1;
  private:
  const ::pvp::PvpEventLogList& _internal_log_list() const;
  public:
  const ::pvp::PvpEventLogList& log_list() const;
  ::pvp::PvpEventLogList* release_log_list();
  ::pvp::PvpEventLogList* mutable_log_list();
  void set_allocated_log_list(::pvp::PvpEventLogList* log_list);
  void unsafe_arena_set_allocated_log_list(
      ::pvp::PvpEventLogList* log_list);
  ::pvp::PvpEventLogList* unsafe_arena_release_log_list();

  // @@protoc_insertion_point(class_scope:pvp.PvpEventLogStateNotify)
 private:
  void set_has_log_list();
  void clear_has_log_list();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::pvp::PvpEventLogList* log_list_;
  friend struct ::protobuf_Pvp_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PvpLootNotify : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pvp.PvpLootNotify) */ {
 public:
  PvpLootNotify();
  virtual ~PvpLootNotify();

  PvpLootNotify(const PvpLootNotify& from);

  inline PvpLootNotify& operator=(const PvpLootNotify& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PvpLootNotify(PvpLootNotify&& from) noexcept
    : PvpLootNotify() {
    *this = ::std::move(from);
  }

  inline PvpLootNotify& operator=(PvpLootNotify&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const PvpLootNotify& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PvpLootNotify* internal_default_instance() {
    return reinterpret_cast<const PvpLootNotify*>(
               &_PvpLootNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void UnsafeArenaSwap(PvpLootNotify* other);
  void Swap(PvpLootNotify* other);
  friend void swap(PvpLootNotify& a, PvpLootNotify& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PvpLootNotify* New() const final {
    return CreateMaybeMessage<PvpLootNotify>(NULL);
  }

  PvpLootNotify* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PvpLootNotify>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PvpLootNotify& from);
  void MergeFrom(const PvpLootNotify& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PvpLootNotify* other);
  protected:
  explicit PvpLootNotify(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 win_gold = 1;
  bool has_win_gold() const;
  void clear_win_gold();
  static const int kWinGoldFieldNumber = 1;
  ::google::protobuf::int32 win_gold() const;
  void set_win_gold(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pvp.PvpLootNotify)
 private:
  void set_has_win_gold();
  void clear_has_win_gold();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 win_gold_;
  friend struct ::protobuf_Pvp_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RandList

// repeated int32 list = 1;
inline int RandList::list_size() const {
  return list_.size();
}
inline void RandList::clear_list() {
  list_.Clear();
}
inline ::google::protobuf::int32 RandList::list(int index) const {
  // @@protoc_insertion_point(field_get:pvp.RandList.list)
  return list_.Get(index);
}
inline void RandList::set_list(int index, ::google::protobuf::int32 value) {
  list_.Set(index, value);
  // @@protoc_insertion_point(field_set:pvp.RandList.list)
}
inline void RandList::add_list(::google::protobuf::int32 value) {
  list_.Add(value);
  // @@protoc_insertion_point(field_add:pvp.RandList.list)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
RandList::list() const {
  // @@protoc_insertion_point(field_list:pvp.RandList.list)
  return list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
RandList::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:pvp.RandList.list)
  return &list_;
}

// -------------------------------------------------------------------

// StageData

// required int32 serverid = 1;
inline bool StageData::has_serverid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StageData::set_has_serverid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StageData::clear_has_serverid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StageData::clear_serverid() {
  serverid_ = 0;
  clear_has_serverid();
}
inline ::google::protobuf::int32 StageData::serverid() const {
  // @@protoc_insertion_point(field_get:pvp.StageData.serverid)
  return serverid_;
}
inline void StageData::set_serverid(::google::protobuf::int32 value) {
  set_has_serverid();
  serverid_ = value;
  // @@protoc_insertion_point(field_set:pvp.StageData.serverid)
}

// required int32 stageid = 2;
inline bool StageData::has_stageid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StageData::set_has_stageid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StageData::clear_has_stageid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StageData::clear_stageid() {
  stageid_ = 0;
  clear_has_stageid();
}
inline ::google::protobuf::int32 StageData::stageid() const {
  // @@protoc_insertion_point(field_get:pvp.StageData.stageid)
  return stageid_;
}
inline void StageData::set_stageid(::google::protobuf::int32 value) {
  set_has_stageid();
  stageid_ = value;
  // @@protoc_insertion_point(field_set:pvp.StageData.stageid)
}

// required bytes name = 3;
inline bool StageData::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StageData::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StageData::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StageData::clear_name() {
  name_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_name();
}
inline const ::std::string& StageData::name() const {
  // @@protoc_insertion_point(field_get:pvp.StageData.name)
  return name_.Get();
}
inline void StageData::set_name(const ::std::string& value) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:pvp.StageData.name)
}
#if LANG_CXX11
inline void StageData::set_name(::std::string&& value) {
  set_has_name();
  name_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:pvp.StageData.name)
}
#endif
inline void StageData::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:pvp.StageData.name)
}
inline void StageData::set_name(const void* value,
    size_t size) {
  set_has_name();
  name_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:pvp.StageData.name)
}
inline ::std::string* StageData::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:pvp.StageData.name)
  return name_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* StageData::release_name() {
  // @@protoc_insertion_point(field_release:pvp.StageData.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void StageData::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:pvp.StageData.name)
}
inline ::std::string* StageData::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pvp.StageData.name)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_name();
  return name_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void StageData::unsafe_arena_set_allocated_name(
    ::std::string* name) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      name, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pvp.StageData.name)
}

// required bytes desc = 4;
inline bool StageData::has_desc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StageData::set_has_desc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StageData::clear_has_desc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StageData::clear_desc() {
  desc_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_desc();
}
inline const ::std::string& StageData::desc() const {
  // @@protoc_insertion_point(field_get:pvp.StageData.desc)
  return desc_.Get();
}
inline void StageData::set_desc(const ::std::string& value) {
  set_has_desc();
  desc_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:pvp.StageData.desc)
}
#if LANG_CXX11
inline void StageData::set_desc(::std::string&& value) {
  set_has_desc();
  desc_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:pvp.StageData.desc)
}
#endif
inline void StageData::set_desc(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_desc();
  desc_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:pvp.StageData.desc)
}
inline void StageData::set_desc(const void* value,
    size_t size) {
  set_has_desc();
  desc_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:pvp.StageData.desc)
}
inline ::std::string* StageData::mutable_desc() {
  set_has_desc();
  // @@protoc_insertion_point(field_mutable:pvp.StageData.desc)
  return desc_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* StageData::release_desc() {
  // @@protoc_insertion_point(field_release:pvp.StageData.desc)
  if (!has_desc()) {
    return NULL;
  }
  clear_has_desc();
  return desc_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void StageData::set_allocated_desc(::std::string* desc) {
  if (desc != NULL) {
    set_has_desc();
  } else {
    clear_has_desc();
  }
  desc_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), desc,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:pvp.StageData.desc)
}
inline ::std::string* StageData::unsafe_arena_release_desc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pvp.StageData.desc)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_desc();
  return desc_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void StageData::unsafe_arena_set_allocated_desc(
    ::std::string* desc) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (desc != NULL) {
    set_has_desc();
  } else {
    clear_has_desc();
  }
  desc_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      desc, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pvp.StageData.desc)
}

// required bytes data_bytes = 5;
inline bool StageData::has_data_bytes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StageData::set_has_data_bytes() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StageData::clear_has_data_bytes() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StageData::clear_data_bytes() {
  data_bytes_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_data_bytes();
}
inline const ::std::string& StageData::data_bytes() const {
  // @@protoc_insertion_point(field_get:pvp.StageData.data_bytes)
  return data_bytes_.Get();
}
inline void StageData::set_data_bytes(const ::std::string& value) {
  set_has_data_bytes();
  data_bytes_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:pvp.StageData.data_bytes)
}
#if LANG_CXX11
inline void StageData::set_data_bytes(::std::string&& value) {
  set_has_data_bytes();
  data_bytes_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:pvp.StageData.data_bytes)
}
#endif
inline void StageData::set_data_bytes(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_data_bytes();
  data_bytes_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:pvp.StageData.data_bytes)
}
inline void StageData::set_data_bytes(const void* value,
    size_t size) {
  set_has_data_bytes();
  data_bytes_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:pvp.StageData.data_bytes)
}
inline ::std::string* StageData::mutable_data_bytes() {
  set_has_data_bytes();
  // @@protoc_insertion_point(field_mutable:pvp.StageData.data_bytes)
  return data_bytes_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* StageData::release_data_bytes() {
  // @@protoc_insertion_point(field_release:pvp.StageData.data_bytes)
  if (!has_data_bytes()) {
    return NULL;
  }
  clear_has_data_bytes();
  return data_bytes_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void StageData::set_allocated_data_bytes(::std::string* data_bytes) {
  if (data_bytes != NULL) {
    set_has_data_bytes();
  } else {
    clear_has_data_bytes();
  }
  data_bytes_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data_bytes,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:pvp.StageData.data_bytes)
}
inline ::std::string* StageData::unsafe_arena_release_data_bytes() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pvp.StageData.data_bytes)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_data_bytes();
  return data_bytes_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void StageData::unsafe_arena_set_allocated_data_bytes(
    ::std::string* data_bytes) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (data_bytes != NULL) {
    set_has_data_bytes();
  } else {
    clear_has_data_bytes();
  }
  data_bytes_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      data_bytes, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pvp.StageData.data_bytes)
}

// optional int32 gold = 6;
inline bool StageData::has_gold() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void StageData::set_has_gold() {
  _has_bits_[0] |= 0x00000020u;
}
inline void StageData::clear_has_gold() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void StageData::clear_gold() {
  gold_ = 0;
  clear_has_gold();
}
inline ::google::protobuf::int32 StageData::gold() const {
  // @@protoc_insertion_point(field_get:pvp.StageData.gold)
  return gold_;
}
inline void StageData::set_gold(::google::protobuf::int32 value) {
  set_has_gold();
  gold_ = value;
  // @@protoc_insertion_point(field_set:pvp.StageData.gold)
}

// optional .pvp.PVP_STAGE_STATE state = 7;
inline bool StageData::has_state() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void StageData::set_has_state() {
  _has_bits_[0] |= 0x00000080u;
}
inline void StageData::clear_has_state() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void StageData::clear_state() {
  state_ = -1;
  clear_has_state();
}
inline ::pvp::PVP_STAGE_STATE StageData::state() const {
  // @@protoc_insertion_point(field_get:pvp.StageData.state)
  return static_cast< ::pvp::PVP_STAGE_STATE >(state_);
}
inline void StageData::set_state(::pvp::PVP_STAGE_STATE value) {
  assert(::pvp::PVP_STAGE_STATE_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:pvp.StageData.state)
}

// required sfixed64 optime = 11;
inline bool StageData::has_optime() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void StageData::set_has_optime() {
  _has_bits_[0] |= 0x00000040u;
}
inline void StageData::clear_has_optime() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void StageData::clear_optime() {
  optime_ = GOOGLE_LONGLONG(0);
  clear_has_optime();
}
inline ::google::protobuf::int64 StageData::optime() const {
  // @@protoc_insertion_point(field_get:pvp.StageData.optime)
  return optime_;
}
inline void StageData::set_optime(::google::protobuf::int64 value) {
  set_has_optime();
  optime_ = value;
  // @@protoc_insertion_point(field_set:pvp.StageData.optime)
}

// -------------------------------------------------------------------

// StageDataList

// repeated .pvp.StageData list = 1;
inline int StageDataList::list_size() const {
  return list_.size();
}
inline void StageDataList::clear_list() {
  list_.Clear();
}
inline ::pvp::StageData* StageDataList::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:pvp.StageDataList.list)
  return list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::pvp::StageData >*
StageDataList::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:pvp.StageDataList.list)
  return &list_;
}
inline const ::pvp::StageData& StageDataList::list(int index) const {
  // @@protoc_insertion_point(field_get:pvp.StageDataList.list)
  return list_.Get(index);
}
inline ::pvp::StageData* StageDataList::add_list() {
  // @@protoc_insertion_point(field_add:pvp.StageDataList.list)
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pvp::StageData >&
StageDataList::list() const {
  // @@protoc_insertion_point(field_list:pvp.StageDataList.list)
  return list_;
}

// -------------------------------------------------------------------

// CardList

// repeated .sg.Sailor list = 1;
inline int CardList::list_size() const {
  return list_.size();
}
inline ::sg::Sailor* CardList::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:pvp.CardList.list)
  return list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sg::Sailor >*
CardList::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:pvp.CardList.list)
  return &list_;
}
inline const ::sg::Sailor& CardList::list(int index) const {
  // @@protoc_insertion_point(field_get:pvp.CardList.list)
  return list_.Get(index);
}
inline ::sg::Sailor* CardList::add_list() {
  // @@protoc_insertion_point(field_add:pvp.CardList.list)
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sg::Sailor >&
CardList::list() const {
  // @@protoc_insertion_point(field_list:pvp.CardList.list)
  return list_;
}

// -------------------------------------------------------------------

// PlayerData

// required int32 pid = 1;
inline bool PlayerData::has_pid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerData::set_has_pid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerData::clear_has_pid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerData::clear_pid() {
  pid_ = 0;
  clear_has_pid();
}
inline ::google::protobuf::int32 PlayerData::pid() const {
  // @@protoc_insertion_point(field_get:pvp.PlayerData.pid)
  return pid_;
}
inline void PlayerData::set_pid(::google::protobuf::int32 value) {
  set_has_pid();
  pid_ = value;
  // @@protoc_insertion_point(field_set:pvp.PlayerData.pid)
}

// required uint64 uuid = 2;
inline bool PlayerData::has_uuid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerData::set_has_uuid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerData::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerData::clear_uuid() {
  uuid_ = GOOGLE_ULONGLONG(0);
  clear_has_uuid();
}
inline ::google::protobuf::uint64 PlayerData::uuid() const {
  // @@protoc_insertion_point(field_get:pvp.PlayerData.uuid)
  return uuid_;
}
inline void PlayerData::set_uuid(::google::protobuf::uint64 value) {
  set_has_uuid();
  uuid_ = value;
  // @@protoc_insertion_point(field_set:pvp.PlayerData.uuid)
}

// optional bytes nick = 3;
inline bool PlayerData::has_nick() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerData::set_has_nick() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerData::clear_has_nick() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerData::clear_nick() {
  nick_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_nick();
}
inline const ::std::string& PlayerData::nick() const {
  // @@protoc_insertion_point(field_get:pvp.PlayerData.nick)
  return nick_.Get();
}
inline void PlayerData::set_nick(const ::std::string& value) {
  set_has_nick();
  nick_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:pvp.PlayerData.nick)
}
#if LANG_CXX11
inline void PlayerData::set_nick(::std::string&& value) {
  set_has_nick();
  nick_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:pvp.PlayerData.nick)
}
#endif
inline void PlayerData::set_nick(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_nick();
  nick_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:pvp.PlayerData.nick)
}
inline void PlayerData::set_nick(const void* value,
    size_t size) {
  set_has_nick();
  nick_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:pvp.PlayerData.nick)
}
inline ::std::string* PlayerData::mutable_nick() {
  set_has_nick();
  // @@protoc_insertion_point(field_mutable:pvp.PlayerData.nick)
  return nick_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* PlayerData::release_nick() {
  // @@protoc_insertion_point(field_release:pvp.PlayerData.nick)
  if (!has_nick()) {
    return NULL;
  }
  clear_has_nick();
  return nick_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void PlayerData::set_allocated_nick(::std::string* nick) {
  if (nick != NULL) {
    set_has_nick();
  } else {
    clear_has_nick();
  }
  nick_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nick,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:pvp.PlayerData.nick)
}
inline ::std::string* PlayerData::unsafe_arena_release_nick() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pvp.PlayerData.nick)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_nick();
  return nick_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void PlayerData::unsafe_arena_set_allocated_nick(
    ::std::string* nick) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (nick != NULL) {
    set_has_nick();
  } else {
    clear_has_nick();
  }
  nick_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      nick, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pvp.PlayerData.nick)
}

// optional int32 level = 4;
inline bool PlayerData::has_level() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlayerData::set_has_level() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlayerData::clear_has_level() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlayerData::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 PlayerData::level() const {
  // @@protoc_insertion_point(field_get:pvp.PlayerData.level)
  return level_;
}
inline void PlayerData::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:pvp.PlayerData.level)
}

// optional .pvp.CardList card_list = 11;
inline bool PlayerData::has_card_list() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerData::set_has_card_list() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerData::clear_has_card_list() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerData::clear_card_list() {
  if (card_list_ != NULL) card_list_->Clear();
  clear_has_card_list();
}
inline const ::pvp::CardList& PlayerData::_internal_card_list() const {
  return *card_list_;
}
inline const ::pvp::CardList& PlayerData::card_list() const {
  const ::pvp::CardList* p = card_list_;
  // @@protoc_insertion_point(field_get:pvp.PlayerData.card_list)
  return p != NULL ? *p : *reinterpret_cast<const ::pvp::CardList*>(
      &::pvp::_CardList_default_instance_);
}
inline ::pvp::CardList* PlayerData::release_card_list() {
  // @@protoc_insertion_point(field_release:pvp.PlayerData.card_list)
  clear_has_card_list();
  ::pvp::CardList* temp = card_list_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  card_list_ = NULL;
  return temp;
}
inline ::pvp::CardList* PlayerData::unsafe_arena_release_card_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pvp.PlayerData.card_list)
  clear_has_card_list();
  ::pvp::CardList* temp = card_list_;
  card_list_ = NULL;
  return temp;
}
inline ::pvp::CardList* PlayerData::mutable_card_list() {
  set_has_card_list();
  if (card_list_ == NULL) {
    auto* p = CreateMaybeMessage<::pvp::CardList>(GetArenaNoVirtual());
    card_list_ = p;
  }
  // @@protoc_insertion_point(field_mutable:pvp.PlayerData.card_list)
  return card_list_;
}
inline void PlayerData::set_allocated_card_list(::pvp::CardList* card_list) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete card_list_;
  }
  if (card_list) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(card_list);
    if (message_arena != submessage_arena) {
      card_list = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, card_list, submessage_arena);
    }
    set_has_card_list();
  } else {
    clear_has_card_list();
  }
  card_list_ = card_list;
  // @@protoc_insertion_point(field_set_allocated:pvp.PlayerData.card_list)
}

// -------------------------------------------------------------------

// UserInput

// required .pvp.UserInput.INPUT_OPCODE code = 1;
inline bool UserInput::has_code() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserInput::set_has_code() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserInput::clear_has_code() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserInput::clear_code() {
  code_ = 1;
  clear_has_code();
}
inline ::pvp::UserInput_INPUT_OPCODE UserInput::code() const {
  // @@protoc_insertion_point(field_get:pvp.UserInput.code)
  return static_cast< ::pvp::UserInput_INPUT_OPCODE >(code_);
}
inline void UserInput::set_code(::pvp::UserInput_INPUT_OPCODE value) {
  assert(::pvp::UserInput_INPUT_OPCODE_IsValid(value));
  set_has_code();
  code_ = value;
  // @@protoc_insertion_point(field_set:pvp.UserInput.code)
}

// optional int32 score = 2;
inline bool UserInput::has_score() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserInput::set_has_score() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserInput::clear_has_score() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserInput::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline ::google::protobuf::int32 UserInput::score() const {
  // @@protoc_insertion_point(field_get:pvp.UserInput.score)
  return score_;
}
inline void UserInput::set_score(::google::protobuf::int32 value) {
  set_has_score();
  score_ = value;
  // @@protoc_insertion_point(field_set:pvp.UserInput.score)
}

// optional int32 star = 3;
inline bool UserInput::has_star() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserInput::set_has_star() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserInput::clear_has_star() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserInput::clear_star() {
  star_ = 0;
  clear_has_star();
}
inline ::google::protobuf::int32 UserInput::star() const {
  // @@protoc_insertion_point(field_get:pvp.UserInput.star)
  return star_;
}
inline void UserInput::set_star(::google::protobuf::int32 value) {
  set_has_star();
  star_ = value;
  // @@protoc_insertion_point(field_set:pvp.UserInput.star)
}

// optional int32 playerid = 11;
inline bool UserInput::has_playerid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserInput::set_has_playerid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserInput::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserInput::clear_playerid() {
  playerid_ = 0;
  clear_has_playerid();
}
inline ::google::protobuf::int32 UserInput::playerid() const {
  // @@protoc_insertion_point(field_get:pvp.UserInput.playerid)
  return playerid_;
}
inline void UserInput::set_playerid(::google::protobuf::int32 value) {
  set_has_playerid();
  playerid_ = value;
  // @@protoc_insertion_point(field_set:pvp.UserInput.playerid)
}

// optional int32 cardid = 12;
inline bool UserInput::has_cardid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserInput::set_has_cardid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserInput::clear_has_cardid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserInput::clear_cardid() {
  cardid_ = 0;
  clear_has_cardid();
}
inline ::google::protobuf::int32 UserInput::cardid() const {
  // @@protoc_insertion_point(field_get:pvp.UserInput.cardid)
  return cardid_;
}
inline void UserInput::set_cardid(::google::protobuf::int32 value) {
  set_has_cardid();
  cardid_ = value;
  // @@protoc_insertion_point(field_set:pvp.UserInput.cardid)
}

// optional int32 pos_x = 13;
inline bool UserInput::has_pos_x() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserInput::set_has_pos_x() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserInput::clear_has_pos_x() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserInput::clear_pos_x() {
  pos_x_ = 0;
  clear_has_pos_x();
}
inline ::google::protobuf::int32 UserInput::pos_x() const {
  // @@protoc_insertion_point(field_get:pvp.UserInput.pos_x)
  return pos_x_;
}
inline void UserInput::set_pos_x(::google::protobuf::int32 value) {
  set_has_pos_x();
  pos_x_ = value;
  // @@protoc_insertion_point(field_set:pvp.UserInput.pos_x)
}

// optional int32 pos_y = 14;
inline bool UserInput::has_pos_y() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserInput::set_has_pos_y() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserInput::clear_has_pos_y() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserInput::clear_pos_y() {
  pos_y_ = 0;
  clear_has_pos_y();
}
inline ::google::protobuf::int32 UserInput::pos_y() const {
  // @@protoc_insertion_point(field_get:pvp.UserInput.pos_y)
  return pos_y_;
}
inline void UserInput::set_pos_y(::google::protobuf::int32 value) {
  set_has_pos_y();
  pos_y_ = value;
  // @@protoc_insertion_point(field_set:pvp.UserInput.pos_y)
}

// -------------------------------------------------------------------

// CombatFrame

// required int64 frameid = 1;
inline bool CombatFrame::has_frameid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CombatFrame::set_has_frameid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CombatFrame::clear_has_frameid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CombatFrame::clear_frameid() {
  frameid_ = GOOGLE_LONGLONG(0);
  clear_has_frameid();
}
inline ::google::protobuf::int64 CombatFrame::frameid() const {
  // @@protoc_insertion_point(field_get:pvp.CombatFrame.frameid)
  return frameid_;
}
inline void CombatFrame::set_frameid(::google::protobuf::int64 value) {
  set_has_frameid();
  frameid_ = value;
  // @@protoc_insertion_point(field_set:pvp.CombatFrame.frameid)
}

// required .pvp.CombatFrame.FRAME_STATE frame_state = 2;
inline bool CombatFrame::has_frame_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CombatFrame::set_has_frame_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CombatFrame::clear_has_frame_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CombatFrame::clear_frame_state() {
  frame_state_ = 1;
  clear_has_frame_state();
}
inline ::pvp::CombatFrame_FRAME_STATE CombatFrame::frame_state() const {
  // @@protoc_insertion_point(field_get:pvp.CombatFrame.frame_state)
  return static_cast< ::pvp::CombatFrame_FRAME_STATE >(frame_state_);
}
inline void CombatFrame::set_frame_state(::pvp::CombatFrame_FRAME_STATE value) {
  assert(::pvp::CombatFrame_FRAME_STATE_IsValid(value));
  set_has_frame_state();
  frame_state_ = value;
  // @@protoc_insertion_point(field_set:pvp.CombatFrame.frame_state)
}

// optional .pvp.UserInput input = 3;
inline bool CombatFrame::has_input() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CombatFrame::set_has_input() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CombatFrame::clear_has_input() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CombatFrame::clear_input() {
  if (input_ != NULL) input_->Clear();
  clear_has_input();
}
inline const ::pvp::UserInput& CombatFrame::_internal_input() const {
  return *input_;
}
inline const ::pvp::UserInput& CombatFrame::input() const {
  const ::pvp::UserInput* p = input_;
  // @@protoc_insertion_point(field_get:pvp.CombatFrame.input)
  return p != NULL ? *p : *reinterpret_cast<const ::pvp::UserInput*>(
      &::pvp::_UserInput_default_instance_);
}
inline ::pvp::UserInput* CombatFrame::release_input() {
  // @@protoc_insertion_point(field_release:pvp.CombatFrame.input)
  clear_has_input();
  ::pvp::UserInput* temp = input_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  input_ = NULL;
  return temp;
}
inline ::pvp::UserInput* CombatFrame::unsafe_arena_release_input() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pvp.CombatFrame.input)
  clear_has_input();
  ::pvp::UserInput* temp = input_;
  input_ = NULL;
  return temp;
}
inline ::pvp::UserInput* CombatFrame::mutable_input() {
  set_has_input();
  if (input_ == NULL) {
    auto* p = CreateMaybeMessage<::pvp::UserInput>(GetArenaNoVirtual());
    input_ = p;
  }
  // @@protoc_insertion_point(field_mutable:pvp.CombatFrame.input)
  return input_;
}
inline void CombatFrame::set_allocated_input(::pvp::UserInput* input) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete input_;
  }
  if (input) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(input);
    if (message_arena != submessage_arena) {
      input = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, input, submessage_arena);
    }
    set_has_input();
  } else {
    clear_has_input();
  }
  input_ = input;
  // @@protoc_insertion_point(field_set_allocated:pvp.CombatFrame.input)
}

// -------------------------------------------------------------------

// CombatFrameList

// repeated .pvp.CombatFrame list = 1;
inline int CombatFrameList::list_size() const {
  return list_.size();
}
inline void CombatFrameList::clear_list() {
  list_.Clear();
}
inline ::pvp::CombatFrame* CombatFrameList::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:pvp.CombatFrameList.list)
  return list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::pvp::CombatFrame >*
CombatFrameList::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:pvp.CombatFrameList.list)
  return &list_;
}
inline const ::pvp::CombatFrame& CombatFrameList::list(int index) const {
  // @@protoc_insertion_point(field_get:pvp.CombatFrameList.list)
  return list_.Get(index);
}
inline ::pvp::CombatFrame* CombatFrameList::add_list() {
  // @@protoc_insertion_point(field_add:pvp.CombatFrameList.list)
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pvp::CombatFrame >&
CombatFrameList::list() const {
  // @@protoc_insertion_point(field_list:pvp.CombatFrameList.list)
  return list_;
}

// -------------------------------------------------------------------

// CombatResult

// optional int32 score = 2;
inline bool CombatResult::has_score() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CombatResult::set_has_score() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CombatResult::clear_has_score() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CombatResult::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline ::google::protobuf::int32 CombatResult::score() const {
  // @@protoc_insertion_point(field_get:pvp.CombatResult.score)
  return score_;
}
inline void CombatResult::set_score(::google::protobuf::int32 value) {
  set_has_score();
  score_ = value;
  // @@protoc_insertion_point(field_set:pvp.CombatResult.score)
}

// optional int32 star = 3;
inline bool CombatResult::has_star() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CombatResult::set_has_star() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CombatResult::clear_has_star() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CombatResult::clear_star() {
  star_ = 0;
  clear_has_star();
}
inline ::google::protobuf::int32 CombatResult::star() const {
  // @@protoc_insertion_point(field_get:pvp.CombatResult.star)
  return star_;
}
inline void CombatResult::set_star(::google::protobuf::int32 value) {
  set_has_star();
  star_ = value;
  // @@protoc_insertion_point(field_set:pvp.CombatResult.star)
}

// -------------------------------------------------------------------

// PvpCombat

// required int32 combatid = 1;
inline bool PvpCombat::has_combatid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PvpCombat::set_has_combatid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PvpCombat::clear_has_combatid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PvpCombat::clear_combatid() {
  combatid_ = 0;
  clear_has_combatid();
}
inline ::google::protobuf::int32 PvpCombat::combatid() const {
  // @@protoc_insertion_point(field_get:pvp.PvpCombat.combatid)
  return combatid_;
}
inline void PvpCombat::set_combatid(::google::protobuf::int32 value) {
  set_has_combatid();
  combatid_ = value;
  // @@protoc_insertion_point(field_set:pvp.PvpCombat.combatid)
}

// required .pvp.COMBAT_TYPE combat_type = 2;
inline bool PvpCombat::has_combat_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PvpCombat::set_has_combat_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PvpCombat::clear_has_combat_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PvpCombat::clear_combat_type() {
  combat_type_ = 0;
  clear_has_combat_type();
}
inline ::pvp::COMBAT_TYPE PvpCombat::combat_type() const {
  // @@protoc_insertion_point(field_get:pvp.PvpCombat.combat_type)
  return static_cast< ::pvp::COMBAT_TYPE >(combat_type_);
}
inline void PvpCombat::set_combat_type(::pvp::COMBAT_TYPE value) {
  assert(::pvp::COMBAT_TYPE_IsValid(value));
  set_has_combat_type();
  combat_type_ = value;
  // @@protoc_insertion_point(field_set:pvp.PvpCombat.combat_type)
}

// optional .pvp.StageData stage_data = 3;
inline bool PvpCombat::has_stage_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PvpCombat::set_has_stage_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PvpCombat::clear_has_stage_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PvpCombat::clear_stage_data() {
  if (stage_data_ != NULL) stage_data_->Clear();
  clear_has_stage_data();
}
inline const ::pvp::StageData& PvpCombat::_internal_stage_data() const {
  return *stage_data_;
}
inline const ::pvp::StageData& PvpCombat::stage_data() const {
  const ::pvp::StageData* p = stage_data_;
  // @@protoc_insertion_point(field_get:pvp.PvpCombat.stage_data)
  return p != NULL ? *p : *reinterpret_cast<const ::pvp::StageData*>(
      &::pvp::_StageData_default_instance_);
}
inline ::pvp::StageData* PvpCombat::release_stage_data() {
  // @@protoc_insertion_point(field_release:pvp.PvpCombat.stage_data)
  clear_has_stage_data();
  ::pvp::StageData* temp = stage_data_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  stage_data_ = NULL;
  return temp;
}
inline ::pvp::StageData* PvpCombat::unsafe_arena_release_stage_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pvp.PvpCombat.stage_data)
  clear_has_stage_data();
  ::pvp::StageData* temp = stage_data_;
  stage_data_ = NULL;
  return temp;
}
inline ::pvp::StageData* PvpCombat::mutable_stage_data() {
  set_has_stage_data();
  if (stage_data_ == NULL) {
    auto* p = CreateMaybeMessage<::pvp::StageData>(GetArenaNoVirtual());
    stage_data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:pvp.PvpCombat.stage_data)
  return stage_data_;
}
inline void PvpCombat::set_allocated_stage_data(::pvp::StageData* stage_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete stage_data_;
  }
  if (stage_data) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(stage_data);
    if (message_arena != submessage_arena) {
      stage_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, stage_data, submessage_arena);
    }
    set_has_stage_data();
  } else {
    clear_has_stage_data();
  }
  stage_data_ = stage_data;
  // @@protoc_insertion_point(field_set_allocated:pvp.PvpCombat.stage_data)
}

// optional .pvp.RandList rand_list = 4;
inline bool PvpCombat::has_rand_list() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PvpCombat::set_has_rand_list() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PvpCombat::clear_has_rand_list() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PvpCombat::clear_rand_list() {
  if (rand_list_ != NULL) rand_list_->Clear();
  clear_has_rand_list();
}
inline const ::pvp::RandList& PvpCombat::_internal_rand_list() const {
  return *rand_list_;
}
inline const ::pvp::RandList& PvpCombat::rand_list() const {
  const ::pvp::RandList* p = rand_list_;
  // @@protoc_insertion_point(field_get:pvp.PvpCombat.rand_list)
  return p != NULL ? *p : *reinterpret_cast<const ::pvp::RandList*>(
      &::pvp::_RandList_default_instance_);
}
inline ::pvp::RandList* PvpCombat::release_rand_list() {
  // @@protoc_insertion_point(field_release:pvp.PvpCombat.rand_list)
  clear_has_rand_list();
  ::pvp::RandList* temp = rand_list_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  rand_list_ = NULL;
  return temp;
}
inline ::pvp::RandList* PvpCombat::unsafe_arena_release_rand_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pvp.PvpCombat.rand_list)
  clear_has_rand_list();
  ::pvp::RandList* temp = rand_list_;
  rand_list_ = NULL;
  return temp;
}
inline ::pvp::RandList* PvpCombat::mutable_rand_list() {
  set_has_rand_list();
  if (rand_list_ == NULL) {
    auto* p = CreateMaybeMessage<::pvp::RandList>(GetArenaNoVirtual());
    rand_list_ = p;
  }
  // @@protoc_insertion_point(field_mutable:pvp.PvpCombat.rand_list)
  return rand_list_;
}
inline void PvpCombat::set_allocated_rand_list(::pvp::RandList* rand_list) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete rand_list_;
  }
  if (rand_list) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(rand_list);
    if (message_arena != submessage_arena) {
      rand_list = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rand_list, submessage_arena);
    }
    set_has_rand_list();
  } else {
    clear_has_rand_list();
  }
  rand_list_ = rand_list;
  // @@protoc_insertion_point(field_set_allocated:pvp.PvpCombat.rand_list)
}

// -------------------------------------------------------------------

// PvpService_PvpRequest

// required .pvp.PvpService.PVP_COMMAND cmd = 1;
inline bool PvpService_PvpRequest::has_cmd() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PvpService_PvpRequest::set_has_cmd() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PvpService_PvpRequest::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PvpService_PvpRequest::clear_cmd() {
  cmd_ = 1;
  clear_has_cmd();
}
inline ::pvp::PvpService_PVP_COMMAND PvpService_PvpRequest::cmd() const {
  // @@protoc_insertion_point(field_get:pvp.PvpService.PvpRequest.cmd)
  return static_cast< ::pvp::PvpService_PVP_COMMAND >(cmd_);
}
inline void PvpService_PvpRequest::set_cmd(::pvp::PvpService_PVP_COMMAND value) {
  assert(::pvp::PvpService_PVP_COMMAND_IsValid(value));
  set_has_cmd();
  cmd_ = value;
  // @@protoc_insertion_point(field_set:pvp.PvpService.PvpRequest.cmd)
}

// optional .pvp.COMBAT_TYPE combat_type = 2;
inline bool PvpService_PvpRequest::has_combat_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PvpService_PvpRequest::set_has_combat_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PvpService_PvpRequest::clear_has_combat_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PvpService_PvpRequest::clear_combat_type() {
  combat_type_ = 0;
  clear_has_combat_type();
}
inline ::pvp::COMBAT_TYPE PvpService_PvpRequest::combat_type() const {
  // @@protoc_insertion_point(field_get:pvp.PvpService.PvpRequest.combat_type)
  return static_cast< ::pvp::COMBAT_TYPE >(combat_type_);
}
inline void PvpService_PvpRequest::set_combat_type(::pvp::COMBAT_TYPE value) {
  assert(::pvp::COMBAT_TYPE_IsValid(value));
  set_has_combat_type();
  combat_type_ = value;
  // @@protoc_insertion_point(field_set:pvp.PvpService.PvpRequest.combat_type)
}

// optional .pvp.StageData stage_data = 3;
inline bool PvpService_PvpRequest::has_stage_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PvpService_PvpRequest::set_has_stage_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PvpService_PvpRequest::clear_has_stage_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PvpService_PvpRequest::clear_stage_data() {
  if (stage_data_ != NULL) stage_data_->Clear();
  clear_has_stage_data();
}
inline const ::pvp::StageData& PvpService_PvpRequest::_internal_stage_data() const {
  return *stage_data_;
}
inline const ::pvp::StageData& PvpService_PvpRequest::stage_data() const {
  const ::pvp::StageData* p = stage_data_;
  // @@protoc_insertion_point(field_get:pvp.PvpService.PvpRequest.stage_data)
  return p != NULL ? *p : *reinterpret_cast<const ::pvp::StageData*>(
      &::pvp::_StageData_default_instance_);
}
inline ::pvp::StageData* PvpService_PvpRequest::release_stage_data() {
  // @@protoc_insertion_point(field_release:pvp.PvpService.PvpRequest.stage_data)
  clear_has_stage_data();
  ::pvp::StageData* temp = stage_data_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  stage_data_ = NULL;
  return temp;
}
inline ::pvp::StageData* PvpService_PvpRequest::unsafe_arena_release_stage_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pvp.PvpService.PvpRequest.stage_data)
  clear_has_stage_data();
  ::pvp::StageData* temp = stage_data_;
  stage_data_ = NULL;
  return temp;
}
inline ::pvp::StageData* PvpService_PvpRequest::mutable_stage_data() {
  set_has_stage_data();
  if (stage_data_ == NULL) {
    auto* p = CreateMaybeMessage<::pvp::StageData>(GetArenaNoVirtual());
    stage_data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:pvp.PvpService.PvpRequest.stage_data)
  return stage_data_;
}
inline void PvpService_PvpRequest::set_allocated_stage_data(::pvp::StageData* stage_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete stage_data_;
  }
  if (stage_data) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(stage_data);
    if (message_arena != submessage_arena) {
      stage_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, stage_data, submessage_arena);
    }
    set_has_stage_data();
  } else {
    clear_has_stage_data();
  }
  stage_data_ = stage_data;
  // @@protoc_insertion_point(field_set_allocated:pvp.PvpService.PvpRequest.stage_data)
}

// optional .pvp.CardList card_list = 4;
inline bool PvpService_PvpRequest::has_card_list() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PvpService_PvpRequest::set_has_card_list() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PvpService_PvpRequest::clear_has_card_list() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PvpService_PvpRequest::clear_card_list() {
  if (card_list_ != NULL) card_list_->Clear();
  clear_has_card_list();
}
inline const ::pvp::CardList& PvpService_PvpRequest::_internal_card_list() const {
  return *card_list_;
}
inline const ::pvp::CardList& PvpService_PvpRequest::card_list() const {
  const ::pvp::CardList* p = card_list_;
  // @@protoc_insertion_point(field_get:pvp.PvpService.PvpRequest.card_list)
  return p != NULL ? *p : *reinterpret_cast<const ::pvp::CardList*>(
      &::pvp::_CardList_default_instance_);
}
inline ::pvp::CardList* PvpService_PvpRequest::release_card_list() {
  // @@protoc_insertion_point(field_release:pvp.PvpService.PvpRequest.card_list)
  clear_has_card_list();
  ::pvp::CardList* temp = card_list_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  card_list_ = NULL;
  return temp;
}
inline ::pvp::CardList* PvpService_PvpRequest::unsafe_arena_release_card_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pvp.PvpService.PvpRequest.card_list)
  clear_has_card_list();
  ::pvp::CardList* temp = card_list_;
  card_list_ = NULL;
  return temp;
}
inline ::pvp::CardList* PvpService_PvpRequest::mutable_card_list() {
  set_has_card_list();
  if (card_list_ == NULL) {
    auto* p = CreateMaybeMessage<::pvp::CardList>(GetArenaNoVirtual());
    card_list_ = p;
  }
  // @@protoc_insertion_point(field_mutable:pvp.PvpService.PvpRequest.card_list)
  return card_list_;
}
inline void PvpService_PvpRequest::set_allocated_card_list(::pvp::CardList* card_list) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete card_list_;
  }
  if (card_list) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(card_list);
    if (message_arena != submessage_arena) {
      card_list = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, card_list, submessage_arena);
    }
    set_has_card_list();
  } else {
    clear_has_card_list();
  }
  card_list_ = card_list;
  // @@protoc_insertion_point(field_set_allocated:pvp.PvpService.PvpRequest.card_list)
}

// repeated int32 select_card_list = 11;
inline int PvpService_PvpRequest::select_card_list_size() const {
  return select_card_list_.size();
}
inline void PvpService_PvpRequest::clear_select_card_list() {
  select_card_list_.Clear();
}
inline ::google::protobuf::int32 PvpService_PvpRequest::select_card_list(int index) const {
  // @@protoc_insertion_point(field_get:pvp.PvpService.PvpRequest.select_card_list)
  return select_card_list_.Get(index);
}
inline void PvpService_PvpRequest::set_select_card_list(int index, ::google::protobuf::int32 value) {
  select_card_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:pvp.PvpService.PvpRequest.select_card_list)
}
inline void PvpService_PvpRequest::add_select_card_list(::google::protobuf::int32 value) {
  select_card_list_.Add(value);
  // @@protoc_insertion_point(field_add:pvp.PvpService.PvpRequest.select_card_list)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PvpService_PvpRequest::select_card_list() const {
  // @@protoc_insertion_point(field_list:pvp.PvpService.PvpRequest.select_card_list)
  return select_card_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PvpService_PvpRequest::mutable_select_card_list() {
  // @@protoc_insertion_point(field_mutable_list:pvp.PvpService.PvpRequest.select_card_list)
  return &select_card_list_;
}

// optional .pvp.UserInput user_input = 12;
inline bool PvpService_PvpRequest::has_user_input() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PvpService_PvpRequest::set_has_user_input() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PvpService_PvpRequest::clear_has_user_input() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PvpService_PvpRequest::clear_user_input() {
  if (user_input_ != NULL) user_input_->Clear();
  clear_has_user_input();
}
inline const ::pvp::UserInput& PvpService_PvpRequest::_internal_user_input() const {
  return *user_input_;
}
inline const ::pvp::UserInput& PvpService_PvpRequest::user_input() const {
  const ::pvp::UserInput* p = user_input_;
  // @@protoc_insertion_point(field_get:pvp.PvpService.PvpRequest.user_input)
  return p != NULL ? *p : *reinterpret_cast<const ::pvp::UserInput*>(
      &::pvp::_UserInput_default_instance_);
}
inline ::pvp::UserInput* PvpService_PvpRequest::release_user_input() {
  // @@protoc_insertion_point(field_release:pvp.PvpService.PvpRequest.user_input)
  clear_has_user_input();
  ::pvp::UserInput* temp = user_input_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  user_input_ = NULL;
  return temp;
}
inline ::pvp::UserInput* PvpService_PvpRequest::unsafe_arena_release_user_input() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pvp.PvpService.PvpRequest.user_input)
  clear_has_user_input();
  ::pvp::UserInput* temp = user_input_;
  user_input_ = NULL;
  return temp;
}
inline ::pvp::UserInput* PvpService_PvpRequest::mutable_user_input() {
  set_has_user_input();
  if (user_input_ == NULL) {
    auto* p = CreateMaybeMessage<::pvp::UserInput>(GetArenaNoVirtual());
    user_input_ = p;
  }
  // @@protoc_insertion_point(field_mutable:pvp.PvpService.PvpRequest.user_input)
  return user_input_;
}
inline void PvpService_PvpRequest::set_allocated_user_input(::pvp::UserInput* user_input) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete user_input_;
  }
  if (user_input) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(user_input);
    if (message_arena != submessage_arena) {
      user_input = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user_input, submessage_arena);
    }
    set_has_user_input();
  } else {
    clear_has_user_input();
  }
  user_input_ = user_input;
  // @@protoc_insertion_point(field_set_allocated:pvp.PvpService.PvpRequest.user_input)
}

// -------------------------------------------------------------------

// PvpService_PvpResponse

// required int32 result = 1;
inline bool PvpService_PvpResponse::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PvpService_PvpResponse::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PvpService_PvpResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PvpService_PvpResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 PvpService_PvpResponse::result() const {
  // @@protoc_insertion_point(field_get:pvp.PvpService.PvpResponse.result)
  return result_;
}
inline void PvpService_PvpResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:pvp.PvpService.PvpResponse.result)
}

// optional .pvp.PvpCombat combat = 2;
inline bool PvpService_PvpResponse::has_combat() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PvpService_PvpResponse::set_has_combat() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PvpService_PvpResponse::clear_has_combat() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PvpService_PvpResponse::clear_combat() {
  if (combat_ != NULL) combat_->Clear();
  clear_has_combat();
}
inline const ::pvp::PvpCombat& PvpService_PvpResponse::_internal_combat() const {
  return *combat_;
}
inline const ::pvp::PvpCombat& PvpService_PvpResponse::combat() const {
  const ::pvp::PvpCombat* p = combat_;
  // @@protoc_insertion_point(field_get:pvp.PvpService.PvpResponse.combat)
  return p != NULL ? *p : *reinterpret_cast<const ::pvp::PvpCombat*>(
      &::pvp::_PvpCombat_default_instance_);
}
inline ::pvp::PvpCombat* PvpService_PvpResponse::release_combat() {
  // @@protoc_insertion_point(field_release:pvp.PvpService.PvpResponse.combat)
  clear_has_combat();
  ::pvp::PvpCombat* temp = combat_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  combat_ = NULL;
  return temp;
}
inline ::pvp::PvpCombat* PvpService_PvpResponse::unsafe_arena_release_combat() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pvp.PvpService.PvpResponse.combat)
  clear_has_combat();
  ::pvp::PvpCombat* temp = combat_;
  combat_ = NULL;
  return temp;
}
inline ::pvp::PvpCombat* PvpService_PvpResponse::mutable_combat() {
  set_has_combat();
  if (combat_ == NULL) {
    auto* p = CreateMaybeMessage<::pvp::PvpCombat>(GetArenaNoVirtual());
    combat_ = p;
  }
  // @@protoc_insertion_point(field_mutable:pvp.PvpService.PvpResponse.combat)
  return combat_;
}
inline void PvpService_PvpResponse::set_allocated_combat(::pvp::PvpCombat* combat) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete combat_;
  }
  if (combat) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(combat);
    if (message_arena != submessage_arena) {
      combat = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, combat, submessage_arena);
    }
    set_has_combat();
  } else {
    clear_has_combat();
  }
  combat_ = combat;
  // @@protoc_insertion_point(field_set_allocated:pvp.PvpService.PvpResponse.combat)
}

// -------------------------------------------------------------------

// PvpService

// optional .pvp.PvpService.PvpRequest req = 1;
inline bool PvpService::has_req() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PvpService::set_has_req() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PvpService::clear_has_req() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PvpService::clear_req() {
  if (req_ != NULL) req_->Clear();
  clear_has_req();
}
inline const ::pvp::PvpService_PvpRequest& PvpService::_internal_req() const {
  return *req_;
}
inline const ::pvp::PvpService_PvpRequest& PvpService::req() const {
  const ::pvp::PvpService_PvpRequest* p = req_;
  // @@protoc_insertion_point(field_get:pvp.PvpService.req)
  return p != NULL ? *p : *reinterpret_cast<const ::pvp::PvpService_PvpRequest*>(
      &::pvp::_PvpService_PvpRequest_default_instance_);
}
inline ::pvp::PvpService_PvpRequest* PvpService::release_req() {
  // @@protoc_insertion_point(field_release:pvp.PvpService.req)
  clear_has_req();
  ::pvp::PvpService_PvpRequest* temp = req_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  req_ = NULL;
  return temp;
}
inline ::pvp::PvpService_PvpRequest* PvpService::unsafe_arena_release_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pvp.PvpService.req)
  clear_has_req();
  ::pvp::PvpService_PvpRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline ::pvp::PvpService_PvpRequest* PvpService::mutable_req() {
  set_has_req();
  if (req_ == NULL) {
    auto* p = CreateMaybeMessage<::pvp::PvpService_PvpRequest>(GetArenaNoVirtual());
    req_ = p;
  }
  // @@protoc_insertion_point(field_mutable:pvp.PvpService.req)
  return req_;
}
inline void PvpService::set_allocated_req(::pvp::PvpService_PvpRequest* req) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete req_;
  }
  if (req) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(req);
    if (message_arena != submessage_arena) {
      req = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, req, submessage_arena);
    }
    set_has_req();
  } else {
    clear_has_req();
  }
  req_ = req;
  // @@protoc_insertion_point(field_set_allocated:pvp.PvpService.req)
}

// optional .pvp.PvpService.PvpResponse resp = 2;
inline bool PvpService::has_resp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PvpService::set_has_resp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PvpService::clear_has_resp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PvpService::clear_resp() {
  if (resp_ != NULL) resp_->Clear();
  clear_has_resp();
}
inline const ::pvp::PvpService_PvpResponse& PvpService::_internal_resp() const {
  return *resp_;
}
inline const ::pvp::PvpService_PvpResponse& PvpService::resp() const {
  const ::pvp::PvpService_PvpResponse* p = resp_;
  // @@protoc_insertion_point(field_get:pvp.PvpService.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::pvp::PvpService_PvpResponse*>(
      &::pvp::_PvpService_PvpResponse_default_instance_);
}
inline ::pvp::PvpService_PvpResponse* PvpService::release_resp() {
  // @@protoc_insertion_point(field_release:pvp.PvpService.resp)
  clear_has_resp();
  ::pvp::PvpService_PvpResponse* temp = resp_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  resp_ = NULL;
  return temp;
}
inline ::pvp::PvpService_PvpResponse* PvpService::unsafe_arena_release_resp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pvp.PvpService.resp)
  clear_has_resp();
  ::pvp::PvpService_PvpResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline ::pvp::PvpService_PvpResponse* PvpService::mutable_resp() {
  set_has_resp();
  if (resp_ == NULL) {
    auto* p = CreateMaybeMessage<::pvp::PvpService_PvpResponse>(GetArenaNoVirtual());
    resp_ = p;
  }
  // @@protoc_insertion_point(field_mutable:pvp.PvpService.resp)
  return resp_;
}
inline void PvpService::set_allocated_resp(::pvp::PvpService_PvpResponse* resp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete resp_;
  }
  if (resp) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(resp);
    if (message_arena != submessage_arena) {
      resp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, resp, submessage_arena);
    }
    set_has_resp();
  } else {
    clear_has_resp();
  }
  resp_ = resp;
  // @@protoc_insertion_point(field_set_allocated:pvp.PvpService.resp)
}

// -------------------------------------------------------------------

// PvpCombatStartNotify

// required .pvp.PlayerData player0 = 1;
inline bool PvpCombatStartNotify::has_player0() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PvpCombatStartNotify::set_has_player0() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PvpCombatStartNotify::clear_has_player0() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PvpCombatStartNotify::clear_player0() {
  if (player0_ != NULL) player0_->Clear();
  clear_has_player0();
}
inline const ::pvp::PlayerData& PvpCombatStartNotify::_internal_player0() const {
  return *player0_;
}
inline const ::pvp::PlayerData& PvpCombatStartNotify::player0() const {
  const ::pvp::PlayerData* p = player0_;
  // @@protoc_insertion_point(field_get:pvp.PvpCombatStartNotify.player0)
  return p != NULL ? *p : *reinterpret_cast<const ::pvp::PlayerData*>(
      &::pvp::_PlayerData_default_instance_);
}
inline ::pvp::PlayerData* PvpCombatStartNotify::release_player0() {
  // @@protoc_insertion_point(field_release:pvp.PvpCombatStartNotify.player0)
  clear_has_player0();
  ::pvp::PlayerData* temp = player0_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  player0_ = NULL;
  return temp;
}
inline ::pvp::PlayerData* PvpCombatStartNotify::unsafe_arena_release_player0() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pvp.PvpCombatStartNotify.player0)
  clear_has_player0();
  ::pvp::PlayerData* temp = player0_;
  player0_ = NULL;
  return temp;
}
inline ::pvp::PlayerData* PvpCombatStartNotify::mutable_player0() {
  set_has_player0();
  if (player0_ == NULL) {
    auto* p = CreateMaybeMessage<::pvp::PlayerData>(GetArenaNoVirtual());
    player0_ = p;
  }
  // @@protoc_insertion_point(field_mutable:pvp.PvpCombatStartNotify.player0)
  return player0_;
}
inline void PvpCombatStartNotify::set_allocated_player0(::pvp::PlayerData* player0) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete player0_;
  }
  if (player0) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(player0);
    if (message_arena != submessage_arena) {
      player0 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, player0, submessage_arena);
    }
    set_has_player0();
  } else {
    clear_has_player0();
  }
  player0_ = player0;
  // @@protoc_insertion_point(field_set_allocated:pvp.PvpCombatStartNotify.player0)
}

// required .pvp.PlayerData player1 = 2;
inline bool PvpCombatStartNotify::has_player1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PvpCombatStartNotify::set_has_player1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PvpCombatStartNotify::clear_has_player1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PvpCombatStartNotify::clear_player1() {
  if (player1_ != NULL) player1_->Clear();
  clear_has_player1();
}
inline const ::pvp::PlayerData& PvpCombatStartNotify::_internal_player1() const {
  return *player1_;
}
inline const ::pvp::PlayerData& PvpCombatStartNotify::player1() const {
  const ::pvp::PlayerData* p = player1_;
  // @@protoc_insertion_point(field_get:pvp.PvpCombatStartNotify.player1)
  return p != NULL ? *p : *reinterpret_cast<const ::pvp::PlayerData*>(
      &::pvp::_PlayerData_default_instance_);
}
inline ::pvp::PlayerData* PvpCombatStartNotify::release_player1() {
  // @@protoc_insertion_point(field_release:pvp.PvpCombatStartNotify.player1)
  clear_has_player1();
  ::pvp::PlayerData* temp = player1_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  player1_ = NULL;
  return temp;
}
inline ::pvp::PlayerData* PvpCombatStartNotify::unsafe_arena_release_player1() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pvp.PvpCombatStartNotify.player1)
  clear_has_player1();
  ::pvp::PlayerData* temp = player1_;
  player1_ = NULL;
  return temp;
}
inline ::pvp::PlayerData* PvpCombatStartNotify::mutable_player1() {
  set_has_player1();
  if (player1_ == NULL) {
    auto* p = CreateMaybeMessage<::pvp::PlayerData>(GetArenaNoVirtual());
    player1_ = p;
  }
  // @@protoc_insertion_point(field_mutable:pvp.PvpCombatStartNotify.player1)
  return player1_;
}
inline void PvpCombatStartNotify::set_allocated_player1(::pvp::PlayerData* player1) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete player1_;
  }
  if (player1) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(player1);
    if (message_arena != submessage_arena) {
      player1 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, player1, submessage_arena);
    }
    set_has_player1();
  } else {
    clear_has_player1();
  }
  player1_ = player1;
  // @@protoc_insertion_point(field_set_allocated:pvp.PvpCombatStartNotify.player1)
}

// -------------------------------------------------------------------

// PvpFrameNotify

// required .pvp.CombatFrameList frame_list = 1;
inline bool PvpFrameNotify::has_frame_list() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PvpFrameNotify::set_has_frame_list() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PvpFrameNotify::clear_has_frame_list() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PvpFrameNotify::clear_frame_list() {
  if (frame_list_ != NULL) frame_list_->Clear();
  clear_has_frame_list();
}
inline const ::pvp::CombatFrameList& PvpFrameNotify::_internal_frame_list() const {
  return *frame_list_;
}
inline const ::pvp::CombatFrameList& PvpFrameNotify::frame_list() const {
  const ::pvp::CombatFrameList* p = frame_list_;
  // @@protoc_insertion_point(field_get:pvp.PvpFrameNotify.frame_list)
  return p != NULL ? *p : *reinterpret_cast<const ::pvp::CombatFrameList*>(
      &::pvp::_CombatFrameList_default_instance_);
}
inline ::pvp::CombatFrameList* PvpFrameNotify::release_frame_list() {
  // @@protoc_insertion_point(field_release:pvp.PvpFrameNotify.frame_list)
  clear_has_frame_list();
  ::pvp::CombatFrameList* temp = frame_list_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  frame_list_ = NULL;
  return temp;
}
inline ::pvp::CombatFrameList* PvpFrameNotify::unsafe_arena_release_frame_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pvp.PvpFrameNotify.frame_list)
  clear_has_frame_list();
  ::pvp::CombatFrameList* temp = frame_list_;
  frame_list_ = NULL;
  return temp;
}
inline ::pvp::CombatFrameList* PvpFrameNotify::mutable_frame_list() {
  set_has_frame_list();
  if (frame_list_ == NULL) {
    auto* p = CreateMaybeMessage<::pvp::CombatFrameList>(GetArenaNoVirtual());
    frame_list_ = p;
  }
  // @@protoc_insertion_point(field_mutable:pvp.PvpFrameNotify.frame_list)
  return frame_list_;
}
inline void PvpFrameNotify::set_allocated_frame_list(::pvp::CombatFrameList* frame_list) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete frame_list_;
  }
  if (frame_list) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(frame_list);
    if (message_arena != submessage_arena) {
      frame_list = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, frame_list, submessage_arena);
    }
    set_has_frame_list();
  } else {
    clear_has_frame_list();
  }
  frame_list_ = frame_list;
  // @@protoc_insertion_point(field_set_allocated:pvp.PvpFrameNotify.frame_list)
}

// optional .pvp.CombatResult result = 2;
inline bool PvpFrameNotify::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PvpFrameNotify::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PvpFrameNotify::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PvpFrameNotify::clear_result() {
  if (result_ != NULL) result_->Clear();
  clear_has_result();
}
inline const ::pvp::CombatResult& PvpFrameNotify::_internal_result() const {
  return *result_;
}
inline const ::pvp::CombatResult& PvpFrameNotify::result() const {
  const ::pvp::CombatResult* p = result_;
  // @@protoc_insertion_point(field_get:pvp.PvpFrameNotify.result)
  return p != NULL ? *p : *reinterpret_cast<const ::pvp::CombatResult*>(
      &::pvp::_CombatResult_default_instance_);
}
inline ::pvp::CombatResult* PvpFrameNotify::release_result() {
  // @@protoc_insertion_point(field_release:pvp.PvpFrameNotify.result)
  clear_has_result();
  ::pvp::CombatResult* temp = result_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  result_ = NULL;
  return temp;
}
inline ::pvp::CombatResult* PvpFrameNotify::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pvp.PvpFrameNotify.result)
  clear_has_result();
  ::pvp::CombatResult* temp = result_;
  result_ = NULL;
  return temp;
}
inline ::pvp::CombatResult* PvpFrameNotify::mutable_result() {
  set_has_result();
  if (result_ == NULL) {
    auto* p = CreateMaybeMessage<::pvp::CombatResult>(GetArenaNoVirtual());
    result_ = p;
  }
  // @@protoc_insertion_point(field_mutable:pvp.PvpFrameNotify.result)
  return result_;
}
inline void PvpFrameNotify::set_allocated_result(::pvp::CombatResult* result) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete result_;
  }
  if (result) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(result);
    if (message_arena != submessage_arena) {
      result = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    set_has_result();
  } else {
    clear_has_result();
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:pvp.PvpFrameNotify.result)
}

// -------------------------------------------------------------------

// PvpReward

// required uint64 typeid = 1;
inline bool PvpReward::has_typeid_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PvpReward::set_has_typeid_() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PvpReward::clear_has_typeid_() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PvpReward::clear_typeid_() {
  typeid__ = GOOGLE_ULONGLONG(0);
  clear_has_typeid_();
}
inline ::google::protobuf::uint64 PvpReward::typeid_() const {
  // @@protoc_insertion_point(field_get:pvp.PvpReward.typeid)
  return typeid__;
}
inline void PvpReward::set_typeid_(::google::protobuf::uint64 value) {
  set_has_typeid_();
  typeid__ = value;
  // @@protoc_insertion_point(field_set:pvp.PvpReward.typeid)
}

// required uint64 num = 2;
inline bool PvpReward::has_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PvpReward::set_has_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PvpReward::clear_has_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PvpReward::clear_num() {
  num_ = GOOGLE_ULONGLONG(0);
  clear_has_num();
}
inline ::google::protobuf::uint64 PvpReward::num() const {
  // @@protoc_insertion_point(field_get:pvp.PvpReward.num)
  return num_;
}
inline void PvpReward::set_num(::google::protobuf::uint64 value) {
  set_has_num();
  num_ = value;
  // @@protoc_insertion_point(field_set:pvp.PvpReward.num)
}

// -------------------------------------------------------------------

// PvpRewardNotify

// required int32 combatid = 1;
inline bool PvpRewardNotify::has_combatid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PvpRewardNotify::set_has_combatid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PvpRewardNotify::clear_has_combatid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PvpRewardNotify::clear_combatid() {
  combatid_ = 0;
  clear_has_combatid();
}
inline ::google::protobuf::int32 PvpRewardNotify::combatid() const {
  // @@protoc_insertion_point(field_get:pvp.PvpRewardNotify.combatid)
  return combatid_;
}
inline void PvpRewardNotify::set_combatid(::google::protobuf::int32 value) {
  set_has_combatid();
  combatid_ = value;
  // @@protoc_insertion_point(field_set:pvp.PvpRewardNotify.combatid)
}

// repeated .pvp.PvpReward reward_list = 2;
inline int PvpRewardNotify::reward_list_size() const {
  return reward_list_.size();
}
inline void PvpRewardNotify::clear_reward_list() {
  reward_list_.Clear();
}
inline ::pvp::PvpReward* PvpRewardNotify::mutable_reward_list(int index) {
  // @@protoc_insertion_point(field_mutable:pvp.PvpRewardNotify.reward_list)
  return reward_list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::pvp::PvpReward >*
PvpRewardNotify::mutable_reward_list() {
  // @@protoc_insertion_point(field_mutable_list:pvp.PvpRewardNotify.reward_list)
  return &reward_list_;
}
inline const ::pvp::PvpReward& PvpRewardNotify::reward_list(int index) const {
  // @@protoc_insertion_point(field_get:pvp.PvpRewardNotify.reward_list)
  return reward_list_.Get(index);
}
inline ::pvp::PvpReward* PvpRewardNotify::add_reward_list() {
  // @@protoc_insertion_point(field_add:pvp.PvpRewardNotify.reward_list)
  return reward_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pvp::PvpReward >&
PvpRewardNotify::reward_list() const {
  // @@protoc_insertion_point(field_list:pvp.PvpRewardNotify.reward_list)
  return reward_list_;
}

// -------------------------------------------------------------------

// PvpEventLog

// required int32 id = 1;
inline bool PvpEventLog::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PvpEventLog::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PvpEventLog::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PvpEventLog::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 PvpEventLog::id() const {
  // @@protoc_insertion_point(field_get:pvp.PvpEventLog.id)
  return id_;
}
inline void PvpEventLog::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:pvp.PvpEventLog.id)
}

// required .pvp.PVP_EVENT_TYPE event_type = 2;
inline bool PvpEventLog::has_event_type() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PvpEventLog::set_has_event_type() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PvpEventLog::clear_has_event_type() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PvpEventLog::clear_event_type() {
  event_type_ = 1;
  clear_has_event_type();
}
inline ::pvp::PVP_EVENT_TYPE PvpEventLog::event_type() const {
  // @@protoc_insertion_point(field_get:pvp.PvpEventLog.event_type)
  return static_cast< ::pvp::PVP_EVENT_TYPE >(event_type_);
}
inline void PvpEventLog::set_event_type(::pvp::PVP_EVENT_TYPE value) {
  assert(::pvp::PVP_EVENT_TYPE_IsValid(value));
  set_has_event_type();
  event_type_ = value;
  // @@protoc_insertion_point(field_set:pvp.PvpEventLog.event_type)
}

// required int32 event_state = 3;
inline bool PvpEventLog::has_event_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PvpEventLog::set_has_event_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PvpEventLog::clear_has_event_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PvpEventLog::clear_event_state() {
  event_state_ = 0;
  clear_has_event_state();
}
inline ::google::protobuf::int32 PvpEventLog::event_state() const {
  // @@protoc_insertion_point(field_get:pvp.PvpEventLog.event_state)
  return event_state_;
}
inline void PvpEventLog::set_event_state(::google::protobuf::int32 value) {
  set_has_event_state();
  event_state_ = value;
  // @@protoc_insertion_point(field_set:pvp.PvpEventLog.event_state)
}

// required .pvp.PvpEventLog.DEFEND_STATE defend_state = 4;
inline bool PvpEventLog::has_defend_state() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PvpEventLog::set_has_defend_state() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PvpEventLog::clear_has_defend_state() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PvpEventLog::clear_defend_state() {
  defend_state_ = 0;
  clear_has_defend_state();
}
inline ::pvp::PvpEventLog_DEFEND_STATE PvpEventLog::defend_state() const {
  // @@protoc_insertion_point(field_get:pvp.PvpEventLog.defend_state)
  return static_cast< ::pvp::PvpEventLog_DEFEND_STATE >(defend_state_);
}
inline void PvpEventLog::set_defend_state(::pvp::PvpEventLog_DEFEND_STATE value) {
  assert(::pvp::PvpEventLog_DEFEND_STATE_IsValid(value));
  set_has_defend_state();
  defend_state_ = value;
  // @@protoc_insertion_point(field_set:pvp.PvpEventLog.defend_state)
}

// required bytes source_nick = 5;
inline bool PvpEventLog::has_source_nick() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PvpEventLog::set_has_source_nick() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PvpEventLog::clear_has_source_nick() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PvpEventLog::clear_source_nick() {
  source_nick_.ClearToEmpty(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
  clear_has_source_nick();
}
inline const ::std::string& PvpEventLog::source_nick() const {
  // @@protoc_insertion_point(field_get:pvp.PvpEventLog.source_nick)
  return source_nick_.Get();
}
inline void PvpEventLog::set_source_nick(const ::std::string& value) {
  set_has_source_nick();
  source_nick_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set:pvp.PvpEventLog.source_nick)
}
#if LANG_CXX11
inline void PvpEventLog::set_source_nick(::std::string&& value) {
  set_has_source_nick();
  source_nick_.Set(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_rvalue:pvp.PvpEventLog.source_nick)
}
#endif
inline void PvpEventLog::set_source_nick(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_source_nick();
  source_nick_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_char:pvp.PvpEventLog.source_nick)
}
inline void PvpEventLog::set_source_nick(const void* value,
    size_t size) {
  set_has_source_nick();
  source_nick_.Set(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_pointer:pvp.PvpEventLog.source_nick)
}
inline ::std::string* PvpEventLog::mutable_source_nick() {
  set_has_source_nick();
  // @@protoc_insertion_point(field_mutable:pvp.PvpEventLog.source_nick)
  return source_nick_.Mutable(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline ::std::string* PvpEventLog::release_source_nick() {
  // @@protoc_insertion_point(field_release:pvp.PvpEventLog.source_nick)
  if (!has_source_nick()) {
    return NULL;
  }
  clear_has_source_nick();
  return source_nick_.ReleaseNonDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), GetArenaNoVirtual());
}
inline void PvpEventLog::set_allocated_source_nick(::std::string* source_nick) {
  if (source_nick != NULL) {
    set_has_source_nick();
  } else {
    clear_has_source_nick();
  }
  source_nick_.SetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), source_nick,
      GetArenaNoVirtual());
  // @@protoc_insertion_point(field_set_allocated:pvp.PvpEventLog.source_nick)
}
inline ::std::string* PvpEventLog::unsafe_arena_release_source_nick() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pvp.PvpEventLog.source_nick)
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  clear_has_source_nick();
  return source_nick_.UnsafeArenaRelease(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}
inline void PvpEventLog::unsafe_arena_set_allocated_source_nick(
    ::std::string* source_nick) {
  GOOGLE_DCHECK(GetArenaNoVirtual() != NULL);
  if (source_nick != NULL) {
    set_has_source_nick();
  } else {
    clear_has_source_nick();
  }
  source_nick_.UnsafeArenaSetAllocated(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      source_nick, GetArenaNoVirtual());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pvp.PvpEventLog.source_nick)
}

// required .pvp.CardList source_card_list = 6;
inline bool PvpEventLog::has_source_card_list() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PvpEventLog::set_has_source_card_list() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PvpEventLog::clear_has_source_card_list() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PvpEventLog::clear_source_card_list() {
  if (source_card_list_ != NULL) source_card_list_->Clear();
  clear_has_source_card_list();
}
inline const ::pvp::CardList& PvpEventLog::_internal_source_card_list() const {
  return *source_card_list_;
}
inline const ::pvp::CardList& PvpEventLog::source_card_list() const {
  const ::pvp::CardList* p = source_card_list_;
  // @@protoc_insertion_point(field_get:pvp.PvpEventLog.source_card_list)
  return p != NULL ? *p : *reinterpret_cast<const ::pvp::CardList*>(
      &::pvp::_CardList_default_instance_);
}
inline ::pvp::CardList* PvpEventLog::release_source_card_list() {
  // @@protoc_insertion_point(field_release:pvp.PvpEventLog.source_card_list)
  clear_has_source_card_list();
  ::pvp::CardList* temp = source_card_list_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  source_card_list_ = NULL;
  return temp;
}
inline ::pvp::CardList* PvpEventLog::unsafe_arena_release_source_card_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pvp.PvpEventLog.source_card_list)
  clear_has_source_card_list();
  ::pvp::CardList* temp = source_card_list_;
  source_card_list_ = NULL;
  return temp;
}
inline ::pvp::CardList* PvpEventLog::mutable_source_card_list() {
  set_has_source_card_list();
  if (source_card_list_ == NULL) {
    auto* p = CreateMaybeMessage<::pvp::CardList>(GetArenaNoVirtual());
    source_card_list_ = p;
  }
  // @@protoc_insertion_point(field_mutable:pvp.PvpEventLog.source_card_list)
  return source_card_list_;
}
inline void PvpEventLog::set_allocated_source_card_list(::pvp::CardList* source_card_list) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete source_card_list_;
  }
  if (source_card_list) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(source_card_list);
    if (message_arena != submessage_arena) {
      source_card_list = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, source_card_list, submessage_arena);
    }
    set_has_source_card_list();
  } else {
    clear_has_source_card_list();
  }
  source_card_list_ = source_card_list;
  // @@protoc_insertion_point(field_set_allocated:pvp.PvpEventLog.source_card_list)
}

// required int32 gold_lock = 7;
inline bool PvpEventLog::has_gold_lock() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PvpEventLog::set_has_gold_lock() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PvpEventLog::clear_has_gold_lock() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PvpEventLog::clear_gold_lock() {
  gold_lock_ = 0;
  clear_has_gold_lock();
}
inline ::google::protobuf::int32 PvpEventLog::gold_lock() const {
  // @@protoc_insertion_point(field_get:pvp.PvpEventLog.gold_lock)
  return gold_lock_;
}
inline void PvpEventLog::set_gold_lock(::google::protobuf::int32 value) {
  set_has_gold_lock();
  gold_lock_ = value;
  // @@protoc_insertion_point(field_set:pvp.PvpEventLog.gold_lock)
}

// required int32 gold_refund = 8;
inline bool PvpEventLog::has_gold_refund() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PvpEventLog::set_has_gold_refund() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PvpEventLog::clear_has_gold_refund() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PvpEventLog::clear_gold_refund() {
  gold_refund_ = 0;
  clear_has_gold_refund();
}
inline ::google::protobuf::int32 PvpEventLog::gold_refund() const {
  // @@protoc_insertion_point(field_get:pvp.PvpEventLog.gold_refund)
  return gold_refund_;
}
inline void PvpEventLog::set_gold_refund(::google::protobuf::int32 value) {
  set_has_gold_refund();
  gold_refund_ = value;
  // @@protoc_insertion_point(field_set:pvp.PvpEventLog.gold_refund)
}

// optional sfixed64 optime = 11;
inline bool PvpEventLog::has_optime() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PvpEventLog::set_has_optime() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PvpEventLog::clear_has_optime() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PvpEventLog::clear_optime() {
  optime_ = GOOGLE_LONGLONG(0);
  clear_has_optime();
}
inline ::google::protobuf::int64 PvpEventLog::optime() const {
  // @@protoc_insertion_point(field_get:pvp.PvpEventLog.optime)
  return optime_;
}
inline void PvpEventLog::set_optime(::google::protobuf::int64 value) {
  set_has_optime();
  optime_ = value;
  // @@protoc_insertion_point(field_set:pvp.PvpEventLog.optime)
}

// -------------------------------------------------------------------

// PvpEventLogList

// repeated .pvp.PvpEventLog list = 1;
inline int PvpEventLogList::list_size() const {
  return list_.size();
}
inline void PvpEventLogList::clear_list() {
  list_.Clear();
}
inline ::pvp::PvpEventLog* PvpEventLogList::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:pvp.PvpEventLogList.list)
  return list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::pvp::PvpEventLog >*
PvpEventLogList::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:pvp.PvpEventLogList.list)
  return &list_;
}
inline const ::pvp::PvpEventLog& PvpEventLogList::list(int index) const {
  // @@protoc_insertion_point(field_get:pvp.PvpEventLogList.list)
  return list_.Get(index);
}
inline ::pvp::PvpEventLog* PvpEventLogList::add_list() {
  // @@protoc_insertion_point(field_add:pvp.PvpEventLogList.list)
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pvp::PvpEventLog >&
PvpEventLogList::list() const {
  // @@protoc_insertion_point(field_list:pvp.PvpEventLogList.list)
  return list_;
}

// -------------------------------------------------------------------

// UserPvpEventLogService_EventLogRequest

// required .pvp.UserPvpEventLogService.EVENT_LOG_COMMAND cmd = 1;
inline bool UserPvpEventLogService_EventLogRequest::has_cmd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserPvpEventLogService_EventLogRequest::set_has_cmd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserPvpEventLogService_EventLogRequest::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserPvpEventLogService_EventLogRequest::clear_cmd() {
  cmd_ = 1;
  clear_has_cmd();
}
inline ::pvp::UserPvpEventLogService_EVENT_LOG_COMMAND UserPvpEventLogService_EventLogRequest::cmd() const {
  // @@protoc_insertion_point(field_get:pvp.UserPvpEventLogService.EventLogRequest.cmd)
  return static_cast< ::pvp::UserPvpEventLogService_EVENT_LOG_COMMAND >(cmd_);
}
inline void UserPvpEventLogService_EventLogRequest::set_cmd(::pvp::UserPvpEventLogService_EVENT_LOG_COMMAND value) {
  assert(::pvp::UserPvpEventLogService_EVENT_LOG_COMMAND_IsValid(value));
  set_has_cmd();
  cmd_ = value;
  // @@protoc_insertion_point(field_set:pvp.UserPvpEventLogService.EventLogRequest.cmd)
}

// optional int32 refund_id = 2;
inline bool UserPvpEventLogService_EventLogRequest::has_refund_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserPvpEventLogService_EventLogRequest::set_has_refund_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserPvpEventLogService_EventLogRequest::clear_has_refund_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserPvpEventLogService_EventLogRequest::clear_refund_id() {
  refund_id_ = 0;
  clear_has_refund_id();
}
inline ::google::protobuf::int32 UserPvpEventLogService_EventLogRequest::refund_id() const {
  // @@protoc_insertion_point(field_get:pvp.UserPvpEventLogService.EventLogRequest.refund_id)
  return refund_id_;
}
inline void UserPvpEventLogService_EventLogRequest::set_refund_id(::google::protobuf::int32 value) {
  set_has_refund_id();
  refund_id_ = value;
  // @@protoc_insertion_point(field_set:pvp.UserPvpEventLogService.EventLogRequest.refund_id)
}

// -------------------------------------------------------------------

// UserPvpEventLogService_EventLogResponse

// required int32 result = 1;
inline bool UserPvpEventLogService_EventLogResponse::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserPvpEventLogService_EventLogResponse::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserPvpEventLogService_EventLogResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserPvpEventLogService_EventLogResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 UserPvpEventLogService_EventLogResponse::result() const {
  // @@protoc_insertion_point(field_get:pvp.UserPvpEventLogService.EventLogResponse.result)
  return result_;
}
inline void UserPvpEventLogService_EventLogResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:pvp.UserPvpEventLogService.EventLogResponse.result)
}

// optional .pvp.PvpEventLogList log_list = 11;
inline bool UserPvpEventLogService_EventLogResponse::has_log_list() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserPvpEventLogService_EventLogResponse::set_has_log_list() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserPvpEventLogService_EventLogResponse::clear_has_log_list() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserPvpEventLogService_EventLogResponse::clear_log_list() {
  if (log_list_ != NULL) log_list_->Clear();
  clear_has_log_list();
}
inline const ::pvp::PvpEventLogList& UserPvpEventLogService_EventLogResponse::_internal_log_list() const {
  return *log_list_;
}
inline const ::pvp::PvpEventLogList& UserPvpEventLogService_EventLogResponse::log_list() const {
  const ::pvp::PvpEventLogList* p = log_list_;
  // @@protoc_insertion_point(field_get:pvp.UserPvpEventLogService.EventLogResponse.log_list)
  return p != NULL ? *p : *reinterpret_cast<const ::pvp::PvpEventLogList*>(
      &::pvp::_PvpEventLogList_default_instance_);
}
inline ::pvp::PvpEventLogList* UserPvpEventLogService_EventLogResponse::release_log_list() {
  // @@protoc_insertion_point(field_release:pvp.UserPvpEventLogService.EventLogResponse.log_list)
  clear_has_log_list();
  ::pvp::PvpEventLogList* temp = log_list_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  log_list_ = NULL;
  return temp;
}
inline ::pvp::PvpEventLogList* UserPvpEventLogService_EventLogResponse::unsafe_arena_release_log_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pvp.UserPvpEventLogService.EventLogResponse.log_list)
  clear_has_log_list();
  ::pvp::PvpEventLogList* temp = log_list_;
  log_list_ = NULL;
  return temp;
}
inline ::pvp::PvpEventLogList* UserPvpEventLogService_EventLogResponse::mutable_log_list() {
  set_has_log_list();
  if (log_list_ == NULL) {
    auto* p = CreateMaybeMessage<::pvp::PvpEventLogList>(GetArenaNoVirtual());
    log_list_ = p;
  }
  // @@protoc_insertion_point(field_mutable:pvp.UserPvpEventLogService.EventLogResponse.log_list)
  return log_list_;
}
inline void UserPvpEventLogService_EventLogResponse::set_allocated_log_list(::pvp::PvpEventLogList* log_list) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete log_list_;
  }
  if (log_list) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(log_list);
    if (message_arena != submessage_arena) {
      log_list = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, log_list, submessage_arena);
    }
    set_has_log_list();
  } else {
    clear_has_log_list();
  }
  log_list_ = log_list;
  // @@protoc_insertion_point(field_set_allocated:pvp.UserPvpEventLogService.EventLogResponse.log_list)
}

// optional int32 gold_refund = 12;
inline bool UserPvpEventLogService_EventLogResponse::has_gold_refund() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserPvpEventLogService_EventLogResponse::set_has_gold_refund() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserPvpEventLogService_EventLogResponse::clear_has_gold_refund() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserPvpEventLogService_EventLogResponse::clear_gold_refund() {
  gold_refund_ = 0;
  clear_has_gold_refund();
}
inline ::google::protobuf::int32 UserPvpEventLogService_EventLogResponse::gold_refund() const {
  // @@protoc_insertion_point(field_get:pvp.UserPvpEventLogService.EventLogResponse.gold_refund)
  return gold_refund_;
}
inline void UserPvpEventLogService_EventLogResponse::set_gold_refund(::google::protobuf::int32 value) {
  set_has_gold_refund();
  gold_refund_ = value;
  // @@protoc_insertion_point(field_set:pvp.UserPvpEventLogService.EventLogResponse.gold_refund)
}

// -------------------------------------------------------------------

// UserPvpEventLogService

// optional .pvp.UserPvpEventLogService.EventLogRequest req = 1;
inline bool UserPvpEventLogService::has_req() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserPvpEventLogService::set_has_req() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserPvpEventLogService::clear_has_req() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserPvpEventLogService::clear_req() {
  if (req_ != NULL) req_->Clear();
  clear_has_req();
}
inline const ::pvp::UserPvpEventLogService_EventLogRequest& UserPvpEventLogService::_internal_req() const {
  return *req_;
}
inline const ::pvp::UserPvpEventLogService_EventLogRequest& UserPvpEventLogService::req() const {
  const ::pvp::UserPvpEventLogService_EventLogRequest* p = req_;
  // @@protoc_insertion_point(field_get:pvp.UserPvpEventLogService.req)
  return p != NULL ? *p : *reinterpret_cast<const ::pvp::UserPvpEventLogService_EventLogRequest*>(
      &::pvp::_UserPvpEventLogService_EventLogRequest_default_instance_);
}
inline ::pvp::UserPvpEventLogService_EventLogRequest* UserPvpEventLogService::release_req() {
  // @@protoc_insertion_point(field_release:pvp.UserPvpEventLogService.req)
  clear_has_req();
  ::pvp::UserPvpEventLogService_EventLogRequest* temp = req_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  req_ = NULL;
  return temp;
}
inline ::pvp::UserPvpEventLogService_EventLogRequest* UserPvpEventLogService::unsafe_arena_release_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pvp.UserPvpEventLogService.req)
  clear_has_req();
  ::pvp::UserPvpEventLogService_EventLogRequest* temp = req_;
  req_ = NULL;
  return temp;
}
inline ::pvp::UserPvpEventLogService_EventLogRequest* UserPvpEventLogService::mutable_req() {
  set_has_req();
  if (req_ == NULL) {
    auto* p = CreateMaybeMessage<::pvp::UserPvpEventLogService_EventLogRequest>(GetArenaNoVirtual());
    req_ = p;
  }
  // @@protoc_insertion_point(field_mutable:pvp.UserPvpEventLogService.req)
  return req_;
}
inline void UserPvpEventLogService::set_allocated_req(::pvp::UserPvpEventLogService_EventLogRequest* req) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete req_;
  }
  if (req) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(req);
    if (message_arena != submessage_arena) {
      req = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, req, submessage_arena);
    }
    set_has_req();
  } else {
    clear_has_req();
  }
  req_ = req;
  // @@protoc_insertion_point(field_set_allocated:pvp.UserPvpEventLogService.req)
}

// optional .pvp.UserPvpEventLogService.EventLogResponse resp = 2;
inline bool UserPvpEventLogService::has_resp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserPvpEventLogService::set_has_resp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserPvpEventLogService::clear_has_resp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserPvpEventLogService::clear_resp() {
  if (resp_ != NULL) resp_->Clear();
  clear_has_resp();
}
inline const ::pvp::UserPvpEventLogService_EventLogResponse& UserPvpEventLogService::_internal_resp() const {
  return *resp_;
}
inline const ::pvp::UserPvpEventLogService_EventLogResponse& UserPvpEventLogService::resp() const {
  const ::pvp::UserPvpEventLogService_EventLogResponse* p = resp_;
  // @@protoc_insertion_point(field_get:pvp.UserPvpEventLogService.resp)
  return p != NULL ? *p : *reinterpret_cast<const ::pvp::UserPvpEventLogService_EventLogResponse*>(
      &::pvp::_UserPvpEventLogService_EventLogResponse_default_instance_);
}
inline ::pvp::UserPvpEventLogService_EventLogResponse* UserPvpEventLogService::release_resp() {
  // @@protoc_insertion_point(field_release:pvp.UserPvpEventLogService.resp)
  clear_has_resp();
  ::pvp::UserPvpEventLogService_EventLogResponse* temp = resp_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  resp_ = NULL;
  return temp;
}
inline ::pvp::UserPvpEventLogService_EventLogResponse* UserPvpEventLogService::unsafe_arena_release_resp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pvp.UserPvpEventLogService.resp)
  clear_has_resp();
  ::pvp::UserPvpEventLogService_EventLogResponse* temp = resp_;
  resp_ = NULL;
  return temp;
}
inline ::pvp::UserPvpEventLogService_EventLogResponse* UserPvpEventLogService::mutable_resp() {
  set_has_resp();
  if (resp_ == NULL) {
    auto* p = CreateMaybeMessage<::pvp::UserPvpEventLogService_EventLogResponse>(GetArenaNoVirtual());
    resp_ = p;
  }
  // @@protoc_insertion_point(field_mutable:pvp.UserPvpEventLogService.resp)
  return resp_;
}
inline void UserPvpEventLogService::set_allocated_resp(::pvp::UserPvpEventLogService_EventLogResponse* resp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete resp_;
  }
  if (resp) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(resp);
    if (message_arena != submessage_arena) {
      resp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, resp, submessage_arena);
    }
    set_has_resp();
  } else {
    clear_has_resp();
  }
  resp_ = resp;
  // @@protoc_insertion_point(field_set_allocated:pvp.UserPvpEventLogService.resp)
}

// -------------------------------------------------------------------

// PvpEventLogStateNotify

// required .pvp.PvpEventLogList log_list = 1;
inline bool PvpEventLogStateNotify::has_log_list() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PvpEventLogStateNotify::set_has_log_list() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PvpEventLogStateNotify::clear_has_log_list() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PvpEventLogStateNotify::clear_log_list() {
  if (log_list_ != NULL) log_list_->Clear();
  clear_has_log_list();
}
inline const ::pvp::PvpEventLogList& PvpEventLogStateNotify::_internal_log_list() const {
  return *log_list_;
}
inline const ::pvp::PvpEventLogList& PvpEventLogStateNotify::log_list() const {
  const ::pvp::PvpEventLogList* p = log_list_;
  // @@protoc_insertion_point(field_get:pvp.PvpEventLogStateNotify.log_list)
  return p != NULL ? *p : *reinterpret_cast<const ::pvp::PvpEventLogList*>(
      &::pvp::_PvpEventLogList_default_instance_);
}
inline ::pvp::PvpEventLogList* PvpEventLogStateNotify::release_log_list() {
  // @@protoc_insertion_point(field_release:pvp.PvpEventLogStateNotify.log_list)
  clear_has_log_list();
  ::pvp::PvpEventLogList* temp = log_list_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  log_list_ = NULL;
  return temp;
}
inline ::pvp::PvpEventLogList* PvpEventLogStateNotify::unsafe_arena_release_log_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pvp.PvpEventLogStateNotify.log_list)
  clear_has_log_list();
  ::pvp::PvpEventLogList* temp = log_list_;
  log_list_ = NULL;
  return temp;
}
inline ::pvp::PvpEventLogList* PvpEventLogStateNotify::mutable_log_list() {
  set_has_log_list();
  if (log_list_ == NULL) {
    auto* p = CreateMaybeMessage<::pvp::PvpEventLogList>(GetArenaNoVirtual());
    log_list_ = p;
  }
  // @@protoc_insertion_point(field_mutable:pvp.PvpEventLogStateNotify.log_list)
  return log_list_;
}
inline void PvpEventLogStateNotify::set_allocated_log_list(::pvp::PvpEventLogList* log_list) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete log_list_;
  }
  if (log_list) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(log_list);
    if (message_arena != submessage_arena) {
      log_list = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, log_list, submessage_arena);
    }
    set_has_log_list();
  } else {
    clear_has_log_list();
  }
  log_list_ = log_list;
  // @@protoc_insertion_point(field_set_allocated:pvp.PvpEventLogStateNotify.log_list)
}

// -------------------------------------------------------------------

// PvpLootNotify

// required int32 win_gold = 1;
inline bool PvpLootNotify::has_win_gold() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PvpLootNotify::set_has_win_gold() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PvpLootNotify::clear_has_win_gold() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PvpLootNotify::clear_win_gold() {
  win_gold_ = 0;
  clear_has_win_gold();
}
inline ::google::protobuf::int32 PvpLootNotify::win_gold() const {
  // @@protoc_insertion_point(field_get:pvp.PvpLootNotify.win_gold)
  return win_gold_;
}
inline void PvpLootNotify::set_win_gold(::google::protobuf::int32 value) {
  set_has_win_gold();
  win_gold_ = value;
  // @@protoc_insertion_point(field_set:pvp.PvpLootNotify.win_gold)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pvp

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::pvp::UserInput_INPUT_OPCODE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pvp::UserInput_INPUT_OPCODE>() {
  return ::pvp::UserInput_INPUT_OPCODE_descriptor();
}
template <> struct is_proto_enum< ::pvp::CombatFrame_FRAME_STATE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pvp::CombatFrame_FRAME_STATE>() {
  return ::pvp::CombatFrame_FRAME_STATE_descriptor();
}
template <> struct is_proto_enum< ::pvp::PvpService_PVP_COMMAND> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pvp::PvpService_PVP_COMMAND>() {
  return ::pvp::PvpService_PVP_COMMAND_descriptor();
}
template <> struct is_proto_enum< ::pvp::PvpEventLog_LOOT_STATE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pvp::PvpEventLog_LOOT_STATE>() {
  return ::pvp::PvpEventLog_LOOT_STATE_descriptor();
}
template <> struct is_proto_enum< ::pvp::PvpEventLog_DEFEND_STATE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pvp::PvpEventLog_DEFEND_STATE>() {
  return ::pvp::PvpEventLog_DEFEND_STATE_descriptor();
}
template <> struct is_proto_enum< ::pvp::UserPvpEventLogService_EVENT_LOG_COMMAND> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pvp::UserPvpEventLogService_EVENT_LOG_COMMAND>() {
  return ::pvp::UserPvpEventLogService_EVENT_LOG_COMMAND_descriptor();
}
template <> struct is_proto_enum< ::pvp::COMBAT_TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pvp::COMBAT_TYPE>() {
  return ::pvp::COMBAT_TYPE_descriptor();
}
template <> struct is_proto_enum< ::pvp::PVP_STAGE_STATE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pvp::PVP_STAGE_STATE>() {
  return ::pvp::PVP_STAGE_STATE_descriptor();
}
template <> struct is_proto_enum< ::pvp::PVP_EVENT_TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pvp::PVP_EVENT_TYPE>() {
  return ::pvp::PVP_EVENT_TYPE_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_Pvp_2eproto
